{"version":3,"file":"index.cjs","sources":["../src/mutations/creators.ts","../src/mutations/operations/creators.ts","../src/mutations/autoKeys.ts","../src/encoders/sanity/encode.ts","../src/encoders/sanity/decode.ts","../src/encoders/compact/encode.ts","../src/encoders/compact/decode.ts","../src/formatters/compact.ts"],"sourcesContent":["import {arrify} from '../utils/arrify'\nimport {type StringToPath, parse} from '../path'\nimport {type Operation} from './operations/types'\nimport {type PatchMutation, type PatchOptions} from './types'\nimport type {\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  NodePatch,\n  NodePatchList,\n  SanityDocumentBase,\n} from './types'\nimport type {Path} from '../path'\nimport type {\n  NormalizeReadOnlyArray,\n  Optional,\n  Tuplify,\n} from '../utils/typeUtils'\n\nexport function create<Doc extends Optional<SanityDocumentBase, '_id'>>(\n  document: Doc,\n): CreateMutation<Doc> {\n  return {type: 'create', document}\n}\n\nexport function patch<P extends NodePatchList | NodePatch>(\n  id: string,\n  patches: P,\n  options?: PatchOptions,\n): PatchMutation<NormalizeReadOnlyArray<Tuplify<P>>> {\n  return {\n    type: 'patch',\n    id,\n    patches: arrify(patches) as any,\n    ...(options ? {options} : {}),\n  }\n}\n\nexport function at<const P extends Path, O extends Operation>(\n  path: P,\n  operation: O,\n): NodePatch<NormalizeReadOnlyArray<P>, O>\n\nexport function at<const P extends string, O extends Operation>(\n  path: P,\n  operation: O,\n): NodePatch<StringToPath<P>, O>\n\nexport function at<O extends Operation>(\n  path: Path | string,\n  operation: O,\n): NodePatch<Path, O> {\n  return {\n    path: typeof path === 'string' ? parse(path) : path,\n    op: operation,\n  }\n}\n\nexport function createIfNotExists<Doc extends SanityDocumentBase>(\n  document: Doc,\n): CreateIfNotExistsMutation<Doc> {\n  return {type: 'createIfNotExists', document}\n}\n\nexport function createOrReplace<Doc extends SanityDocumentBase>(\n  document: Doc,\n): CreateOrReplaceMutation<Doc> {\n  return {type: 'createOrReplace', document}\n}\n\nexport function delete_(id: string): DeleteMutation {\n  return {type: 'delete', id}\n}\n\nexport const del = delete_\nexport const destroy = delete_\n","import {arrify} from '../../utils/arrify'\nimport type {\n  AnyArray,\n  ArrayElement,\n  NormalizeReadOnlyArray,\n} from '../../utils/typeUtils'\nimport type {\n  AssignOp,\n  DecOp,\n  DiffMatchPatchOp,\n  IncOp,\n  Index,\n  InsertOp,\n  KeyedPathElement,\n  RelativePosition,\n  ReplaceOp,\n  SetIfMissingOp,\n  SetOp,\n  TruncateOp,\n  UnassignOp,\n  UnsetOp,\n  UpsertOp,\n} from './types'\n\nexport const set = <const T>(value: T): SetOp<T> => ({type: 'set', value})\n\nexport const assign = <const T extends {[K in string]: unknown}>(\n  value: T,\n): AssignOp<T> => ({\n  type: 'assign',\n  value,\n})\n\nexport const unassign = <const K extends readonly string[]>(\n  keys: K,\n): UnassignOp<K> => ({\n  type: 'unassign',\n  keys,\n})\n\nexport const setIfMissing = <const T>(value: T): SetIfMissingOp<T> => ({\n  type: 'setIfMissing',\n  value,\n})\n\nexport const unset = (): UnsetOp => ({type: 'unset'})\n\nexport const inc = <const N extends number = 1>(\n  amount: N = 1 as N,\n): IncOp<N> => ({\n  type: 'inc',\n  amount,\n})\n\nexport const dec = <const N extends number = 1>(\n  amount: N = 1 as N,\n): DecOp<N> => ({\n  type: 'dec',\n  amount,\n})\n\nexport const diffMatchPatch = (value: string): DiffMatchPatchOp => ({\n  type: 'diffMatchPatch',\n  value,\n})\n\nexport function insert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  indexOrReferenceItem: ReferenceItem,\n): InsertOp<NormalizeReadOnlyArray<Items>, Pos, ReferenceItem> {\n  return {\n    type: 'insert',\n    referenceItem: indexOrReferenceItem,\n    position,\n    items: arrify(items) as any,\n  }\n}\n\nexport function append<const Items extends AnyArray<unknown>>(\n  items: Items | ArrayElement<Items>,\n) {\n  return insert(items, 'after', -1)\n}\n\nexport function prepend<const Items extends AnyArray<unknown>>(\n  items: Items | ArrayElement<Items>,\n) {\n  return insert(items, 'before', 0)\n}\n\nexport function insertBefore<\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(items: Items | ArrayElement<Items>, indexOrReferenceItem: ReferenceItem) {\n  return insert(items, 'before', indexOrReferenceItem)\n}\n\nexport const insertAfter = <\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  indexOrReferenceItem: ReferenceItem,\n) => {\n  return insert(items, 'after', indexOrReferenceItem)\n}\n\nexport function truncate(startIndex: number, endIndex?: number): TruncateOp {\n  return {\n    type: 'truncate',\n    startIndex,\n    endIndex,\n  }\n}\n\n/*\n  Use this when you know the ref Items already exists\n */\nexport function replace<\n  Items extends any[],\n  ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  referenceItem: ReferenceItem,\n): ReplaceOp<Items, ReferenceItem> {\n  return {\n    type: 'replace',\n    referenceItem,\n    items: arrify(items) as Items,\n  }\n}\n\n/*\nuse this when the reference Items may or may not exist\n */\nexport function upsert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  referenceItem: ReferenceItem,\n): UpsertOp<Items, Pos, ReferenceItem> {\n  return {\n    type: 'upsert',\n    items: arrify(items) as Items,\n    referenceItem,\n    position,\n  }\n}\n","import {isObject} from '../utils/isObject'\nimport {\n  insert as _insert,\n  replace as _replace,\n  upsert as _upsert,\n} from './operations/creators'\nimport {type RelativePosition} from './operations/types'\nimport type {Index, KeyedPathElement} from '../path'\n\nexport function autoKeys<Item>(generateKey: (item: Item) => string) {\n  const ensureKeys = createEnsureKeys(generateKey)\n\n  const insert = <\n    Pos extends RelativePosition,\n    Ref extends Index | KeyedPathElement,\n  >(\n    position: Pos,\n    referenceItem: Ref,\n    items: Item[],\n  ) => _insert(ensureKeys(items), position, referenceItem)\n  const upsert = <\n    Pos extends RelativePosition,\n    ReferenceItem extends Index | KeyedPathElement,\n  >(\n    items: Item[],\n    position: Pos,\n    referenceItem: ReferenceItem,\n  ) => _upsert(ensureKeys(items), position, referenceItem)\n\n  const replace = <\n    Pos extends RelativePosition,\n    ReferenceItem extends Index | KeyedPathElement,\n  >(\n    items: Item[],\n    position: Pos,\n    referenceItem: ReferenceItem,\n  ) => _replace(ensureKeys(items), referenceItem)\n\n  const insertBefore = <Ref extends Index | KeyedPathElement>(\n    ref: Ref,\n    items: Item[],\n  ) => insert('before', ref, items)\n\n  const prepend = (items: Item[]) => insertBefore(0, items)\n\n  const insertAfter = <Ref extends Index | KeyedPathElement>(\n    ref: Ref,\n    items: Item[],\n  ) => insert('after', ref, items)\n\n  const append = (items: Item[]) => insert('after', -1, items)\n\n  return {insert, upsert, replace, insertBefore, prepend, insertAfter, append}\n}\n\nfunction hasKey<T extends object>(item: T): item is T & {_key: string} {\n  return '_key' in item\n}\n\nfunction createEnsureKeys<T>(generateKey: (item: T) => string) {\n  return (array: T[]): T[] => {\n    let didModify = false\n    const withKeys = array.map(item => {\n      if (needsKey(item)) {\n        didModify = true\n        return {...item, _key: generateKey(item)}\n      }\n      return item\n    })\n    return didModify ? withKeys : array\n  }\n}\n\nfunction needsKey(arrayItem: any): arrayItem is object {\n  return isObject(arrayItem) && !hasKey(arrayItem)\n}\n","import {stringify as stringifyPath} from '../../path/parser/stringify'\nimport type {Mutation, NodePatch} from '../../mutations/types'\n\nexport function encode(mutations: Mutation[]) {\n  return mutations.flatMap(encodeMutation)\n}\n\nexport function encodeMutation(mutation: Mutation) {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return {[mutation.type]: mutation.document}\n  }\n  if (mutation.type === 'delete') {\n    return {\n      delete: {id: mutation.id},\n    }\n  }\n  const ifRevisionID = mutation.options?.ifRevision\n  return mutation.patches.map(patch => {\n    return {\n      patch: {\n        id: mutation.id,\n        ...(ifRevisionID && {ifRevisionID}),\n        ...patchToSanity(patch),\n      },\n    }\n  })\n}\n\nfunction patchToSanity(patch: NodePatch) {\n  const {path, op} = patch\n  if (op.type === 'unset') {\n    return {unset: [stringifyPath(path)]}\n  }\n  if (op.type === 'insert') {\n    return {\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'diffMatchPatch') {\n    return {diffMatchPatch: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'inc') {\n    return {inc: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'dec') {\n    return {dec: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'set' || op.type === 'setIfMissing') {\n    return {[op.type]: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'truncate') {\n    const range = [\n      op.startIndex,\n      typeof op.endIndex === 'number' ? op.endIndex : '',\n    ].join(':')\n\n    return {unset: [`${stringifyPath(path)}[${range}]`]}\n  }\n  if (op.type === 'upsert') {\n    // note: upsert currently not supported by sanity, so will always insert at reference position\n    return {\n      unset: op.items.map(item =>\n        stringifyPath([...path, {_key: (item as any)._key}]),\n      ),\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'assign') {\n    return {\n      set: Object.fromEntries(\n        Object.keys(op.value).map(key => [\n          stringifyPath(path.concat(key)),\n          op.value[key as keyof typeof op.value],\n        ]),\n      ),\n    }\n  }\n  if (op.type === 'unassign') {\n    return {\n      unset: op.keys.map(key => stringifyPath(path.concat(key))),\n    }\n  }\n  if (op.type === 'replace') {\n    return {\n      insert: {\n        replace: stringifyPath(path.concat(op.referenceItem)),\n        items: op.items,\n      },\n    }\n  }\n  //@ts-expect-error all cases should be covered\n  throw new Error(`Unknown operation type ${op.type}`)\n}\n","import {parse as parsePath} from '../../path/parser/parse'\nimport type {\n  Mutation,\n  NodePatch,\n  SanityDocumentBase,\n} from '../../mutations/types'\nimport type {SetIfMissingOp, SetOp} from '../../mutations/operations/types'\n\nexport type {SanityDocumentBase, Mutation}\n\nexport type SanityDiffMatchPatch = {\n  id: string\n  diffMatchPatch: {[path: string]: string}\n}\n\nexport type SanitySetPatch = {\n  id: string\n  set: {[path: string]: any}\n}\n\nexport type Insert = {\n  before?: string\n  after?: string\n  replace?: string\n  items: any[]\n}\n\nexport type SanityInsertPatch = {\n  id: string\n  insert: Insert\n}\n\nexport type SanityUnsetPatch = {\n  id: string\n  unset: string[]\n}\n\nexport type SanityIncPatch = {\n  id: string\n  inc: {[path: string]: number}\n}\n\nexport type SanityDecPatch = {\n  id: string\n  dec: {[path: string]: number}\n}\n\nexport type SanitySetIfMissingPatch = {\n  id: string\n  setIfMissing: {[path: string]: any}\n}\n\nexport type SanityPatch =\n  | SanitySetPatch\n  | SanityUnsetPatch\n  | SanityInsertPatch\n  | SanitySetIfMissingPatch\n  | SanityDiffMatchPatch\n  | SanityIncPatch\n  | SanityDecPatch\n\nexport type SanityCreateIfNotExistsMutation<Doc extends SanityDocumentBase> = {\n  createIfNotExists: Doc\n}\n\nexport type SanityCreateOrReplaceMutation<Doc extends SanityDocumentBase> = {\n  createOrReplace: Doc\n}\n\nexport type SanityCreateMutation<Doc extends SanityDocumentBase> = {\n  create: Doc\n}\n\nexport type SanityDeleteMutation = {\n  delete: {id: string}\n}\n\nexport type SanityPatchMutation = {\n  patch:\n    | SanitySetPatch\n    | SanitySetIfMissingPatch\n    | SanityDiffMatchPatch\n    | SanityInsertPatch\n    | SanityUnsetPatch\n}\n\nexport type SanityMutation<\n  Doc extends SanityDocumentBase = SanityDocumentBase,\n> =\n  | SanityCreateMutation<Doc>\n  | SanityCreateIfNotExistsMutation<Doc>\n  | SanityCreateOrReplaceMutation<Doc>\n  | SanityDeleteMutation\n  | SanityPatchMutation\n\nfunction isCreateIfNotExistsMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateIfNotExistsMutation<Doc> {\n  return 'createIfNotExists' in sanityMutation\n}\n\nfunction isCreateOrReplaceMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateOrReplaceMutation<Doc> {\n  return 'createOrReplace' in sanityMutation\n}\n\nfunction isCreateMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateMutation<Doc> {\n  return 'create' in sanityMutation\n}\n\nfunction isDeleteMutation(\n  sanityMutation: SanityMutation<any>,\n): sanityMutation is SanityDeleteMutation {\n  return 'delete' in sanityMutation\n}\n\nfunction isPatchMutation(\n  sanityMutation: SanityMutation<any>,\n): sanityMutation is SanityPatchMutation {\n  return 'patch' in sanityMutation\n}\n\nfunction isSetPatch(sanityPatch: SanityPatch): sanityPatch is SanitySetPatch {\n  return 'set' in sanityPatch\n}\n\nfunction isSetIfMissingPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanitySetIfMissingPatch {\n  return 'setIfMissing' in sanityPatch\n}\n\nfunction isDiffMatchPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityDiffMatchPatch {\n  return 'diffMatchPatch' in sanityPatch\n}\n\nfunction isUnsetPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityUnsetPatch {\n  return 'unset' in sanityPatch\n}\n\nfunction isIncPatch(sanityPatch: SanityPatch): sanityPatch is SanityIncPatch {\n  return 'inc' in sanityPatch\n}\n\nfunction isDecPatch(sanityPatch: SanityPatch): sanityPatch is SanityDecPatch {\n  return 'inc' in sanityPatch\n}\n\nfunction isInsertPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityInsertPatch {\n  return 'insert' in sanityPatch\n}\n\nexport function decode<Doc extends SanityDocumentBase>(\n  encodedMutation: SanityMutation<Doc>[],\n) {\n  return encodedMutation.reduce(\n    (muts: Mutation[], mut) => [...muts, ...decodeMutation(mut)],\n    [],\n  )\n}\n\nfunction decodeMutation<Doc extends SanityDocumentBase>(\n  encodedMutation: SanityMutation<Doc>,\n): Mutation[] {\n  if (isCreateIfNotExistsMutation(encodedMutation)) {\n    return [\n      {\n        type: 'createIfNotExists',\n        document: encodedMutation.createIfNotExists,\n      },\n    ]\n  }\n  if (isCreateOrReplaceMutation(encodedMutation)) {\n    return [\n      {\n        type: 'createOrReplace',\n        document: encodedMutation.createOrReplace,\n      },\n    ]\n  }\n  if (isCreateMutation(encodedMutation)) {\n    return [{type: 'create', document: encodedMutation.create}]\n  }\n  if (isDeleteMutation(encodedMutation)) {\n    return [{id: encodedMutation.delete.id, type: 'delete'}]\n  }\n  if (isPatchMutation(encodedMutation)) {\n    return [\n      {\n        type: 'patch',\n        id: encodedMutation.patch.id,\n        patches: decodeNodePatches(encodedMutation.patch),\n      },\n    ]\n  }\n  throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`)\n}\n\nconst POSITION_KEYS = ['before', 'replace', 'after'] as const\n\nfunction getInsertPosition(insert: Insert) {\n  const positions = POSITION_KEYS.filter(k => k in insert)\n  if (positions.length > 1) {\n    throw new Error(\n      `Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(\n        ', ',\n      )}, instead found ${positions.join(', ')}`,\n    )\n  }\n  return positions[0]\n}\n\nfunction decodeNodePatches<T>(patch: SanityPatch): NodePatch<any, any>[] {\n  // If multiple patches are included, then the order of execution is as follows\n  // set, setIfMissing, unset, inc, dec, insert.\n  // order is defined here: https://www.sanity.io/docs/http-mutations#2f480b2baca5\n  return [\n    ...getSetPatches(patch),\n    ...getSetIfMissingPatches(patch),\n    ...getUnsetPatches(patch),\n    ...getIncPatches(patch),\n    ...getDecPatches(patch),\n    ...getInsertPatches(patch),\n  ]\n\n  throw new Error(`Unknown patch: ${JSON.stringify(patch)}`)\n}\n\nfunction getSetPatches(patch: SanityPatch): NodePatch<any[], SetOp<any>>[] {\n  return isSetPatch(patch)\n    ? Object.keys(patch.set).map(path => ({\n        path: parsePath(path),\n        op: {type: 'set', value: patch.set[path]},\n      }))\n    : []\n}\n\nfunction getSetIfMissingPatches(\n  patch: SanityPatch,\n): NodePatch<any[], SetIfMissingOp<any>>[] {\n  return isSetIfMissingPatch(patch)\n    ? Object.keys(patch.setIfMissing).map(path => ({\n        path: parsePath(path),\n        op: {type: 'setIfMissing', value: patch.setIfMissing[path]},\n      }))\n    : []\n}\n\nfunction getDiffMatchPatchPatches(patch: SanityPatch) {\n  return isDiffMatchPatch(patch)\n    ? Object.keys(patch.diffMatchPatch).map(path => ({\n        path: parsePath(path),\n        op: {type: 'diffMatchPatch', value: patch.diffMatchPatch[path]},\n      }))\n    : []\n}\n\nfunction getUnsetPatches(patch: SanityPatch) {\n  return isUnsetPatch(patch)\n    ? patch.unset.map(path => ({\n        path: parsePath(path),\n        op: {type: 'unset'},\n      }))\n    : []\n}\n\nfunction getIncPatches(patch: SanityPatch) {\n  return isIncPatch(patch)\n    ? Object.keys(patch.inc).map(path => ({\n        path: parsePath(path),\n        op: {type: 'inc', amount: patch.inc[path]},\n      }))\n    : []\n}\n\nfunction getDecPatches(patch: SanityPatch) {\n  return isDecPatch(patch)\n    ? Object.keys(patch.dec).map(path => ({\n        path: parsePath(path),\n        op: {type: 'dec', amount: patch.dec[path]},\n      }))\n    : []\n}\n\nfunction getInsertPatches(patch: SanityPatch) {\n  if (!isInsertPatch(patch)) {\n    return []\n  }\n  const position = getInsertPosition(patch.insert)\n  if (!position) {\n    throw new Error('Insert patch missing position')\n  }\n\n  const path = parsePath(patch.insert[position]!)\n  const referenceItem = path.pop()\n\n  const op =\n    position === 'replace'\n      ? {\n          type: 'insert',\n          position: position,\n          referenceItem,\n          items: patch.insert.items,\n        }\n      : {\n          type: 'insert',\n          position: position,\n          referenceItem,\n          items: patch.insert.items,\n        }\n\n  return [{path, op}]\n}\n","// An example of a compact transport/serialization format\nimport {stringify as stringifyPath} from '../../path/parser/stringify'\nimport type {Index, KeyedPathElement} from '../../path'\nimport type {CompactMutation, CompactPatchMutation, ItemRef} from './types'\nimport type {\n  Mutation,\n  NodePatch,\n  SanityDocumentBase,\n} from '../../mutations/types'\n\nexport function encode<Doc extends SanityDocumentBase>(\n  mutations: Mutation[],\n): CompactMutation<Doc>[] {\n  return mutations.flatMap(m => encodeMutation<Doc>(m))\n}\n\nfunction encodeItemRef(ref: Index | KeyedPathElement): ItemRef {\n  return typeof ref === 'number' ? ref : ref._key\n}\n\nfunction encodeMutation<Doc extends SanityDocumentBase>(\n  mutation: Mutation,\n): CompactMutation<Doc>[] {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return [[mutation.type, mutation.document]]\n  }\n  if (mutation.type === 'delete') {\n    return [['delete', mutation.id]]\n  }\n  if (mutation.type === 'patch') {\n    return mutation.patches.map(patch =>\n      maybeAddRevision(\n        mutation.options?.ifRevision,\n        encodePatchMutation(mutation.id, patch),\n      ),\n    )\n  }\n\n  //@ts-expect-error - all cases are covered\n  throw new Error(`Invalid mutation type: ${mutation.type}`)\n}\n\nfunction encodePatchMutation(\n  id: string,\n  patch: NodePatch<any>,\n): CompactPatchMutation {\n  const {op} = patch\n  const path = stringifyPath(patch.path)\n  if (op.type === 'unset') {\n    return ['patch', 'unset', id, path, []]\n  }\n  if (op.type === 'diffMatchPatch') {\n    return ['patch', 'diffMatchPatch', id, path, [op.value]]\n  }\n  if (op.type === 'inc' || op.type === 'dec') {\n    return ['patch', op.type, id, path, [op.amount]]\n  }\n  if (op.type === 'set') {\n    return ['patch', op.type, id, path, [op.value]]\n  }\n  if (op.type === 'setIfMissing') {\n    return ['patch', op.type, id, path, [op.value]]\n  }\n  if (op.type === 'insert') {\n    return [\n      'patch',\n      'insert',\n      id,\n      path,\n      [op.position, encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'upsert') {\n    return [\n      'patch',\n      'upsert',\n      id,\n      path,\n      [op.position, encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'assign') {\n    return ['patch', 'assign', id, path, [op.value]]\n  }\n  if (op.type === 'unassign') {\n    return ['patch', 'assign', id, path, [op.keys]]\n  }\n  if (op.type === 'replace') {\n    return [\n      'patch',\n      'replace',\n      id,\n      path,\n      [encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'truncate') {\n    return ['patch', 'truncate', id, path, [op.startIndex, op.endIndex]]\n  }\n  // @ts-expect-error all cases are covered\n  throw new Error(`Invalid operation type: ${op.type}`)\n}\n\nfunction maybeAddRevision<T extends CompactPatchMutation>(\n  revision: string | undefined,\n  mut: T,\n): T {\n  const [mutType, patchType, id, path, args] = mut\n  return (revision ? [mutType, patchType, id, path, args, revision] : mut) as T\n}\n","import {parse as parsePath} from '../../path/parser/parse'\nimport type {Index, KeyedPathElement} from '../../path'\nimport type {\n  CompactMutation,\n  CompactPatchMutation,\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  ItemRef,\n} from './types'\n\nimport type {\n  Mutation,\n  PatchMutation,\n  SanityDocumentBase,\n} from '../../mutations/types'\n\nexport {Mutation, SanityDocumentBase}\n\nexport function decode<Doc extends SanityDocumentBase>(\n  mutations: CompactMutation<Doc>[],\n): Mutation[] {\n  return mutations.map(decodeMutation)\n}\n\nexport function decodeMutation<Doc extends SanityDocumentBase>(\n  mutation: CompactMutation<Doc>,\n): Mutation {\n  const [type] = mutation\n  if (type === 'delete') {\n    const [, id] = mutation as DeleteMutation\n    return {id, type}\n  } else if (type === 'create') {\n    const [, document] = mutation as CreateMutation<Doc>\n    return {type, document}\n  } else if (type === 'createIfNotExists') {\n    const [, document] = mutation as CreateIfNotExistsMutation<Doc>\n    return {type, document}\n  } else if (type === 'createOrReplace') {\n    const [, document] = mutation as CreateOrReplaceMutation<Doc>\n    return {type, document}\n  } else if (type === 'patch') {\n    return decodePatchMutation(mutation)\n  }\n  throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`)\n}\n\nfunction decodePatchMutation(mutation: CompactPatchMutation): PatchMutation {\n  const [, type, id, serializedPath, , revisionId] = mutation\n\n  const path = parsePath(serializedPath)\n  if (type === 'dec' || type === 'inc') {\n    const [, , , , [amount]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'inc', amount}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'unset') {\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'unset'}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'insert') {\n    const [, , , , [position, ref, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {\n          path,\n          op: {\n            type: 'insert',\n            position,\n            items,\n            referenceItem: typeof ref === 'string' ? {_key: ref} : ref,\n          },\n        },\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'set') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'set', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'setIfMissing') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'setIfMissing', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'diffMatchPatch') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'diffMatchPatch', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'truncate') {\n    const [, , , , [startIndex, endIndex]] = mutation\n\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'truncate', startIndex, endIndex}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'assign') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'assign', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'replace') {\n    const [, , , , [ref, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {path, op: {type: 'replace', items, referenceItem: decodeItemRef(ref)}},\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'upsert') {\n    const [, , , , [position, referenceItem, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {\n          path,\n          op: {\n            type: 'upsert',\n            items,\n            referenceItem: decodeItemRef(referenceItem),\n            position,\n          },\n        },\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  throw new Error(`Invalid mutation type: ${type}`)\n}\n\nfunction decodeItemRef(ref: ItemRef): Index | KeyedPathElement {\n  return typeof ref === 'string' ? {_key: ref} : ref\n}\n\nfunction createOpts(revisionId: undefined | string) {\n  return revisionId ? {options: {ifRevision: revisionId}} : null\n}\n","// An example of a compact formatter\n\nimport {stringify} from '../path'\nimport type {Index, KeyedPathElement} from '../path'\nimport type {Mutation, NodePatch, SanityDocumentBase} from '../mutations/types'\n\nexport type ItemRef = string | number\n\nexport function format<Doc extends SanityDocumentBase>(\n  mutations: Mutation[],\n): string {\n  return mutations.flatMap(m => encodeMutation<Doc>(m)).join('\\n')\n}\n\nfunction encodeItemRef(ref: Index | KeyedPathElement): ItemRef {\n  return typeof ref === 'number' ? ref : ref._key\n}\n\nfunction encodeMutation<Doc extends SanityDocumentBase>(\n  mutation: Mutation,\n): string {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return [mutation.type, ': ', JSON.stringify(mutation.document)].join('')\n  }\n  if (mutation.type === 'delete') {\n    return ['delete ', mutation.id].join(': ')\n  }\n  if (mutation.type === 'patch') {\n    const ifRevision = mutation.options?.ifRevision\n    return [\n      'patch',\n      ' ',\n      `id=${mutation.id}`,\n      ifRevision ? ` (if revision==${ifRevision})` : '',\n      ':\\n',\n      mutation.patches\n        .map(nodePatch => `  ${formatPatchMutation(nodePatch)}`)\n        .join('\\n'),\n    ].join('')\n  }\n\n  //@ts-expect-error - all cases are covered\n  throw new Error(`Invalid mutation type: ${mutation.type}`)\n}\n\nfunction formatPatchMutation(patch: NodePatch<any>): string {\n  const {op} = patch\n  const path = stringify(patch.path)\n  if (op.type === 'unset') {\n    return [path, 'unset()'].join(': ')\n  }\n  if (op.type === 'diffMatchPatch') {\n    return [path, `diffMatchPatch(${op.value})`].join(': ')\n  }\n  if (op.type === 'inc' || op.type === 'dec') {\n    return [path, `${op.type}(${op.amount})`].join(': ')\n  }\n  if (op.type === 'set' || op.type === 'setIfMissing') {\n    return [path, `${op.type}(${JSON.stringify(op.value)})`].join(': ')\n  }\n  if (op.type === 'assign') {\n    return [path, `${op.type}(${JSON.stringify(op.value)})`].join(': ')\n  }\n  if (op.type === 'unassign') {\n    return [path, `${op.type}(${JSON.stringify(op.keys)})`].join(': ')\n  }\n  if (op.type === 'insert' || op.type === 'upsert') {\n    return [\n      path,\n      `${op.type}(${op.position}, ${encodeItemRef(\n        op.referenceItem,\n      )}, ${JSON.stringify(op.items)})`,\n    ].join(': ')\n  }\n  if (op.type === 'replace') {\n    return [\n      path,\n      `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(\n        op.items,\n      )})`,\n    ].join(': ')\n  }\n  if (op.type === 'truncate') {\n    return [path, `truncate(${op.startIndex}, ${op.endIndex}`].join(': ')\n  }\n  // @ts-expect-error all cases are covered\n  throw new Error(`Invalid operation type: ${op.type}`)\n}\n"],"names":["create","document","type","patch","id","patches","options","arrify","at","path","operation","parse","op","createIfNotExists","createOrReplace","delete_","del","destroy","set","value","assign","unassign","keys","setIfMissing","unset","inc","amount","arguments","length","undefined","dec","diffMatchPatch","insert","items","position","indexOrReferenceItem","referenceItem","append","prepend","insertBefore","insertAfter","truncate","startIndex","endIndex","replace","upsert","autoKeys","generateKey","ensureKeys","createEnsureKeys","insert$1","_insert","upsert$1","_upsert","replace$1","_replace","ref","hasKey","item","array","didModify","withKeys","map","needsKey","_key","arrayItem","isObject","encode","mutations","flatMap","encodeMutation","mutation","_a","delete","ifRevisionID","ifRevision","patchToSanity","stringifyPath","stringify","range","join","concat","Object","fromEntries","key","Error","isCreateIfNotExistsMutation","sanityMutation","isCreateOrReplaceMutation","isCreateMutation","isDeleteMutation","isPatchMutation","isSetPatch","sanityPatch","isSetIfMissingPatch","isUnsetPatch","isIncPatch","isDecPatch","isInsertPatch","decode","encodedMutation","reduce","muts","mut","decodeMutation","decodeNodePatches","JSON","POSITION_KEYS","getInsertPosition","positions","filter","k","getSetPatches","getSetIfMissingPatches","getUnsetPatches","getIncPatches","getDecPatches","getInsertPatches","parsePath","pop","m","encodeItemRef","maybeAddRevision","encodePatchMutation","revision","mutType","patchType","args","decodePatchMutation","serializedPath","revisionId","createOpts","decodeItemRef","format","nodePatch","formatPatchMutation"],"mappings":"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"}