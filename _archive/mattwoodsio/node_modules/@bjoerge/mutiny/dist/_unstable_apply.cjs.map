{"version":3,"file":"_unstable_apply.cjs","sources":["../src/apply/utils/getKeyOf.ts","../src/apply/utils/array.ts","../src/apply/patch/operations/common.ts","../src/apply/utils/hasOwn.ts","../src/apply/utils/isEmpty.ts","../src/apply/utils/omit.ts","../src/apply/patch/operations/object.ts","../src/apply/patch/operations/array.ts","../src/apply/patch/operations/number.ts","../src/apply/patch/operations/string.ts","../src/apply/patch/applyOp.ts","../src/apply/patch/applyNodePatch.ts","../src/apply/applyPatchMutation.ts","../src/apply/applyInCollection.ts","../src/apply/store/utils.ts","../src/apply/store/store.ts","../src/apply/applyInIndex.ts"],"sourcesContent":["export function keyOf(value: any): string | null {\n  return (\n    (value !== null &&\n      typeof value === 'object' &&\n      typeof value._key === 'string' &&\n      value._key) ||\n    null\n  )\n}\n","import {isKeyedElement} from '../../path'\nimport {keyOf} from './getKeyOf'\nimport type {PathElement} from '../../path'\n\nexport function findTargetIndex<T>(array: T[], pathSegment: PathElement) {\n  if (typeof pathSegment === 'number') {\n    return normalizeIndex(array.length, pathSegment)\n  }\n  if (isKeyedElement(pathSegment)) {\n    const idx = array.findIndex(value => keyOf(value) === pathSegment._key)\n    return idx === -1 ? null : idx\n  }\n  throw new Error(\n    `Expected path segment to be addressing a single array item either by numeric index or by '_key'. Instead saw ${JSON.stringify(\n      pathSegment,\n    )}`,\n  )\n}\n\nexport function getTargetIdx(position: 'before' | 'after', index: number) {\n  return position === 'before' ? index : index + 1\n}\n\n// normalizes the index according to the array length\n// returns null if the normalized index is out of bounds\nexport function normalizeIndex(length: number, index: number) {\n  if (length === 0 && (index === -1 || index === 0)) {\n    return 0\n  }\n  const normalized = index < 0 ? length + index : index\n  return normalized >= length || normalized < 0 ? null : normalized\n}\n\n// non-mutating splice\nexport function splice<T>(arr: T[], start: number, deleteCount: number): T[]\nexport function splice<T>(\n  arr: T[],\n  start: number,\n  deleteCount: number,\n  items: T[],\n): T[]\nexport function splice<T>(\n  arr: T[],\n  start: number,\n  deleteCount: number,\n  items?: T[],\n): T[] {\n  const copy = arr.slice()\n  copy.splice(start, deleteCount, ...(items || []))\n  return copy\n}\n","import type {\n  SetIfMissingOp,\n  SetOp,\n  UnsetOp,\n} from '../../../mutations/operations/types'\n\nexport function set<O extends SetOp<any>, CurrentValue>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  return op.value\n}\n\nexport function setIfMissing<O extends SetIfMissingOp<any>, CurrentValue>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  return currentValue ?? op.value\n}\n\nexport function unset<O extends UnsetOp, CurrentValue>(op: O) {\n  return undefined\n}\n","export const hasOwn = Object.prototype.hasOwnProperty.call.bind(\n  Object.prototype.hasOwnProperty,\n)\n","import {hasOwn} from './hasOwn'\n\nexport function isEmpty(v: object) {\n  for (const key in v) {\n    if (hasOwn(v, key)) {\n      return false\n    }\n  }\n  return true\n}\n","export function omit<T, K extends keyof T>(val: T, props: K[]): Omit<T, K> {\n  const copy = {...val}\n  for (const prop of props) {\n    delete copy[prop]\n  }\n  return copy\n}\n","import {isEmpty} from '../../utils/isEmpty'\nimport {omit} from '../../utils/omit'\nimport {isObject} from '../../../utils/isObject'\nimport type {AssignOp, UnassignOp} from '../../../mutations/operations/types'\n\nexport function unassign<T extends object, K extends string[]>(\n  op: UnassignOp<K>,\n  currentValue: T,\n) {\n  if (!isObject(currentValue)) {\n    throw new TypeError('Cannot apply \"unassign()\" on non-object value')\n  }\n\n  return op.keys.length === 0\n    ? currentValue\n    : omit(currentValue, op.keys as any[])\n}\n\nexport function assign<T extends object>(op: AssignOp<T>, currentValue: T) {\n  if (!isObject(currentValue)) {\n    throw new TypeError('Cannot apply \"assign()\" on non-object value')\n  }\n\n  return isEmpty(op.value) ? currentValue : {...currentValue, ...op.value}\n}\n","import {findTargetIndex, getTargetIdx, splice} from '../../utils/array'\nimport type {\n  InsertOp,\n  KeyedPathElement,\n  RelativePosition,\n  ReplaceOp,\n  TruncateOp,\n  UpsertOp,\n} from '../../../mutations/operations/types'\n\nexport function insert<\n  O extends InsertOp<unknown[], RelativePosition, number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"insert()\" on non-array value')\n  }\n\n  const index = findTargetIndex(currentValue, op.referenceItem)\n  if (index === null) {\n    throw new Error(`Found no matching array element to insert ${op.position}`)\n  }\n  // special case for empty arrays\n  if (currentValue.length === 0) {\n    return op.items\n  }\n  return splice(currentValue, getTargetIdx(op.position, index), 0, op.items)\n}\n\nexport function upsert<\n  O extends UpsertOp<unknown[], RelativePosition, number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"upsert()\" on non-array value')\n  }\n\n  if (op.items.length === 0) {\n    return currentValue\n  }\n  const replaceItemsMap: number[] = []\n  const insertItems: unknown[] = []\n  op.items.forEach((itemToBeUpserted: any, i) => {\n    const existingIndex = currentValue.findIndex(\n      existingItem => (existingItem as any)?._key === itemToBeUpserted._key,\n    )\n    if (existingIndex >= 0) {\n      replaceItemsMap[existingIndex] = i\n    } else {\n      insertItems.push(itemToBeUpserted)\n    }\n  })\n\n  if (replaceItemsMap.length === 0 && insertItems.length == 0) {\n    return currentValue\n  }\n\n  const next = [...currentValue]\n  // Replace existing items\n  for (const i of replaceItemsMap) {\n    next[i] = op.items[replaceItemsMap[i]!]!\n  }\n\n  // Insert the items that doesn't exist\n  return insert(\n    {\n      type: 'insert',\n      items: insertItems,\n      referenceItem: op.referenceItem,\n      position: op.position,\n    },\n    next,\n  )\n}\n\nexport function replace<\n  O extends ReplaceOp<unknown[], number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"replace()\" on non-array value')\n  }\n\n  const index = findTargetIndex(currentValue, op.referenceItem)\n  if (index === null) {\n    throw new Error(`Found no matching array element to replace`)\n  }\n  return splice(currentValue, index, op.items.length, op.items)\n}\n\nexport function truncate<O extends TruncateOp, CurrentValue extends unknown[]>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"truncate()\" on non-array value')\n  }\n\n  return typeof op.endIndex === 'number'\n    ? currentValue\n        .slice(0, op.startIndex)\n        .concat(currentValue.slice(op.endIndex))\n    : currentValue.slice(0, op.startIndex)\n}\n","import type {DecOp, IncOp} from '../../../mutations/operations/types'\n\nexport function inc<O extends IncOp<number>, CurrentValue extends number>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (typeof currentValue !== 'number') {\n    throw new TypeError('Cannot apply \"inc()\" on non-numeric value')\n  }\n\n  return currentValue + op.amount\n}\n\nexport function dec<O extends DecOp<number>, CurrentValue extends number>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (typeof currentValue !== 'number') {\n    throw new TypeError('Cannot apply \"dec()\" on non-numeric value')\n  }\n\n  return currentValue - op.amount\n}\n","import * as DMP from 'diff-match-patch'\nimport type {DiffMatchPatchOp} from '../../../mutations/operations/types'\n\nconst dmp = new DMP.diff_match_patch()\n\nexport function diffMatchPatch<\n  O extends DiffMatchPatchOp,\n  CurrentValue extends string,\n>(op: O, currentValue: CurrentValue) {\n  if (typeof currentValue !== 'string') {\n    throw new TypeError('Cannot apply \"diffMatchPatch()\" on non-string value')\n  }\n\n  return dmp.patch_apply(dmp.patch_fromText(op.value), currentValue)[0]\n}\n","import * as operations from './operations'\nimport type {\n  AnyOp,\n  ArrayOp,\n  NumberOp,\n  ObjectOp,\n  Operation,\n  StringOp,\n} from '../../mutations/operations/types'\nimport type {AnyArray} from '../../utils/typeUtils'\n\nimport type {ApplyOp} from './typings/applyOp'\n\nexport function applyOp<const Op extends AnyOp, const CurrentValue>(\n  op: Op,\n  currentValue: CurrentValue,\n): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends NumberOp,\n  const CurrentValue extends number,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends StringOp,\n  const CurrentValue extends string,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends ObjectOp,\n  const CurrentValue extends {[k in keyof any]: unknown},\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends ArrayOp,\n  const CurrentValue extends AnyArray,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<const Op extends Operation, const CurrentValue>(\n  op: Op,\n  currentValue: CurrentValue,\n): ApplyOp<Op, CurrentValue> {\n  if (!(op.type in operations)) {\n    throw new Error(`Invalid operation type: \"${op.type}\"`)\n  }\n\n  return (operations[op.type] as CallableFunction)(op, currentValue)\n}\n","import {isArrayElement, isPropertyElement, stringify} from '../../path'\nimport {isObject} from '../../utils/isObject'\nimport {findTargetIndex, splice} from '../utils/array'\nimport {applyOp} from './applyOp'\nimport type {KeyedPathElement, Path} from '../'\n\nimport type {\n  ApplyAtPath,\n  ApplyNodePatch,\n  ApplyPatches,\n} from './typings/applyNodePatch'\nimport type {NormalizeReadOnlyArray} from '../../utils/typeUtils'\nimport type {Operation} from '../../mutations/operations/types'\nimport type {NodePatch, NodePatchList} from '../../mutations/types'\n\nexport function applyPatches<Patches extends NodePatchList, const Doc>(\n  patches: Patches,\n  document: Doc,\n): ApplyPatches<NormalizeReadOnlyArray<Patches>, Doc> {\n  return (patches as NodePatch[]).reduce(\n    (prev, patch) => applyNodePatch(patch, prev) as any,\n    document,\n  ) as any\n}\n\nexport function applyNodePatch<const Patch extends NodePatch, const Doc>(\n  patch: Patch,\n  document: Doc,\n): ApplyNodePatch<Patch, Doc> {\n  return applyAtPath(patch.path, patch.op, document) as any\n}\n\nfunction applyAtPath<P extends Path, O extends Operation, T>(\n  path: P,\n  op: O,\n  value: T,\n): ApplyAtPath<P, O, T> {\n  if (isEmptyArray(path)) {\n    return applyOp(op as any, value) as any\n  }\n\n  const [head, ...tail] = path\n\n  if (isArrayElement(head) && Array.isArray(value)) {\n    return applyInArray(head, tail, op, value)\n  }\n\n  if (isPropertyElement(head) && isObject(value)) {\n    return applyInObject(head, tail, op, value) as any\n  }\n\n  throw new Error(\n    `Cannot apply operation of type \"${op.type}\" to path ${stringify(\n      path,\n    )} on ${typeof value} value`,\n  )\n}\n\nfunction applyInObject<Key extends keyof any, T extends {[key in Key]?: any}>(\n  head: Key,\n  tail: Path,\n  op: Operation,\n  object: T,\n) {\n  const current = object[head]\n\n  if (current === undefined && tail.length > 0) {\n    return object\n  }\n\n  // The patch targets the item at the index specified by \"head\"\n  // so forward it to the item\n  const patchedValue = applyAtPath(tail, op, current)\n\n  // If the result of applying it to the item yields the item back we assume it was\n  // a noop and don't modify our value. If we get a new value back, we return a\n  // new array with the modified item replaced\n  return patchedValue === current ? object : {...object, [head]: patchedValue}\n}\n\nfunction applyInArray<T>(\n  head: number | KeyedPathElement,\n  tail: Path,\n  op: Operation,\n  value: T[],\n) {\n  const index = findTargetIndex(value, head!)\n\n  if (index === null) {\n    // partial is default behavior for arrays\n    // the patch targets an index that is out of bounds\n    return value\n  }\n\n  // If the given selector could not be found, return as-is\n  if (index === -1) {\n    return value\n  }\n\n  const current = value[index]!\n\n  // The patch targets the item at the index specified by \"head\"\n  // so forward it to the item\n  const patchedItem = applyAtPath(tail, op, current)\n\n  // If the result of applying it to the item yields the item back we assume it was\n  // a noop and don't modify our value. If we get a new value back, we return a\n  // new array with the modified item replaced\n  return patchedItem === current\n    ? current\n    : splice(value, index, 1, [patchedItem])\n}\n\nfunction isEmptyArray(a: any[] | readonly any[]): a is [] {\n  return a.length === 0\n}\n","import {applyPatches} from './patch/applyNodePatch'\nimport type {NormalizeReadOnlyArray} from '../utils/typeUtils'\nimport type {ApplyPatches} from './patch/typings/applyNodePatch'\nimport type {PatchMutation, SanityDocumentBase} from '../mutations/types'\n\nexport type ApplyPatchMutation<\n  Mutation extends PatchMutation,\n  Doc extends SanityDocumentBase,\n> = Mutation extends PatchMutation<infer Patches>\n  ? ApplyPatches<NormalizeReadOnlyArray<Patches>, Doc>\n  : Doc\n\nexport function applyPatchMutation<\n  const Mutation extends PatchMutation,\n  const Doc extends SanityDocumentBase,\n>(mutation: Mutation, document: Doc): ApplyPatchMutation<Mutation, Doc> {\n  if (\n    mutation.options?.ifRevision &&\n    document._rev !== mutation.options.ifRevision\n  ) {\n    throw new Error('Revision mismatch')\n  }\n  if (mutation.id !== document._id) {\n    throw new Error(\n      `Document id mismatch. Refusing to apply mutation for document with id=\"${mutation.id}\" on the given document with id=\"${document._id}\"`,\n    )\n  }\n  return applyPatches(mutation.patches, document) as any\n}\n","import {arrify} from '../utils/arrify'\nimport {splice} from './utils/array'\nimport {applyPatchMutation} from './applyPatchMutation'\nimport type {\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  Mutation,\n  PatchMutation,\n  SanityDocumentBase,\n} from '../mutations/types'\n\nexport function applyInCollection<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutations: Mutation | Mutation[],\n) {\n  const a = arrify(mutations) as Mutation[]\n  return a.reduce((prev, mutation) => {\n    if (mutation.type === 'create') {\n      return createIn(prev, mutation)\n    }\n    if (mutation.type === 'createIfNotExists') {\n      return createIfNotExistsIn(prev, mutation)\n    }\n    if (mutation.type === 'delete') {\n      return deleteIn(prev, mutation)\n    }\n    if (mutation.type === 'createOrReplace') {\n      return createOrReplaceIn(prev, mutation)\n    }\n    if (mutation.type === 'patch') {\n      return patchIn(prev, mutation)\n    }\n    // @ts-expect-error all cases should be covered\n    throw new Error(`Invalid mutation type: ${mutation.type}`)\n  }, collection)\n}\n\nfunction createIn<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutation: CreateMutation<Doc>,\n) {\n  const currentIdx = collection.findIndex(\n    doc => doc._id === mutation.document._id,\n  )\n  if (currentIdx !== -1) {\n    throw new Error('Document already exist')\n  }\n  return collection.concat(mutation.document)\n}\n\nfunction createIfNotExistsIn<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutation: CreateIfNotExistsMutation<Doc>,\n) {\n  const currentIdx = collection.findIndex(\n    doc => doc._id === mutation.document._id,\n  )\n  return currentIdx === -1 ? collection.concat(mutation.document) : collection\n}\n\nfunction createOrReplaceIn<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutation: CreateOrReplaceMutation<Doc>,\n) {\n  const currentIdx = collection.findIndex(\n    doc => doc._id === mutation.document._id,\n  )\n  return currentIdx === -1\n    ? collection.concat(mutation.document)\n    : splice(collection, currentIdx, 1, [mutation.document])\n}\n\nfunction deleteIn<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutation: DeleteMutation,\n) {\n  const currentIdx = collection.findIndex(doc => doc._id === mutation.id)\n  return currentIdx === -1 ? collection : splice(collection, currentIdx, 1)\n}\n\nfunction patchIn<Doc extends SanityDocumentBase>(\n  collection: Doc[],\n  mutation: PatchMutation,\n): Doc[] {\n  const currentIdx = collection.findIndex(doc => doc._id === mutation.id)\n  if (currentIdx === -1) {\n    throw new Error('Cannot apply patch on nonexistent document')\n  }\n  const current = collection[currentIdx]!\n\n  const next = applyPatchMutation(mutation, current)\n\n  return next === current\n    ? collection\n    : splice(collection, currentIdx, 1, [next])\n}\n","import type {StoredDocument} from '../applyInIndex'\nimport type {SanityDocumentBase} from '../../mutations/types'\n\nexport function hasId(doc: SanityDocumentBase): doc is StoredDocument {\n  return '_id' in doc\n}\nexport function assignId<Doc extends SanityDocumentBase>(\n  doc: Doc,\n  generateId: () => string,\n): Doc & {_id: string} {\n  return hasId(doc) ? doc : {...doc, _id: generateId()}\n}\n","import {nanoid} from 'nanoid'\nimport {arrify} from '../../utils/arrify'\nimport {applyInIndex} from '../applyInIndex'\nimport {assignId} from './utils'\nimport type {ToIdentified, ToStored} from '../applyInIndex'\nimport type {DocumentIndex, Format} from '../../apply'\nimport type {Mutation, SanityDocumentBase} from '../../mutations/types'\n\nexport type RequiredSelect<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]-?: T[P]\n}\n\nfunction update<Doc extends ToIdentified<SanityDocumentBase>>(\n  doc: Doc,\n  revision: string,\n): ToStored<Doc> {\n  return {\n    ...doc,\n    _rev: revision,\n    _createdAt: doc._createdAt || new Date().toISOString(),\n    _updatedAt: new Date().toISOString(),\n  }\n}\n\nconst empty: DocumentIndex<any> = {}\n\nexport const createStore = <Doc extends SanityDocumentBase>(\n  initialEntries?: Doc[],\n) => {\n  let version = 0\n\n  let index: DocumentIndex<Format<ToStored<Doc & SanityDocumentBase>>> =\n    initialEntries && initialEntries?.length > 0\n      ? Object.fromEntries(\n          initialEntries.map(entry => {\n            const doc = update(assignId(entry, nanoid), nanoid())\n            return [doc._id, doc]\n          }),\n        )\n      : empty\n\n  return {\n    get version() {\n      return version\n    },\n    // todo: support listening for changes\n    entries: () => Object.entries(index),\n    get: <Id extends string>(\n      id: Id,\n    ): Format<Omit<(typeof index)[keyof typeof index], '_id'> & {_id: Id}> =>\n      index[id] as any,\n    apply: (mutations: Mutation[] | Mutation) => {\n      const nextIndex = applyInIndex(index, arrify(mutations))\n      if (nextIndex !== index) {\n        index = nextIndex\n        version++\n      }\n    },\n  }\n}\n","import {nanoid} from 'nanoid'\nimport {assignId, hasId} from './store'\nimport {applyPatchMutation} from './applyPatchMutation'\nimport type {RequiredSelect} from './store'\nimport type {\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  Mutation,\n  PatchMutation,\n  SanityDocumentBase,\n} from '../mutations/types'\n\nexport type DocumentIndex<Doc extends SanityDocumentBase> = {[id: string]: Doc}\n\nexport function applyInIndex<\n  Doc extends SanityDocumentBase,\n  Index extends DocumentIndex<ToStored<Doc>>,\n>(index: Index, mutations: Mutation<Doc>[]): Index {\n  return mutations.reduce((prev, mutation) => {\n    if (mutation.type === 'create') {\n      return createIn(prev, mutation)\n    }\n    if (mutation.type === 'createIfNotExists') {\n      return createIfNotExistsIn(prev, mutation)\n    }\n    if (mutation.type === 'delete') {\n      return deleteIn(prev, mutation)\n    }\n    if (mutation.type === 'createOrReplace') {\n      return createOrReplaceIn(prev, mutation)\n    }\n    if (mutation.type === 'patch') {\n      return patchIn(prev, mutation)\n    }\n    // @ts-expect-error all cases should be covered\n    throw new Error(`Invalid mutation type: ${mutation.type}`)\n  }, index)\n}\n\nexport type ToStored<Doc extends SanityDocumentBase> = Doc &\n  Required<SanityDocumentBase>\n\nexport type ToIdentified<Doc extends SanityDocumentBase> = RequiredSelect<\n  Doc,\n  '_id'\n>\n\nexport type StoredDocument = ToStored<SanityDocumentBase>\n\nfunction createIn<\n  Index extends DocumentIndex<Doc>,\n  Doc extends SanityDocumentBase,\n>(index: Index, mutation: CreateMutation<Doc>): Index {\n  const document = assignId(mutation.document, nanoid)\n\n  if (document._id in index) {\n    throw new Error('Document already exist')\n  }\n  return {...index, [document._id]: mutation.document}\n}\n\nfunction createIfNotExistsIn<\n  Index extends DocumentIndex<Doc>,\n  Doc extends SanityDocumentBase,\n>(index: Index, mutation: CreateIfNotExistsMutation<Doc>): Index {\n  if (!hasId(mutation.document)) {\n    throw new Error('Cannot createIfNotExists on document without _id')\n  }\n  return mutation.document._id in index\n    ? index\n    : {...index, [mutation.document._id]: mutation.document}\n}\n\nfunction createOrReplaceIn<\n  Index extends DocumentIndex<Doc>,\n  Doc extends SanityDocumentBase,\n>(index: Index, mutation: CreateOrReplaceMutation<Doc>): Index {\n  if (!hasId(mutation.document)) {\n    throw new Error('Cannot createIfNotExists on document without _id')\n  }\n\n  return {...index, [mutation.document._id]: mutation.document}\n}\n\nfunction deleteIn<Index extends DocumentIndex<SanityDocumentBase>>(\n  index: Index,\n  mutation: DeleteMutation,\n): Index {\n  if (mutation.id in index) {\n    const copy = {...index}\n    delete copy[mutation.id]\n    return copy\n  } else {\n    return index\n  }\n}\n\nfunction patchIn<Index extends DocumentIndex<SanityDocumentBase>>(\n  index: Index,\n  mutation: PatchMutation,\n): Index {\n  if (!(mutation.id in index)) {\n    throw new Error('Cannot apply patch on nonexistent document')\n  }\n  const current = index[mutation.id]!\n  const next = applyPatchMutation(mutation, current)\n\n  return next === current ? index : {...index, [mutation.id]: next}\n}\n"],"names":["keyOf","value","_key","findTargetIndex","array","pathSegment","normalizeIndex","length","isKeyedElement","idx","findIndex","Error","concat","JSON","stringify","getTargetIdx","position","index","normalized","splice","arr","start","deleteCount","items","copy","slice","set","op","currentValue","setIfMissing","unset","hasOwn","Object","prototype","hasOwnProperty","call","bind","isEmpty","v","key","omit","val","props","prop","unassign","isObject","TypeError","keys","assign","insert","Array","isArray","referenceItem","upsert","replaceItemsMap","insertItems","forEach","itemToBeUpserted","i","existingIndex","existingItem","push","next","type","replace","truncate","endIndex","startIndex","inc","amount","dec","dmp","DMP","diff_match_patch","diffMatchPatch","patch_apply","patch_fromText","applyOp","operations","applyPatches","patches","document","reduce","prev","patch","applyNodePatch","applyAtPath","path","isEmptyArray","head","tail","isArrayElement","applyInArray","isPropertyElement","applyInObject","object","current","patchedValue","patchedItem","a","applyPatchMutation","mutation","_a","options","ifRevision","_rev","id","_id","applyInCollection","collection","mutations","arrify","createIn","createIfNotExistsIn","deleteIn","createOrReplaceIn","patchIn","createIn$1","currentIdx","doc","createIfNotExistsIn$1","createOrReplaceIn$1","deleteIn$1","patchIn$1","hasId","assignId","generateId","update","revision","_createdAt","Date","toISOString","_updatedAt","empty","createStore","initialEntries","version","fromEntries","map","entry","nanoid","entries","get","apply","nextIndex","applyInIndex"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,SAASA,MAAMC,KAA2B,EAAA;EAE5C,OAAAA,KAAA,KAAU,IACT,IAAA,OAAOA,KAAU,KAAA,QAAA,IACjB,OAAOA,KAAM,CAAAC,IAAA,KAAS,QACtB,IAAAD,KAAA,CAAMC,IACR,IAAA,IAAA;AAEJ;ACJgB,SAAAC,eAAAA,CAAmBC,OAAYC,WAA0B,EAAA;EACnE,IAAA,OAAOA,gBAAgB,QAAU,EAAA;IAC5B,OAAAC,cAAA,CAAeF,KAAM,CAAAG,MAAA,EAAQF,WAAW,CAAA;EACjD;EACI,IAAAG,SAAAA,CAAAA,cAAA,CAAeH,WAAW,CAAG,EAAA;IACzB,MAAAI,GAAA,GAAML,MAAMM,SAAU,CAAAT,KAAA,IAASD,MAAMC,KAAK,CAAA,KAAMI,YAAYH,IAAI,CAAA;IAC/D,OAAAO,GAAA,KAAQ,KAAK,IAAO,GAAAA,GAAA;EAC7B;EACA,MAAM,IAAIE,KAAA,CACR,gHAAgHC,MAAK,CAAAC,IAAA,CAAAC,SAAA,CACnHT,WAAA,CACF,CAAA,CACF;AACF;AAEgB,SAAAU,YAAAA,CAAaC,UAA8BC,KAAe,EAAA;EACjE,OAAAD,QAAA,KAAa,QAAW,GAAAC,KAAA,GAAQA,KAAQ,GAAA,CAAA;AACjD;AAIgB,SAAAX,cAAAA,CAAeC,QAAgBU,KAAe,EAAA;EAC5D,IAAIV,MAAW,KAAA,CAAA,KAAMU,KAAU,KAAA,CAAA,CAAA,IAAMA,UAAU,CAAI,CAAA,EAAA;IAC1C,OAAA,CAAA;EACT;EACA,MAAMC,UAAa,GAAAD,KAAA,GAAQ,CAAI,GAAAV,MAAA,GAASU,KAAQ,GAAAA,KAAA;EAChD,OAAOC,UAAc,IAAAX,MAAA,IAAUW,UAAa,GAAA,CAAA,GAAI,IAAO,GAAAA,UAAA;AACzD;AAUO,SAASC,MACdA,CAAAC,GAAA,EACAC,KACA,EAAAC,WAAA,EACAC,KACK,EAAA;EACC,MAAAC,IAAA,GAAOJ,IAAIK,KAAM,EAAA;EACvBD,IAAA,CAAKL,OAAOE,KAAO,EAAAC,WAAA,EAAa,IAAIC,KAAA,IAAS,EAAG,EAAA;EACzC,OAAAC,IAAA;AACT;AC5CgB,SAAAE,GAAAA,CACdC,IACAC,YACA,EAAA;EACA,OAAOD,EAAG,CAAA1B,KAAA;AACZ;AAEgB,SAAA4B,YAAAA,CACdF,IACAC,YACA,EAAA;EACA,OAAOA,sCAAgBD,EAAG,CAAA1B,KAAA;AAC5B;AAEO,SAAS6B,MAAuCH,EAAO,EAAA;EACrD,OAAA,KAAA,CAAA;AACT;ACtBO,MAAMI,MAAS,GAAAC,MAAA,CAAOC,SAAU,CAAAC,cAAA,CAAeC,IAAK,CAAAC,IAAA,CACzDJ,OAAOC,SAAU,CAAAC,cACnB,CAAA;ACAO,SAASG,QAAQC,CAAW,EAAA;EACjC,KAAA,MAAWC,OAAOD,CAAG,EAAA;IACf,IAAAP,MAAA,CAAOO,CAAG,EAAAC,GAAG,CAAG,EAAA;MACX,OAAA,KAAA;IACT;EACF;EACO,OAAA,IAAA;AACT;ACTgB,SAAAC,IAAAA,CAA2BC,KAAQC,KAAwB,EAAA;EACnE,MAAAlB,IAAA,GAAO;IAAC,GAAGiB;GAAG;EACpB,KAAA,MAAWE,QAAQD,KAAO,EAAA;IACxB,OAAOlB,KAAKmB,IAAI,CAAA;EAClB;EACO,OAAAnB,IAAA;AACT;ACDgB,SAAAoB,QAAAA,CACdjB,IACAC,YACA,EAAA;EACI,IAAA,CAACiB,QAAAA,CAAAA,QAAS,CAAAjB,YAAY,CAAG,EAAA;IACrB,MAAA,IAAIkB,UAAU,+CAA+C,CAAA;EACrE;EAEO,OAAAnB,EAAA,CAAGoB,KAAKxC,MAAW,KAAA,CAAA,GACtBqB,eACAY,IAAK,CAAAZ,YAAA,EAAcD,GAAGoB,IAAa,CAAA;AACzC;AAEgB,SAAAC,MAAAA,CAAyBrB,IAAiBC,YAAiB,EAAA;EACrE,IAAA,CAACiB,QAAAA,CAAAA,QAAS,CAAAjB,YAAY,CAAG,EAAA;IACrB,MAAA,IAAIkB,UAAU,6CAA6C,CAAA;EACnE;EAEO,OAAAT,OAAA,CAAQV,EAAG,CAAA1B,KAAK,CAAI,GAAA2B,YAAA,GAAe;IAAC,GAAGA,YAAA;IAAc,GAAGD,EAAA,CAAG1B;GAAK;AACzE;ACdgB,SAAAgD,MAAAA,CAGdtB,IAAOC,YAA4B,EAAA;EACnC,IAAI,CAACsB,KAAA,CAAMC,OAAQ,CAAAvB,YAAY,CAAG,EAAA;IAC1B,MAAA,IAAIkB,UAAU,4CAA4C,CAAA;EAClE;EAEA,MAAM7B,KAAQ,GAAAd,eAAA,CAAgByB,YAAc,EAAAD,EAAA,CAAGyB,aAAa,CAAA;EAC5D,IAAInC,UAAU,IAAM,EAAA;IAClB,MAAM,IAAIN,KAAA,CAAM,4CAA6C,CAAAC,MAAA,CAAAe,EAAA,CAAGX,QAAU,CAAA,CAAA;EAC5E;EAEI,IAAAY,YAAA,CAAarB,WAAW,CAAG,EAAA;IAC7B,OAAOoB,EAAG,CAAAJ,KAAA;EACZ;EACO,OAAAJ,MAAA,CAAOS,cAAcb,YAAa,CAAAY,EAAA,CAAGX,UAAUC,KAAK,CAAA,EAAG,CAAG,EAAAU,EAAA,CAAGJ,KAAK,CAAA;AAC3E;AAEgB,SAAA8B,MAAAA,CAGd1B,IAAOC,YAA4B,EAAA;EACnC,IAAI,CAACsB,KAAA,CAAMC,OAAQ,CAAAvB,YAAY,CAAG,EAAA;IAC1B,MAAA,IAAIkB,UAAU,4CAA4C,CAAA;EAClE;EAEI,IAAAnB,EAAA,CAAGJ,KAAM,CAAAhB,MAAA,KAAW,CAAG,EAAA;IAClB,OAAAqB,YAAA;EACT;EACA,MAAM0B,kBAA4B,EAAC;EACnC,MAAMC,cAAyB,EAAC;EAChC5B,EAAA,CAAGJ,KAAM,CAAAiC,OAAA,CAAQ,CAACC,gBAAA,EAAuBC,CAAM,KAAA;IAC7C,MAAMC,gBAAgB/B,YAAa,CAAAlB,SAAA,CACjCkD,YAAA,IAAA,CAAiBA,YAAsB,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,YAAA,CAAA1D,IAAA,MAASuD,gBAAiB,CAAAvD,IAAA,CACnE;IACA,IAAIyD,iBAAiB,CAAG,EAAA;MACtBL,eAAA,CAAgBK,aAAa,CAAI,GAAAD,CAAA;IAAA,CAC5B,MAAA;MACLH,WAAA,CAAYM,KAAKJ,gBAAgB,CAAA;IACnC;EAAA,CACD,CAAA;EAED,IAAIH,eAAgB,CAAA/C,MAAA,KAAW,CAAK,IAAAgD,WAAA,CAAYhD,UAAU,CAAG,EAAA;IACpD,OAAAqB,YAAA;EACT;EAEM,MAAAkC,IAAA,GAAO,CAAC,GAAGlC,YAAY,CAAA;EAE7B,KAAA,MAAW8B,KAAKJ,eAAiB,EAAA;IAC/BQ,IAAA,CAAKJ,CAAC,CAAI,GAAA/B,EAAA,CAAGJ,KAAM,CAAA+B,eAAA,CAAgBI,CAAC,CAAE,CAAA;EACxC;EAGO,OAAAT,MAAA,CACL;IACEc,IAAM,EAAA,QAAA;IACNxC,KAAO,EAAAgC,WAAA;IACPH,eAAezB,EAAG,CAAAyB,aAAA;IAClBpC,UAAUW,EAAG,CAAAX;EACf,CAAA,EACA8C,IAAA,CACF;AACF;AAEgB,SAAAE,OAAAA,CAGdrC,IAAOC,YAA4B,EAAA;EACnC,IAAI,CAACsB,KAAA,CAAMC,OAAQ,CAAAvB,YAAY,CAAG,EAAA;IAC1B,MAAA,IAAIkB,UAAU,6CAA6C,CAAA;EACnE;EAEA,MAAM7B,KAAQ,GAAAd,eAAA,CAAgByB,YAAc,EAAAD,EAAA,CAAGyB,aAAa,CAAA;EAC5D,IAAInC,UAAU,IAAM,EAAA;IACZ,MAAA,IAAIN,MAAM,4CAA4C,CAAA;EAC9D;EACA,OAAOQ,OAAOS,YAAc,EAAAX,KAAA,EAAOU,GAAGJ,KAAM,CAAAhB,MAAA,EAAQoB,GAAGJ,KAAK,CAAA;AAC9D;AAEgB,SAAA0C,QAAAA,CACdtC,IACAC,YACA,EAAA;EACA,IAAI,CAACsB,KAAA,CAAMC,OAAQ,CAAAvB,YAAY,CAAG,EAAA;IAC1B,MAAA,IAAIkB,UAAU,8CAA8C,CAAA;EACpE;EAEO,OAAA,OAAOnB,GAAGuC,QAAa,KAAA,QAAA,GAC1BtC,aACGH,KAAM,CAAA,CAAA,EAAGE,GAAGwC,UAAU,CAAA,CACtBvD,OAAOgB,YAAa,CAAAH,KAAA,CAAME,GAAGuC,QAAQ,CAAC,IACzCtC,YAAa,CAAAH,KAAA,CAAM,CAAG,EAAAE,EAAA,CAAGwC,UAAU,CAAA;AACzC;ACrGgB,SAAAC,GAAAA,CACdzC,IACAC,YACA,EAAA;EACI,IAAA,OAAOA,iBAAiB,QAAU,EAAA;IAC9B,MAAA,IAAIkB,UAAU,2CAA2C,CAAA;EACjE;EAEA,OAAOlB,eAAeD,EAAG,CAAA0C,MAAA;AAC3B;AAEgB,SAAAC,GAAAA,CACd3C,IACAC,YACA,EAAA;EACI,IAAA,OAAOA,iBAAiB,QAAU,EAAA;IAC9B,MAAA,IAAIkB,UAAU,2CAA2C,CAAA;EACjE;EAEA,OAAOlB,eAAeD,EAAG,CAAA0C,MAAA;AAC3B;ACnBA,MAAME,GAAA,GAAM,IAAIC,cAAA,CAAIC,gBAAiB,EAAA;AAErB,SAAAC,cAAAA,CAGd/C,IAAOC,YAA4B,EAAA;EAC/B,IAAA,OAAOA,iBAAiB,QAAU,EAAA;IAC9B,MAAA,IAAIkB,UAAU,qDAAqD,CAAA;EAC3E;EAEO,OAAAyB,GAAA,CAAII,YAAYJ,GAAI,CAAAK,cAAA,CAAejD,GAAG1B,KAAK,CAAA,EAAG2B,YAAY,CAAA,CAAE,CAAC,CAAA;AACtE;;;;;;;;;;;;;;;;ACmBgB,SAAAiD,OAAAA,CACdlD,IACAC,YAC2B,EAAA;EACvB,IAAA,EAAED,EAAG,CAAAoC,IAAA,IAAQe,UAAa,CAAA,EAAA;IAC5B,MAAM,IAAInE,KAAA,CAAM,2BAA4B,CAAAC,MAAA,CAAAe,EAAA,CAAGoC,MAAI,GAAG,CAAA,CAAA;EACxD;EAEA,OAAQe,UAAW,CAAAnD,EAAA,CAAGoC,IAAI,CAAA,CAAuBpC,IAAIC,YAAY,CAAA;AACnE;AC3BgB,SAAAmD,YAAAA,CACdC,SACAC,QACoD,EAAA;EACpD,OAAQD,OAAwB,CAAAE,MAAA,CAC9B,CAACC,IAAA,EAAMC,KAAU,KAAAC,cAAA,CAAeD,OAAOD,IAAI,CAAA,EAC3CF,QAAA,CACF;AACF;AAEgB,SAAAI,cAAAA,CACdD,OACAH,QAC4B,EAAA;EAC5B,OAAOK,WAAY,CAAAF,KAAA,CAAMG,IAAM,EAAAH,KAAA,CAAMzD,IAAIsD,QAAQ,CAAA;AACnD;AAEA,SAASK,WAAAA,CACPC,IACA,EAAA5D,EAAA,EACA1B,KACsB,EAAA;EAClB,IAAAuF,YAAA,CAAaD,IAAI,CAAG,EAAA;IACf,OAAAV,OAAA,CAAQlD,IAAW1B,KAAK,CAAA;EACjC;EAEA,MAAM,CAACwF,IAAA,EAAM,GAAGC,IAAI,CAAI,GAAAH,IAAA;EAExB,IAAII,SAAAA,CAAAA,eAAeF,IAAI,CAAA,IAAKvC,KAAM,CAAAC,OAAA,CAAQlD,KAAK,CAAG,EAAA;IAChD,OAAO2F,YAAa,CAAAH,IAAA,EAAMC,IAAM,EAAA/D,EAAA,EAAI1B,KAAK,CAAA;EAC3C;EAEA,IAAI4F,SAAkB,CAAAA,iBAAA,CAAAJ,IAAI,CAAK,IAAA5C,QAAA,CAAAA,QAAA,CAAS5C,KAAK,CAAG,EAAA;IAC9C,OAAO6F,aAAc,CAAAL,IAAA,EAAMC,IAAM,EAAA/D,EAAA,EAAI1B,KAAK,CAAA;EAC5C;EAEA,MAAM,IAAIU,KAAA,CACR,kCAAA,CAAmCC,MAAG,CAAAe,EAAA,CAAAoC,IAAA,EAAI,YAAa,CAAA,CAAAnD,MAAA,CAAAE,SAAA,CAAAA,SAAA,CACrDyE,IACF,CAAA,EAAC,MAAO,CAAA,CAAA3E,MAAA,CAAA,OAAOX,KAAK,EAAA,QAAA,CAAA,CACtB;AACF;AAEA,SAAS6F,aACPA,CAAAL,IAAA,EACAC,IACA,EAAA/D,EAAA,EACAoE,MACA,EAAA;EACM,MAAAC,OAAA,GAAUD,OAAON,IAAI,CAAA;EAE3B,IAAIO,OAAY,KAAA,KAAA,CAAA,IAAaN,IAAK,CAAAnF,MAAA,GAAS,CAAG,EAAA;IACrC,OAAAwF,MAAA;EACT;EAIA,MAAME,YAAe,GAAAX,WAAA,CAAYI,IAAM,EAAA/D,EAAA,EAAIqE,OAAO,CAAA;EAK3C,OAAAC,YAAA,KAAiBD,UAAUD,MAAS,GAAA;IAAC,GAAGA,MAAQ;IAAA,CAACN,IAAI,GAAGQ;GAAY;AAC7E;AAEA,SAASL,YACPA,CAAAH,IAAA,EACAC,IACA,EAAA/D,EAAA,EACA1B,KACA,EAAA;EACM,MAAAgB,KAAA,GAAQd,eAAgB,CAAAF,KAAA,EAAOwF,IAAK,CAAA;EAE1C,IAAIxE,UAAU,IAAM,EAAA;IAGX,OAAAhB,KAAA;EACT;EAGA,IAAIgB,UAAU,CAAI,CAAA,EAAA;IACT,OAAAhB,KAAA;EACT;EAEM,MAAA+F,OAAA,GAAU/F,MAAMgB,KAAK,CAAA;EAI3B,MAAMiF,WAAc,GAAAZ,WAAA,CAAYI,IAAM,EAAA/D,EAAA,EAAIqE,OAAO,CAAA;EAK1C,OAAAE,WAAA,KAAgBF,UACnBA,OACA,GAAA7E,MAAA,CAAOlB,OAAOgB,KAAO,EAAA,CAAA,EAAG,CAACiF,WAAW,CAAC,CAAA;AAC3C;AAEA,SAASV,aAAaW,CAAoC,EAAA;EACxD,OAAOA,EAAE5F,MAAW,KAAA,CAAA;AACtB;ACvGgB,SAAA6F,kBAAAA,CAGdC,UAAoBpB,QAAkD,EAAA;EAfxE,IAAAqB,EAAA;EAiBI,IAAA,CAAA,CAAAA,EAAA,GAAAD,QAAA,CAASE,YAAT,IAAkB,GAAA,KAAA,CAAA,GAAAD,EAAA,CAAAE,UAAA,KAClBvB,SAASwB,IAAS,KAAAJ,QAAA,CAASE,QAAQC,UACnC,EAAA;IACM,MAAA,IAAI7F,MAAM,mBAAmB,CAAA;EACrC;EACI,IAAA0F,QAAA,CAASK,EAAO,KAAAzB,QAAA,CAAS0B,GAAK,EAAA;IAChC,MAAM,IAAIhG,KAAA,CACR,yEAA0E,CAAAC,MAAA,CAAAyF,QAAA,CAASK,EAAE,EAAA,mCAAA,CAAA,CAAoC9F,gBAAS+F,GAAG,EAAA,GAAA,CAAA,CACvI;EACF;EACO,OAAA5B,YAAA,CAAasB,QAAS,CAAArB,OAAA,EAASC,QAAQ,CAAA;AAChD;ACfgB,SAAA2B,iBAAAA,CACdC,YACAC,SACA,EAAA;EACM,MAAAX,CAAA,GAAIY,gBAAOD,SAAS,CAAA;EAC1B,OAAOX,CAAE,CAAAjB,MAAA,CAAO,CAACC,IAAA,EAAMkB,QAAa,KAAA;IAC9B,IAAAA,QAAA,CAAStC,SAAS,QAAU,EAAA;MACvB,OAAAiD,UAAA,CAAS7B,MAAMkB,QAAQ,CAAA;IAChC;IACI,IAAAA,QAAA,CAAStC,SAAS,mBAAqB,EAAA;MAClC,OAAAkD,qBAAA,CAAoB9B,MAAMkB,QAAQ,CAAA;IAC3C;IACI,IAAAA,QAAA,CAAStC,SAAS,QAAU,EAAA;MACvB,OAAAmD,UAAA,CAAS/B,MAAMkB,QAAQ,CAAA;IAChC;IACI,IAAAA,QAAA,CAAStC,SAAS,iBAAmB,EAAA;MAChC,OAAAoD,mBAAA,CAAkBhC,MAAMkB,QAAQ,CAAA;IACzC;IACI,IAAAA,QAAA,CAAStC,SAAS,OAAS,EAAA;MACtB,OAAAqD,SAAA,CAAQjC,MAAMkB,QAAQ,CAAA;IAC/B;IAEA,MAAM,IAAI1F,KAAA,CAAM,yBAA0B,CAAAC,MAAA,CAAAyF,QAAA,CAAStC,IAAM,CAAA,CAAA;KACxD8C,UAAU,CAAA;AACf;AAEA,SAASG,UAAAK,CACPR,YACAR,QACA,EAAA;EACA,MAAMiB,aAAaT,UAAW,CAAAnG,SAAA,CACrB6G,GAAA,IAAAA,GAAA,CAAIZ,GAAQ,KAAAN,QAAA,CAASpB,QAAS,CAAA0B,GAAA,CACvC;EACA,IAAIW,eAAe,CAAI,CAAA,EAAA;IACf,MAAA,IAAI3G,MAAM,wBAAwB,CAAA;EAC1C;EACO,OAAAkG,UAAA,CAAWjG,MAAO,CAAAyF,QAAA,CAASpB,QAAQ,CAAA;AAC5C;AAEA,SAASgC,qBAAAO,CACPX,YACAR,QACA,EAAA;EACA,MAAMiB,aAAaT,UAAW,CAAAnG,SAAA,CACrB6G,GAAA,IAAAA,GAAA,CAAIZ,GAAQ,KAAAN,QAAA,CAASpB,QAAS,CAAA0B,GAAA,CACvC;EACA,OAAOW,eAAe,CAAK,CAAA,GAAAT,UAAA,CAAWjG,MAAO,CAAAyF,QAAA,CAASpB,QAAQ,CAAI,GAAA4B,UAAA;AACpE;AAEA,SAASM,mBAAAM,CACPZ,YACAR,QACA,EAAA;EACA,MAAMiB,aAAaT,UAAW,CAAAnG,SAAA,CACrB6G,GAAA,IAAAA,GAAA,CAAIZ,GAAQ,KAAAN,QAAA,CAASpB,QAAS,CAAA0B,GAAA,CACvC;EACA,OAAOW,UAAe,KAAA,CAAA,CAAA,GAClBT,UAAW,CAAAjG,MAAA,CAAOyF,SAASpB,QAAQ,CAAA,GACnC9D,MAAO,CAAA0F,UAAA,EAAYS,UAAY,EAAA,CAAA,EAAG,CAACjB,QAAA,CAASpB,QAAQ,CAAC,CAAA;AAC3D;AAEA,SAASiC,UAAAQ,CACPb,YACAR,QACA,EAAA;EACA,MAAMiB,aAAaT,UAAW,CAAAnG,SAAA,QAAiB6G,GAAI,CAAAZ,GAAA,KAAQN,SAASK,EAAE,CAAA;EACtE,OAAOY,eAAe,CAAK,CAAA,GAAAT,UAAA,GAAa1F,MAAO,CAAA0F,UAAA,EAAYS,YAAY,CAAC,CAAA;AAC1E;AAEA,SAASF,SAAAO,CACPd,YACAR,QACO,EAAA;EACP,MAAMiB,aAAaT,UAAW,CAAAnG,SAAA,QAAiB6G,GAAI,CAAAZ,GAAA,KAAQN,SAASK,EAAE,CAAA;EACtE,IAAIY,eAAe,CAAI,CAAA,EAAA;IACf,MAAA,IAAI3G,MAAM,4CAA4C,CAAA;EAC9D;EACM,MAAAqF,OAAA,GAAUa,WAAWS,UAAU,CAAA;EAE/B,MAAAxD,IAAA,GAAOsC,kBAAmB,CAAAC,QAAA,EAAUL,OAAO,CAAA;EAE1C,OAAAlC,IAAA,KAASkC,UACZa,UACA,GAAA1F,MAAA,CAAO0F,YAAYS,UAAY,EAAA,CAAA,EAAG,CAACxD,IAAI,CAAC,CAAA;AAC9C;AC9FO,SAAS8D,MAAML,GAAgD,EAAA;EACpE,OAAO,KAAS,IAAAA,GAAA;AAClB;AACgB,SAAAM,QAAAA,CACdN,KACAO,UACqB,EAAA;EACd,OAAAF,KAAA,CAAML,GAAG,CAAI,GAAAA,GAAA,GAAM;IAAC,GAAGA,GAAA;IAAKZ,GAAK,EAAAmB,UAAA,CAAA;GAAY;AACtD;ACCA,SAASC,MAAAA,CACPR,KACAS,QACe,EAAA;EACR,OAAA;IACL,GAAGT,GAAA;IACHd,IAAM,EAAAuB,QAAA;IACNC,YAAYV,GAAI,CAAAU,UAAA,IAAA,EAAkB,eAAA,IAAAC,IAAA,CAAA,GAAOC,WAAY,CAAA,CAAA;IACrDC,UAAY,EAAA,EAAA,eAAA,IAAIF,IAAK,CAAA,CAAA,EAAEC,WAAY,CAAA;EAAA,CACrC;AACF;AAEA,MAAME,QAA4B,CAAA,CAAC;AAEtB,MAAAC,WAAA,GACXC,cACG,IAAA;EACH,IAAIC,OAAU,GAAA,CAAA;EAEd,IAAIvH,KACF,GAAAsH,cAAA,IAAA,CAAkBA,cAAgB,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,cAAA,CAAAhI,MAAA,IAAS,IACvCyB,MAAO,CAAAyG,WAAA,CACLF,cAAA,CAAeG,IAAaC,KAAA,IAAA;IAC1B,MAAMpB,MAAMQ,MAAO,CAAAF,QAAA,CAASc,OAAOC,aAAM,CAAA,EAAGA,eAAQ,CAAA;IAC7C,OAAA,CAACrB,GAAI,CAAAZ,GAAA,EAAKY,GAAG,CAAA;EAAA,CACrB,CAEH,CAAA,GAAAc,KAAA;EAEC,OAAA;IACL,IAAIG,OAAUA,CAAA,EAAA;MACL,OAAAA,OAAA;IACT,CAAA;IAAA;IAEAK,OAAS,EAAAA,CAAA,KAAM7G,MAAO,CAAA6G,OAAA,CAAQ5H,KAAK,CAAA;IACnC6H,GAAK,EACHpC,EAEA,IAAAzF,KAAA,CAAMyF,EAAE,CAAA;IACVqC,KAAA,EAAQjC,SAAqC,IAAA;MAC3C,MAAMkC,SAAY,GAAAC,YAAA,CAAahI,KAAO,EAAA8F,QAAAA,CAAAA,MAAA,CAAOD,SAAS,CAAC,CAAA;MACvD,IAAIkC,cAAc/H,KAAO,EAAA;QACfA,KAAA,GAAA+H,SAAA;QACRR,OAAA,EAAA;MACF;IACF;EAAA,CACF;AACF,CAAA;AC3CgB,SAAAS,YAAAA,CAGdhI,OAAc6F,SAAmC,EAAA;EACjD,OAAOA,SAAU,CAAA5B,MAAA,CAAO,CAACC,IAAA,EAAMkB,QAAa,KAAA;IACtC,IAAAA,QAAA,CAAStC,SAAS,QAAU,EAAA;MACvB,OAAAiD,QAAA,CAAS7B,MAAMkB,QAAQ,CAAA;IAChC;IACI,IAAAA,QAAA,CAAStC,SAAS,mBAAqB,EAAA;MAClC,OAAAkD,mBAAA,CAAoB9B,MAAMkB,QAAQ,CAAA;IAC3C;IACI,IAAAA,QAAA,CAAStC,SAAS,QAAU,EAAA;MACvB,OAAAmD,QAAA,CAAS/B,MAAMkB,QAAQ,CAAA;IAChC;IACI,IAAAA,QAAA,CAAStC,SAAS,iBAAmB,EAAA;MAChC,OAAAoD,iBAAA,CAAkBhC,MAAMkB,QAAQ,CAAA;IACzC;IACI,IAAAA,QAAA,CAAStC,SAAS,OAAS,EAAA;MACtB,OAAAqD,OAAA,CAAQjC,MAAMkB,QAAQ,CAAA;IAC/B;IAEA,MAAM,IAAI1F,KAAA,CAAM,yBAA0B,CAAAC,MAAA,CAAAyF,QAAA,CAAStC,IAAM,CAAA,CAAA;KACxD9C,KAAK,CAAA;AACV;AAYA,SAAS+F,QAAAA,CAGP/F,OAAcoF,QAAsC,EAAA;EACpD,MAAMpB,QAAW,GAAA4C,QAAA,CAASxB,QAAS,CAAApB,QAAA,EAAU2D,MAAM,CAAAA,MAAA,CAAA;EAE/C,IAAA3D,QAAA,CAAS0B,OAAO1F,KAAO,EAAA;IACnB,MAAA,IAAIN,MAAM,wBAAwB,CAAA;EAC1C;EACO,OAAA;IAAC,GAAGM,KAAO;IAAA,CAACgE,SAAS0B,GAAG,GAAGN,SAASpB;GAAQ;AACrD;AAEA,SAASgC,mBAAAA,CAGPhG,OAAcoF,QAAiD,EAAA;EAC/D,IAAI,CAACuB,KAAA,CAAMvB,QAAS,CAAApB,QAAQ,CAAG,EAAA;IACvB,MAAA,IAAItE,MAAM,kDAAkD,CAAA;EACpE;EACA,OAAO0F,QAAS,CAAApB,QAAA,CAAS0B,GAAO,IAAA1F,KAAA,GAC5BA,QACA;IAAC,GAAGA,KAAO;IAAA,CAACoF,QAAS,CAAApB,QAAA,CAAS0B,GAAG,GAAGN,SAASpB;EAAQ,CAAA;AAC3D;AAEA,SAASkC,iBAAAA,CAGPlG,OAAcoF,QAA+C,EAAA;EAC7D,IAAI,CAACuB,KAAA,CAAMvB,QAAS,CAAApB,QAAQ,CAAG,EAAA;IACvB,MAAA,IAAItE,MAAM,kDAAkD,CAAA;EACpE;EAEO,OAAA;IAAC,GAAGM,KAAO;IAAA,CAACoF,SAASpB,QAAS,CAAA0B,GAAG,GAAGN,QAAA,CAASpB;GAAQ;AAC9D;AAEA,SAASiC,QAAAA,CACPjG,OACAoF,QACO,EAAA;EACH,IAAAA,QAAA,CAASK,MAAMzF,KAAO,EAAA;IAClB,MAAAO,IAAA,GAAO;MAAC,GAAGP;KAAK;IACf,OAAAO,IAAA,CAAK6E,SAASK,EAAE,CAAA;IAChB,OAAAlF,IAAA;EAAA,CACF,MAAA;IACE,OAAAP,KAAA;EACT;AACF;AAEA,SAASmG,OAAAA,CACPnG,OACAoF,QACO,EAAA;EACH,IAAA,EAAEA,QAAS,CAAAK,EAAA,IAAMzF,KAAQ,CAAA,EAAA;IACrB,MAAA,IAAIN,MAAM,4CAA4C,CAAA;EAC9D;EACM,MAAAqF,OAAA,GAAU/E,KAAM,CAAAoF,QAAA,CAASK,EAAE,CAAA;EAC3B,MAAA5C,IAAA,GAAOsC,kBAAmB,CAAAC,QAAA,EAAUL,OAAO,CAAA;EAE1C,OAAAlC,IAAA,KAASkC,OAAU,GAAA/E,KAAA,GAAQ;IAAC,GAAGA;IAAO,CAACoF,QAAA,CAASK,EAAE,GAAG5C;GAAI;AAClE;;;;;;;;;"}