import { arrify, isObject } from './_chunks/isObject-L-OoLJ4l.js';
import { parse } from './_chunks/parse-g6_rgqvy.js';
import { stringify } from './_chunks/stringify-2_qfPACh.js';
function create(document) {
  return {
    type: "create",
    document
  };
}
function patch(id, patches, options) {
  return {
    type: "patch",
    id,
    patches: arrify(patches),
    ...(options ? {
      options
    } : {})
  };
}
function at(path, operation) {
  return {
    path: typeof path === "string" ? parse(path) : path,
    op: operation
  };
}
function createIfNotExists(document) {
  return {
    type: "createIfNotExists",
    document
  };
}
function createOrReplace(document) {
  return {
    type: "createOrReplace",
    document
  };
}
function delete_(id) {
  return {
    type: "delete",
    id
  };
}
const del = delete_;
const destroy = delete_;
const set = value => ({
  type: "set",
  value
});
const assign = value => ({
  type: "assign",
  value
});
const unassign = keys => ({
  type: "unassign",
  keys
});
const setIfMissing = value => ({
  type: "setIfMissing",
  value
});
const unset = () => ({
  type: "unset"
});
const inc = function () {
  let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return {
    type: "inc",
    amount
  };
};
const dec = function () {
  let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return {
    type: "dec",
    amount
  };
};
const diffMatchPatch = value => ({
  type: "diffMatchPatch",
  value
});
function insert(items, position, indexOrReferenceItem) {
  return {
    type: "insert",
    referenceItem: indexOrReferenceItem,
    position,
    items: arrify(items)
  };
}
function append(items) {
  return insert(items, "after", -1);
}
function prepend(items) {
  return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
  return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem) => {
  return insert(items, "after", indexOrReferenceItem);
};
function truncate(startIndex, endIndex) {
  return {
    type: "truncate",
    startIndex,
    endIndex
  };
}
function replace(items, referenceItem) {
  return {
    type: "replace",
    referenceItem,
    items: arrify(items)
  };
}
function upsert(items, position, referenceItem) {
  return {
    type: "upsert",
    items: arrify(items),
    referenceItem,
    position
  };
}
function autoKeys(generateKey) {
  const ensureKeys = createEnsureKeys(generateKey);
  const insert$1 = (position, referenceItem, items) => insert(ensureKeys(items), position, referenceItem);
  const upsert$1 = (items, position, referenceItem) => upsert(ensureKeys(items), position, referenceItem);
  const replace$1 = (items, position, referenceItem) => replace(ensureKeys(items), referenceItem);
  const insertBefore = (ref, items) => insert$1("before", ref, items);
  const prepend = items => insertBefore(0, items);
  const insertAfter = (ref, items) => insert$1("after", ref, items);
  const append = items => insert$1("after", -1, items);
  return {
    insert: insert$1,
    upsert: upsert$1,
    replace: replace$1,
    insertBefore,
    prepend,
    insertAfter,
    append
  };
}
function hasKey(item) {
  return "_key" in item;
}
function createEnsureKeys(generateKey) {
  return array => {
    let didModify = false;
    const withKeys = array.map(item => {
      if (needsKey(item)) {
        didModify = true;
        return {
          ...item,
          _key: generateKey(item)
        };
      }
      return item;
    });
    return didModify ? withKeys : array;
  };
}
function needsKey(arrayItem) {
  return isObject(arrayItem) && !hasKey(arrayItem);
}
function encode$1(mutations) {
  return mutations.flatMap(encodeMutation$2);
}
function encodeMutation$2(mutation) {
  var _a;
  if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") {
    return {
      [mutation.type]: mutation.document
    };
  }
  if (mutation.type === "delete") {
    return {
      delete: {
        id: mutation.id
      }
    };
  }
  const ifRevisionID = (_a = mutation.options) == null ? void 0 : _a.ifRevision;
  return mutation.patches.map(patch => {
    return {
      patch: {
        id: mutation.id,
        ...(ifRevisionID && {
          ifRevisionID
        }),
        ...patchToSanity(patch)
      }
    };
  });
}
function patchToSanity(patch) {
  const {
    path,
    op
  } = patch;
  if (op.type === "unset") {
    return {
      unset: [stringify(path)]
    };
  }
  if (op.type === "insert") {
    return {
      insert: {
        [op.position]: stringify([...path, op.referenceItem]),
        items: op.items
      }
    };
  }
  if (op.type === "diffMatchPatch") {
    return {
      diffMatchPatch: {
        [stringify(path)]: op.value
      }
    };
  }
  if (op.type === "inc") {
    return {
      inc: {
        [stringify(path)]: op.amount
      }
    };
  }
  if (op.type === "dec") {
    return {
      dec: {
        [stringify(path)]: op.amount
      }
    };
  }
  if (op.type === "set" || op.type === "setIfMissing") {
    return {
      [op.type]: {
        [stringify(path)]: op.value
      }
    };
  }
  if (op.type === "truncate") {
    const range = [op.startIndex, typeof op.endIndex === "number" ? op.endIndex : ""].join(":");
    return {
      unset: ["".concat(stringify(path), "[").concat(range, "]")]
    };
  }
  if (op.type === "upsert") {
    return {
      unset: op.items.map(item => stringify([...path, {
        _key: item._key
      }])),
      insert: {
        [op.position]: stringify([...path, op.referenceItem]),
        items: op.items
      }
    };
  }
  if (op.type === "assign") {
    return {
      set: Object.fromEntries(Object.keys(op.value).map(key => [stringify(path.concat(key)), op.value[key]]))
    };
  }
  if (op.type === "unassign") {
    return {
      unset: op.keys.map(key => stringify(path.concat(key)))
    };
  }
  if (op.type === "replace") {
    return {
      insert: {
        replace: stringify(path.concat(op.referenceItem)),
        items: op.items
      }
    };
  }
  throw new Error("Unknown operation type ".concat(op.type));
}
function isCreateIfNotExistsMutation(sanityMutation) {
  return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
  return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
  return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
  return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
  return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
  return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
  return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
  return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
  return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
  return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
  return "insert" in sanityPatch;
}
function decode$1(encodedMutation) {
  return encodedMutation.reduce((muts, mut) => [...muts, ...decodeMutation$1(mut)], []);
}
function decodeMutation$1(encodedMutation) {
  if (isCreateIfNotExistsMutation(encodedMutation)) {
    return [{
      type: "createIfNotExists",
      document: encodedMutation.createIfNotExists
    }];
  }
  if (isCreateOrReplaceMutation(encodedMutation)) {
    return [{
      type: "createOrReplace",
      document: encodedMutation.createOrReplace
    }];
  }
  if (isCreateMutation(encodedMutation)) {
    return [{
      type: "create",
      document: encodedMutation.create
    }];
  }
  if (isDeleteMutation(encodedMutation)) {
    return [{
      id: encodedMutation.delete.id,
      type: "delete"
    }];
  }
  if (isPatchMutation(encodedMutation)) {
    return [{
      type: "patch",
      id: encodedMutation.patch.id,
      patches: decodeNodePatches(encodedMutation.patch)
    }];
  }
  throw new Error("Unknown mutation: ".concat(JSON.stringify(encodedMutation)));
}
const POSITION_KEYS = ["before", "replace", "after"];
function getInsertPosition(insert) {
  const positions = POSITION_KEYS.filter(k => k in insert);
  if (positions.length > 1) {
    throw new Error("Insert patch is ambiguous. Should only contain one of: ".concat(POSITION_KEYS.join(", "), ", instead found ").concat(positions.join(", ")));
  }
  return positions[0];
}
function decodeNodePatches(patch) {
  return [...getSetPatches(patch), ...getSetIfMissingPatches(patch), ...getUnsetPatches(patch), ...getIncPatches(patch), ...getDecPatches(patch), ...getInsertPatches(patch)];
}
function getSetPatches(patch) {
  return isSetPatch(patch) ? Object.keys(patch.set).map(path => ({
    path: parse(path),
    op: {
      type: "set",
      value: patch.set[path]
    }
  })) : [];
}
function getSetIfMissingPatches(patch) {
  return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map(path => ({
    path: parse(path),
    op: {
      type: "setIfMissing",
      value: patch.setIfMissing[path]
    }
  })) : [];
}
function getUnsetPatches(patch) {
  return isUnsetPatch(patch) ? patch.unset.map(path => ({
    path: parse(path),
    op: {
      type: "unset"
    }
  })) : [];
}
function getIncPatches(patch) {
  return isIncPatch(patch) ? Object.keys(patch.inc).map(path => ({
    path: parse(path),
    op: {
      type: "inc",
      amount: patch.inc[path]
    }
  })) : [];
}
function getDecPatches(patch) {
  return isDecPatch(patch) ? Object.keys(patch.dec).map(path => ({
    path: parse(path),
    op: {
      type: "dec",
      amount: patch.dec[path]
    }
  })) : [];
}
function getInsertPatches(patch) {
  if (!isInsertPatch(patch)) {
    return [];
  }
  const position = getInsertPosition(patch.insert);
  if (!position) {
    throw new Error("Insert patch missing position");
  }
  const path = parse(patch.insert[position]);
  const referenceItem = path.pop();
  const op = position === "replace" ? {
    type: "insert",
    position,
    referenceItem,
    items: patch.insert.items
  } : {
    type: "insert",
    position,
    referenceItem,
    items: patch.insert.items
  };
  return [{
    path,
    op
  }];
}
var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  decode: decode$1,
  encode: encode$1
});
function encode(mutations) {
  return mutations.flatMap(m => encodeMutation$1(m));
}
function encodeItemRef$1(ref) {
  return typeof ref === "number" ? ref : ref._key;
}
function encodeMutation$1(mutation) {
  if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") {
    return [[mutation.type, mutation.document]];
  }
  if (mutation.type === "delete") {
    return [["delete", mutation.id]];
  }
  if (mutation.type === "patch") {
    return mutation.patches.map(patch => {
      var _a;
      return maybeAddRevision((_a = mutation.options) == null ? void 0 : _a.ifRevision, encodePatchMutation(mutation.id, patch));
    });
  }
  throw new Error("Invalid mutation type: ".concat(mutation.type));
}
function encodePatchMutation(id, patch) {
  const {
    op
  } = patch;
  const path = stringify(patch.path);
  if (op.type === "unset") {
    return ["patch", "unset", id, path, []];
  }
  if (op.type === "diffMatchPatch") {
    return ["patch", "diffMatchPatch", id, path, [op.value]];
  }
  if (op.type === "inc" || op.type === "dec") {
    return ["patch", op.type, id, path, [op.amount]];
  }
  if (op.type === "set") {
    return ["patch", op.type, id, path, [op.value]];
  }
  if (op.type === "setIfMissing") {
    return ["patch", op.type, id, path, [op.value]];
  }
  if (op.type === "insert") {
    return ["patch", "insert", id, path, [op.position, encodeItemRef$1(op.referenceItem), op.items]];
  }
  if (op.type === "upsert") {
    return ["patch", "upsert", id, path, [op.position, encodeItemRef$1(op.referenceItem), op.items]];
  }
  if (op.type === "assign") {
    return ["patch", "assign", id, path, [op.value]];
  }
  if (op.type === "unassign") {
    return ["patch", "assign", id, path, [op.keys]];
  }
  if (op.type === "replace") {
    return ["patch", "replace", id, path, [encodeItemRef$1(op.referenceItem), op.items]];
  }
  if (op.type === "truncate") {
    return ["patch", "truncate", id, path, [op.startIndex, op.endIndex]];
  }
  throw new Error("Invalid operation type: ".concat(op.type));
}
function maybeAddRevision(revision, mut) {
  const [mutType, patchType, id, path, args] = mut;
  return revision ? [mutType, patchType, id, path, args, revision] : mut;
}
function decode(mutations) {
  return mutations.map(decodeMutation);
}
function decodeMutation(mutation) {
  const [type] = mutation;
  if (type === "delete") {
    const [, id] = mutation;
    return {
      id,
      type
    };
  } else if (type === "create") {
    const [, document] = mutation;
    return {
      type,
      document
    };
  } else if (type === "createIfNotExists") {
    const [, document] = mutation;
    return {
      type,
      document
    };
  } else if (type === "createOrReplace") {
    const [, document] = mutation;
    return {
      type,
      document
    };
  } else if (type === "patch") {
    return decodePatchMutation(mutation);
  }
  throw new Error("Unrecognized mutation: ".concat(JSON.stringify(mutation)));
}
function decodePatchMutation(mutation) {
  const [, type, id, serializedPath,, revisionId] = mutation;
  const path = parse(serializedPath);
  if (type === "dec" || type === "inc") {
    const [,,,, [amount]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "inc",
          amount
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "unset") {
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "unset"
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "insert") {
    const [,,,, [position, ref, items]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "insert",
          position,
          items,
          referenceItem: typeof ref === "string" ? {
            _key: ref
          } : ref
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "set") {
    const [,,,, [value]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "set",
          value
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "setIfMissing") {
    const [,,,, [value]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "setIfMissing",
          value
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "diffMatchPatch") {
    const [,,,, [value]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "diffMatchPatch",
          value
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "truncate") {
    const [,,,, [startIndex, endIndex]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "truncate",
          startIndex,
          endIndex
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "assign") {
    const [,,,, [value]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "assign",
          value
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "replace") {
    const [,,,, [ref, items]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "replace",
          items,
          referenceItem: decodeItemRef(ref)
        }
      }],
      ...createOpts(revisionId)
    };
  }
  if (type === "upsert") {
    const [,,,, [position, referenceItem, items]] = mutation;
    return {
      type: "patch",
      id,
      patches: [{
        path,
        op: {
          type: "upsert",
          items,
          referenceItem: decodeItemRef(referenceItem),
          position
        }
      }],
      ...createOpts(revisionId)
    };
  }
  throw new Error("Invalid mutation type: ".concat(type));
}
function decodeItemRef(ref) {
  return typeof ref === "string" ? {
    _key: ref
  } : ref;
}
function createOpts(revisionId) {
  return revisionId ? {
    options: {
      ifRevision: revisionId
    }
  } : null;
}
var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  decode: decode,
  encode: encode
});
function format(mutations) {
  return mutations.flatMap(m => encodeMutation(m)).join("\n");
}
function encodeItemRef(ref) {
  return typeof ref === "number" ? ref : ref._key;
}
function encodeMutation(mutation) {
  var _a;
  if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") {
    return [mutation.type, ": ", JSON.stringify(mutation.document)].join("");
  }
  if (mutation.type === "delete") {
    return ["delete ", mutation.id].join(": ");
  }
  if (mutation.type === "patch") {
    const ifRevision = (_a = mutation.options) == null ? void 0 : _a.ifRevision;
    return ["patch", " ", "id=".concat(mutation.id), ifRevision ? " (if revision==".concat(ifRevision, ")") : "", ":\n", mutation.patches.map(nodePatch => "  ".concat(formatPatchMutation(nodePatch))).join("\n")].join("");
  }
  throw new Error("Invalid mutation type: ".concat(mutation.type));
}
function formatPatchMutation(patch) {
  const {
    op
  } = patch;
  const path = stringify(patch.path);
  if (op.type === "unset") {
    return [path, "unset()"].join(": ");
  }
  if (op.type === "diffMatchPatch") {
    return [path, "diffMatchPatch(".concat(op.value, ")")].join(": ");
  }
  if (op.type === "inc" || op.type === "dec") {
    return [path, "".concat(op.type, "(").concat(op.amount, ")")].join(": ");
  }
  if (op.type === "set" || op.type === "setIfMissing") {
    return [path, "".concat(op.type, "(").concat(JSON.stringify(op.value), ")")].join(": ");
  }
  if (op.type === "assign") {
    return [path, "".concat(op.type, "(").concat(JSON.stringify(op.value), ")")].join(": ");
  }
  if (op.type === "unassign") {
    return [path, "".concat(op.type, "(").concat(JSON.stringify(op.keys), ")")].join(": ");
  }
  if (op.type === "insert" || op.type === "upsert") {
    return [path, "".concat(op.type, "(").concat(op.position, ", ").concat(encodeItemRef(op.referenceItem), ", ").concat(JSON.stringify(op.items), ")")].join(": ");
  }
  if (op.type === "replace") {
    return [path, "replace(".concat(encodeItemRef(op.referenceItem), ", ").concat(JSON.stringify(op.items), ")")].join(": ");
  }
  if (op.type === "truncate") {
    return [path, "truncate(".concat(op.startIndex, ", ").concat(op.endIndex)].join(": ");
  }
  throw new Error("Invalid operation type: ".concat(op.type));
}
var compact = /*#__PURE__*/Object.freeze({
  __proto__: null,
  format: format
});
export { index as CompactEncoder, compact as CompactFormatter, index$1 as SanityEncoder, append, assign, at, autoKeys, create, createIfNotExists, createOrReplace, dec, del, delete_, destroy, diffMatchPatch, inc, insert, insertAfter, insertBefore, patch, prepend, replace, set, setIfMissing, truncate, unassign, unset, upsert };
//# sourceMappingURL=index.js.map
