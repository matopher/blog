'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var stringify = require('./_chunks/stringify-Fw2FifQ5.cjs');
var isObject = require('./_chunks/isObject-9f_dI0Pz.cjs');
var DMP = require('diff-match-patch');
var nanoid = require('nanoid');
function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var DMP__namespace = /*#__PURE__*/_interopNamespaceCompat(DMP);
function keyOf(value) {
  return value !== null && typeof value === "object" && typeof value._key === "string" && value._key || null;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment === "number") {
    return normalizeIndex(array.length, pathSegment);
  }
  if (stringify.isKeyedElement(pathSegment)) {
    const idx = array.findIndex(value => keyOf(value) === pathSegment._key);
    return idx === -1 ? null : idx;
  }
  throw new Error("Expected path segment to be addressing a single array item either by numeric index or by '_key'. Instead saw ".concat(JSON.stringify(pathSegment)));
}
function getTargetIdx(position, index) {
  return position === "before" ? index : index + 1;
}
function normalizeIndex(length, index) {
  if (length === 0 && (index === -1 || index === 0)) {
    return 0;
  }
  const normalized = index < 0 ? length + index : index;
  return normalized >= length || normalized < 0 ? null : normalized;
}
function splice(arr, start, deleteCount, items) {
  const copy = arr.slice();
  copy.splice(start, deleteCount, ...(items || []));
  return copy;
}
function set(op, currentValue) {
  return op.value;
}
function setIfMissing(op, currentValue) {
  return currentValue != null ? currentValue : op.value;
}
function unset(op) {
  return void 0;
}
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isEmpty(v) {
  for (const key in v) {
    if (hasOwn(v, key)) {
      return false;
    }
  }
  return true;
}
function omit(val, props) {
  const copy = {
    ...val
  };
  for (const prop of props) {
    delete copy[prop];
  }
  return copy;
}
function unassign(op, currentValue) {
  if (!isObject.isObject(currentValue)) {
    throw new TypeError('Cannot apply "unassign()" on non-object value');
  }
  return op.keys.length === 0 ? currentValue : omit(currentValue, op.keys);
}
function assign(op, currentValue) {
  if (!isObject.isObject(currentValue)) {
    throw new TypeError('Cannot apply "assign()" on non-object value');
  }
  return isEmpty(op.value) ? currentValue : {
    ...currentValue,
    ...op.value
  };
}
function insert(op, currentValue) {
  if (!Array.isArray(currentValue)) {
    throw new TypeError('Cannot apply "insert()" on non-array value');
  }
  const index = findTargetIndex(currentValue, op.referenceItem);
  if (index === null) {
    throw new Error("Found no matching array element to insert ".concat(op.position));
  }
  if (currentValue.length === 0) {
    return op.items;
  }
  return splice(currentValue, getTargetIdx(op.position, index), 0, op.items);
}
function upsert(op, currentValue) {
  if (!Array.isArray(currentValue)) {
    throw new TypeError('Cannot apply "upsert()" on non-array value');
  }
  if (op.items.length === 0) {
    return currentValue;
  }
  const replaceItemsMap = [];
  const insertItems = [];
  op.items.forEach((itemToBeUpserted, i) => {
    const existingIndex = currentValue.findIndex(existingItem => (existingItem == null ? void 0 : existingItem._key) === itemToBeUpserted._key);
    if (existingIndex >= 0) {
      replaceItemsMap[existingIndex] = i;
    } else {
      insertItems.push(itemToBeUpserted);
    }
  });
  if (replaceItemsMap.length === 0 && insertItems.length == 0) {
    return currentValue;
  }
  const next = [...currentValue];
  for (const i of replaceItemsMap) {
    next[i] = op.items[replaceItemsMap[i]];
  }
  return insert({
    type: "insert",
    items: insertItems,
    referenceItem: op.referenceItem,
    position: op.position
  }, next);
}
function replace(op, currentValue) {
  if (!Array.isArray(currentValue)) {
    throw new TypeError('Cannot apply "replace()" on non-array value');
  }
  const index = findTargetIndex(currentValue, op.referenceItem);
  if (index === null) {
    throw new Error("Found no matching array element to replace");
  }
  return splice(currentValue, index, op.items.length, op.items);
}
function truncate(op, currentValue) {
  if (!Array.isArray(currentValue)) {
    throw new TypeError('Cannot apply "truncate()" on non-array value');
  }
  return typeof op.endIndex === "number" ? currentValue.slice(0, op.startIndex).concat(currentValue.slice(op.endIndex)) : currentValue.slice(0, op.startIndex);
}
function inc(op, currentValue) {
  if (typeof currentValue !== "number") {
    throw new TypeError('Cannot apply "inc()" on non-numeric value');
  }
  return currentValue + op.amount;
}
function dec(op, currentValue) {
  if (typeof currentValue !== "number") {
    throw new TypeError('Cannot apply "dec()" on non-numeric value');
  }
  return currentValue - op.amount;
}
const dmp = new DMP__namespace.diff_match_patch();
function diffMatchPatch(op, currentValue) {
  if (typeof currentValue !== "string") {
    throw new TypeError('Cannot apply "diffMatchPatch()" on non-string value');
  }
  return dmp.patch_apply(dmp.patch_fromText(op.value), currentValue)[0];
}
var operations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  assign: assign,
  dec: dec,
  diffMatchPatch: diffMatchPatch,
  inc: inc,
  insert: insert,
  replace: replace,
  set: set,
  setIfMissing: setIfMissing,
  truncate: truncate,
  unassign: unassign,
  unset: unset,
  upsert: upsert
});
function applyOp(op, currentValue) {
  if (!(op.type in operations)) {
    throw new Error('Invalid operation type: "'.concat(op.type, '"'));
  }
  return operations[op.type](op, currentValue);
}
function applyPatches(patches, document) {
  return patches.reduce((prev, patch) => applyNodePatch(patch, prev), document);
}
function applyNodePatch(patch, document) {
  return applyAtPath(patch.path, patch.op, document);
}
function applyAtPath(path, op, value) {
  if (isEmptyArray(path)) {
    return applyOp(op, value);
  }
  const [head, ...tail] = path;
  if (stringify.isArrayElement(head) && Array.isArray(value)) {
    return applyInArray(head, tail, op, value);
  }
  if (stringify.isPropertyElement(head) && isObject.isObject(value)) {
    return applyInObject(head, tail, op, value);
  }
  throw new Error('Cannot apply operation of type "'.concat(op.type, '" to path ').concat(stringify.stringify(path), " on ").concat(typeof value, " value"));
}
function applyInObject(head, tail, op, object) {
  const current = object[head];
  if (current === void 0 && tail.length > 0) {
    return object;
  }
  const patchedValue = applyAtPath(tail, op, current);
  return patchedValue === current ? object : {
    ...object,
    [head]: patchedValue
  };
}
function applyInArray(head, tail, op, value) {
  const index = findTargetIndex(value, head);
  if (index === null) {
    return value;
  }
  if (index === -1) {
    return value;
  }
  const current = value[index];
  const patchedItem = applyAtPath(tail, op, current);
  return patchedItem === current ? current : splice(value, index, 1, [patchedItem]);
}
function isEmptyArray(a) {
  return a.length === 0;
}
function applyPatchMutation(mutation, document) {
  var _a;
  if (((_a = mutation.options) == null ? void 0 : _a.ifRevision) && document._rev !== mutation.options.ifRevision) {
    throw new Error("Revision mismatch");
  }
  if (mutation.id !== document._id) {
    throw new Error('Document id mismatch. Refusing to apply mutation for document with id="'.concat(mutation.id, '" on the given document with id="').concat(document._id, '"'));
  }
  return applyPatches(mutation.patches, document);
}
function applyInCollection(collection, mutations) {
  const a = isObject.arrify(mutations);
  return a.reduce((prev, mutation) => {
    if (mutation.type === "create") {
      return createIn$1(prev, mutation);
    }
    if (mutation.type === "createIfNotExists") {
      return createIfNotExistsIn$1(prev, mutation);
    }
    if (mutation.type === "delete") {
      return deleteIn$1(prev, mutation);
    }
    if (mutation.type === "createOrReplace") {
      return createOrReplaceIn$1(prev, mutation);
    }
    if (mutation.type === "patch") {
      return patchIn$1(prev, mutation);
    }
    throw new Error("Invalid mutation type: ".concat(mutation.type));
  }, collection);
}
function createIn$1(collection, mutation) {
  const currentIdx = collection.findIndex(doc => doc._id === mutation.document._id);
  if (currentIdx !== -1) {
    throw new Error("Document already exist");
  }
  return collection.concat(mutation.document);
}
function createIfNotExistsIn$1(collection, mutation) {
  const currentIdx = collection.findIndex(doc => doc._id === mutation.document._id);
  return currentIdx === -1 ? collection.concat(mutation.document) : collection;
}
function createOrReplaceIn$1(collection, mutation) {
  const currentIdx = collection.findIndex(doc => doc._id === mutation.document._id);
  return currentIdx === -1 ? collection.concat(mutation.document) : splice(collection, currentIdx, 1, [mutation.document]);
}
function deleteIn$1(collection, mutation) {
  const currentIdx = collection.findIndex(doc => doc._id === mutation.id);
  return currentIdx === -1 ? collection : splice(collection, currentIdx, 1);
}
function patchIn$1(collection, mutation) {
  const currentIdx = collection.findIndex(doc => doc._id === mutation.id);
  if (currentIdx === -1) {
    throw new Error("Cannot apply patch on nonexistent document");
  }
  const current = collection[currentIdx];
  const next = applyPatchMutation(mutation, current);
  return next === current ? collection : splice(collection, currentIdx, 1, [next]);
}
function hasId(doc) {
  return "_id" in doc;
}
function assignId(doc, generateId) {
  return hasId(doc) ? doc : {
    ...doc,
    _id: generateId()
  };
}
function update(doc, revision) {
  return {
    ...doc,
    _rev: revision,
    _createdAt: doc._createdAt || ( /* @__PURE__ */new Date()).toISOString(),
    _updatedAt: ( /* @__PURE__ */new Date()).toISOString()
  };
}
const empty = {};
const createStore = initialEntries => {
  let version = 0;
  let index = initialEntries && (initialEntries == null ? void 0 : initialEntries.length) > 0 ? Object.fromEntries(initialEntries.map(entry => {
    const doc = update(assignId(entry, nanoid.nanoid), nanoid.nanoid());
    return [doc._id, doc];
  })) : empty;
  return {
    get version() {
      return version;
    },
    // todo: support listening for changes
    entries: () => Object.entries(index),
    get: id => index[id],
    apply: mutations => {
      const nextIndex = applyInIndex(index, isObject.arrify(mutations));
      if (nextIndex !== index) {
        index = nextIndex;
        version++;
      }
    }
  };
};
function applyInIndex(index, mutations) {
  return mutations.reduce((prev, mutation) => {
    if (mutation.type === "create") {
      return createIn(prev, mutation);
    }
    if (mutation.type === "createIfNotExists") {
      return createIfNotExistsIn(prev, mutation);
    }
    if (mutation.type === "delete") {
      return deleteIn(prev, mutation);
    }
    if (mutation.type === "createOrReplace") {
      return createOrReplaceIn(prev, mutation);
    }
    if (mutation.type === "patch") {
      return patchIn(prev, mutation);
    }
    throw new Error("Invalid mutation type: ".concat(mutation.type));
  }, index);
}
function createIn(index, mutation) {
  const document = assignId(mutation.document, nanoid.nanoid);
  if (document._id in index) {
    throw new Error("Document already exist");
  }
  return {
    ...index,
    [document._id]: mutation.document
  };
}
function createIfNotExistsIn(index, mutation) {
  if (!hasId(mutation.document)) {
    throw new Error("Cannot createIfNotExists on document without _id");
  }
  return mutation.document._id in index ? index : {
    ...index,
    [mutation.document._id]: mutation.document
  };
}
function createOrReplaceIn(index, mutation) {
  if (!hasId(mutation.document)) {
    throw new Error("Cannot createIfNotExists on document without _id");
  }
  return {
    ...index,
    [mutation.document._id]: mutation.document
  };
}
function deleteIn(index, mutation) {
  if (mutation.id in index) {
    const copy = {
      ...index
    };
    delete copy[mutation.id];
    return copy;
  } else {
    return index;
  }
}
function patchIn(index, mutation) {
  if (!(mutation.id in index)) {
    throw new Error("Cannot apply patch on nonexistent document");
  }
  const current = index[mutation.id];
  const next = applyPatchMutation(mutation, current);
  return next === current ? index : {
    ...index,
    [mutation.id]: next
  };
}
exports.applyInCollection = applyInCollection;
exports.applyInIndex = applyInIndex;
exports.applyNodePatch = applyNodePatch;
exports.applyOp = applyOp;
exports.applyPatchMutation = applyPatchMutation;
exports.applyPatches = applyPatches;
exports.assignId = assignId;
exports.createStore = createStore;
exports.hasId = hasId;
//# sourceMappingURL=_unstable_apply.cjs.map
