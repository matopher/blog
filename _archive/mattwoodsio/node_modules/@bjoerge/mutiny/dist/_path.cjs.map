{"version":3,"file":"_path.cjs","sources":["../src/path/get/getAtPath.ts","../src/path/utils/normalize.ts"],"sourcesContent":["import {isArrayElement, isKeyedElement} from '../utils/predicates'\nimport type {AnyArray} from '../../utils/typeUtils'\nimport type {FindInArray} from './types'\nimport type {KeyedPathElement, Path, PathElement} from '../types'\nexport type {AnyArray} from '../../utils/typeUtils'\n\nexport type Get<\n  P extends number | KeyedPathElement | Readonly<KeyedPathElement> | string,\n  T,\n> = T extends AnyArray\n  ? P extends KeyedPathElement | Readonly<KeyedPathElement> | number\n    ? FindInArray<P, T>\n    : undefined\n  : P extends keyof T\n  ? T[P]\n  : never\n\nexport type GetAtPath<P extends readonly PathElement[], T> = P extends []\n  ? T\n  : P extends [infer Head, ...infer Tail]\n  ? Head extends PathElement\n    ? Tail extends PathElement[]\n      ? GetAtPath<Tail, Get<Head, T>>\n      : undefined\n    : undefined\n  : undefined\n\nexport function getAtPath<const Head extends PathElement, const T>(\n  path: [head: Head],\n  value: T,\n): Get<Head, T>\nexport function getAtPath<\n  const Head extends PathElement,\n  const Tail extends PathElement[],\n  T,\n>(path: [head: Head, ...tail: Tail], value: T): GetAtPath<[Head, ...Tail], T>\nexport function getAtPath<T>(path: [], value: T): T\nexport function getAtPath(path: Path, value: unknown): unknown\nexport function getAtPath(path: Path, value: unknown): unknown {\n  if (path.length === 0) {\n    return value\n  }\n\n  let current = value\n  for (const head of path) {\n    if (isArrayElement(head)) {\n      if (!Array.isArray(current)) {\n        return undefined\n      }\n\n      if (isKeyedElement(head)) {\n        current = current.find(item => item._key === head._key)\n        continue\n      }\n      current = current[head]\n      continue\n    }\n    current = (current as any)[head]\n  }\n  return current\n}\n","import {parse} from '../parser/parse'\nimport type {Path} from '../types'\n\nexport function normalize(path: string | Readonly<Path>): Readonly<Path> {\n  return typeof path === 'string' ? parse(path) : path\n}\n"],"names":["getAtPath","path","value","length","current","head","isArrayElement","Array","isArray","isKeyedElement","find","item","_key","normalize","parse"],"mappings":";;;;;;;AAsCgB,SAAAA,SAAAA,CAAUC,MAAYC,KAAyB,EAAA;EACzD,IAAAD,IAAA,CAAKE,WAAW,CAAG,EAAA;IACd,OAAAD,KAAA;EACT;EAEA,IAAIE,OAAU,GAAAF,KAAA;EACd,KAAA,MAAWG,QAAQJ,IAAM,EAAA;IACnB,IAAAK,SAAAA,CAAAA,cAAA,CAAeD,IAAI,CAAG,EAAA;MACxB,IAAI,CAACE,KAAA,CAAMC,OAAQ,CAAAJ,OAAO,CAAG,EAAA;QACpB,OAAA,KAAA,CAAA;MACT;MAEI,IAAAK,SAAAA,CAAAA,cAAA,CAAeJ,IAAI,CAAG,EAAA;QACxBD,OAAA,GAAUA,QAAQM,IAAK,CAAAC,IAAA,IAAQA,IAAK,CAAAC,IAAA,KAASP,KAAKO,IAAI,CAAA;QACtD;MACF;MACAR,OAAA,GAAUA,QAAQC,IAAI,CAAA;MACtB;IACF;IACAD,OAAA,GAAWA,QAAgBC,IAAI,CAAA;EACjC;EACO,OAAAD,OAAA;AACT;ACzDO,SAASS,UAAUZ,IAA+C,EAAA;EACvE,OAAO,OAAOA,IAAA,KAAS,QAAW,GAAAa,KAAA,CAAAA,KAAA,CAAMb,IAAI,CAAI,GAAAA,IAAA;AAClD;;;;;;;;;;;;"}