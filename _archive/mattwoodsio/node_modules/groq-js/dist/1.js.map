{"version":3,"file":"1.js","sources":["../src/values/Path.ts","../src/values/StreamValue.ts","../src/values/dateHelpers.ts","../src/values/utils.ts","../src/evaluator/equality.ts","../src/evaluator/matching.ts","../src/evaluator/ordering.ts","../src/evaluator/operators.ts","../src/evaluator/scope.ts","../src/evaluator/evaluate.ts","../src/evaluator/constantEvaluate.ts","../src/evaluator/pt.ts","../src/evaluator/scoring.ts","../src/evaluator/functions.ts","../src/markProcessor.ts","../src/rawParser.js","../src/traversal.ts","../src/parser.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n","import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i'),\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n","import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null,\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate,\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor,\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value,\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (scope.context.dereference) {\n      return fromJS(await scope.context.dereference({_ref: id}))\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {},\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference,\n    },\n    null,\n  )\n  return evaluate(tree, scope)\n}\n","import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n      return canConstantEvaluate(node.base)\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null,\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n","import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nconst dateTime: FunctionSet = {}\ndateTime.now = async function now(args, scope, execute) {\n  return fromDateTime(new DateTime(scope.context.timestamp))\n}\ndateTime.now.arity = 0\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n}\n","import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos},\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null,\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      namespace,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right,\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs,\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right,\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`,\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n"],"names":["__publicField","array","count","path","string","dateTime","parse","rhs","identLen","value","rawParse"],"mappings":"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"}