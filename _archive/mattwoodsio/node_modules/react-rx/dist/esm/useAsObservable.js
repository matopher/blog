import { BehaviorSubject } from 'rxjs';
import { useCallback, useEffect, useRef } from 'react';
import { distinctUntilChanged } from 'rxjs/operators';
export function useAsObservable(value, operator) {
    var setup = useCallback(function () {
        var subject = new BehaviorSubject(value);
        var observable = subject.asObservable().pipe(distinctUntilChanged());
        return [operator ? observable.pipe(operator) : observable, subject];
    }, []);
    var ref = useRef();
    if (!ref.current) {
        ref.current = setup();
    }
    var observable = ref.current[0];
    useEffect(function () {
        if (!ref.current) {
            return;
        }
        var _a = ref.current, subject = _a[1];
        subject.next(value);
    }, [value, ref]);
    var shouldRestoreSubscriptionRef = useRef(false);
    useEffect(function () {
        if (shouldRestoreSubscriptionRef.current) {
            if (!ref.current) {
                ref.current = setup();
            }
            shouldRestoreSubscriptionRef.current = false;
        }
        return function () {
            if (!ref.current) {
                return;
            }
            // React StrictMode will call effects as `setup + teardown + setup` thus we can't trust this callback as "react is about to unmount"
            // Tracking this ref lets us set the subscription back up on the next `setup` call if needed, and if it really did unmounted then all is well
            shouldRestoreSubscriptionRef.current = true;
            var _a = ref.current, subject = _a[1];
            subject.complete();
            ref.current = undefined;
        };
    }, []);
    return observable;
}
