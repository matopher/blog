import { act, render, renderHook } from '@testing-library/react';
import { useObservable } from '../useObservable';
import { asyncScheduler, Observable, of, scheduled, Subject, timer } from 'rxjs';
import { mapTo } from 'rxjs/operators';
import { createElement, Fragment } from 'react';
test('should subscribe immediately on component mount and unsubscribe on component unmount', function () {
    var subscribed = false;
    var observable = new Observable(function () {
        subscribed = true;
        return function () {
            subscribed = false;
        };
    });
    expect(subscribed).toBe(false);
    var unmount = renderHook(function () { return useObservable(observable); }).unmount;
    expect(subscribed).toBe(true);
    unmount();
    expect(subscribed).toBe(false);
});
test('should only subscribe once when given same observable on re-renders', function () {
    var subscriptionCount = 0;
    var observable = new Observable(function () {
        subscriptionCount++;
    });
    expect(subscriptionCount).toBe(0);
    var _a = renderHook(function () { return useObservable(observable); }), unmount = _a.unmount, rerender = _a.rerender;
    expect(subscriptionCount).toBe(1);
    rerender();
    expect(subscriptionCount).toBe(1);
    unmount();
    renderHook(function () { return useObservable(observable); });
    expect(subscriptionCount).toBe(2);
});
test('should not return undefined during render if initial value is given', function () {
    var observable = timer(100).pipe(mapTo('emitted value'));
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = useObservable(observable, 'initial value');
        returnedValues.push(observedValue);
        return createElement(Fragment, null, observedValue);
    }
    render(createElement(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining(['initial value']));
});
test('should not return undefined during render if observable is sync', function () {
    var observable = of('initial value');
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = useObservable(observable);
        returnedValues.push(observedValue);
        return createElement(Fragment, null, observedValue);
    }
    render(createElement(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining(['initial value']));
});
test('should return undefined during first render if observable is async', function () {
    var observable = scheduled('async value', asyncScheduler);
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = useObservable(observable);
        returnedValues.push(observedValue);
        return createElement(Fragment, null, observedValue);
    }
    render(createElement(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining([undefined]));
});
test('should have sync values from an observable as initial value', function () {
    var observable = of('something sync');
    var result = renderHook(function () { return useObservable(observable); }).result;
    expect(result.current).toBe('something sync');
});
test('should have undefined as initial value from delayed observables', function () {
    var _a = renderHook(function () {
        return useObservable(scheduled('something async', asyncScheduler));
    }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBeUndefined();
    unmount();
});
test('should have passed initialValue as initial value from delayed observables', function () {
    var _a = renderHook(function () {
        return useObservable(scheduled('something async', asyncScheduler), 'initial');
    }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBe('initial');
    unmount();
});
test('should update with values from observables', function () {
    var values$ = new Subject();
    var _a = renderHook(function () { return useObservable(values$); }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBe(undefined);
    act(function () { return values$.next('something'); });
    expect(result.current).toBe('something');
    act(function () { return values$.next('otherthing'); });
    expect(result.current).toBe('otherthing');
    unmount();
});
test('should re-subscribe when receiving a new observable', function () {
    var first$ = new Subject();
    var second$ = new Subject();
    var current$ = first$;
    var _a = renderHook(function () { return useObservable(current$, '!!initial!!'); }), result = _a.result, rerender = _a.rerender, unmount = _a.unmount;
    act(function () { return first$.next('first 1'); });
    expect(result.current).toBe('first 1');
    current$ = second$;
    rerender();
    // since observable #2 hasn't emitted a value yet, we should use the initial value
    expect(result.current).toBe('!!initial!!');
    // Now we should be subscribed to second$ and it's emission should be returned
    act(function () { return second$.next('second 1'); });
    expect(result.current).toBe('second 1');
    // we should no longer be subscribed to the first and ignore any emissions
    act(function () { return first$.next('first 2'); });
    expect(result.current).toBe('second 1');
    unmount();
});
