"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAsObservable = void 0;
var rxjs_1 = require("rxjs");
var react_1 = require("react");
var operators_1 = require("rxjs/operators");
function useAsObservable(value, operator) {
    var setup = (0, react_1.useCallback)(function () {
        var subject = new rxjs_1.BehaviorSubject(value);
        var observable = subject.asObservable().pipe((0, operators_1.distinctUntilChanged)());
        return [operator ? observable.pipe(operator) : observable, subject];
    }, []);
    var ref = (0, react_1.useRef)();
    if (!ref.current) {
        ref.current = setup();
    }
    var observable = ref.current[0];
    (0, react_1.useEffect)(function () {
        if (!ref.current) {
            return;
        }
        var _a = ref.current, subject = _a[1];
        subject.next(value);
    }, [value, ref]);
    var shouldRestoreSubscriptionRef = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(function () {
        if (shouldRestoreSubscriptionRef.current) {
            if (!ref.current) {
                ref.current = setup();
            }
            shouldRestoreSubscriptionRef.current = false;
        }
        return function () {
            if (!ref.current) {
                return;
            }
            // React StrictMode will call effects as `setup + teardown + setup` thus we can't trust this callback as "react is about to unmount"
            // Tracking this ref lets us set the subscription back up on the next `setup` call if needed, and if it really did unmounted then all is well
            shouldRestoreSubscriptionRef.current = true;
            var _a = ref.current, subject = _a[1];
            subject.complete();
            ref.current = undefined;
        };
    }, []);
    return observable;
}
exports.useAsObservable = useAsObservable;
