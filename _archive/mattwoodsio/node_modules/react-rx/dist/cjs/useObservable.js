"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMemoObservable = exports.useObservable = void 0;
var react_1 = require("react");
var shim_1 = require("use-sync-external-store/shim");
var operators_1 = require("rxjs/operators");
function getValue(value) {
    return typeof value === 'function' ? value() : value;
}
var cache = new WeakMap();
function getOrCreateStore(inputObservable, initialValue) {
    if (!cache.has(inputObservable)) {
        var entry_1 = { currentValue: initialValue };
        entry_1.observable = inputObservable.pipe((0, operators_1.shareReplay)({ refCount: true, bufferSize: 1 }), (0, operators_1.tap)(function (value) { return (entry_1.currentValue = value); }));
        // Eagerly subscribe to sync set `entry.currentValue` to what the observable returns
        entry_1.subscription = entry_1.observable.subscribe();
        cache.set(inputObservable, entry_1);
    }
    return cache.get(inputObservable);
}
function useObservable(observable, initialValue) {
    var _a = (0, react_1.useMemo)(function () {
        var store = getOrCreateStore(observable, getValue(initialValue));
        if (store.subscription.closed) {
            store.subscription = store.observable.subscribe();
        }
        return [
            function getSnapshot() {
                // @TODO: perf opt opportunity: we could do `store.subscription.unsubscribe()` here to clear up some memory, as this subscription is only needed to provide a sync initialValue.
                return store.currentValue;
            },
            function subscribe(callback) {
                // @TODO: perf opt opportunity: we could do `store.subscription.unsubscribe()` here as we only need 1 subscription active to keep the observer alive
                var sub = store.observable.subscribe(callback);
                return function () {
                    sub.unsubscribe();
                };
            },
        ];
    }, [observable]), getSnapshot = _a[0], subscribe = _a[1];
    var shouldRestoreSubscriptionRef = (0, react_1.useRef)(false);
    (0, react_1.useEffect)(function () {
        var store = getOrCreateStore(observable, getValue(initialValue));
        if (shouldRestoreSubscriptionRef.current) {
            if (store.subscription.closed) {
                store.subscription = store.observable.subscribe();
            }
            shouldRestoreSubscriptionRef.current = false;
        }
        return function () {
            // React StrictMode will call effects as `setup + teardown + setup` thus we can't trust this callback as "react is about to unmount"
            // Tracking this ref lets us set the subscription back up on the next `setup` call if needed, and if it really did unmounted then all is well
            shouldRestoreSubscriptionRef.current = !store.subscription.closed;
            store.subscription.unsubscribe();
        };
    }, [observable]);
    return (0, shim_1.useSyncExternalStore)(subscribe, getSnapshot);
}
exports.useObservable = useObservable;
function useMemoObservable(observableOrFactory, deps, initialValue) {
    return useObservable((0, react_1.useMemo)(function () { return getValue(observableOrFactory); }, deps), initialValue);
}
exports.useMemoObservable = useMemoObservable;
