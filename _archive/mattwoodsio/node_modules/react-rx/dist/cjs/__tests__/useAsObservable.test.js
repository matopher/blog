"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var useAsObservable_1 = require("../useAsObservable");
var react_1 = __importDefault(require("react"));
var react_2 = require("@testing-library/react");
test('the returned observable should receive a new value when component is rendered with a new value', function () {
    var receivedValues = [];
    var _a = (0, react_2.renderHook)(function (props) {
        var observable = (0, useAsObservable_1.useAsObservable)(props.value);
        react_1.default.useEffect(function () {
            var subscription = observable.subscribe(function (v) {
                receivedValues.push(v);
            });
            return function () {
                subscription.unsubscribe();
            };
        }, []);
    }, { initialProps: { value: 'initial' } }), unmount = _a.unmount, rerender = _a.rerender;
    rerender({ value: 'rerender' });
    rerender({ value: 'rerender again' });
    expect(receivedValues).toEqual(['initial', 'rerender', 'rerender again']);
    unmount();
});
test('the returned observable should *not* receive a new value when component is rendered with an unchanged value', function () {
    var receivedValues = [];
    var _a = (0, react_2.renderHook)(function (props) {
        var observable = (0, useAsObservable_1.useAsObservable)(props.value);
        react_1.default.useEffect(function () {
            var subscription = observable.subscribe(function (v) {
                receivedValues.push(v);
            });
            return function () {
                subscription.unsubscribe();
            };
        }, []);
    }, { initialProps: { value: 'some value' } }), unmount = _a.unmount, rerender = _a.rerender;
    rerender({ value: 'some value' });
    rerender({ value: 'some value' });
    expect(receivedValues).toEqual(['some value']);
    unmount();
});
test('the returned observable should have the same identity across multiple re-renders/hook calls', function () {
    var returnValues = [];
    var _a = (0, react_2.renderHook)(function () {
        returnValues.push((0, useAsObservable_1.useAsObservable)('render'));
    }), unmount = _a.unmount, rerender = _a.rerender;
    rerender();
    rerender();
    var initial = returnValues[0], firstRerender = returnValues[1], secondRerender = returnValues[2];
    expect(initial).toBe(firstRerender);
    expect(firstRerender).toBe(secondRerender);
    unmount();
});
test('the returned observable should complete on unmount', function () {
    var didComplete = false;
    var _a = (0, react_2.renderHook)(function () {
        var observable = (0, useAsObservable_1.useAsObservable)('render');
        react_1.default.useEffect(function () {
            var subscription = observable.subscribe({
                complete: function () {
                    didComplete = true;
                },
            });
            return function () {
                subscription.unsubscribe();
            };
        }, []);
    }), unmount = _a.unmount, rerender = _a.rerender;
    expect(didComplete).toBe(false);
    rerender();
    expect(didComplete).toBe(false);
    unmount();
    expect(didComplete).toBe(true);
});
