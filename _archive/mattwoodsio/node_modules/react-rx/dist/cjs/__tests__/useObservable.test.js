"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("@testing-library/react");
var useObservable_1 = require("../useObservable");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var react_2 = require("react");
test('should subscribe immediately on component mount and unsubscribe on component unmount', function () {
    var subscribed = false;
    var observable = new rxjs_1.Observable(function () {
        subscribed = true;
        return function () {
            subscribed = false;
        };
    });
    expect(subscribed).toBe(false);
    var unmount = (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(observable); }).unmount;
    expect(subscribed).toBe(true);
    unmount();
    expect(subscribed).toBe(false);
});
test('should only subscribe once when given same observable on re-renders', function () {
    var subscriptionCount = 0;
    var observable = new rxjs_1.Observable(function () {
        subscriptionCount++;
    });
    expect(subscriptionCount).toBe(0);
    var _a = (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(observable); }), unmount = _a.unmount, rerender = _a.rerender;
    expect(subscriptionCount).toBe(1);
    rerender();
    expect(subscriptionCount).toBe(1);
    unmount();
    (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(observable); });
    expect(subscriptionCount).toBe(2);
});
test('should not return undefined during render if initial value is given', function () {
    var observable = (0, rxjs_1.timer)(100).pipe((0, operators_1.mapTo)('emitted value'));
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = (0, useObservable_1.useObservable)(observable, 'initial value');
        returnedValues.push(observedValue);
        return (0, react_2.createElement)(react_2.Fragment, null, observedValue);
    }
    (0, react_1.render)((0, react_2.createElement)(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining(['initial value']));
});
test('should not return undefined during render if observable is sync', function () {
    var observable = (0, rxjs_1.of)('initial value');
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = (0, useObservable_1.useObservable)(observable);
        returnedValues.push(observedValue);
        return (0, react_2.createElement)(react_2.Fragment, null, observedValue);
    }
    (0, react_1.render)((0, react_2.createElement)(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining(['initial value']));
});
test('should return undefined during first render if observable is async', function () {
    var observable = (0, rxjs_1.scheduled)('async value', rxjs_1.asyncScheduler);
    var returnedValues = [];
    function ObservableComponent() {
        var observedValue = (0, useObservable_1.useObservable)(observable);
        returnedValues.push(observedValue);
        return (0, react_2.createElement)(react_2.Fragment, null, observedValue);
    }
    (0, react_1.render)((0, react_2.createElement)(ObservableComponent));
    expect(returnedValues).toEqual(expect.arrayContaining([undefined]));
});
test('should have sync values from an observable as initial value', function () {
    var observable = (0, rxjs_1.of)('something sync');
    var result = (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(observable); }).result;
    expect(result.current).toBe('something sync');
});
test('should have undefined as initial value from delayed observables', function () {
    var _a = (0, react_1.renderHook)(function () {
        return (0, useObservable_1.useObservable)((0, rxjs_1.scheduled)('something async', rxjs_1.asyncScheduler));
    }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBeUndefined();
    unmount();
});
test('should have passed initialValue as initial value from delayed observables', function () {
    var _a = (0, react_1.renderHook)(function () {
        return (0, useObservable_1.useObservable)((0, rxjs_1.scheduled)('something async', rxjs_1.asyncScheduler), 'initial');
    }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBe('initial');
    unmount();
});
test('should update with values from observables', function () {
    var values$ = new rxjs_1.Subject();
    var _a = (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(values$); }), result = _a.result, unmount = _a.unmount;
    expect(result.current).toBe(undefined);
    (0, react_1.act)(function () { return values$.next('something'); });
    expect(result.current).toBe('something');
    (0, react_1.act)(function () { return values$.next('otherthing'); });
    expect(result.current).toBe('otherthing');
    unmount();
});
test('should re-subscribe when receiving a new observable', function () {
    var first$ = new rxjs_1.Subject();
    var second$ = new rxjs_1.Subject();
    var current$ = first$;
    var _a = (0, react_1.renderHook)(function () { return (0, useObservable_1.useObservable)(current$, '!!initial!!'); }), result = _a.result, rerender = _a.rerender, unmount = _a.unmount;
    (0, react_1.act)(function () { return first$.next('first 1'); });
    expect(result.current).toBe('first 1');
    current$ = second$;
    rerender();
    // since observable #2 hasn't emitted a value yet, we should use the initial value
    expect(result.current).toBe('!!initial!!');
    // Now we should be subscribed to second$ and it's emission should be returned
    (0, react_1.act)(function () { return second$.next('second 1'); });
    expect(result.current).toBe('second 1');
    // we should no longer be subscribed to the first and ignore any emissions
    (0, react_1.act)(function () { return first$.next('first 2'); });
    expect(result.current).toBe('second 1');
    unmount();
});
