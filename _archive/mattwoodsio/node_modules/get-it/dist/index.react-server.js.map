{"version":3,"file":"index.react-server.js","sources":["../src/request/browser/fetchXhr.ts","../src/request/browser-request.ts","../src/index.browser.ts","../src/index.react-server.ts"],"sourcesContent":["/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: () => void\n  onerror: (error?: any) => void\n  onreadystatechange: () => void\n  ontimeout: XMLHttpRequest['ontimeout']\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText']\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status']\n  statusText: XMLHttpRequest['statusText']\n  withCredentials: XMLHttpRequest['withCredentials']\n\n  /**\n   * Private implementation details\n   */\n  #method: string\n  #url: string\n  #resHeaders: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  #init: RequestInit = {}\n  #useAbortSignal: boolean\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init: RequestInit, useAbortSignal = true) {\n    this.#init = init\n    this.#useAbortSignal = useAbortSignal\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      ...this.#init,\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function' && this.#useAbortSignal) {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n","import parseHeaders from 'parse-headers'\n\nimport type {HttpRequest, MiddlewareResponse, RequestAdapter, RequestOptions} from '../types'\nimport {FetchXhr} from './browser/fetchXhr'\n\n// Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\nexport const adapter: RequestAdapter = typeof XMLHttpRequest === 'function' ? 'xhr' : 'fetch'\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport const httpRequester: HttpRequest = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts) as RequestOptions\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  if (xhr instanceof FetchXhr && typeof options.fetch === 'object') {\n    xhr.setInit(options.fetch, options.useAbortSignal ?? true)\n  }\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request error while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method!,\n    options.url,\n    true, // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`,\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: typeof options\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse(): MiddlewareResponse {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method!,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status,\n      statusMessage: xhr.statusText,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n","import {createRequester} from './createRequester'\nimport {httpRequester} from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport type * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester,\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment: ExportEnv = 'browser'\n\n/** @public */\nexport {adapter} from './request/browser-request'\n","import type {ExportEnv} from './types'\n\nexport * from './index.browser'\n\n/** @public */\nexport const environment: ExportEnv = 'react-server'\n"],"names":[],"mappings":"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"}