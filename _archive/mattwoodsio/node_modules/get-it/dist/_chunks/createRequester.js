import { p as processOptions, v as validateOptions } from "./defaultOptionsValidator.js";
const middlewareReducer = (middleware) => function(hook, defaultValue, ...args) {
  const bailEarly = hook === "onError";
  let value = defaultValue;
  for (let i = 0; i < middleware[hook].length; i++) {
    const handler = middleware[hook][i];
    if (value = handler(value, ...args), bailEarly && !value)
      break;
  }
  return value;
};
function createPubSub() {
  const subscribers = /* @__PURE__ */ Object.create(null);
  let nextId = 0;
  function subscribe(subscriber) {
    const id = nextId++;
    return subscribers[id] = subscriber, function() {
      delete subscribers[id];
    };
  }
  function publish(event) {
    for (const id in subscribers)
      subscribers[id](event);
  }
  return {
    publish,
    subscribe
  };
}
const channelNames = [
  "request",
  "response",
  "progress",
  "error",
  "abort"
], middlehooks = [
  "processOptions",
  "validateOptions",
  "interceptRequest",
  "finalizeOptions",
  "onRequest",
  "onResponse",
  "onError",
  "onReturn",
  "onHeaders"
];
function createRequester(initMiddleware, httpRequest) {
  const loadedMiddleware = [], middleware = middlehooks.reduce(
    (ware, name) => (ware[name] = ware[name] || [], ware),
    {
      processOptions: [processOptions],
      validateOptions: [validateOptions]
    }
  );
  function request(opts) {
    const onResponse = (reqErr, res, ctx) => {
      let error = reqErr, response = res;
      if (!error)
        try {
          response = applyMiddleware("onResponse", res, ctx);
        } catch (err) {
          response = null, error = err;
        }
      error = error && applyMiddleware("onError", error, ctx), error ? channels.error.publish(error) : response && channels.response.publish(response);
    }, channels = channelNames.reduce((target, name) => (target[name] = createPubSub(), target), {}), applyMiddleware = middlewareReducer(middleware), options = applyMiddleware("processOptions", opts);
    applyMiddleware("validateOptions", options);
    const context = { options, channels, applyMiddleware };
    let ongoingRequest;
    const unsubscribe = channels.request.subscribe((ctx) => {
      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));
    });
    channels.abort.subscribe(() => {
      unsubscribe(), ongoingRequest && ongoingRequest.abort();
    });
    const returnValue = applyMiddleware("onReturn", channels, context);
    return returnValue === channels && channels.request.publish(context), returnValue;
  }
  return request.use = function(newMiddleware) {
    if (!newMiddleware)
      throw new Error("Tried to add middleware that resolved to falsey value");
    if (typeof newMiddleware == "function")
      throw new Error(
        "Tried to add middleware that was a function. It probably expects you to pass options to it."
      );
    if (newMiddleware.onReturn && middleware.onReturn.length > 0)
      throw new Error(
        "Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event"
      );
    return middlehooks.forEach((key) => {
      newMiddleware[key] && middleware[key].push(newMiddleware[key]);
    }), loadedMiddleware.push(newMiddleware), request;
  }, request.clone = () => createRequester(loadedMiddleware, httpRequest), initMiddleware.forEach(request.use), request;
}
export {
  createRequester as c
};
//# sourceMappingURL=createRequester.js.map
