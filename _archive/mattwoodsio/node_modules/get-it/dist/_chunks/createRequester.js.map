{"version":3,"file":"createRequester.js","sources":["../../src/util/middlewareReducer.ts","../../src/util/pubsub.ts","../../src/createRequester.ts"],"sourcesContent":["import type {ApplyMiddleware, MiddlewareReducer} from '../types'\n\nexport const middlewareReducer = (middleware: MiddlewareReducer) =>\n  function applyMiddleware(hook, defaultValue, ...args) {\n    const bailEarly = hook === 'onError'\n\n    let value = defaultValue\n    for (let i = 0; i < middleware[hook].length; i++) {\n      const handler = middleware[hook][i]\n      // @ts-expect-error -- find a better way to deal with argument tuples\n      value = handler(value, ...args)\n\n      if (bailEarly && !value) {\n        break\n      }\n    }\n\n    return value\n  } as ApplyMiddleware\n","// Code borrowed from https://github.com/bjoerge/nano-pubsub\n\nimport type {PubSub, Subscriber} from '../types'\n\nexport function createPubSub<Message = void>(): PubSub<Message> {\n  const subscribers: {[id: string]: Subscriber<Message>} = Object.create(null)\n  let nextId = 0\n  function subscribe(subscriber: Subscriber<Message>) {\n    const id = nextId++\n    subscribers[id] = subscriber\n    return function unsubscribe() {\n      delete subscribers[id]\n    }\n  }\n\n  function publish(event: Message) {\n    for (const id in subscribers) {\n      subscribers[id](event)\n    }\n  }\n\n  return {\n    publish,\n    subscribe,\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {processOptions} from './middleware/defaultOptionsProcessor'\nimport {validateOptions} from './middleware/defaultOptionsValidator'\nimport type {\n  HttpContext,\n  HttpRequest,\n  HttpRequestOngoing,\n  Middleware,\n  MiddlewareChannels,\n  MiddlewareHooks,\n  MiddlewareReducer,\n  MiddlewareResponse,\n  Middlewares,\n  Requester,\n  RequestOptions,\n} from './types'\nimport {middlewareReducer} from './util/middlewareReducer'\nimport {createPubSub} from './util/pubsub'\n\nconst channelNames = [\n  'request',\n  'response',\n  'progress',\n  'error',\n  'abort',\n] satisfies (keyof MiddlewareChannels)[]\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders',\n] satisfies (keyof MiddlewareHooks)[]\n\n/** @public */\nexport function createRequester(initMiddleware: Middlewares, httpRequest: HttpRequest): Requester {\n  const loadedMiddleware: Middlewares = []\n  const middleware: MiddlewareReducer = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions],\n    } as any,\n  )\n\n  function request(opts: RequestOptions | string) {\n    const onResponse = (reqErr: Error | null, res: MiddlewareResponse, ctx: HttpContext) => {\n      let error = reqErr\n      let response: MiddlewareResponse | null = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err: any) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n\n    const channels: MiddlewareChannels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub() as MiddlewareChannels[typeof name]\n      return target\n    }, {} as any)\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts as RequestOptions)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest: HttpRequestOngoing | undefined\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res!, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n  }\n\n  request.use = function use(newMiddleware: Middleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.',\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event',\n      )\n    }\n\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key] as any)\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = () => createRequester(loadedMiddleware, httpRequest)\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n"],"names":[],"mappings":"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"}