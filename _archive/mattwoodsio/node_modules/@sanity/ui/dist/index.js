"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var theme = require("@sanity/ui/theme"), jsxRuntime = require("react/jsx-runtime"), react = require("react"), ReactIs = require("react-is"), styled = require("styled-components"), icons = require("@sanity/icons"), Refractor = require("react-refractor"), reactDom$1 = require("@floating-ui/react-dom"), framerMotion = require("framer-motion"), reactDom = require("react-dom");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var ReactIs__default = /* @__PURE__ */ _interopDefaultCompat(ReactIs), styled__default = /* @__PURE__ */ _interopDefaultCompat(styled), Refractor__default = /* @__PURE__ */ _interopDefaultCompat(Refractor);
const createColorTheme = theme.createColorTheme, hexToRgb = theme.hexToRgb, hslToRgb = theme.hslToRgb, multiply = theme.multiply, parseColor = theme.parseColor, rgbToHex = theme.rgbToHex, rgbToHsl = theme.rgbToHsl, rgba = theme.rgba, screen = theme.screen, studioTheme = theme.buildTheme(), EMPTY_ARRAY = [], EMPTY_RECORD = {}, POPOVER_MOTION_CONTENT_OPACITY_PROPERTY = "--motion-content-opacity", POPOVER_MOTION_PROPS = {
  initial: {
    opacity: 0.5,
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
    scale: 0.97,
    willChange: "transform"
  },
  animate: {
    opacity: [null, 1, 1],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, null, 1],
    scale: 1
  },
  exit: {
    // @ts-expect-error -- passing null a second time is valid: https://github.com/framer/motion/blob/b9ce4c42914c3916ea523609c5b032dfc72718bb/packages/framer-motion/src/animation/utils/keyframes.ts#L34C22-L34C22
    opacity: [null, null, 0],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, 0, 0],
    scale: 0.97
  },
  transition: { duration: 0.4, type: "spring" }
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => (style[key2] = value, style), {});
}
function rem(pixelValue) {
  return pixelValue === 0 ? 0 : `${pixelValue / 16}rem`;
}
function _responsive(media, values, callback) {
  return ((values == null ? void 0 : values.map(callback)) || []).map((statement, mediaIndex) => mediaIndex === 0 ? statement : { [`@media screen and (min-width: ${media[mediaIndex - 1]}px)`]: statement });
}
function _getArrayProp(val, defaultVal) {
  return val === void 0 ? defaultVal || EMPTY_ARRAY : Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme$1, props, spaceIndexes = EMPTY_ARRAY) {
  if (!Array.isArray(spaceIndexes))
    throw new Error("the property must be array of numbers");
  if (spaceIndexes.length === 0)
    return null;
  const { media, space } = theme.getTheme_v2(theme$1);
  return _responsive(
    media,
    spaceIndexes,
    (spaceIndex) => _fillCSSObject(props, rem(space[spaceIndex]))
  );
}
function responsiveFont(fontKey, props) {
  const { $size, $weight } = props, { font, media } = theme.getTheme_v2(props.theme), { family, sizes, weights } = font[fontKey], fontWeight = $weight && weights[$weight] || weights.regular, defaultSize = sizes[2], base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size)
    return responsiveFont.warned || (console.warn("No size specified for responsive font", { fontKey, $size, props, base }), responsiveFont.warned = !0), [base];
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size2) {
  const { ascenderHeight, descenderHeight, fontSize: fontSize2, iconSize, letterSpacing, lineHeight } = size2, negHeight = ascenderHeight + descenderHeight, capHeight = lineHeight - negHeight, iconOffset = (capHeight - iconSize) / 2, customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1, customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: `calc(${lineHeight} / ${fontSize2})`,
    letterSpacing: rem(letterSpacing),
    transform: `translateY(${rem(descenderHeight)})`,
    "&:before": {
      marginTop: `calc(${rem(0 - negHeight)} - 1px)`
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: `calc(${customIconSize} / 16 * 1rem)`,
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: `calc(${iconSize} / 16 * 1rem)`,
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$align, (textAlign) => ({ textAlign }));
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = react.useMemo(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return react.useMemo(
    () => _getArrayProp(val, defaultVal),
    // Improve performance: Keep object identify for a given hash of the value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [__perf_hash__]
  );
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg)
    Array.isArray(el) ? ret.push(...el) : ret.push(el);
  return ret.filter(Boolean);
}
function useClickOutside(listener, elementsArg = EMPTY_ARRAY, boundaryElement) {
  const [element, setElement] = react.useState(null), [elements, setElements] = react.useState(() => _getElements(element, elementsArg)), elementsRef = react.useRef(elements);
  return react.useEffect(() => {
    const prevElements = elementsRef.current, nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements), elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements)
      if (!nextElements.includes(el)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
    for (const el of nextElements)
      if (!prevElements.includes(el)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
  }, [element, elementsArg]), react.useEffect(() => {
    if (!listener)
      return;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (target instanceof Node && !(boundaryElement && !boundaryElement.contains(target))) {
        for (const el of elements)
          if (target === el || el.contains(target))
            return;
        listener(evt);
      }
    };
    return window.addEventListener("mousedown", handleWindowMouseDown), () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]), setElement;
}
var resizeObservers = [], hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
}, hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
}, msg = "ResizeObserver loop completed with undelivered notifications.", deliverResizeLoopError = function() {
  var event;
  typeof ErrorEvent == "function" ? event = new ErrorEvent("error", {
    message: msg
  }) : (event = document.createEvent("Event"), event.initEvent("error", !1, !1), event.message = msg), window.dispatchEvent(event);
}, ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2.BORDER_BOX = "border-box", ResizeObserverBoxOptions2.CONTENT_BOX = "content-box", ResizeObserverBoxOptions2.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
}, ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize, this.blockSize = blockSize, freeze(this);
  }
  return ResizeObserverSize2;
}(), DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    return this.x = x, this.y = y, this.width = width, this.height = height, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, freeze(this);
  }
  return DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x, y, top, right, bottom, left, width, height };
  }, DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }, DOMRectReadOnly2;
}(), isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
}, isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
}, isElement = function(obj) {
  var _a;
  if (obj instanceof Element)
    return !0;
  var scope = (_a = obj == null ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
}, isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, global$1 = typeof window < "u" ? window : {}, cache = /* @__PURE__ */ new WeakMap(), scrollRegexp = /auto|scroll/, verticalRegexp = /^tb|vertical/, IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent), parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
}, size$1 = function(inlineSize, blockSize, switchSizes) {
  return inlineSize === void 0 && (inlineSize = 0), blockSize === void 0 && (blockSize = 0), switchSizes === void 0 && (switchSizes = !1), new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
}, zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
}), calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0 && (forceRecalculation = !1), cache.has(target) && !forceRecalculation)
    return cache.get(target);
  if (isHidden(target))
    return cache.set(target, zeroBoxes), zeroBoxes;
  var cs = getComputedStyle(target), svg = isSVG(target) && target.ownerSVGElement && target.getBBox(), removePadding = !IE && cs.boxSizing === "border-box", switchSizes = verticalRegexp.test(cs.writingMode || ""), canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || ""), canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || ""), paddingTop = svg ? 0 : parseDimension(cs.paddingTop), paddingRight = svg ? 0 : parseDimension(cs.paddingRight), paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom), paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft), borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth), borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth), borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth), borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth), horizontalPadding = paddingLeft + paddingRight, verticalPadding = paddingTop + paddingBottom, horizontalBorderArea = borderLeft2 + borderRight2, verticalBorderArea = borderTop2 + borderBottom2, horizontalScrollbarThickness = canScrollHorizontally ? target.offsetHeight - verticalBorderArea - target.clientHeight : 0, verticalScrollbarThickness = canScrollVertically ? target.offsetWidth - horizontalBorderArea - target.clientWidth : 0, widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0, heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0, contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness, contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness, borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea, borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea, boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  return cache.set(target, boxes), boxes;
}, calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
}, ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target, this.contentRect = boxes.contentRect, this.borderBoxSize = freeze([boxes.borderBoxSize]), this.contentBoxSize = freeze([boxes.contentBoxSize]), this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}(), calculateDepthForNode = function(node) {
  if (isHidden(node))
    return 1 / 0;
  for (var depth = 0, parent = node.parentNode; parent; )
    depth += 1, parent = parent.parentNode;
  return depth;
}, broadcastActiveObservations = function() {
  var shallowestDepth = 1 / 0, callbacks2 = [];
  resizeObservers.forEach(function(ro) {
    if (ro.activeTargets.length !== 0) {
      var entries = [];
      ro.activeTargets.forEach(function(ot) {
        var entry = new ResizeObserverEntry(ot.target), targetDepth = calculateDepthForNode(ot.target);
        entries.push(entry), ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox), targetDepth < shallowestDepth && (shallowestDepth = targetDepth);
      }), callbacks2.push(function() {
        ro.callback.call(ro.observer, entries, ro.observer);
      }), ro.activeTargets.splice(0, ro.activeTargets.length);
    }
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
}, gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length), ro.skippedTargets.splice(0, ro.skippedTargets.length), ro.observationTargets.forEach(function(ot) {
      ot.isActive() && (calculateDepthForNode(ot.target) > depth ? ro.activeTargets.push(ot) : ro.skippedTargets.push(ot));
    });
  });
}, process = function() {
  var depth = 0;
  for (gatherActiveObservationsAtDepth(depth); hasActiveObservations(); )
    depth = broadcastActiveObservations(), gatherActiveObservationsAtDepth(depth);
  return hasSkippedObservations() && deliverResizeLoopError(), depth > 0;
}, trigger, callbacks = [], notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
}, queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0, el_1 = document.createTextNode(""), config = { characterData: !0 };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config), trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback), trigger();
}, queueResizeObserver = function(cb) {
  queueMicroTask(function() {
    requestAnimationFrame(cb);
  });
}, watching = 0, isWatching = function() {
  return !!watching;
}, CATCH_PERIOD = 250, observerConfig = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], time = function(timeout) {
  return timeout === void 0 && (timeout = 0), Date.now() + timeout;
}, scheduled = !1, Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = !0, this.listener = function() {
      return _this.schedule();
    };
  }
  return Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0 && (timeout = CATCH_PERIOD), !scheduled) {
      scheduled = !0;
      var until = time(timeout);
      queueResizeObserver(function() {
        var elementsHaveResized = !1;
        try {
          elementsHaveResized = process();
        } finally {
          if (scheduled = !1, timeout = until - time(), !isWatching())
            return;
          elementsHaveResized ? _this.run(1e3) : timeout > 0 ? _this.run(timeout) : _this.start();
        }
      });
    }
  }, Scheduler2.prototype.schedule = function() {
    this.stop(), this.run();
  }, Scheduler2.prototype.observe = function() {
    var _this = this, cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  }, Scheduler2.prototype.start = function() {
    var _this = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), events.forEach(function(name) {
      return global$1.addEventListener(name, _this.listener, !0);
    }));
  }, Scheduler2.prototype.stop = function() {
    var _this = this;
    this.stopped || (this.observer && this.observer.disconnect(), events.forEach(function(name) {
      return global$1.removeEventListener(name, _this.listener, !0);
    }), this.stopped = !0);
  }, Scheduler2;
}(), scheduler = new Scheduler(), updateCount = function(n) {
  !watching && n > 0 && scheduler.start(), watching += n, !watching && scheduler.stop();
}, skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
}, ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target, this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, !0);
    return skipNotifyOnElement(this.target) && (this.lastReportedSize = size2), this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize;
  }, ResizeObservation2;
}(), ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = resizeObserver, this.callback = callback;
  }
  return ResizeObserverDetail2;
}(), observerMap = /* @__PURE__ */ new WeakMap(), getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1)
    if (observationTargets[i].target === target)
      return i;
  return -1;
}, ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  return ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  }, ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver), firstObservation = detail.observationTargets.length === 0;
    getObservationIndex(detail.observationTargets, target) < 0 && (firstObservation && resizeObservers.push(detail), detail.observationTargets.push(new ResizeObservation(target, options && options.box)), updateCount(1), scheduler.schedule());
  }, ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver), index = getObservationIndex(detail.observationTargets, target), lastObservation = detail.observationTargets.length === 1;
    index >= 0 && (lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1), detail.observationTargets.splice(index, 1), updateCount(-1));
  }, ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this, detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    }), detail.activeTargets.splice(0, detail.activeTargets.length);
  }, ResizeObserverController2;
}(), ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof callback != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    ResizeObserverController.connect(this, callback);
  }
  return ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.observe(this, target, options);
  }, ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.unobserve(this, target);
  }, ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  }, ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, ResizeObserver2;
}();
const _ResizeObserver = typeof document < "u" && typeof window < "u" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver, _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(([entry]) => {
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      return resizeObserver.observe(element), () => {
        resizeObserver.unobserve(element), resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap(), subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      return subscribersCache.has(element) || (subscribersCache.set(element, subscribers), dispose = _createElementRectValueListener().subscribe(element, (elementRect) => {
        for (const sub of subscribers)
          sub(elementRect);
      })), subscribers.push(subscriber), () => {
        const idx = subscribers.indexOf(subscriber);
        idx > -1 && subscribers.splice(idx, 1), subscribers.length === 0 && dispose && dispose();
      };
    }
  };
}
function useElementSize(element) {
  const [size2, setSize] = react.useState(null);
  return react.useEffect(() => {
    if (element)
      return _elementSizeObserver.subscribe(element, setSize);
  }, [element]), size2;
}
function useElementRect(element) {
  const elementSize = useElementSize(element);
  return (elementSize == null ? void 0 : elementSize._contentRect) || null;
}
function useGlobalKeyDown(onKeyDown) {
  return react.useEffect(() => (addEventListener("keydown", onKeyDown), () => removeEventListener("keydown", onKeyDown)), [onKeyDown]);
}
function getGlobalScope() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof window < "u")
    return window;
  if (typeof self < "u")
    return self;
  if (typeof global < "u")
    return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope(), key$8 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$8] = globalScope[key$8] || react.createContext(null);
const ThemeContext = globalScope[key$8];
function ThemeProvider(props) {
  const parentTheme = react.useContext(ThemeContext), {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: rootTheme = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props, themeContext = react.useMemo(() => rootTheme ? {
    version: 0,
    theme: rootTheme,
    scheme,
    tone
  } : null, [rootTheme, scheme, tone]), theme$1 = react.useMemo(() => rootTheme ? theme.getScopedTheme(rootTheme, scheme, tone) : null, [scheme, rootTheme, tone]);
  return theme$1 ? /* @__PURE__ */ jsxRuntime.jsx(ThemeContext.Provider, { value: themeContext, children: /* @__PURE__ */ jsxRuntime.jsx(styled.ThemeProvider, { theme: theme$1, children }) }) : /* @__PURE__ */ jsxRuntime.jsx("pre", { children: 'ThemeProvider: no "theme" property provided' });
}
function useRootTheme() {
  const value = react.useContext(ThemeContext);
  if (!value)
    throw new Error("useRootTheme(): missing context value");
  return value;
}
function ThemeColorProvider(props) {
  const { children, scheme, tone } = props, root = useRootTheme();
  return /* @__PURE__ */ jsxRuntime.jsx(ThemeProvider, { scheme: scheme || root.scheme, theme: root.theme, tone, children });
}
function useTheme() {
  return styled.useTheme();
}
function useTheme_v2() {
  return theme.getTheme_v2(styled.useTheme());
}
const MEDIA_STORE_CACHE = /* @__PURE__ */ new WeakMap();
function _getMediaQuery(media, index) {
  return index === 0 ? `screen and (max-width: ${media[index] - 1}px)` : index === media.length ? `screen and (min-width: ${media[index - 1]}px)` : `screen and (min-width: ${media[index - 1]}px) and (max-width: ${media[index] - 1}px)`;
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({ index, mq: window.matchMedia(mediaQuery) });
      }
    }
    return sizes;
  };
  return { getSnapshot: () => {
    for (const { index, mq } of getSizes())
      if (mq.matches)
        return index;
    return 0;
  }, subscribe: (onStoreChange) => {
    const disposeFns = [];
    for (const { mq } of getSizes()) {
      const handleChange = () => {
        mq.matches && onStoreChange();
      };
      mq.addEventListener("change", handleChange), disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns)
        disposeFn();
    };
  } };
}
function getServerSnapshot$2() {
  return 0;
}
function useMediaIndex() {
  const { media } = useTheme_v2();
  let store = MEDIA_STORE_CACHE.get(media);
  return store || (store = _createMediaStore(media), MEDIA_STORE_CACHE.set(media, store)), react.useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot$2);
}
let MEDIA_QUERY_CACHE$1;
function getMatchMedia$1() {
  return MEDIA_QUERY_CACHE$1 || (MEDIA_QUERY_CACHE$1 = window.matchMedia("(prefers-color-scheme: dark)")), MEDIA_QUERY_CACHE$1;
}
function subscribe$2(onStoreChange) {
  const matchMedia = getMatchMedia$1();
  return matchMedia.addEventListener("change", onStoreChange), () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot$1() {
  return getMatchMedia$1().matches;
}
function getServerSnapshot$1() {
  return !1;
}
function usePrefersDark() {
  return react.useSyncExternalStore(subscribe$2, getSnapshot$1, getServerSnapshot$1);
}
let MEDIA_QUERY_CACHE;
function getMatchMedia() {
  return MEDIA_QUERY_CACHE || (MEDIA_QUERY_CACHE = window.matchMedia("(prefers-reduced-motion: reduce)")), MEDIA_QUERY_CACHE;
}
function subscribe$1(onStoreChange) {
  const matchMedia = getMatchMedia();
  return matchMedia.addEventListener("change", onStoreChange), () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot() {
  return getMatchMedia().matches;
}
function getServerSnapshot() {
  return !1;
}
function usePrefersReducedMotion() {
  return react.useSyncExternalStore(subscribe$1, getSnapshot, getServerSnapshot);
}
const useIsomorphicEffect = typeof window < "u" ? react.useLayoutEffect : react.useEffect;
function useForwardedRef(ref) {
  const innerRef = react.useRef(null);
  return useIsomorphicEffect(() => {
    ref && (typeof ref == "function" ? ref(innerRef.current) : ref.current = innerRef.current);
  }), innerRef;
}
function useCustomValidity(ref, customValidity) {
  react.useEffect(() => {
    ref.current && ref.current.setCustomValidity(customValidity || "");
  }, [customValidity, ref]);
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  var _a, _b;
  const { card, media } = theme.getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$border,
    (value) => value ? { "&&": { border: borderStyle } } : { "&&": { border: 0 } }
  );
}
function borderTop(props) {
  var _a, _b;
  const { card, media } = theme.getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderTop,
    (value) => value ? { "&&": { borderTop: borderStyle } } : { "&&": { borderTop: 0 } }
  );
}
function borderRight(props) {
  var _a, _b;
  const { card, media } = theme.getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderRight,
    (value) => value ? { "&&": { borderRight: borderStyle } } : { "&&": { borderRight: 0 } }
  );
}
function borderBottom(props) {
  var _a, _b;
  const { card, media } = theme.getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderBottom,
    (value) => value ? { "&&": { borderBottom: borderStyle } } : { "&&": { borderBottom: 0 } }
  );
}
function borderLeft(props) {
  var _a, _b;
  const { card, media } = theme.getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderLeft,
    (value) => value ? { "&&": { borderLeft: borderStyle } } : { "&&": { borderLeft: 0 } }
  );
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, BOX_SIZING = {
  content: "content-box",
  border: "border-box"
}, BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [
    responsiveBoxSizingStyle,
    responsiveBoxHeightStyle,
    responsiveBoxOverflowStyle,
    responsiveBoxDisplayStyle
  ];
}
function responsiveBoxDisplayStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$display, (display) => ({
    "&:not([hidden])": { display }
  }));
}
function responsiveBoxSizingStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$overflow, (overflow) => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [
    BASE_STYLE$3,
    responsiveFlexAlignStyle,
    responsiveFlexGapStyle,
    responsiveFlexWrapStyle,
    responsiveFlexJustifyStyle,
    responsiveFlexDirectionStyle
  ];
}
function responsiveFlexAlignStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$align, (align) => ({ alignItems: align }));
}
function responsiveFlexGapStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$wrap, (wrap) => ({ flexWrap: wrap }));
}
function responsiveFlexJustifyStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$justify, (justify) => ({ justifyContent: justify }));
}
function responsiveFlexDirectionStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$direction, (direction) => ({ flexDirection: direction }));
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return props.$flex ? _responsive(media, props.$flex, (flex) => ({ flex })) : EMPTY_ARRAY;
}
function focusRingBorderStyle(border2) {
  return `inset 0 0 0 ${border2.width}px ${border2.color}`;
}
function focusRingStyle(opts) {
  const { base, border: border2, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border2 && focusRingBorderStyle(border2),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
}, GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [
    GRID_CSS,
    responsiveGridAutoFlowStyle,
    responsiveGridAutoRowsStyle,
    responsiveGridAutoColsStyle,
    responsiveGridColumnsStyle,
    responsiveGridRowsStyle,
    responsiveGridGapStyle,
    responsiveGridGapXStyle,
    responsiveGridGapYStyle
  ];
}
function responsiveGridAutoFlowStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$columns, (columns) => ({
    gridTemplateColumns: columns && `repeat(${columns},minmax(0,1fr));`
  }));
}
function responsiveGridRowsStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$rows, (rows) => ({
    gridTemplateRows: rows && `repeat(${rows},minmax(0,1fr));`
  }));
}
function responsiveGridGapStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [
    responsiveGridItemRowStyle,
    responsiveGridItemRowStartStyle,
    responsiveGridItemRowEndStyle,
    responsiveGridItemColumnStyle,
    responsiveGridItemColumnStartStyle,
    responsiveGridItemColumnEndStyle
  ];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
}, GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$row, (row) => typeof row == "number" ? { gridRow: `span ${row} / span ${row}` } : { gridRow: GRID_ITEM_ROW[row] });
}
function responsiveGridItemRowStartStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$rowEnd, (rowEnd) => ({ gridRowEnd: rowEnd }));
}
function responsiveGridItemColumnStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$column, (column) => typeof column == "number" ? { gridColumn: `span ${column} / span ${column}` } : { gridColumn: GRID_ITEM_COLUMN[column] });
}
function responsiveGridItemColumnStartStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const { $fontSize, $iconLeft, $iconRight, $padding, $space } = props, { font, media, space } = theme.getTheme_v2(props.theme), len = Math.max($padding.length, $space.length, $fontSize.length), _padding = [], _space = [], _fontSize = [];
  for (let i = 0; i < len; i += 1)
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i], _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i], _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  return _responsive(media, _padding, (_, i) => {
    const size2 = font.text.sizes[_fontSize[i]] || font.text.sizes[2], emSize = size2.lineHeight - size2.ascenderHeight - size2.descenderHeight, p = space[_padding[i]], s = space[_space[i]], styles = {
      paddingTop: rem(p - size2.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size2.descenderHeight),
      paddingLeft: rem(p)
    };
    return $iconRight && (styles.paddingRight = rem(p + emSize + s)), $iconLeft && (styles.paddingLeft = rem(p + emSize + s)), styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({ ...props, $iconRight: !0 });
}
const ROOT_STYLE = styled.css`
  &:not([hidden]) {
    display: flex;
  }

  align-items: center;
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const { $scheme, $tone, $weight } = props, { color, font } = theme.getTheme_v2(props.theme);
  return styled.css`
    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${$weight && font.text.weights[$weight] || font.text.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;

    /* NOTE: This is a hack to disable Chromeâ€™s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    color: var(--input-fg-color);

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --input-fg-color: ${color.input.default.enabled.fg};
      --input-placeholder-color: ${color.input.default.enabled.placeholder};

      /* enabled */
      &:not(:invalid):not(:disabled):not(:read-only) {
        --input-fg-color: ${color.input.default.enabled.fg};
        --input-placeholder-color: ${color.input.default.enabled.placeholder};
      }

      /* disabled */
      &:not(:invalid):disabled {
        --input-fg-color: ${color.input.default.disabled.fg};
        --input-placeholder-color: ${color.input.default.disabled.placeholder};
      }

      /* invalid */
      &:invalid {
        --input-fg-color: ${color.input.invalid.enabled.fg};
        --input-placeholder-color: ${color.input.invalid.enabled.placeholder};
      }

      /* readOnly */
      &:read-only {
        --input-fg-color: ${color.input.default.readOnly.fg};
        --input-placeholder-color: ${color.input.default.readOnly.placeholder};
      }
    }
  `;
}
function textInputFontSizeStyle(props) {
  const { font, media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$fontSize, (sizeIndex) => {
    const size2 = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size2.fontSize),
      lineHeight: size2.lineHeight / size2.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const { $hasPrefix, $hasSuffix, $scheme, $tone, $unstableDisableFocusRing } = props, { color, input } = theme.getTheme_v2(props.theme);
  return styled.css`
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;

    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --card-bg-color: ${color.input.default.enabled.bg};
      --card-fg-color: ${color.input.default.enabled.fg};

      /* enabled */
      *:not(:disabled) + &[data-border] {
        --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
      }

      /* invalid */
      *:not(:disabled):invalid + & {
        --card-bg-color: ${color.input.invalid.enabled.bg};
        --card-fg-color: ${color.input.invalid.enabled.fg};

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.enabled.border,
    width: input.border.width
  })};
        }
      }

      /* focused */
      *:not(:disabled):focus + & {
        &[data-border] {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: { color: color.input.default.enabled.border, width: input.border.width },
    focusRing: input.text.focusRing
  })};
        }

        &:not([data-border]) {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({ focusRing: input.text.focusRing })};
        }
      }

      /* disabled */
      *:not(:invalid):disabled + & {
        --card-bg-color: ${color.input.default.disabled.bg} !important;
        --card-fg-color: ${color.input.default.disabled.fg} !important;
        --card-icon-color: ${color.input.default.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  })};
        }
      }

      *:invalid:disabled + & {
        --card-bg-color: ${color.input.invalid.disabled.bg} !important;
        --card-fg-color: ${color.input.invalid.disabled.fg} !important;
        --card-icon-color: ${color.input.invalid.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.disabled.border,
    width: input.border.width
  })};
        }
      }

      /* readOnly */
      *:not(:invalid):read-only + & {
        --card-bg-color: ${color.input.default.readOnly.bg} !important;
        --card-fg-color: ${color.input.default.readOnly.fg} !important;
      }

      *:invalid:read-only + & {
        --card-bg-color: ${color.input.invalid.readOnly.bg} !important;
        --card-fg-color: ${color.input.invalid.readOnly.fg} !important;
      }

      /* hovered */
      @media (hover: hover) {
        *:not(:disabled):not(:read-only):not(:invalid):hover + & {
          --card-bg-color: ${color.input.default.hovered.bg};
          --card-fg-color: ${color.input.default.hovered.fg};
        }

        *:invalid:not(:disabled):not(:read-only):hover + & {
          --card-bg-color: ${color.input.invalid.hovered.bg};
          --card-fg-color: ${color.input.invalid.hovered.fg};
        }

        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
        }

        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.hovered.border,
    width: input.border.width
  })};
        }
      }
    }
  `;
}
function responsiveMarginStyle(props) {
  const { theme: theme2 } = props;
  return [
    _getResponsiveSpace(theme2, ["margin"], props.$margin),
    _getResponsiveSpace(theme2, ["marginLeft", "marginRight"], props.$marginX),
    _getResponsiveSpace(theme2, ["marginTop", "marginBottom"], props.$marginY),
    _getResponsiveSpace(theme2, ["marginTop"], props.$marginTop),
    _getResponsiveSpace(theme2, ["marginRight"], props.$marginRight),
    _getResponsiveSpace(theme2, ["marginBottom"], props.$marginBottom),
    _getResponsiveSpace(theme2, ["marginLeft"], props.$marginLeft)
  ].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const { theme: theme2 } = props;
  return [
    _getResponsiveSpace(theme2, ["padding"], props.$padding),
    _getResponsiveSpace(theme2, ["paddingLeft", "paddingRight"], props.$paddingX),
    _getResponsiveSpace(theme2, ["paddingTop", "paddingBottom"], props.$paddingY),
    _getResponsiveSpace(theme2, ["paddingTop"], props.$paddingTop),
    _getResponsiveSpace(theme2, ["paddingRight"], props.$paddingRight),
    _getResponsiveSpace(theme2, ["paddingBottom"], props.$paddingBottom),
    _getResponsiveSpace(theme2, ["paddingLeft"], props.$paddingLeft)
  ].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const { media, radius } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$radius, (value) => {
    let borderRadius = 0;
    return typeof value == "number" && (borderRadius = rem(radius[value])), value === "full" && (borderRadius = "9999px"), { borderRadius };
  });
}
function toBoxShadow(shadow, color) {
  return `${shadow.map(rem).join(" ")} ${color}`;
}
function shadowStyle(shadow, outlineWidth = 1) {
  if (!shadow)
    return EMPTY_RECORD;
  const outline = `0 0 0 ${rem(outlineWidth)} var(--card-shadow-outline-color)`, umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)"), penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)"), ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return { boxShadow: `${outline}, ${umbra}, ${penumbra}, ${ambient}` };
}
function responsiveShadowStyle(props) {
  const { card, media, shadow } = theme.getTheme_v2(props.theme);
  return _responsive(
    media,
    props.$shadow,
    (index) => shadowStyle(shadow[index], card.shadow.outline)
  );
}
function labelBaseStyle(props) {
  const { $accent, $muted } = props, { font } = theme.getTheme_v2(props.theme);
  return styled.css`
    text-transform: uppercase;

    ${$accent && styled.css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && styled.css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$C = styled__default.default.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle), SpanWithTextOverflow$2 = styled__default.default.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Label = react.forwardRef(function(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" ? children = /* @__PURE__ */ jsxRuntime.jsx(SpanWithTextOverflow$2, { children }) : children = /* @__PURE__ */ jsxRuntime.jsx("span", { children }), /* @__PURE__ */ jsxRuntime.jsx(
    Root$C,
    {
      "data-ui": "Label",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      $size: useArrayProp(size2),
      $weight: weight,
      ref,
      children
    }
  );
}), avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const { $color } = props, { avatar } = theme.getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": `var(--card-avatar-${$color}-bg-color)`,
    "--avatar-fg-color": `var(--card-avatar-${$color}-fg-color)`,
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({ focusRing: avatar.focusRing })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const { avatar, media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$B = styled__default.default.div(
  responsiveAvatarSizeStyle,
  avatarStyle.root
), Arrow$1 = styled__default.default.div(avatarStyle.arrow), BgStroke = styled__default.default.ellipse(avatarStyle.bgStroke), Stroke = styled__default.default.ellipse(avatarStyle.stroke), Initials = styled__default.default.div(avatarStyle.initials), InitialsLabel = styled__default.default(Label)({
  color: "inherit"
}), Image = styled__default.default.svg(avatarStyle.image), Avatar = react.forwardRef(function(props, ref) {
  const {
    __unstable_hideInnerStroke,
    as: asProp,
    color = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 1,
    ...restProps
  } = props, { avatar } = useTheme_v2(), as = ReactIs__default.default.isValidElementType(asProp) ? asProp : "div", size2 = useArrayProp(sizeProp), _sizeRem = (avatar.sizes[size2[0]] || avatar.sizes[0]).size, _radius = _sizeRem / 2, elementId = react.useId(), [arrowPosition, setArrowPosition] = react.useState(
    animateArrowFrom || arrowPositionProp || "inside"
  ), [imageFailed, setImageFailed] = react.useState(!1), imageId = `avatar-image-${elementId}`;
  react.useEffect(() => {
    if (arrowPosition === arrowPositionProp)
      return;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]), react.useEffect(() => {
    src && setImageFailed(!1);
  }, [src]);
  const handleImageError = react.useCallback(() => {
    setImageFailed(!0), onImageLoadError && onImageLoadError(new Error("Avatar: the image failed to load"));
  }, [onImageLoadError]), initialsSize = react.useMemo(
    () => size2.map((s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0),
    [size2]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$B,
    {
      as,
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Avatar",
      ...restProps,
      $color: color,
      $size: size2,
      "aria-label": title,
      "data-arrow-position": arrowPosition,
      "data-status": status,
      ref,
      title,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(Arrow$1, { children: /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "11", height: "7", viewBox: "0 0 11 7", fill: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
            fill: color
          }
        ) }) }),
        !imageFailed && src && /* @__PURE__ */ jsxRuntime.jsxs(Image, { viewBox: `0 0 ${_sizeRem} ${_sizeRem}`, fill: "none", children: [
          /* @__PURE__ */ jsxRuntime.jsx("defs", { children: /* @__PURE__ */ jsxRuntime.jsx("pattern", { id: imageId, patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntime.jsx(
            "image",
            {
              href: src,
              width: "1",
              height: "1",
              onError: handleImageError
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: _radius, cy: _radius, r: _radius, fill: `url(#${imageId})` }),
          !__unstable_hideInnerStroke && /* @__PURE__ */ jsxRuntime.jsx(
            BgStroke,
            {
              cx: _radius,
              cy: _radius,
              rx: _radius,
              ry: _radius,
              vectorEffect: "non-scaling-stroke"
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            Stroke,
            {
              cx: _radius,
              cy: _radius,
              rx: _radius,
              ry: _radius,
              vectorEffect: "non-scaling-stroke"
            }
          )
        ] }),
        (imageFailed || !src) && initials && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(Initials, { children: /* @__PURE__ */ jsxRuntime.jsx(InitialsLabel, { forwardedAs: "span", size: initialsSize, weight: "medium", children: initials }) }) })
      ]
    }
  );
});
function _responsiveAvatarCounterSizeStyle(props) {
  const { avatar, media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    } : EMPTY_RECORD;
  });
}
function _avatarCounterBaseStyle(props) {
  const { space } = theme.getTheme_v2(props.theme);
  return styled.css`
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    user-select: none;
    color: inherit;
    color: var(--card-fg-color);
    background: var(--card-bg-color);
    box-shadow:
      0 0 0 1px var(--card-bg-color),
      inset 0 0 0 1px var(--card-hairline-hard-color);
    padding: 0 ${rem(space[2])};

    &:not([hidden]) {
      display: flex;
    }
  `;
}
const Root$A = styled__default.default.div(
  _responsiveAvatarCounterSizeStyle,
  _avatarCounterBaseStyle
), AvatarCounter = react.forwardRef(function(props, ref) {
  const { count, size: sizeProp = 1 } = props, size2 = useArrayProp(sizeProp), fontSize2 = react.useMemo(
    () => size2.map((s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0),
    [size2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Root$A, { $size: size2, "data-ui": "AvatarCounter", ref, children: /* @__PURE__ */ jsxRuntime.jsx(Label, { as: "span", size: fontSize2, weight: "medium", children: count }) });
});
function childrenToElementArray(children) {
  return (Array.isArray(children) ? children : [children]).filter(
    (node) => ReactIs.isElement(node) || ReactIs.isFragment(node) || typeof node == "string"
  );
}
const BASE_STYLES = styled.css`
  white-space: nowrap;

  & > div {
    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  }
`;
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const { avatar, media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    } : EMPTY_RECORD;
  });
}
const Root$z = styled__default.default.div(responsiveAvatarStackSizeStyle, avatarStackStyle), AvatarStack = react.forwardRef(function(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 1,
    ...restProps
  } = props, children = childrenToElementArray(childrenProp).filter(
    (child) => typeof child != "string"
  ), maxLength = Math.max(maxLengthProp, 0), size2 = useArrayProp(sizeProp), len = children.length, visibleCount = maxLength - 1, extraCount = len - visibleCount, visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$z, { "data-ui": "AvatarStack", ...restProps, ref, $size: size2, children: [
    len === 0 && /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(AvatarCounter, { count: len, size: size2 }) }),
    len !== 0 && extraCount > 1 && /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(AvatarCounter, { count: extraCount, size: size2 }) }),
    visibleChildren.map((child, childIndex) => /* @__PURE__ */ jsxRuntime.jsx("div", { children: react.cloneElement(child, { size: size2 }) }, String(childIndex)))
  ] });
}), Root$y = styled__default.default.div(
  boxStyle,
  flexItemStyle,
  responsiveBoxStyle,
  responsiveGridItemStyle,
  responsiveMarginStyle,
  responsivePaddingStyle
), Box = react.forwardRef(function(props, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$y,
    {
      "data-as": typeof asProp == "string" ? asProp : void 0,
      "data-ui": "Box",
      ...restProps,
      $column: useArrayProp(column),
      $columnStart: useArrayProp(columnStart),
      $columnEnd: useArrayProp(columnEnd),
      $display: useArrayProp(display),
      $flex: useArrayProp(flex),
      $height: useArrayProp(height),
      $margin: useArrayProp(margin),
      $marginX: useArrayProp(marginX),
      $marginY: useArrayProp(marginY),
      $marginTop: useArrayProp(marginTop),
      $marginRight: useArrayProp(marginRight),
      $marginBottom: useArrayProp(marginBottom),
      $marginLeft: useArrayProp(marginLeft),
      $overflow: useArrayProp(overflow),
      $padding: useArrayProp(padding),
      $paddingX: useArrayProp(paddingX),
      $paddingY: useArrayProp(paddingY),
      $paddingTop: useArrayProp(paddingTop),
      $paddingRight: useArrayProp(paddingRight),
      $paddingBottom: useArrayProp(paddingBottom),
      $paddingLeft: useArrayProp(paddingLeft),
      $row: useArrayProp(row),
      $rowStart: useArrayProp(rowStart),
      $rowEnd: useArrayProp(rowEnd),
      $sizing: useArrayProp(sizing),
      as: asProp,
      ref,
      children: props.children
    }
  );
});
function textBaseStyle(props) {
  const { $accent, $muted } = props, { font } = theme.getTheme_v2(props.theme);
  return styled.css`
    color: var(--card-fg-color);

    ${$accent && styled.css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && styled.css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
      background-color: var(--card-code-bg-color);
      color: var(--card-code-fg-color);
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.text.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
      color: var(--card-icon-color);

      & path {
        vector-effect: non-scaling-stroke !important;
      }
    }
  `;
}
const Root$x = styled__default.default.div(
  responsiveTextFont,
  responsiveTextAlignStyle,
  textBaseStyle
), SpanWithTextOverflow$1 = styled__default.default.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Text = react.forwardRef(function(props, ref) {
  const {
    accent = !1,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" && (children = /* @__PURE__ */ jsxRuntime.jsx(SpanWithTextOverflow$1, { children })), /* @__PURE__ */ jsxRuntime.jsx(
    Root$x,
    {
      "data-ui": "Text",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      ref,
      $size: useArrayProp(size2),
      $weight: weight,
      children: /* @__PURE__ */ jsxRuntime.jsx("span", { children })
    }
  );
});
function badgeStyle(props) {
  const { $tone } = props;
  return {
    "--card-bg-color": `var(--card-badge-${$tone}-bg-color)`,
    "--card-fg-color": `var(--card-badge-${$tone}-fg-color)`,
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
const Root$w = styled__default.default(Box)(
  responsiveRadiusStyle,
  badgeStyle
), Badge = react.forwardRef(function(props, ref) {
  const {
    children,
    fontSize: fontSize2 = 1,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mode: _deprecated_mode,
    padding = 1,
    radius = "full",
    tone = "default",
    ...restProps
  } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$w,
    {
      "data-ui": "Badge",
      ...restProps,
      $tone: tone,
      $radius: useArrayProp(radius),
      padding: useArrayProp(padding),
      ref,
      children: /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, children })
    }
  );
}), Root$v = styled__default.default(Box)(
  flexItemStyle,
  responsiveFlexStyle
), Flex = react.forwardRef(function(props, ref) {
  const { align, as, direction = "row", gap, justify, wrap, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$v,
    {
      "data-ui": "Flex",
      ...restProps,
      $align: useArrayProp(align),
      $direction: useArrayProp(direction),
      $gap: useArrayProp(gap),
      $justify: useArrayProp(justify),
      $wrap: useArrayProp(wrap),
      forwardedAs: as,
      ref
    }
  );
}), rotate$1 = styled.keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, Root$u = styled__default.default(Text)`
  & > span > svg {
    animation: ${rotate$1} 500ms linear infinite;
  }
`, Spinner = react.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(Root$u, { "data-ui": "Spinner", ...props, ref, children: /* @__PURE__ */ jsxRuntime.jsx(icons.SpinnerIcon, {}) });
});
function _cardColorStyle(base, color, checkered = !1) {
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color.accent.fg,
    "--card-avatar-gray-bg-color": color.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color.avatar.red.bg,
    "--card-avatar-red-fg-color": color.avatar.red.fg,
    "--card-avatar-orange-bg-color": color.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color.avatar.green.bg,
    "--card-avatar-green-fg-color": color.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color.avatar.cyan.fg,
    "--card-bg-color": color.bg,
    "--card-bg-image": checkered ? `repeating-conic-gradient(${color.bg} 0% 25%, ${color.muted.bg} 0% 50%)` : void 0,
    "--card-border-color": color.border,
    "--card-badge-default-bg-color": color.badge.default.bg,
    "--card-badge-default-dot-color": color.badge.default.dot,
    "--card-badge-default-fg-color": color.badge.default.fg,
    "--card-badge-default-icon-color": color.badge.default.icon,
    "--card-badge-primary-bg-color": color.badge.primary.bg,
    "--card-badge-primary-dot-color": color.badge.primary.dot,
    "--card-badge-primary-fg-color": color.badge.primary.fg,
    "--card-badge-primary-icon-color": color.badge.primary.icon,
    "--card-badge-positive-bg-color": color.badge.positive.bg,
    "--card-badge-positive-dot-color": color.badge.positive.dot,
    "--card-badge-positive-fg-color": color.badge.positive.fg,
    "--card-badge-positive-icon-color": color.badge.positive.icon,
    "--card-badge-caution-bg-color": color.badge.caution.bg,
    "--card-badge-caution-dot-color": color.badge.caution.dot,
    "--card-badge-caution-fg-color": color.badge.caution.fg,
    "--card-badge-caution-icon-color": color.badge.caution.icon,
    "--card-badge-critical-bg-color": color.badge.critical.bg,
    "--card-badge-critical-dot-color": color.badge.critical.dot,
    "--card-badge-critical-fg-color": color.badge.critical.fg,
    "--card-badge-critical-icon-color": color.badge.critical.icon,
    "--card-code-bg-color": color.code.bg,
    "--card-code-fg-color": color.code.fg,
    "--card-fg-color": color.fg,
    "--card-icon-color": color.icon,
    "--card-kbd-bg-color": color.kbd.bg,
    "--card-kbd-border-color": color.kbd.border,
    "--card-kbd-fg-color": color.kbd.fg,
    "--card-link-fg-color": color.link.fg,
    "--card-muted-bg-color": color.muted.bg,
    "--card-muted-fg-color": color.muted.fg,
    "--card-skeleton-color-from": color.skeleton.from,
    "--card-skeleton-color-to": color.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color.muted.bg,
    "--card-link-color": color.link.fg,
    "--card-hairline-soft-color": color.border,
    "--card-hairline-hard-color": color.border
  };
}
function buttonBaseStyles(props) {
  const { $width } = props, { style } = theme.getTheme_v2(props.theme);
  return styled.css`
    ${style == null ? void 0 : style.button};

    -webkit-font-smoothing: inherit;
    appearance: none;
    display: inline-flex;
    align-items: center;
    font: inherit;
    border: 0;
    outline: none;
    user-select: none;
    text-decoration: none;
    border: 0;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    white-space: nowrap;
    text-align: left;
    position: relative;
    vertical-align: top;

    ${$width === "fill" && styled.css`
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    `}

    & > span {
      display: block;
      flex: 1;
      min-width: 0;
      border-radius: inherit;
    }

    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  `;
}
function combineBoxShadow(...boxShadows) {
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  var _a;
  const { $mode } = props, { button, color: baseColor, style } = theme.getTheme_v2(props.theme), shadow = props.$mode === "ghost", mode = baseColor.button[$mode] || baseColor.button.default, color = mode[props.$tone] || mode.default, border2 = {
    width: button.border.width,
    color: "var(--card-border-color)"
  }, defaultBoxShadow = void 0;
  return [
    _cardColorStyle(baseColor, color.enabled),
    {
      backgroundColor: "var(--card-bg-color)",
      color: "var(--card-fg-color)",
      boxShadow: focusRingBorderStyle(border2),
      '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color.disabled),
      "&:not([data-disabled='true'])": {
        boxShadow: combineBoxShadow(
          focusRingBorderStyle(border2),
          shadow ? defaultBoxShadow : void 0
        ),
        "&:focus": {
          boxShadow: focusRingStyle({
            base: baseColor,
            border: { width: 2, color: baseColor.bg },
            focusRing: button.focusRing
          })
        },
        "&:focus:not(:focus-visible)": {
          boxShadow: combineBoxShadow(
            focusRingBorderStyle(border2),
            shadow ? defaultBoxShadow : void 0
          )
        },
        "@media (hover: hover)": {
          "&:hover": _cardColorStyle(baseColor, color.hovered),
          "&:active": _cardColorStyle(baseColor, color.pressed),
          "&[data-hovered]": _cardColorStyle(baseColor, color.hovered)
        },
        "&[data-selected]": _cardColorStyle(baseColor, color.pressed)
      }
    },
    (_a = style == null ? void 0 : style.button) == null ? void 0 : _a.root
  ].filter(Boolean);
}
const Root$t = styled__default.default.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles), LoadingBox = styled__default.default.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--card-bg-color);
  border-radius: inherit;
  z-index: 1;
  box-shadow: inherit;
`, Button = react.forwardRef(function(props, ref) {
  const {
    children,
    disabled,
    fontSize: fontSize2 = 1,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    muted = !1,
    width,
    ...restProps
  } = props, { button } = useTheme_v2(), justify = useArrayProp(justifyProp), padding = useArrayProp(paddingProp), paddingX = useArrayProp(paddingXProp), paddingY = useArrayProp(paddingYProp), paddingTop = useArrayProp(paddingTopProp), paddingBottom = useArrayProp(paddingBottomProp), paddingLeft = useArrayProp(paddingLeftProp), paddingRight = useArrayProp(paddingRightProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp), boxProps = react.useMemo(
    () => ({
      // flex: 1,
      padding,
      paddingX,
      paddingY,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    }),
    [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$t,
    {
      "data-ui": "Button",
      ...restProps,
      $mode: mode,
      $radius: radius,
      $tone: tone,
      "data-disabled": !!(loading || disabled),
      "data-selected": selected ? "" : void 0,
      disabled: !!(loading || disabled),
      ref,
      type,
      $width: width,
      children: [
        !!loading && /* @__PURE__ */ jsxRuntime.jsx(LoadingBox, { children: /* @__PURE__ */ jsxRuntime.jsx(Spinner, {}) }),
        (icon || text || iconRight) && /* @__PURE__ */ jsxRuntime.jsx(Box, { as: "span", ...boxProps, children: /* @__PURE__ */ jsxRuntime.jsxs(Flex, { as: "span", justify, gap: space, children: [
          icon && /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(icon) && icon,
            ReactIs.isValidElementType(icon) && react.createElement(icon)
          ] }),
          text && /* @__PURE__ */ jsxRuntime.jsx(
            Text,
            {
              muted,
              align: textAlign,
              size: fontSize2,
              textOverflow: "ellipsis",
              weight: button.textWeight,
              children: text
            }
          ),
          iconRight && /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(iconRight) && iconRight,
            ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)
          ] })
        ] }) }),
        children && /* @__PURE__ */ jsxRuntime.jsx(Box, { as: "span", ...boxProps, children })
      ]
    }
  );
});
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const { $checkered } = props, { space } = theme.getTheme_v2(props.theme);
  return styled.css`
    ${$checkered && styled.css`
      background-size: ${space[3]}px ${space[3]}px;
      background-position: 50% 50%;
      background-image: var(--card-bg-image);
    `}

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      outline: none;
      text-decoration: none;
    }

    /* &:is(pre) */
    &[data-as='pre'] {
      font: inherit;
    }
  `;
}
function cardColorStyle(props) {
  var _a;
  const { $checkered, $focusRing } = props, { card, color, style } = theme.getTheme_v2(props.theme), border2 = { width: card.border.width, color: "var(--card-border-color)" };
  return styled.css`
    color-scheme: ${color._dark ? "dark" : "light"};

    ${_cardColorStyle(color, color, $checkered)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);

    /* &:is(button) */
    &[data-as='button'] {
      --card-focus-ring-box-shadow: none;

      cursor: default;
      box-shadow: var(--card-focus-ring-box-shadow);

      &:disabled {
        ${_cardColorStyle(color, color.selectable.default.disabled, $checkered)}
      }

      &:not(:disabled) {
        &[data-pressed] {
          ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, color.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, color.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({ base: color, border: border2, focusRing: card.focusRing }) : void 0};
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      cursor: pointer;
      box-shadow: var(--card-focus-ring-box-shadow);

      &[data-disabled] {
        ${_cardColorStyle(color, color.selectable.default.disabled, $checkered)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, color.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, color.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({ base: color, border: border2, focusRing: card.focusRing }) : void 0};
        }
      }
    }

    ${(_a = style == null ? void 0 : style.card) == null ? void 0 : _a.root}
  `;
}
const Root$s = styled__default.default(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle), Card = react.forwardRef(function(props, ref) {
  const {
    __unstable_checkered: checkered = !1,
    __unstable_focusRing: focusRing = !1,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props, as = ReactIs.isValidElementType(asProp) ? asProp : "div", rootTheme = useRootTheme(), tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return /* @__PURE__ */ jsxRuntime.jsx(ThemeColorProvider, { scheme, tone, children: /* @__PURE__ */ jsxRuntime.jsx(
    Root$s,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border2),
      $borderTop: useArrayProp(borderTop2),
      $borderRight: useArrayProp(borderRight2),
      $borderBottom: useArrayProp(borderBottom2),
      $borderLeft: useArrayProp(borderLeft2),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    }
  ) });
});
function checkboxBaseStyles() {
  return styled.css`
    position: relative;
    display: inline-block;
  `;
}
function inputElementStyles(props) {
  const { color, input, radius } = theme.getTheme_v2(props.theme), { focusRing } = input.checkbox;
  return styled.css`
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    opacity: 0;
    z-index: 1;
    padding: 0;
    margin: 0;

    & + span {
      position: relative;
      display: block;
      height: ${rem(input.checkbox.size)};
      width: ${rem(input.checkbox.size)};
      box-sizing: border-box;
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
      border-radius: ${rem(radius[2])};
      line-height: 1;
      background-color: ${color.input.default.enabled.bg};

      & > svg {
        display: block;
        position: absolute;
        opacity: 0;
        height: 100%;
        width: 100%;

        & > path {
          vector-effect: non-scaling-stroke;
          stroke-width: 1.5px !important;
        }
      }
    }

    &:checked + span {
      background: ${color.input.default.enabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.fg,
    width: input.border.width
  })};
      color: ${color.input.default.enabled.bg};
    }

    /* focus */
    &:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({ focusRing })};
    }

    /* focus when checked - uses a different offset */
    &:not(:disabled):focus:focus-visible&:checked + span {
      box-shadow: ${focusRingStyle({ focusRing: { width: 1, offset: 1 } })};
    }

    &[data-error] + span {
      background-color: ${color.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  })};
      color: ${color.input.default.disabled.fg};
    }
    &[data-error]&:checked + span {
      background-color: ${color.input.invalid.enabled.muted.bg};
      color: ${color.input.default.enabled.bg};
    }
    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color.input.invalid.readOnly.muted.bg },
    focusRing: { width: 1, offset: 1 }
  })};
    }

    &:disabled + span {
      background-color: ${color.input.default.disabled.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.disabled.border
  })};
      color: ${color.input.default.disabled.fg};
    }
    &:disabled&:checked + span {
      background-color: ${color.input.default.disabled.muted.bg};
    }

    &[data-read-only] + span {
      background-color: ${color.input.default.readOnly.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.readOnly.border
  })};
      color: ${color.input.default.readOnly.fg};
    }

    &[data-read-only]&:checked + span {
      background-color: ${color.input.default.readOnly.muted.bg};
    }

    &:checked + span > svg:first-child {
      opacity: 1;
    }
    &:indeterminate + span > svg:last-child {
      opacity: 1;
    }
  `;
}
const Root$r = styled__default.default.div(checkboxBaseStyles), Input$5 = styled__default.default.input(inputElementStyles), Checkbox = react.forwardRef(function(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props, ref = useForwardedRef(forwardedRef);
  return useCustomValidity(ref, customValidity), react.useEffect(() => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, [indeterminate, ref]), /* @__PURE__ */ jsxRuntime.jsxs(Root$r, { className, "data-ui": "Checkbox", style, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Input$5,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-error": customValidity ? "" : void 0,
        ...restProps,
        checked,
        disabled: disabled || readOnly,
        type: "checkbox",
        readOnly,
        ref
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}),
      /* @__PURE__ */ jsxRuntime.jsx(icons.RemoveIcon, {})
    ] })
  ] });
});
function codeSyntaxHighlightingStyle({ theme: theme$1 }) {
  const {
    color: { syntax: color }
  } = theme.getTheme_v2(theme$1);
  return {
    "&.atrule": { color: color.atrule },
    "&.attr-name": { color: color.attrName },
    "&.attr-value": { color: color.attrValue },
    "&.attribute": { color: color.attribute },
    "&.boolean": { color: color.boolean },
    "&.builtin": { color: color.builtin },
    "&.cdata": { color: color.cdata },
    "&.char": { color: color.char },
    "&.class": { color: color.class },
    "&.class-name": { color: color.className },
    "&.comment": { color: color.comment },
    "&.constant": { color: color.constant },
    "&.deleted": { color: color.deleted },
    "&.doctype": { color: color.doctype },
    "&.entity": { color: color.entity },
    "&.function": { color: color.function },
    "&.hexcode": { color: color.hexcode },
    "&.id": { color: color.id },
    "&.important": { color: color.important },
    "&.inserted": { color: color.inserted },
    "&.keyword": { color: color.keyword },
    "&.number": { color: color.number },
    "&.operator": { color: color.operator },
    "&.prolog": { color: color.prolog },
    "&.property": { color: color.property },
    "&.pseudo-class": { color: color.pseudoClass },
    "&.pseudo-element": { color: color.pseudoElement },
    "&.punctuation": { color: color.punctuation },
    "&.regex": { color: color.regex },
    "&.selector": { color: color.selector },
    "&.string": { color: color.string },
    "&.symbol": { color: color.symbol },
    "&.tag": { color: color.tag },
    "&.unit": { color: color.unit },
    "&.url": { color: color.url },
    "&.variable": { color: color.variable }
  };
}
function codeBaseStyle() {
  return styled.css`
    color: var(--card-code-fg-color);

    & code {
      font-family: inherit;

      &.refractor .token {
        ${codeSyntaxHighlightingStyle}
      }
    }

    & a {
      color: inherit;
      text-decoration: underline;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$q = styled__default.default.pre(codeBaseStyle, responsiveCodeFontStyle), Code = react.forwardRef(function(props, ref) {
  const { children, language: languageProp, size: size2 = 2, weight, ...restProps } = props, language = typeof languageProp == "string" ? languageProp : void 0, registered = language ? Refractor__default.default.hasLanguage(language) : !1;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$q, { "data-ui": "Code", ...restProps, $size: useArrayProp(size2), $weight: weight, ref, children: [
    !(language && registered) && /* @__PURE__ */ jsxRuntime.jsx("code", { children }),
    language && registered && /* @__PURE__ */ jsxRuntime.jsx(Refractor__default.default, { inline: !0, language, value: String(children) })
  ] });
}), BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const { container, media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$p = styled__default.default(Box)(
  containerBaseStyle,
  responsiveContainerWidthStyle
), Container = react.forwardRef(function(props, ref) {
  const { as, width = 2, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$p,
    {
      "data-ui": "Container",
      ...restProps,
      $width: useArrayProp(width),
      forwardedAs: as,
      ref
    }
  );
}), Root$o = styled__default.default(Box)(responsiveGridStyle), Grid = react.forwardRef(function(props, ref) {
  const { as, autoRows, autoCols, autoFlow, columns, gap, gapX, gapY, rows, children, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$o,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Grid",
      ...restProps,
      $autoRows: useArrayProp(autoRows),
      $autoCols: useArrayProp(autoCols),
      $autoFlow: useArrayProp(autoFlow),
      $columns: useArrayProp(columns),
      $gap: useArrayProp(gap),
      $gapX: useArrayProp(gapX),
      $gapY: useArrayProp(gapY),
      $rows: useArrayProp(rows),
      forwardedAs: as,
      ref,
      children
    }
  );
});
function headingBaseStyle(props) {
  const { $accent, $muted } = props, { font } = theme.getTheme_v2(props.theme);
  return styled.css`
    ${$accent && styled.css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && styled.css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.heading.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$n = styled__default.default.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont), SpanWithTextOverflow = styled__default.default.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Heading = react.forwardRef(function(props, ref) {
  const {
    accent = !1,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" && (children = /* @__PURE__ */ jsxRuntime.jsx(SpanWithTextOverflow, { children })), /* @__PURE__ */ jsxRuntime.jsx(
    Root$n,
    {
      "data-ui": "Heading",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      $size: useArrayProp(size2),
      $weight: weight,
      ref,
      children: /* @__PURE__ */ jsxRuntime.jsx("span", { children })
    }
  );
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => {
    const _space = rem(spaceIndex === 0.5 ? space[1] / 2 : space[spaceIndex]);
    return {
      margin: `-${_space} 0 0 -${_space}`,
      "& > div": { padding: `${_space} 0 0 ${_space}` }
    };
  });
}
const Root$m = styled__default.default(Box)(inlineBaseStyle, inlineSpaceStyle), Inline = react.forwardRef(function(props, ref) {
  const { as, children: childrenProp, space, ...restProps } = props, children = react.useMemo(
    () => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => /* @__PURE__ */ jsxRuntime.jsx("div", { children: child }, idx)),
    [childrenProp]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$m,
    {
      "data-ui": "Inline",
      ...restProps,
      $space: useArrayProp(space),
      forwardedAs: as,
      ref,
      children
    }
  );
});
function kbdStyle() {
  return styled.css`
    --card-bg-color: var(--card-kbd-bg-color);
    --card-border-color: var(--card-kbd-border-color);
    --card-fg-color: var(--card-kbd-fg-color);

    box-shadow: inset 0 0 0 1px var(--card-border-color);
    background: var(--card-bg-color);
    font: inherit;

    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
const Root$l = styled__default.default.kbd(responsiveRadiusStyle, kbdStyle), KBD = react.forwardRef(function(props, ref) {
  const { children, fontSize: fontSize2 = 0, padding = 1, radius = 2, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$l, { "data-ui": "KBD", ...restProps, $radius: useArrayProp(radius), ref, children: /* @__PURE__ */ jsxRuntime.jsx(Box, { as: "span", padding, children: /* @__PURE__ */ jsxRuntime.jsx(Text, { as: "span", size: fontSize2, weight: "semibold", children }) }) });
}), origin = {
  name: "@sanity/ui/origin",
  fn({ middlewareData, placement, rects }) {
    var _a, _b;
    const [side] = placement.split("-"), floatingWidth = rects.floating.width, floatingHeight = rects.floating.height, shiftX = ((_a = middlewareData.shift) == null ? void 0 : _a.x) || 0, shiftY = ((_b = middlewareData.shift) == null ? void 0 : _b.y) || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0)
      return {};
    const isVerticalPlacement = ["bottom", "top"].includes(side), { originX, originY } = isVerticalPlacement ? {
      originX: clamp(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: { originX, originY }
    };
  }
};
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x, height = targetPoint.y - movingPoint.y, distance = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length, cmds = [];
  for (let i = 0; i < len; i += 1) {
    const point = points[i], prevPoint = points[i - 1], nextPoint = points[i + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius), curveEnd = moveTowardsLength(point, nextPoint, point.radius), startControl = moveTowardsFractional(curveStart, point, 0.5), endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      }), cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else
      cmds.push({
        type: "point",
        ...point
      });
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n, idx) => n.type === "point" ? `${idx === 0 ? "M" : "L"} ${n.x} ${n.y}` : n.type === "curve" ? `C ${n.startControl.x} ${n.startControl.y} ${n.endControl.x} ${n.endControl.y} ${n.curveEnd.x} ${n.curveEnd.y}` : "").join(" ");
}
const Root$k = styled__default.default.div(
  ({ $w: w }) => styled.css`
    position: absolute;
    width: ${w}px;
    height: ${w}px;

    :empty + & {
      display: none;
    }

    & > svg {
      display: block;
      line-height: 0;
      transform-origin: ${w / 2}px ${w / 2}px;
    }

    [data-placement^='top'] > & {
      bottom: -${w}px;

      & > svg {
        transform: rotate(0);
      }
    }

    [data-placement^='right'] > & {
      left: -${w}px;

      & > svg {
        transform: rotate(90deg);
      }
    }

    [data-placement^='left'] > & {
      right: -${w}px;

      & > svg {
        transform: rotate(-90deg);
      }
    }

    [data-placement^='bottom'] > & {
      top: -${w}px;

      & > svg {
        transform: rotate(180deg);
      }
    }
  `
), StrokePath = styled__default.default.path`
  stroke: var(--card-shadow-outline-color);
`, ShapePath = styled__default.default.path`
  fill: var(--card-bg-color);
`, Arrow = react.forwardRef(function(props, ref) {
  const { width: w, height: h, radius = 0, ...restProps } = props, { card } = useTheme_v2(), strokeWidth = card.shadow.outline, center = w / 2, points = [
    {
      x: 0,
      y: 0
    },
    {
      x: radius,
      y: 0,
      radius
    },
    {
      x: center,
      y: h - 1,
      radius
    },
    {
      x: w - radius,
      y: 0,
      radius
    },
    {
      x: w,
      y: 0
    }
  ], cmds = getRoundedCommands(points), path = compileCommands(cmds), strokePath = `${path}`, fillPath = `${path} M ${w} -1 M 0 -1 Z`;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$k, { ...restProps, $w: w, ref, children: /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: w, height: w, viewBox: `0 0 ${w} ${w}`, children: [
    /* @__PURE__ */ jsxRuntime.jsx("mask", { id: "stroke-mask", children: /* @__PURE__ */ jsxRuntime.jsx("rect", { x: 0, y: strokeWidth, width: w, height: w, fill: "white" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(StrokePath, { d: strokePath, mask: "url(#stroke-mask)", strokeWidth: strokeWidth * 2 }),
    /* @__PURE__ */ jsxRuntime.jsx(ShapePath, { d: fillPath })
  ] }) });
}), key$7 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$7] = globalScope[key$7] || react.createContext(null);
const BoundaryElementContext = globalScope[key$7];
function BoundaryElementProvider(props) {
  const { children, element } = props, value = react.useMemo(() => ({ version: 0, element }), [element]);
  return /* @__PURE__ */ jsxRuntime.jsx(BoundaryElementContext.Provider, { value, children });
}
function isRecord(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = react.useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0))
    throw new Error("useBoundaryElement(): the context value is not compatible");
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper({
  children,
  condition,
  wrapper
}) {
  return condition ? wrapper(children) : children;
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] > width && ret.push(i);
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] <= width && ret.push(i);
  return ret;
}
const ElementQuery = react.forwardRef(function(props, ref) {
  const theme2 = useTheme_v2(), { children, media = theme2.media, ...restProps } = props, forwardedRef = useForwardedRef(ref), [element, setElement] = react.useState(null), elementSize = useElementSize(element), width = react.useMemo(() => {
    var _a;
    return (_a = elementSize == null ? void 0 : elementSize.border.width) != null ? _a : window.innerWidth;
  }, [elementSize]), max = react.useMemo(() => findMaxBreakpoints(media, width), [media, width]), min = react.useMemo(() => findMinBreakpoints(media, width), [media, width]), setRef = react.useCallback(
    (el) => {
      forwardedRef.current = el, setElement(el);
    },
    [forwardedRef]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    "div",
    {
      "data-ui": "ElementQuery",
      ...restProps,
      "data-eq-max": max.length ? max.join(" ") : void 0,
      "data-eq-min": min.length ? min.join(" ") : void 0,
      ref: setRef,
      children
    }
  );
});
var __defProp = Object.defineProperty, __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key2] = value, __publicField = (obj, key2, value) => (__defNormalProp(obj, typeof key2 != "symbol" ? key2 + "" : key2, value), value);
class ErrorBoundary extends react.Component {
  constructor() {
    super(...arguments), __publicField(this, "state", { error: null });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({ error, info });
  }
  render() {
    const { error } = this.state;
    if (error) {
      const message = typeof (error == null ? void 0 : error.message) == "string" ? error.message : "Error";
      return /* @__PURE__ */ jsxRuntime.jsx(Code, { children: message });
    }
    return this.props.children;
  }
}
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0)
    throw new Error("the context value is not compatible");
  if (!contextValue)
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  if (contextValue.version === 0)
    return contextValue;
  throw new Error("could not get layer context");
}
const key$6 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$6] = globalScope[key$6] || react.createContext(null);
const LayerContext = globalScope[key$6];
function useLayer() {
  const value = react.useContext(LayerContext);
  if (!value)
    throw new Error("useLayer(): missing context value");
  try {
    return getLayerContext(value);
  } catch (err) {
    throw err instanceof Error ? new Error(`useLayer(): ${err.message}`) : new Error(`useLayer(): ${err}`);
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    innerDispose && innerDispose(), outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? !0 : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : !1;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return !1;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return !0;
  }
  return !1;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return !0;
  }
  return !1;
}
function _isScrollable(el) {
  if (!(el instanceof Element))
    return !1;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props) {
  var _a;
  const { children, zOffset: zOffsetProp = 0 } = props, parentContextValue = react.useContext(LayerContext), parent = parentContextValue && getLayerContext(parentContextValue), parentRegisterChild = parent == null ? void 0 : parent.registerChild, level = ((_a = parent == null ? void 0 : parent.level) != null ? _a : 0) + 1, zOffset = useArrayProp(zOffsetProp), maxMediaIndex = zOffset.length - 1, mediaIndex = Math.min(useMediaIndex(), maxMediaIndex), zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex], [, setChildLayers] = react.useState({}), [size2, setSize] = react.useState(0), isTopLayer = size2 === 0, registerChild = react.useCallback(
    (childLevel) => {
      const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
      return childLevel !== void 0 ? setChildLayers((state) => {
        var _a2;
        const prevLen = (_a2 = state[childLevel]) != null ? _a2 : 0, nextState = { ...state, [childLevel]: prevLen + 1 };
        return setSize(Object.keys(nextState).length), nextState;
      }) : setSize((v) => v + 1), () => {
        childLevel !== void 0 ? setChildLayers((state) => {
          const nextState = { ...state };
          return nextState[childLevel] === 1 ? (delete nextState[childLevel], setSize(Object.keys(nextState).length)) : nextState[childLevel] -= 1, nextState;
        }) : setSize((v) => v - 1), parentDispose == null || parentDispose();
      };
    },
    [parentRegisterChild]
  );
  react.useEffect(() => parentRegisterChild == null ? void 0 : parentRegisterChild(level), [level, parentRegisterChild]);
  const value = react.useMemo(
    () => ({
      version: 0,
      isTopLayer,
      level,
      registerChild,
      size: size2,
      zIndex
    }),
    [isTopLayer, level, registerChild, size2, zIndex]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(LayerContext.Provider, { value, children });
}
const Root$j = styled__default.default.div({ position: "relative" }), LayerChildren = react.forwardRef(function(props, ref) {
  const { children, onActivate, onFocus, style = EMPTY_RECORD, ...restProps } = props, { zIndex, isTopLayer } = useLayer(), lastFocusedRef = react.useRef(null), forwardedRef = useForwardedRef(ref), isTopLayerRef = react.useRef(isTopLayer);
  react.useEffect(() => {
    isTopLayerRef.current !== isTopLayer && isTopLayer && (onActivate == null || onActivate({ activeElement: lastFocusedRef.current })), isTopLayerRef.current = isTopLayer;
  }, [isTopLayer, onActivate]);
  const handleFocus = react.useCallback(
    (event) => {
      onFocus == null || onFocus(event);
      const rootElement = forwardedRef.current, target = document.activeElement;
      !isTopLayer || !rootElement || !target || isHTMLElement(target) && containsOrEqualsElement(rootElement, target) && (lastFocusedRef.current = target);
    },
    [forwardedRef, isTopLayer, onFocus]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$j,
    {
      ...restProps,
      "data-ui": "Layer",
      onFocus: handleFocus,
      ref: forwardedRef,
      style: { ...style, zIndex },
      children
    }
  );
}), Layer = react.forwardRef(function(props, ref) {
  const { children, zOffset = 1, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsxRuntime.jsx(LayerChildren, { ...restProps, ref, children }) });
}), key$5 = Symbol.for("@sanity/ui/context/portal"), elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    return typeof document > "u" ? null : (globalScope[elementKey] || (globalScope[elementKey] = document.createElement("div"), globalScope[elementKey].setAttribute("data-portal", ""), document.body.appendChild(globalScope[elementKey])), globalScope[elementKey]);
  }
};
globalScope[key$5] = globalScope[key$5] || react.createContext(defaultContextValue);
const PortalContext = globalScope[key$5];
function usePortal() {
  const value = react.useContext(PortalContext);
  if (!value)
    throw new Error("usePortal(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("usePortal(): the context value is not compatible");
  return value;
}
function Portal(props) {
  var _a;
  const { children, __unstable_name: name } = props, portal = usePortal(), portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  return portalElement ? reactDom.createPortal(children, portalElement) : null;
}
function useUnique(value) {
  const valueRef = react.useRef(value);
  return _isEqual(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB)
    return objA === objB;
  const keysA = Object.keys(objA), keysB = Object.keys(objB);
  return keysA.length !== keysB.length ? !1 : keysA.every((key2) => objA[key2] === objB[key2]);
}
const __BROWSER__ = typeof document < "u";
function PortalProvider(props) {
  const { boundaryElement, children, element, __unstable_elements: elementsProp } = props, elements = useUnique(elementsProp), value = react.useMemo(() => ({
    version: 0,
    boundaryElement: boundaryElement || null,
    element: element || __BROWSER__ && document.body || null,
    elements
  }), [boundaryElement, element, elements]);
  return /* @__PURE__ */ jsxRuntime.jsx(PortalContext.Provider, { value, children });
}
const Root$i = styled__default.default.div`
  display: block;
  width: 0;
  height: 0;
  position: absolute;
  overflow: hidden;
  overflow: clip;
`, SrOnly = react.forwardRef(function(props, ref) {
  const { as, children } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$i, { "aria-hidden": !0, as, "data-ui": "SrOnly", ref, children });
}), Root$h = styled__default.default.div`
  position: relative;
`, ItemWrapper = styled__default.default.div`
  position: absolute;
  left: 0;
  right: 0;
`, VirtualList = react.forwardRef(function(props, ref) {
  const { as = "div", gap = 0, getItemKey, items = [], onChange, renderItem, ...restProps } = props, { space } = useTheme_v2(), forwardedRef = useForwardedRef(ref), wrapperRef = react.useRef(null), [scrollTop, setScrollTop] = react.useState(0), [scrollHeight, setScrollHeight] = react.useState(0), [itemHeight, setItemHeight] = react.useState(-1);
  react.useEffect(() => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    firstElement instanceof HTMLElement && setItemHeight(firstElement.offsetHeight);
  }, [renderItem]), react.useEffect(() => {
    if (!forwardedRef.current)
      return;
    let _scrollEl = forwardedRef.current.parentNode;
    for (; _scrollEl && !_isScrollable(_scrollEl); )
      _scrollEl = _scrollEl.parentNode;
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, { passive: !0 });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      return ro.observe(scrollEl), handleScroll2(), () => {
        scrollEl.removeEventListener("scroll", handleScroll2), ro.unobserve(scrollEl), ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    }, handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    return window.addEventListener("scroll", handleScroll, { passive: !0 }), window.addEventListener("resize", handleResize), setScrollHeight(window.innerHeight), handleScroll(), () => {
      window.removeEventListener("scroll", handleScroll), window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length, height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0, fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0, toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  react.useEffect(() => {
    onChange && onChange({ fromIndex, gap: space[gap], itemHeight, scrollHeight, scrollTop, toIndex });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = react.useMemo(() => !renderItem || items.length === 0 ? null : itemHeight === -1 ? [/* @__PURE__ */ jsxRuntime.jsx(ItemWrapper, { children: renderItem(items[0]) }, 0)] : items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
    const itemIndex = fromIndex + _itemIndex, node = renderItem(item), key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
    return /* @__PURE__ */ jsxRuntime.jsx(ItemWrapper, { style: { top: itemIndex * (itemHeight + space[gap]) }, children: node }, key2);
  }), [fromIndex, gap, getItemKey, itemHeight, items, renderItem, space, toIndex]), wrapperStyle = react.useMemo(() => ({ height }), [height]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$h, { as, "data-ui": "VirtualList", ...restProps, ref: forwardedRef, children: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: wrapperRef, style: wrapperStyle, children }) });
}), DEFAULT_POPOVER_DISTANCE = 4, DEFAULT_POPOVER_PADDING = 4, DEFAULT_POPOVER_ARROW_WIDTH = 19, DEFAULT_POPOVER_ARROW_HEIGHT = 8, DEFAULT_POPOVER_ARROW_RADIUS = 2, DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0], DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const { apply, margins, padding = 0 } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const { elements, placement, platform, rects } = args, { floating, reference } = rects, overflow = await reactDom$1.detectOverflow(args, {
        altBoundary: !0,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = 1 / 0, maxHeight = 1 / 0;
      const floatingW = floating.width, floatingH = floating.height;
      placement.includes("top") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.top), placement.includes("right") && (maxWidth = floatingW - overflow.right, maxHeight = floatingH - (overflow.top + overflow.bottom)), placement.includes("bottom") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.bottom), placement.includes("left") && (maxWidth = floatingW - overflow.left, maxHeight = floatingH - (overflow.top + overflow.bottom)), apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating), targetH = nextDimensions.height, targetW = nextDimensions.width;
      return floatingW !== targetW || floatingH !== targetH ? { reset: { rects: !0 } } : {};
    }
  };
}
function calcCurrentWidth(params) {
  const { container, mediaIndex, width } = params, w = width[mediaIndex], currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth == "number" ? container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const { boundaryWidth, currentWidth } = params;
  if (!(currentWidth === void 0 && boundaryWidth === void 0))
    return Math.min(
      currentWidth != null ? currentWidth : 1 / 0,
      (boundaryWidth || 1 / 0) - DEFAULT_POPOVER_PADDING * 2
    );
}
const MotionCard$1 = styled__default.default(framerMotion.motion(Card))`
  &:not([hidden]) {
    display: flex;
  }
  flex-direction: column;
  width: max-content;
  min-width: min-content;
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, PopoverCard = react.memo(
  react.forwardRef(function(props, ref) {
    const {
      __unstable_margins: marginsProp,
      animate,
      arrow,
      arrowRef,
      arrowX,
      arrowY,
      children,
      padding,
      placement,
      originX,
      originY,
      overflow,
      radius,
      scheme,
      shadow,
      strategy,
      style,
      tone,
      width,
      x: xProp,
      y: yProp,
      ...restProps
    } = props, { zIndex } = useLayer(), margins = react.useMemo(
      () => marginsProp || DEFAULT_POPOVER_MARGINS,
      [marginsProp]
    ), x = (xProp != null ? xProp : 0) + margins[3], y = (yProp != null ? yProp : 0) + margins[0], rootStyle2 = react.useMemo(
      () => ({
        left: x,
        originX,
        originY,
        position: strategy,
        top: y,
        width,
        zIndex,
        willChange: animate ? "transform" : void 0,
        ...style
      }),
      [animate, originX, originY, strategy, style, width, x, y, zIndex]
    ), arrowStyle = react.useMemo(
      () => ({
        left: arrowX !== null ? arrowX : void 0,
        top: arrowY !== null ? arrowY : void 0,
        right: void 0,
        bottom: void 0
      }),
      [arrowX, arrowY]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs(
      MotionCard$1,
      {
        "data-ui": "Popover",
        ...restProps,
        "data-placement": placement,
        radius,
        ref,
        scheme,
        shadow,
        sizing: "border",
        style: rootStyle2,
        tone,
        ...animate ? POPOVER_MOTION_PROPS : {},
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(Flex, { "data-ui": "Popover__wrapper", direction: "column", flex: 1, overflow, children: /* @__PURE__ */ jsxRuntime.jsx(Flex, { direction: "column", flex: 1, padding, children }) }),
          arrow && /* @__PURE__ */ jsxRuntime.jsx(
            Arrow,
            {
              ref: arrowRef,
              style: arrowStyle,
              width: DEFAULT_POPOVER_ARROW_WIDTH,
              height: DEFAULT_POPOVER_ARROW_HEIGHT,
              radius: DEFAULT_POPOVER_ARROW_RADIUS
            }
          )
        ]
      }
    );
  })
);
PopoverCard.displayName = "PopoverCard";
const Popover = react.memo(
  react.forwardRef(function(props, ref) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { container, layer } = useTheme_v2(), boundaryElementContext = useBoundaryElement(), {
      __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
      animate: _animate = !1,
      arrow: arrowProp = !1,
      boundaryElement = boundaryElementContext.element,
      children: childProp,
      constrainSize = !1,
      content,
      disabled,
      fallbackPlacements = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS$1[(_a = props.placement) != null ? _a : "bottom"],
      matchReferenceWidth,
      floatingBoundary = (_c = props.boundaryElement) != null ? _c : boundaryElementContext.element,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onActivate,
      open,
      overflow = "hidden",
      padding: paddingProp,
      placement: placementProp = "bottom",
      portal,
      preventOverflow = !0,
      radius: radiusProp = 3,
      referenceBoundary = (_d = props.boundaryElement) != null ? _d : boundaryElementContext.element,
      referenceElement,
      scheme,
      shadow: shadowProp = 3,
      tone = "inherit",
      width: widthProp = "auto",
      zOffset: zOffsetProp = layer.popover.zOffset,
      updateRef,
      ...restProps
    } = props, animate = usePrefersReducedMotion() ? !1 : _animate, boundarySize = (_e = useElementSize(boundaryElement)) == null ? void 0 : _e.border, padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), widthArrayProp = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), forwardedRef = useForwardedRef(ref), arrowRef = react.useRef(null), rootBoundary = "viewport", mediaIndex = useMediaIndex(), boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0, width = calcCurrentWidth({
      container,
      mediaIndex,
      width: widthArrayProp
    }), widthRef = react.useRef(width);
    react.useEffect(() => {
      widthRef.current = width;
    }, [width]);
    const maxWidth = calcMaxWidth({ boundaryWidth, currentWidth: width }), maxWidthRef = react.useRef(maxWidth);
    react.useEffect(() => {
      maxWidthRef.current = maxWidth;
    }, [maxWidth]);
    const referenceWidthRef = react.useRef();
    react.useEffect(() => {
      const floatingElement = forwardedRef.current;
      if (!open || !floatingElement)
        return;
      const referenceWidth = referenceWidthRef.current;
      matchReferenceWidth ? referenceWidth !== void 0 && (floatingElement.style.width = `${referenceWidth}px`) : width !== void 0 && (floatingElement.style.width = `${width}px`), typeof maxWidth == "number" && (floatingElement.style.maxWidth = `${maxWidth}px`);
    }, [width, forwardedRef, matchReferenceWidth, maxWidth, open]);
    const middleware = react.useMemo(() => {
      const ret = [];
      return (constrainSize || preventOverflow) && ret.push(
        reactDom$1.flip({
          boundary: floatingBoundary || void 0,
          fallbackPlacements,
          padding: DEFAULT_POPOVER_PADDING,
          rootBoundary
        })
      ), ret.push(reactDom$1.offset({ mainAxis: DEFAULT_POPOVER_DISTANCE })), (constrainSize || matchReferenceWidth) && ret.push(
        size({
          apply({ availableWidth, availableHeight, elements, referenceWidth }) {
            referenceWidthRef.current = referenceWidth;
            const _currentWidth = widthRef.current, _maxWidth = maxWidthRef.current;
            matchReferenceWidth ? elements.floating.style.width = `${referenceWidth}px` : _currentWidth !== void 0 && (elements.floating.style.width = `${_currentWidth}px`), constrainSize && (elements.floating.style.maxWidth = `${Math.min(
              availableWidth,
              _maxWidth != null ? _maxWidth : 1 / 0
            )}px`, elements.floating.style.maxHeight = `${availableHeight}px`);
          },
          boundaryElement: floatingBoundary || void 0,
          constrainSize,
          margins,
          matchReferenceWidth,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), preventOverflow && ret.push(
        reactDom$1.shift({
          boundary: floatingBoundary || void 0,
          rootBoundary,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), arrowProp && ret.push(
        reactDom$1.arrow({
          element: arrowRef,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), animate && ret.push(origin), ret.push(
        reactDom$1.hide({
          boundary: referenceBoundary || void 0,
          padding: DEFAULT_POPOVER_PADDING,
          strategy: "referenceHidden"
        })
      ), ret;
    }, [
      animate,
      arrowProp,
      constrainSize,
      fallbackPlacements,
      floatingBoundary,
      margins,
      matchReferenceWidth,
      preventOverflow,
      referenceBoundary
    ]), { x, y, middlewareData, placement, refs, strategy, update } = reactDom$1.useFloating({
      middleware,
      placement: placementProp,
      whileElementsMounted: reactDom$1.autoUpdate
    }), referenceHidden = (_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden, arrowX = (_g = middlewareData.arrow) == null ? void 0 : _g.x, arrowY = (_h = middlewareData.arrow) == null ? void 0 : _h.y, originX = (_i = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _i.originX, originY = (_j = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _j.originY, setArrow = react.useCallback((arrowEl) => {
      arrowRef.current = arrowEl;
    }, []), setFloating = react.useCallback(
      (node) => {
        forwardedRef.current = node, refs.setFloating(node);
      },
      [forwardedRef, refs]
    ), setReference = react.useCallback(
      (node) => {
        refs.setReference(node);
        const childRef = childProp == null ? void 0 : childProp.ref;
        typeof childRef == "function" ? childRef(node) : childRef && (childRef.current = node);
      },
      [childProp, refs]
    ), child = react.useMemo(() => !childProp || referenceElement ? null : react.cloneElement(childProp, { ref: setReference }), [childProp, referenceElement, setReference]);
    if (react.useEffect(() => {
      updateRef && (typeof updateRef == "function" ? updateRef(update) : updateRef && (updateRef.current = update));
    }, [update, updateRef]), react.useEffect(() => {
      child || refs.setReference(referenceElement || null);
    }, [referenceElement, refs, child]), disabled)
      return childProp || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {});
    const popover = /* @__PURE__ */ jsxRuntime.jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsxRuntime.jsx(
      PopoverCard,
      {
        ...restProps,
        __unstable_margins: margins,
        animate,
        arrow: arrowProp,
        arrowRef: setArrow,
        arrowX,
        arrowY,
        hidden: referenceHidden,
        overflow,
        padding,
        placement,
        radius,
        ref: setFloating,
        scheme,
        shadow,
        originX,
        originY,
        strategy,
        tone,
        width: matchReferenceWidth ? referenceWidthRef.current : width,
        x,
        y,
        children: content
      }
    ) });
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ConditionalWrapper,
        {
          condition: animate,
          wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children }),
          children: open && /* @__PURE__ */ jsxRuntime.jsx(
            ConditionalWrapper,
            {
              condition: !!portal,
              wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(Portal, { __unstable_name: typeof portal == "string" ? portal : void 0, children }),
              children: popover
            }
          )
        }
      ),
      child
    ] });
  })
);
Popover.displayName = "Popover";
function radioBaseStyle() {
  return styled.css`
    position: relative;

    &:not([hidden]) {
      display: inline-block;
    }

    &[data-read-only] {
      outline: 1px solid red;
    }
  `;
}
function inputElementStyle(props) {
  const { color, input } = theme.getTheme_v2(props.theme), dist = (input.radio.size - input.radio.markSize) / 2;
  return styled.css`
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    z-index: 1;
    padding: 0;
    margin: 0;
    border-radius: ${rem(input.radio.size / 2)};
    border: none;

    /* enabled */
    & + span {
      display: block;
      position: relative;
      height: ${rem(input.radio.size)};
      width: ${rem(input.radio.size)};
      border-radius: ${rem(input.radio.size / 2)};
      background: ${color.input.default.enabled.bg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

      &::after {
        content: '';
        position: absolute;
        top: ${rem(dist)};
        left: ${rem(dist)};
        height: ${rem(input.radio.markSize)};
        width: ${rem(input.radio.markSize)};
        border-radius: ${rem(input.radio.markSize / 2)};
        background: ${color.input.default.enabled.fg};
        opacity: 0;
      }
    }

    /* focused */
    &:not(:disabled):focus + span {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color.input.default.enabled.border },
    focusRing: input.radio.focusRing
  })};
    }

    &:not(:disabled):focus:not(:focus-visible) + span {
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
    }

    &:checked + span::after {
      opacity: 1;
    }

    /* customValidity */
    &[data-error] + span {
      background-color: ${color.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  })};
      &::after {
        background: ${color.input.invalid.enabled.muted.bg};
      }
    }

    /* read only */
    &[data-read-only] + span {
      box-shadow: 0 0 0 1px ${color.input.default.readOnly.border};
      background: ${color.input.default.readOnly.bg};

      &::after {
        background: ${color.input.default.readOnly.border};
      }
    }

    /* disabled */
    &:not([data-read-only]):disabled + span {
      box-shadow: 0 0 0 1px ${color.input.default.disabled.border};
      background: ${color.input.default.disabled.bg};

      &::after {
        background: ${color.input.default.disabled.border};
      }
    }
  `;
}
const Root$g = styled__default.default.div(radioBaseStyle), Input$4 = styled__default.default.input(inputElementStyle), Radio = react.forwardRef(function(props, forwardedRef) {
  const { className, disabled, style, customValidity, readOnly, ...restProps } = props, ref = useForwardedRef(forwardedRef);
  return useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxRuntime.jsxs(Root$g, { className, "data-ui": "Radio", style, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Input$4,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-error": customValidity ? "" : void 0,
        ...restProps,
        disabled: disabled || readOnly,
        readOnly,
        ref,
        type: "radio"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx("span", {})
  ] });
});
function rootStyle() {
  return styled.css`
    position: relative;
    width: -moz-available;
    width: -webkit-fill-available;
    width: stretch;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function inputBaseStyle(props) {
  const { font } = theme.getTheme_v2(props.theme);
  return styled.css`
    -webkit-font-smoothing: antialiased;
    appearance: none;
    border: 0;
    font-family: ${font.text.family};
    color: inherit;
    width: 100%;
    outline: none;
    margin: 0;

    &:disabled {
      opacity: 1;
    }
  `;
}
function inputColorStyle(props) {
  const { color, input } = theme.getTheme_v2(props.theme);
  return styled.css`
    /* enabled */
    background-color: ${color.input.default.enabled.bg};
    color: ${color.input.default.enabled.fg};
    box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

    /* hovered */
    @media (hover: hover) {
      &:not(:disabled):hover {
        background-color: ${color.input.default.hovered.bg};
        color: ${color.input.default.hovered.fg};
        box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
      }
    }

    /* focused */
    &:not(:disabled):focus {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color.input.default.enabled.border },
    focusRing: input.select.focusRing
  })};
    }

    /* read-only */
    &[data-read-only] {
      background-color: ${color.input.default.readOnly.bg};
      color: ${color.input.default.readOnly.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.readOnly.border,
    width: input.border.width
  })};
    }

    /* disabled */
    &:not([data-read-only]):disabled {
      background-color: ${color.input.default.disabled.bg};
      color: ${color.input.default.disabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  })};
    }
  `;
}
function textSize(size2) {
  return { fontSize: rem(size2.fontSize), lineHeight: rem(size2.lineHeight) };
}
function inputTextSizeStyle(props) {
  const { $fontSize } = props, { font, media } = theme.getTheme_v2(props.theme);
  return _responsive(
    media,
    $fontSize,
    (sizeIndex) => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2])
  );
}
function inputStyle() {
  return [
    responsiveRadiusStyle,
    inputBaseStyle,
    inputColorStyle,
    inputTextSizeStyle,
    responsiveInputPaddingIconRightStyle
  ];
}
function iconBoxStyle(props) {
  const { color } = theme.getTheme_v2(props.theme);
  return styled.css`
    pointer-events: none;
    position: absolute;
    top: 0;
    right: 0;

    /* enabled */
    --card-fg-color: ${color.input.default.enabled.fg};

    /* hover */
    @media (hover: hover) {
      select:not(disabled):not(:read-only):hover + && {
        --card-fg-color: ${color.input.default.hovered.fg};
      }
    }

    /* disabled */
    select:disabled + && {
      --card-fg-color: ${color.input.default.disabled.fg};
    }

    /* read-only */
    select[data-read-only] + && {
      --card-fg-color: ${color.input.default.readOnly.fg};
    }
  `;
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
}, Root$f = styled__default.default.div(selectStyle.root), Input$3 = styled__default.default.select(selectStyle.input), IconBox = styled__default.default(Box)(selectStyle.iconBox), Select = react.forwardRef(function(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 2,
    readOnly,
    space = 3,
    ...restProps
  } = props, ref = useForwardedRef(forwardedRef);
  return useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxRuntime.jsxs(Root$f, { "data-ui": "Select", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Input$3,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-ui": "Select",
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $radius: useArrayProp(radius),
        $space: useArrayProp(space),
        disabled: disabled || readOnly,
        ref,
        children
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(IconBox, { padding, children: /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
  ] });
}), BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const { media, space } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
const Root$e = styled__default.default(Box)(stackBaseStyle, responsiveStackSpaceStyle), Stack = react.forwardRef(function(props, ref) {
  const { as, space, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$e,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Stack",
      ...restProps,
      $space: useArrayProp(space),
      forwardedAs: as,
      ref
    }
  );
});
function switchBaseStyles() {
  return styled.css`
    position: relative;
    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function switchInputStyles() {
  return styled.css`
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
    margin: 0;

    /* Place the input element above the representation element */
    z-index: 1;
  `;
}
function switchRepresentationStyles(props) {
  const { color, input } = theme.getTheme_v2(props.theme);
  return styled.css`
    --switch-bg-color: ${color.input.default.enabled.border};
    --switch-fg-color: ${color.input.default.enabled.bg};
    --switch-box-shadow: none;

    &:not([hidden]) {
      display: block;
    }
    position: relative;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};

    /* Make sure itâ€™s not possible to interact with the wrapper element */
    pointer-events: none;

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      box-shadow: var(--switch-box-shadow);
      border-radius: inherit;
    }

    /* Focus styles */
    input:focus + && {
      --switch-box-shadow: ${focusRingStyle({ focusRing: input.switch.focusRing })};
    }

    input:focus:not(:focus-visible) + && {
      --switch-box-shadow: none;
    }

    input:checked + && {
      --switch-bg-color: ${color.input.default.enabled.fg};
      --switch-fg-color: ${color.input.default.enabled.bg};
    }

    @media (hover: hover) {
      input:not(:disabled):hover + && {
        --switch-bg-color: ${color.input.default.hovered.border};
        --switch-fg-color: ${color.input.default.hovered.bg};
      }

      input:not(:disabled):checked:hover + && {
        --switch-bg-color: ${color.input.default.enabled.fg};
        --switch-fg-color: ${color.input.default.enabled.bg};
      }
    }

    input:not([data-read-only]):disabled + && {
      --switch-bg-color: ${color.input.default.disabled.border};
      --switch-fg-color: ${color.input.default.disabled.bg};
    }

    input[data-read-only]:disabled + && {
      --switch-bg-color: ${color.input.default.readOnly.border};
      --switch-fg-color: ${color.input.default.readOnly.bg};
    }

    input:checked[data-read-only]:disabled + && {
      --switch-bg-color: ${color.input.default.readOnly.fg};
      --switch-fg-color: ${color.input.default.readOnly.bg};
    }
  `;
}
function switchTrackStyles(props) {
  const { input } = theme.getTheme_v2(props.theme);
  return styled.css`
    &:not([hidden]) {
      display: block;
    }
    background-color: var(--switch-bg-color);
    position: absolute;
    left: 0;
    top: 0;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};
  `;
}
function switchThumbStyles(props) {
  const { $indeterminate } = props, { input } = theme.getTheme_v2(props.theme), trackWidth = input.switch.width, trackHeight = input.switch.height, trackPadding = input.switch.padding, size2 = trackHeight - input.switch.padding * 2, checkedOffset = trackWidth - trackPadding * 2 - size2, indeterminateOffset = trackWidth / 2 - size2 / 2 - trackPadding, checked = $indeterminate !== !0 && props.$checked === !0;
  return styled.css`
    &:not([hidden]) {
      display: block;
    }
    position: absolute;
    left: ${rem(trackPadding)};
    top: ${rem(trackPadding)};
    height: ${rem(size2)};
    width: ${rem(size2)};
    border-radius: ${rem(size2 / 2)};
    transition-property: transform;
    transition-duration: ${input.switch.transitionDurationMs}ms;
    transition-timing-function: ${input.switch.transitionTimingFunction};
    background: var(--switch-fg-color);
    transform: translate3d(0, 0, 0);
    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);

    ${checked && styled.css`
      transform: translate3d(${checkedOffset}px, 0, 0);
    `}

    ${$indeterminate && styled.css`
      transform: translate3d(${indeterminateOffset}px, 0, 0);
    `}
  `;
}
const Root$d = styled__default.default.span(switchBaseStyles), Input$2 = styled__default.default.input(switchInputStyles), Representation = styled__default.default.span(switchRepresentationStyles), Track = styled__default.default.span(switchTrackStyles), Thumb = styled__default.default.span(switchThumbStyles), Switch = react.forwardRef(function(props, forwardedRef) {
  const { checked, className, disabled, indeterminate, readOnly, style, ...restProps } = props, ref = useForwardedRef(forwardedRef);
  return react.useEffect(() => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, [indeterminate, ref]), /* @__PURE__ */ jsxRuntime.jsxs(Root$d, { className, "data-ui": "Switch", style, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Input$2,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        ...restProps,
        checked: indeterminate !== !0 && checked,
        disabled: disabled || readOnly,
        type: "checkbox",
        ref
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(Representation, { "aria-hidden": !0, "data-name": "representation", children: [
      /* @__PURE__ */ jsxRuntime.jsx(Track, {}),
      /* @__PURE__ */ jsxRuntime.jsx(Thumb, { $checked: checked, $indeterminate: indeterminate })
    ] })
  ] });
}), Root$c = styled__default.default.span(textInputRootStyle), InputRoot$1 = styled__default.default.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Input$1 = styled__default.default.textarea(
  responsiveInputPaddingStyle,
  textInputBaseStyle,
  textInputFontSizeStyle
), Presentation$1 = styled__default.default.div(
  responsiveRadiusStyle,
  textInputRepresentationStyle
), TextArea = react.forwardRef(function(props, forwardedRef) {
  const {
    border: border2 = !0,
    customValidity,
    disabled = !1,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 2,
    weight,
    ...restProps
  } = props, ref = useForwardedRef(forwardedRef), rootTheme = useRootTheme();
  return useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxRuntime.jsx(Root$c, { "data-ui": "TextArea", children: /* @__PURE__ */ jsxRuntime.jsxs(InputRoot$1, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Input$1,
      {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      Presentation$1,
      {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      }
    )
  ] }) });
}), CLEAR_BUTTON_BOX_STYLE = { zIndex: 2 }, Root$b = styled__default.default(Card).attrs({ forwardedAs: "span" })(textInputRootStyle), InputRoot = styled__default.default.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Prefix = styled__default.default(Card).attrs({ forwardedAs: "span" })`
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Suffix = styled__default.default(Card).attrs({ forwardedAs: "span" })`
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Input = styled__default.default.input(
  responsiveInputPaddingStyle,
  textInputBaseStyle,
  textInputFontSizeStyle
), Presentation = styled__default.default.span(
  responsiveRadiusStyle,
  textInputRepresentationStyle
), LeftBox = styled__default.default(Box)`
  position: absolute;
  top: 0;
  left: 0;
`, RightBox = styled__default.default(Box)`
  position: absolute;
  top: 0;
  right: 0;
`, RightCard = styled__default.default(Card)`
  background-color: transparent;
  position: absolute;
  top: 0;
  right: 0;
`, TextInputClearButton = styled__default.default(Button)({
  "&:not([hidden])": {
    display: "block"
  }
}), TextInput = react.forwardRef(function(props, forwardedRef) {
  const {
    __unstable_disableFocusRing,
    border: border2 = !0,
    clearButton,
    disabled = !1,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 2,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props, ref = useForwardedRef(forwardedRef), rootTheme = useRootTheme(), fontSize2 = useArrayProp(fontSizeProp), padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp), $hasClearButton = !!clearButton, $hasIcon = !!icon, $hasIconRight = !!iconRight, $hasSuffix = !!suffix, $hasPrefix = !!prefix;
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = react.useCallback((event) => {
    event.preventDefault(), event.stopPropagation();
  }, []), handleClearClick = react.useCallback(
    (event) => {
      var _a;
      event.preventDefault(), event.stopPropagation(), onClear && onClear(), (_a = ref.current) == null || _a.focus();
    },
    [onClear, ref]
  ), prefixNode = react.useMemo(
    () => prefix && /* @__PURE__ */ jsxRuntime.jsx(Prefix, { borderTop: !0, borderLeft: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: prefix }) }),
    [prefix, radius]
  ), presentationNode = react.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsxs(
      Presentation,
      {
        $hasPrefix,
        $unstableDisableFocusRing: __unstable_disableFocusRing,
        $hasSuffix,
        $radius: radius,
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        children: [
          icon && /* @__PURE__ */ jsxRuntime.jsx(LeftBox, { padding, children: /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(icon) && icon,
            ReactIs.isValidElementType(icon) && react.createElement(icon)
          ] }) }),
          !$hasClearButton && iconRight && /* @__PURE__ */ jsxRuntime.jsx(RightBox, { padding, children: /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(iconRight) && iconRight,
            ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)
          ] }) })
        ]
      }
    ),
    [
      __unstable_disableFocusRing,
      border2,
      fontSize2,
      icon,
      iconRight,
      padding,
      radius,
      rootTheme,
      $hasClearButton,
      $hasPrefix,
      $hasSuffix
    ]
  ), clearButtonBoxPadding = react.useMemo(
    () => padding.map((v) => v === 0 ? 0 : v === 1 || v === 2 ? 1 : v - 2),
    [padding]
  ), clearButtonPadding = react.useMemo(
    () => padding.map((v) => v === 0 || v === 1 ? 0 : v === 2 ? 1 : v - 1),
    [padding]
  ), clearButtonProps = react.useMemo(
    () => typeof clearButton == "object" ? clearButton : EMPTY_RECORD,
    [clearButton]
  ), clearButtonNode = react.useMemo(
    () => !disabled && !readOnly && clearButton && /* @__PURE__ */ jsxRuntime.jsx(
      RightCard,
      {
        forwardedAs: "span",
        padding: clearButtonBoxPadding,
        style: CLEAR_BUTTON_BOX_STYLE,
        tone: customValidity ? "critical" : "inherit",
        children: /* @__PURE__ */ jsxRuntime.jsx(
          TextInputClearButton,
          {
            "aria-label": "Clear",
            "data-qa": "clear-button",
            fontSize: fontSize2,
            icon: icons.CloseIcon,
            mode: "bleed",
            padding: clearButtonPadding,
            radius,
            ...clearButtonProps,
            onClick: handleClearClick,
            onMouseDown: handleClearMouseDown
          }
        )
      }
    ),
    [
      clearButton,
      clearButtonBoxPadding,
      clearButtonPadding,
      clearButtonProps,
      customValidity,
      disabled,
      fontSize2,
      handleClearClick,
      handleClearMouseDown,
      radius,
      readOnly
    ]
  ), suffixNode = react.useMemo(
    () => suffix && /* @__PURE__ */ jsxRuntime.jsx(Suffix, { borderTop: !0, borderRight: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: suffix }) }),
    [radius, suffix]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$b, { "data-ui": "TextInput", tone: rootTheme.tone, children: [
    prefixNode,
    /* @__PURE__ */ jsxRuntime.jsxs(InputRoot, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        Input,
        {
          "data-as": "input",
          "data-scheme": rootTheme.scheme,
          "data-tone": rootTheme.tone,
          ...restProps,
          $fontSize: fontSize2,
          $iconLeft: $hasIcon,
          $iconRight: $hasIconRight || $hasClearButton,
          $padding: padding,
          $scheme: rootTheme.scheme,
          $space: space,
          $tone: rootTheme.tone,
          $weight: weight,
          disabled,
          readOnly,
          ref,
          type
        }
      ),
      presentationNode,
      clearButtonNode
    ] }),
    suffixNode
  ] });
});
function useDelayedState(initialState) {
  const [state, setState] = react.useState(initialState), delayedAction = react.useRef(), onStateChange = react.useCallback((nextState, delay) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current && (clearTimeout(delayedAction.current), delayedAction.current = void 0), !delay)
      return action();
    delayedAction.current = setTimeout(action, delay);
  }, []);
  return [state, onStateChange];
}
const DEFAULT_TOOLTIP_ARROW_WIDTH = 15, DEFAULT_TOOLTIP_ARROW_HEIGHT = 6, DEFAULT_TOOLTIP_ARROW_RADIUS = 2, DEFAULT_TOOLTIP_DISTANCE = 4, DEFAULT_TOOLTIP_PADDING = 4, DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
}, MotionCard = styled__default.default(framerMotion.motion(Card))`
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, TooltipCard = react.memo(
  react.forwardRef(function(props, ref) {
    const {
      animate,
      arrow,
      arrowRef,
      arrowX,
      arrowY,
      children,
      originX,
      originY,
      padding,
      placement,
      radius,
      scheme,
      shadow,
      style,
      ...restProps
    } = props, rootStyle2 = react.useMemo(
      () => ({
        originX,
        originY,
        willChange: animate ? "transform" : void 0,
        ...style
      }),
      [animate, originX, originY, style]
    ), arrowStyle = react.useMemo(
      () => ({
        left: arrowX !== null ? arrowX : void 0,
        top: arrowY !== null ? arrowY : void 0,
        right: void 0,
        bottom: void 0
      }),
      [arrowX, arrowY]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs(
      MotionCard,
      {
        "data-ui": "Tooltip__card",
        ...restProps,
        "data-placement": placement,
        padding,
        radius,
        ref,
        scheme,
        shadow,
        style: rootStyle2,
        ...animate ? POPOVER_MOTION_PROPS : {},
        children: [
          children,
          arrow && /* @__PURE__ */ jsxRuntime.jsx(
            Arrow,
            {
              ref: arrowRef,
              style: arrowStyle,
              width: DEFAULT_TOOLTIP_ARROW_WIDTH,
              height: DEFAULT_TOOLTIP_ARROW_HEIGHT,
              radius: DEFAULT_TOOLTIP_ARROW_RADIUS
            }
          )
        ]
      }
    );
  })
);
TooltipCard.displayName = "TooltipCard";
const key$4 = Symbol.for("@sanity/ui/context/tooltipDelayGroup");
globalScope[key$4] = globalScope[key$4] || react.createContext(null);
const TooltipDelayGroupContext = globalScope[key$4];
function useTooltipDelayGroup() {
  return react.useContext(TooltipDelayGroupContext);
}
function TooltipDelayGroupProvider(props) {
  const { children, delay } = props, [isGroupActive, setIsGroupActive] = useDelayedState(!1), [openTooltipId, setOpenTooltipId] = useDelayedState(null), openDelay = typeof delay == "number" ? delay : (delay == null ? void 0 : delay.open) || 0, closeDelay = typeof delay == "number" ? delay : (delay == null ? void 0 : delay.close) || 0, value = react.useMemo(
    () => ({
      isGroupActive,
      setIsGroupActive,
      openTooltipId,
      setOpenTooltipId,
      // When the group is active, we want the next tooltip to open immediately.
      openDelay: isGroupActive ? 1 : openDelay,
      closeDelay
    }),
    [closeDelay, isGroupActive, openDelay, openTooltipId, setIsGroupActive, setOpenTooltipId]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupContext.Provider, { value, children });
}
const Root$a = styled__default.default(Layer)`
  pointer-events: none;
  max-width: ${({ $maxWidth }) => $maxWidth}px;
`, Tooltip = react.forwardRef(function(props, ref) {
  var _a, _b, _c, _d, _e, _f, _g;
  const boundaryElementContext = useBoundaryElement(), { layer } = useTheme_v2(), {
    animate: _animate = !1,
    arrow: arrowProp = !1,
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS[(_a = props.placement) != null ? _a : "bottom"],
    padding = 2,
    placement: placementProp = "bottom",
    portal: portalProp,
    radius = 2,
    scheme,
    shadow = 2,
    zOffset = layer.tooltip.zOffset,
    delay,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, fallbackPlacements = useArrayProp(fallbackPlacementsProp), forwardedRef = useForwardedRef(ref), [referenceElement, setReferenceElement] = react.useState(null), arrowRef = react.useRef(null), rootBoundary = "viewport", portal = usePortal(), portalElement = typeof portalProp == "string" ? ((_c = portal.elements) == null ? void 0 : _c[portalProp]) || null : portal.element, tooltipWidth = react.useMemo(() => {
    const availableWidths = [
      ...boundaryElement ? [boundaryElement.offsetWidth] : [],
      (portalElement == null ? void 0 : portalElement.offsetWidth) || document.body.offsetWidth
    ];
    return Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2;
  }, [boundaryElement, portalElement == null ? void 0 : portalElement.offsetWidth]), middleware = react.useMemo(() => {
    const ret = [];
    return ret.push(
      reactDom$1.flip({
        boundary: boundaryElement || void 0,
        fallbackPlacements,
        padding: DEFAULT_TOOLTIP_PADDING,
        rootBoundary
      })
    ), ret.push(reactDom$1.offset({ mainAxis: DEFAULT_TOOLTIP_DISTANCE })), ret.push(
      reactDom$1.shift({
        boundary: boundaryElement || void 0,
        rootBoundary,
        padding: DEFAULT_TOOLTIP_PADDING
      })
    ), arrowProp && ret.push(reactDom$1.arrow({ element: arrowRef, padding: DEFAULT_TOOLTIP_PADDING })), animate && ret.push(origin), ret;
  }, [animate, arrowProp, boundaryElement, fallbackPlacements]), { floatingStyles, placement, middlewareData, refs, update } = reactDom$1.useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: reactDom$1.autoUpdate
  }), arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x, arrowY = (_e = middlewareData.arrow) == null ? void 0 : _e.y, originX = (_f = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _f.originX, originY = (_g = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _g.originY, tooltipId = react.useId(), [isOpen, setIsOpen] = useDelayedState(!1), delayGroupContext = useTooltipDelayGroup(), showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId, isInsideGroup = delayGroupContext !== null, openDelayProp = typeof delay == "number" ? delay : (delay == null ? void 0 : delay.open) || 0, closeDelayProp = typeof delay == "number" ? delay : (delay == null ? void 0 : delay.close) || 0, openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp, closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp, handleIsOpenChange = react.useCallback(
    (open, immediate) => {
      if (isInsideGroup)
        if (open) {
          const groupedOpenDelay = immediate ? 0 : openDelay;
          delayGroupContext.setIsGroupActive(open, groupedOpenDelay), delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
        } else {
          const groupDeactivateDelay = closeDelay > 200 ? closeDelay : 200;
          delayGroupContext.setIsGroupActive(open, groupDeactivateDelay), delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
        }
      else
        setIsOpen(open, immediate ? 0 : open ? openDelay : closeDelay);
    },
    [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]
  ), handleBlur = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onBlur) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  ), handleClick = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1, !0), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onClick) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  ), handleContextMenu = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1, !0), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onContextMenu) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  ), handleFocus = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!0), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onFocus) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  ), handleMouseEnter = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!0), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onMouseEnter) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  ), handleMouseLeave = react.useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onMouseLeave) == null || _b2.call(_a2, e);
    },
    [childProp == null ? void 0 : childProp.props, handleIsOpenChange]
  );
  react.useEffect(() => {
    if (!showTooltip)
      return;
    function handleWindowMouseMove(event) {
      referenceElement && (referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target) || (handleIsOpenChange(!1), window.removeEventListener("mousemove", handleWindowMouseMove)));
    }
    return window.addEventListener("mousemove", handleWindowMouseMove), () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [showTooltip, referenceElement, handleIsOpenChange]), react.useEffect(() => {
    disabled && showTooltip && handleIsOpenChange(!1);
  }, [disabled, handleIsOpenChange, showTooltip]), react.useEffect(() => {
    !content && showTooltip && handleIsOpenChange(!1);
  }, [content, handleIsOpenChange, showTooltip]), react.useEffect(() => refs.setReference(referenceElement), [referenceElement, refs]), react.useEffect(() => {
    if (!showTooltip)
      return;
    function handleWindowKeyDown(event) {
      event.key === "Escape" && handleIsOpenChange(!1, !0);
    }
    return window.addEventListener("keydown", handleWindowKeyDown), () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]);
  const setArrow = react.useCallback(
    (arrowEl) => {
      arrowRef.current = arrowEl, update();
    },
    [update]
  ), setFloating = react.useCallback(
    (node) => {
      forwardedRef.current = node, refs.setFloating(node);
    },
    [forwardedRef, refs]
  ), childRef = childProp == null ? void 0 : childProp.ref, setReference = react.useCallback(
    (node) => {
      typeof childRef == "function" ? childRef(node) : childRef && (childRef.current = node), setReferenceElement(node);
    },
    [childRef]
  ), child = react.useMemo(() => childProp ? react.cloneElement(childProp, {
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onContextMenu: handleContextMenu,
    ref: setReference
  }) : null, [
    childProp,
    handleBlur,
    handleClick,
    handleContextMenu,
    handleFocus,
    handleMouseEnter,
    handleMouseLeave,
    setReference
  ]);
  if (!child)
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {});
  if (disabled)
    return child;
  const tooltip = /* @__PURE__ */ jsxRuntime.jsx(
    Root$a,
    {
      "data-ui": "Tooltip",
      ...restProps,
      ref: setFloating,
      style: floatingStyles,
      zOffset,
      $maxWidth: tooltipWidth,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipCard,
        {
          ...restProps,
          animate,
          arrow: arrowProp,
          arrowRef: setArrow,
          arrowX,
          arrowY,
          originX,
          originY,
          padding,
          placement,
          radius,
          ref: setFloating,
          scheme,
          shadow,
          children: content
        }
      )
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ConditionalWrapper,
      {
        condition: animate,
        wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children }),
        children: showTooltip && /* @__PURE__ */ jsxRuntime.jsx(
          ConditionalWrapper,
          {
            condition: !!portalProp,
            wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(Portal, { __unstable_name: typeof portalProp == "string" ? portalProp : void 0, children }),
            children: tooltip
          }
        )
      }
    ),
    child
  ] });
}), Root$9 = styled__default.default.div`
  line-height: 0;
`, ListBox = styled__default.default(Box)`
  & > ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
`, rotate = styled.keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled__default.default(icons.SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function AutocompleteOption(props) {
  const { children, id, onSelect, selected, value } = props, handleClick = react.useCallback(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]), handleKeyDown = react.useCallback(
    (event) => {
      event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
    },
    [handleClick]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    "li",
    {
      "aria-selected": selected,
      "data-ui": "AutocompleteOption",
      id,
      role: "option",
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      children
    }
  );
}
function autocompleteReducer(state, msg2) {
  return msg2.type === "input/change" ? { ...state, activeValue: null, focused: !0, query: msg2.query } : msg2.type === "input/focus" ? { ...state, focused: !0 } : msg2.type === "root/blur" ? { ...state, focused: !1, query: null } : msg2.type === "root/clear" ? { ...state, activeValue: null, query: null, value: null } : msg2.type === "root/escape" ? { ...state, focused: !1, query: null } : msg2.type === "root/open" ? { ...state, query: state.query || msg2.query } : msg2.type === "root/setActiveValue" ? { ...state, activeValue: msg2.value, listFocused: msg2.listFocused || state.listFocused } : msg2.type === "root/setListFocused" ? { ...state, listFocused: msg2.listFocused } : msg2.type === "value/change" ? { ...state, activeValue: msg2.value, query: null, value: msg2.value } : state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
], AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start", AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"], DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value, DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1, InnerAutocomplete = react.forwardRef(function(props, ref) {
  const {
    border: border2 = !0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props, [state, dispatch] = react.useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: !1,
    listFocused: !1,
    query: null,
    value: valueProp || null
  }), { activeValue, focused, listFocused, query, value } = state, defaultRenderOption = react.useCallback(
    ({ value: value2 }) => /* @__PURE__ */ jsxRuntime.jsx(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, textOverflow: "ellipsis", children: value2 }) }),
    [fontSize2, paddingProp]
  ), renderOption = typeof renderOptionProp == "function" ? renderOptionProp : defaultRenderOption, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = react.useRef(null), resultsPopoverElementRef = react.useRef(null), inputElementRef = react.useRef(null), listBoxElementRef = react.useRef(null), listFocusedRef = react.useRef(!1), valueRef = react.useRef(value), valuePropRef = react.useRef(valueProp), popoverMouseWithinRef = react.useRef(!1), forwardedRef = useForwardedRef(ref), listBoxId = `${id}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = useArrayProp(paddingProp), currentOption = react.useMemo(
    () => value !== null ? options.find((o) => o.value === value) : void 0,
    [options, value]
  ), filteredOptions = react.useMemo(
    () => options.filter((option) => query ? filterOption(query, option) : !0),
    [filterOption, options, query]
  ), filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null, handleRootBlur = react.useCallback(
    (event) => {
      setTimeout(() => {
        if (popoverMouseWithinRef.current)
          return;
        const elements = (relatedElements || []).concat(
          rootElementRef.current ? [rootElementRef.current] : [],
          resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []
        );
        let focusInside = !1;
        if (document.activeElement) {
          for (const e of elements)
            if (e === document.activeElement || e.contains(document.activeElement)) {
              focusInside = !0;
              break;
            }
        }
        focusInside === !1 && (dispatch({ type: "root/blur" }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
      }, 0);
    },
    [onBlur, onQueryChange, relatedElements]
  ), handleRootFocus = react.useCallback((event) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event.target instanceof HTMLElement ? event.target : null, listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || !1;
    listFocused2 !== listFocusedRef.current && (listFocusedRef.current = listFocused2, dispatch({ type: "root/setListFocused", listFocused: listFocused2 }));
  }, []), handleOptionSelect = react.useCallback(
    (v) => {
      var _a;
      dispatch({ type: "value/change", value: v }), popoverMouseWithinRef.current = !1, onSelect && onSelect(v), valueRef.current = v, onChange && onChange(v), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
    },
    [onChange, onSelect, onQueryChange]
  ), handleRootKeyDown = react.useCallback(
    (event) => {
      var _a, _b;
      if (event.key === "ArrowDown") {
        if (event.preventDefault(), !filteredOptionsLen)
          return;
        const activeOption = filteredOptions.find((o) => o.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
        nextActiveOption && dispatch({ type: "root/setActiveValue", value: nextActiveOption.value, listFocused: !0 });
        return;
      }
      if (event.key === "ArrowUp") {
        if (event.preventDefault(), !filteredOptionsLen)
          return;
        const activeOption = filteredOptions.find((o) => o.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
        nextActiveOption && dispatch({ type: "root/setActiveValue", value: nextActiveOption.value, listFocused: !0 });
        return;
      }
      if (event.key === "Escape") {
        dispatch({ type: "root/escape" }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
        return;
      }
      const target = event.target, listEl = listBoxElementRef.current;
      if ((listEl === target || listEl != null && listEl.contains(target)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
        (_b = inputElementRef.current) == null || _b.focus();
        return;
      }
    },
    [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]
  ), handleInputChange = react.useCallback(
    (event) => {
      const nextQuery = event.currentTarget.value;
      dispatch({ type: "input/change", query: nextQuery }), onQueryChange && onQueryChange(nextQuery);
    },
    [onQueryChange]
  ), handleInputFocus = react.useCallback(
    (event) => {
      focused || (dispatch({ type: "input/focus" }), onFocus && onFocus(event));
    },
    [focused, onFocus]
  ), handlePopoverMouseEnter = react.useCallback(() => {
    popoverMouseWithinRef.current = !0;
  }, []), handlePopoverMouseLeave = react.useCallback(() => {
    popoverMouseWithinRef.current = !1;
  }, []), handleClearButtonClick = react.useCallback(() => {
    var _a;
    dispatch({ type: "root/clear" }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
  }, [onChange, onQueryChange]), handleClearButtonFocus = react.useCallback(() => {
    dispatch({ type: "input/focus" });
  }, []);
  react.useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({ type: "value/change", value: valueProp }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({ type: "value/change", value: valueProp || null }));
  }, [valueProp]), react.useEffect(() => {
    !focused && valueRef.current && dispatch({ type: "root/setActiveValue", value: valueRef.current });
  }, [focused]), react.useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement)
      return;
    const activeOption = filteredOptions.find((o) => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption), activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = react.useCallback(
    (el) => {
      inputElementRef.current = el, forwardedRef.current = el;
    },
    [forwardedRef]
  ), clearButton = react.useMemo(() => {
    if (!loading && !disabled && value)
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
  }, [disabled, handleClearButtonFocus, loading, value]), openButtonBoxPadding = react.useMemo(
    () => padding.map((v) => v === 0 ? 0 : v === 1 || v === 2 ? 1 : v - 2),
    [padding]
  ), openButtonPadding = react.useMemo(() => padding.map((v) => Math.max(v - 1, 0)), [padding]), openButtonProps = react.useMemo(
    () => typeof openButton == "object" ? openButton : EMPTY_RECORD,
    [openButton]
  ), handleOpenClick = react.useCallback(
    (event) => {
      dispatch({
        type: "root/open",
        query: value ? renderValue(value, currentOption) : ""
      }), openButtonProps.onClick && openButtonProps.onClick(event), _raf(() => {
        var _a;
        return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      });
    },
    [currentOption, openButtonProps, renderValue, value]
  ), openButtonNode = react.useMemo(
    () => !disabled && !readOnly && openButton ? /* @__PURE__ */ jsxRuntime.jsx(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: /* @__PURE__ */ jsxRuntime.jsx(
      Button,
      {
        "aria-label": "Open",
        disabled: expanded,
        fontSize: fontSize2,
        icon: icons.ChevronDownIcon,
        mode: "bleed",
        padding: openButtonPadding,
        ...openButtonProps,
        onClick: handleOpenClick
      }
    ) }) : void 0,
    [
      disabled,
      expanded,
      fontSize2,
      handleOpenClick,
      openButton,
      openButtonBoxPadding,
      openButtonPadding,
      openButtonProps,
      readOnly
    ]
  ), inputValue = react.useMemo(() => query === null ? value !== null ? renderValue(value, currentOption) : "" : query, [currentOption, query, renderValue, value]), input = /* @__PURE__ */ jsxRuntime.jsx(
    TextInput,
    {
      ...restProps,
      "aria-activedescendant": activeItemId,
      "aria-autocomplete": "list",
      "aria-expanded": expanded,
      "aria-owns": listBoxId,
      autoCapitalize: "off",
      autoComplete: "off",
      autoCorrect: "off",
      border: border2,
      clearButton,
      customValidity,
      disabled,
      fontSize: fontSize2,
      icon,
      iconRight: loading && AnimatedSpinnerIcon,
      id,
      inputMode: "search",
      onChange: handleInputChange,
      onClear: handleClearButtonClick,
      onFocus: handleInputFocus,
      padding,
      prefix,
      radius,
      readOnly,
      ref: setRef,
      role: "combobox",
      spellCheck: !1,
      suffix: suffix || openButtonNode,
      value: inputValue
    }
  ), handleListBoxKeyDown = react.useCallback(
    (event) => {
      var _a;
      event.key === "Tab" && listFocused && ((_a = inputElementRef.current) == null || _a.focus());
    },
    [listFocused]
  ), content = react.useMemo(() => filteredOptions.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
    ListBox,
    {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        Stack,
        {
          as: "ul",
          "aria-multiselectable": !1,
          "data-ui": "AutoComplete__resultsList",
          id: listBoxId,
          ref: listBoxElementRef,
          role: "listbox",
          space: 1,
          children: filteredOptions.map((option) => {
            const active = activeValue !== null ? option.value === activeValue : currentOption === option;
            return /* @__PURE__ */ jsxRuntime.jsx(
              AutocompleteOption,
              {
                id: `${id}-option-${option.value}`,
                onSelect: handleOptionSelect,
                selected: active,
                value: option.value,
                children: react.cloneElement(renderOption(option), {
                  disabled: loading,
                  selected: active,
                  tabIndex: listFocused && active ? 0 : -1
                })
              },
              option.value
            );
          })
        }
      )
    }
  ), [
    activeValue,
    currentOption,
    filteredOptions,
    handleOptionSelect,
    handleListBoxKeyDown,
    id,
    listBox,
    listBoxId,
    listFocused,
    loading,
    renderOption
  ]), results = react.useMemo(() => renderPopover ? renderPopover(
    {
      content,
      hidden: !expanded,
      inputElement: inputElementRef.current,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave
    },
    resultsPopoverElementRef
  ) : filteredOptionsLen === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
    Popover,
    {
      arrow: !1,
      constrainSize: !0,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: !0,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: !0,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    }
  ), [
    content,
    expanded,
    filteredOptionsLen,
    handlePopoverMouseEnter,
    handlePopoverMouseLeave,
    popover,
    radius,
    renderPopover
  ]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$9,
    {
      "data-ui": "Autocomplete",
      onBlur: handleRootBlur,
      onFocus: handleRootFocus,
      onKeyDown: handleRootKeyDown,
      ref: rootElementRef,
      children: [
        input,
        results
      ]
    }
  );
}), Autocomplete = InnerAutocomplete, Root$8 = styled__default.default.ol`
  margin: 0;
  padding: 0;
  display: flex;
  list-style: none;
  align-items: center;
  white-space: nowrap;
  line-height: 0;
`, ExpandButton = styled__default.default(Button)`
  appearance: none;
  margin: -4px;
`, Breadcrumbs = react.forwardRef(function(props, ref) {
  const { children, maxLength, separator, space: spaceRaw = 2, ...restProps } = props, space = useArrayProp(spaceRaw), [open, setOpen] = react.useState(!1), [expandElement, setExpandElement] = react.useState(null), [popoverElement, setPopoverElement] = react.useState(null), collapse = react.useCallback(() => setOpen(!1), []), expand = react.useCallback(() => setOpen(!0), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = react.useMemo(
    () => react.Children.toArray(children).filter((child) => react.isValidElement(child)),
    [children]
  ), items = react.useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
      return [
        ...rawItems.slice(0, beforeLength - 1),
        /* @__PURE__ */ jsxRuntime.jsx(
          Popover,
          {
            constrainSize: !0,
            content: /* @__PURE__ */ jsxRuntime.jsx(Stack, { as: "ol", overflow: "auto", padding: space, space, children: rawItems.slice(beforeLength - 1, len - afterLength) }),
            open,
            placement: "top",
            portal: !0,
            ref: setPopoverElement,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ExpandButton,
              {
                fontSize: 1,
                mode: "bleed",
                onClick: open ? collapse : expand,
                padding: 1,
                ref: setExpandElement,
                selected: open,
                text: "\u2026"
              }
            )
          },
          "button"
        ),
        ...rawItems.slice(len - afterLength)
      ];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$8, { "data-ui": "Breadcrumbs", ...restProps, ref, children: items.map((item, itemIndex) => /* @__PURE__ */ jsxRuntime.jsxs(react.Fragment, { children: [
    itemIndex > 0 && /* @__PURE__ */ jsxRuntime.jsx(Box, { "aria-hidden": !0, as: "li", paddingX: space, children: separator || /* @__PURE__ */ jsxRuntime.jsx(Text, { muted: !0, children: "/" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(Box, { as: "li", children: item })
  ] }, itemIndex)) });
});
function dialogStyle({ theme: theme$1 }) {
  const { color } = theme.getTheme_v2(theme$1);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const { media } = theme.getTheme_v2(props.theme);
  return _responsive(media, props.$position, (position) => ({ "&&": { position } }));
}
function animationDialogStyle(props) {
  return props.$animate ? styled.css`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : styled.css``;
}
const key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || react.createContext({ version: 0 });
const DialogContext = globalScope[key$3];
function useDialog() {
  return react.useContext(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? !0 : containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
const Root$7 = styled__default.default(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle), DialogContainer = styled__default.default(Container)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  height: 100%;
  flex-direction: column;
  align-items: center;
  justify-content: center;
`, DialogCardRoot = styled__default.default(Card)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  min-height: 0;
  max-height: 100%;
  overflow: hidden;
  overflow: clip;
`, DialogLayout = styled__default.default(Flex)`
  flex: 1;
  min-height: 0;
  width: 100%;
`, DialogHeader = styled__default.default(Box)`
  position: relative;
  z-index: 2;
`, DialogContent = styled__default.default(Box)`
  position: relative;
  z-index: 1;
  overflow: auto;
  outline: none;
`, DialogFooter = styled__default.default(Box)`
  position: relative;
  z-index: 3;
`, DialogCard = react.forwardRef(function(props, ref) {
  var _a;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), width = useArrayProp(widthProp), forwardedRef = useForwardedRef(ref), [rootElement, setRootElement] = react.useState(null), localContentRef = react.useRef(null), layer = useLayer(), { isTopLayer } = layer, labelId = `${id}_label`, showCloseButton = !!onClose && hideCloseButton === !1, showHeader = !!header || showCloseButton;
  react.useEffect(() => {
    autoFocus && forwardedRef.current && focusFirstDescendant(forwardedRef.current);
  }, [autoFocus, forwardedRef]), useGlobalKeyDown(
    react.useCallback(
      (event) => {
        if (!isTopLayer || !onClose)
          return;
        const target = document.activeElement;
        target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
      },
      [boundaryElement, isTopLayer, onClose, portalElement]
    )
  ), useClickOutside(
    react.useCallback(
      (event) => {
        if (!isTopLayer || !onClickOutside)
          return;
        const target = event.target;
        target && !isTargetWithinScope(boundaryElement, portalElement, target) || onClickOutside();
      },
      [boundaryElement, isTopLayer, onClickOutside, portalElement]
    ),
    [rootElement]
  );
  const setRef = react.useCallback(
    (el) => {
      setRootElement(el), forwardedRef.current = el;
    },
    [forwardedRef]
  ), setContentRef = react.useCallback(
    (el) => {
      localContentRef.current = el, typeof contentRef == "function" ? contentRef(el) : contentRef && (contentRef.current = el);
    },
    [contentRef]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(DialogContainer, { "data-ui": "DialogCard", width, children: /* @__PURE__ */ jsxRuntime.jsx(DialogCardRoot, { radius, ref: setRef, scheme, shadow, children: /* @__PURE__ */ jsxRuntime.jsxs(DialogLayout, { direction: "column", children: [
    showHeader && /* @__PURE__ */ jsxRuntime.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntime.jsxs(Flex, { align: "center", padding: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(Box, { flex: 1, padding: 2, children: header && /* @__PURE__ */ jsxRuntime.jsx(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
      showCloseButton && /* @__PURE__ */ jsxRuntime.jsx(Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
        Button,
        {
          "aria-label": "Close dialog",
          disabled: !onClose,
          icon: icons.CloseIcon,
          mode: "bleed",
          onClick: onClose,
          padding: 2
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(DialogContent, { flex: 1, ref: setContentRef, tabIndex: -1, children }),
    footer && /* @__PURE__ */ jsxRuntime.jsx(DialogFooter, { children: footer })
  ] }) }) });
}), Dialog = react.forwardRef(function(props, ref) {
  var _a;
  const dialog = useDialog(), { layer } = useTheme_v2(), {
    __unstable_autoFocus: autoFocus = !0,
    __unstable_hideCloseButton: hideCloseButton = !1,
    cardRadius: cardRadiusProp = 4,
    cardShadow = 3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 3,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || layer.dialog.zOffset,
    animate: _animate = !1,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, cardRadius = useArrayProp(cardRadiusProp), padding = useArrayProp(paddingProp), position = useArrayProp(positionProp), width = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), preDivRef = react.useRef(null), postDivRef = react.useRef(null), cardRef = react.useRef(null), focusedElementRef = react.useRef(null), handleFocus = react.useCallback(
    (event) => {
      onFocus == null || onFocus(event);
      const target = event.target, cardElement = cardRef.current;
      if (cardElement && target === preDivRef.current) {
        focusLastDescendant(cardElement);
        return;
      }
      if (cardElement && target === postDivRef.current) {
        focusFirstDescendant(cardElement);
        return;
      }
      isHTMLElement(event.target) && (focusedElementRef.current = event.target);
    },
    [onFocus]
  ), labelId = `${id}_label`, rootClickTimeoutRef = react.useRef(), handleRootClick = react.useCallback(() => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target = focusedElementRef.current;
        if (!target || !document.body.contains(target)) {
          const cardElement = cardRef.current;
          cardElement && focusFirstDescendant(cardElement);
          return;
        }
        target.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return /* @__PURE__ */ jsxRuntime.jsx(Portal, { __unstable_name: portalProp, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Root$7,
    {
      ...restProps,
      $animate: animate,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": !0,
      "data-ui": "Dialog",
      id,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("div", { ref: preDivRef, tabIndex: 0 }),
        /* @__PURE__ */ jsxRuntime.jsx(
          DialogCard,
          {
            __unstable_autoFocus: autoFocus,
            __unstable_hideCloseButton: hideCloseButton,
            contentRef,
            footer,
            header,
            id,
            onClickOutside,
            onClose,
            portal: portalProp,
            radius: cardRadius,
            ref: cardRef,
            scheme,
            shadow: cardShadow,
            width,
            children
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("div", { ref: postDivRef, tabIndex: 0 })
      ]
    }
  ) });
});
function DialogProvider(props) {
  const { children, position, zOffset } = props, contextValue = react.useMemo(
    () => ({
      version: 0,
      position,
      zOffset
    }),
    [position, zOffset]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(DialogContext.Provider, { value: contextValue, children });
}
const Root$6 = styled__default.default.kbd`
  font: inherit;
  padding: 1px;

  &:not([hidden]) {
    display: block;
  }
`, Key = styled__default.default(KBD)`
  &:not([hidden]) {
    display: block;
  }
`, Hotkeys = react.forwardRef(function(props, ref) {
  const { fontSize: fontSize2, keys, padding, radius, space: spaceProp = 0.5, ...restProps } = props, space = useArrayProp(spaceProp);
  return !keys || keys.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {}) : /* @__PURE__ */ jsxRuntime.jsx(Root$6, { "data-ui": "Hotkeys", ...restProps, ref, children: /* @__PURE__ */ jsxRuntime.jsx(Inline, { as: "span", space, children: keys.map((key2, i) => /* @__PURE__ */ jsxRuntime.jsx(Key, { fontSize: fontSize2, padding, radius, children: key2 }, i)) }) });
}), key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || react.createContext(null);
const MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement)
      return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement)
    return;
  const map = /* @__PURE__ */ new WeakMap();
  for (const el of elements)
    map.set(el, _getDOMPath(rootElement, el));
  const _sort = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH, _b = map.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const { onKeyDown, originElement, shouldFocus } = props, elementsRef = react.useRef([]), [rootElement, setRootElement] = react.useState(null), [activeIndex, _setActiveIndex] = react.useState(-1), activeIndexRef = react.useRef(activeIndex), activeElement = elementsRef.current[activeIndex] || null, mounted = !!rootElement, setActiveIndex = react.useCallback((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex), activeIndexRef.current = nextActiveIndex;
  }, []), mount = react.useCallback(
    (element, selected) => {
      if (!element)
        return () => {
        };
      if (elementsRef.current.indexOf(element) === -1 && (elementsRef.current.push(element), _sortElements(rootElement, elementsRef.current)), selected) {
        const selectedIndex = elementsRef.current.indexOf(element);
        setActiveIndex(selectedIndex);
      }
      return () => {
        const idx = elementsRef.current.indexOf(element);
        idx > -1 && elementsRef.current.splice(idx, 1);
      };
    },
    [rootElement, setActiveIndex]
  ), handleKeyDown = react.useCallback(
    (event) => {
      if (event.key === "Tab") {
        originElement && originElement.focus();
        return;
      }
      if (event.key === "Home") {
        event.preventDefault(), event.stopPropagation();
        const el = _getFocusableElements(elementsRef.current)[0];
        if (!el)
          return;
        const currentIndex = elementsRef.current.indexOf(el);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "End") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), el = focusableElements[focusableElements.length - 1];
        if (!el)
          return;
        const currentIndex = elementsRef.current.indexOf(el);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), focusableLen = focusableElements.length;
        if (focusableLen === 0)
          return;
        const focusedElement = elementsRef.current[activeIndexRef.current];
        let focusedIndex = focusableElements.indexOf(focusedElement);
        focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
        const el = focusableElements[focusedIndex], currentIndex = elementsRef.current.indexOf(el);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "ArrowDown") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), focusableLen = focusableElements.length;
        if (focusableLen === 0)
          return;
        const focusedElement = elementsRef.current[activeIndexRef.current];
        let focusedIndex = focusableElements.indexOf(focusedElement);
        focusedIndex = (focusedIndex + 1) % focusableLen;
        const el = focusableElements[focusedIndex], currentIndex = elementsRef.current.indexOf(el);
        setActiveIndex(currentIndex);
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onKeyDown, originElement, setActiveIndex]
  ), handleItemMouseEnter = react.useCallback(
    (event) => {
      const element = event.currentTarget, currentIndex = elementsRef.current.indexOf(element);
      setActiveIndex(currentIndex);
    },
    [setActiveIndex]
  ), handleItemMouseLeave = react.useCallback(() => {
    setActiveIndex(-2), rootElement == null || rootElement.focus();
  }, [setActiveIndex, rootElement]);
  return react.useEffect(() => {
    if (!mounted)
      return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const el = _getFocusableElements(elementsRef.current)[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex), activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current), el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex), activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null || element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
const Root$5 = styled__default.default(Box)`
  outline: none;
  overflow: auto;
`, Menu = react.forwardRef(function(props, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props, forwardedRef = useForwardedRef(ref), { isTopLayer } = useLayer(), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({ onKeyDown, originElement, shouldFocus }), handleRefChange = react.useCallback(
    (el) => {
      setRootElement(el), forwardedRef.current = el;
    },
    [forwardedRef, setRootElement]
  );
  react.useEffect(() => {
    onItemSelect && onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]), useClickOutside(
    react.useCallback(
      (event) => isTopLayer && onClickOutside && onClickOutside(event),
      [isTopLayer, onClickOutside]
    ),
    [rootElement]
  ), useGlobalKeyDown(
    react.useCallback(
      (event) => {
        isTopLayer && event.key === "Escape" && (event.stopPropagation(), onEscape && onEscape());
      },
      [isTopLayer, onEscape]
    )
  ), react.useEffect(() => {
    if (!(!rootElement || !registerElement))
      return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = react.useMemo(
    () => ({
      version: 0,
      activeElement,
      activeIndex,
      mount,
      onClickOutside,
      onEscape,
      onItemClick,
      onItemMouseEnter: handleItemMouseEnter,
      onItemMouseLeave: handleItemMouseLeave,
      registerElement,
      // deprecated
      onMouseEnter: handleItemMouseEnter,
      onMouseLeave: handleItemMouseLeave
    }),
    [
      activeElement,
      activeIndex,
      mount,
      handleItemMouseEnter,
      handleItemMouseLeave,
      onClickOutside,
      onEscape,
      onItemClick,
      registerElement
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(MenuContext.Provider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(
    Root$5,
    {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsx(Stack, { space, children })
    }
  ) });
}), MenuButton = react.forwardRef(function(props, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = !1,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = !0,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, [open, setOpen] = react.useState(!1), [shouldFocus, setShouldFocus] = react.useState(null), [buttonElement, setButtonElement] = react.useState(null), [menuElements, setChildMenuElements] = react.useState([]), openRef = react.useRef(open);
  react.useEffect(() => {
    onOpen && open && !openRef.current && onOpen();
  }, [onOpen, open]), react.useEffect(() => {
    onClose && !open && openRef.current && onClose();
  }, [onClose, open]), react.useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = react.useCallback(() => {
    setOpen((v) => !v), setShouldFocus(null);
  }, []), handleMouseDown = react.useCallback(
    (event) => {
      open && event.preventDefault();
    },
    [open]
  ), handleButtonKeyDown = react.useCallback((event) => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault(), setOpen(!0), setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault(), setOpen(!0), setShouldFocus("last");
      return;
    }
  }, []), handleMenuClickOutside = react.useCallback(
    (event) => {
      const target = event.target;
      if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
        for (const el of menuElements)
          if (target === el || el.contains(target))
            return;
        setOpen(!1);
      }
    },
    [buttonElement, menuElements]
  ), handleMenuEscape = react.useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), handleBlur = react.useCallback(
    (event) => {
      const target = event.relatedTarget;
      if (target instanceof Node) {
        for (const el of menuElements)
          if (el === target || el.contains(target))
            return;
        setOpen(!1);
      }
    },
    [menuElements]
  ), handleItemClick = react.useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), registerElement = react.useCallback((el) => (setChildMenuElements((els) => els.concat([el])), () => {
    setChildMenuElements((els) => els.filter((_el) => _el !== el));
  }), []), menuProps = react.useMemo(
    () => ({
      "aria-labelledby": id,
      onBlurCapture: handleBlur,
      onClickOutside: handleMenuClickOutside,
      onEscape: handleMenuEscape,
      onItemClick: handleItemClick,
      originElement: buttonElement,
      registerElement,
      shouldFocus
    }),
    [
      buttonElement,
      handleMenuClickOutside,
      handleMenuEscape,
      handleItemClick,
      id,
      handleBlur,
      registerElement,
      shouldFocus
    ]
  ), menu = ReactIs.isElement(menuProp) ? react.cloneElement(menuProp, menuProps) : null, setButtonRef = react.useCallback(
    (el) => {
      typeof ref == "function" ? ref(el) : ref && (ref.current = el), setButtonElement(el);
    },
    [ref]
  ), button = react.useMemo(
    () => ReactIs.isElement(buttonProp) ? react.cloneElement(buttonProp, {
      "data-ui": "MenuButton",
      id,
      onClick: handleButtonClick,
      onKeyDown: handleButtonKeyDown,
      onMouseDown: handleMouseDown,
      "aria-haspopup": !0,
      "aria-expanded": open,
      ref: setButtonRef,
      selected: open
    }) : null,
    [buttonProp, handleButtonClick, handleButtonKeyDown, handleMouseDown, id, open, setButtonRef]
  ), popoverProps = react.useMemo(
    () => ({
      boundaryElement: deprecated_boundaryElement,
      overflow: "auto",
      placement: deprecated_placement,
      portal: deprecated_portal,
      preventOverflow: deprecated_preventOverflow,
      radius: deprecated_popoverRadius,
      scheme: deprecated_popoverScheme,
      ...popover || {}
    }),
    [
      deprecated_boundaryElement,
      deprecated_placement,
      deprecated_popoverRadius,
      deprecated_popoverScheme,
      deprecated_portal,
      deprecated_preventOverflow,
      popover
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: button || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {}) });
}), MenuDivider = styled__default.default.hr`
  height: 1px;
  border: 0;
  background: var(--card-hairline-soft-color);
  margin: 0;
`;
function selectableBaseStyle() {
  return styled.css`
    background-color: inherit;
    color: inherit;

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function selectableColorStyle(props) {
  var _a;
  const { $tone } = props, { color, style } = theme.getTheme_v2(props.theme), tone = color.selectable[$tone];
  return styled.css`
    ${_cardColorStyle(color, tone.enabled)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);
    outline: none;

    /* &:is(button) */
    &[data-as='button'] {
      &:disabled {
        ${_cardColorStyle(color, tone.disabled)}
      }

      &:not(:disabled) {
        &[aria-pressed='true'] {
          ${_cardColorStyle(color, tone.pressed)}
        }

        &[data-selected],
        &[aria-selected='true'] > & {
          ${_cardColorStyle(color, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, tone.hovered)}
            }

            &:active {
              ${_cardColorStyle(color, tone.pressed)}
            }
          }
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      &[data-disabled] {
        ${_cardColorStyle(color, tone.disabled)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color, tone.pressed)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, tone.hovered)}
            }
            &:active {
              ${_cardColorStyle(color, tone.pressed)}
            }
          }
        }
      }
    }

    ${(_a = style == null ? void 0 : style.card) == null ? void 0 : _a.root}
  `;
}
const Selectable = styled__default.default(Box)(
  responsiveRadiusStyle,
  selectableBaseStyle,
  selectableColorStyle
);
function useMenu() {
  const value = react.useContext(MenuContext);
  if (!value)
    throw new Error("useMenu(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useMenu(): the context value is not compatible");
  return value;
}
function MenuGroup(props) {
  const {
    as = "button",
    children,
    fontSize: fontSize2 = 1,
    icon,
    onClick,
    padding = 3,
    popover,
    radius = 2,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props, menu = useMenu(), { scheme } = useRootTheme(), {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    registerElement
  } = menu, [rootElement, setRootElement] = react.useState(null), [open, setOpen] = react.useState(!1), shouldFocusRef = react.useRef(null), active = !!activeElement && activeElement === rootElement, [withinMenu, setWithinMenu] = react.useState(!1), handleMouseEnter = react.useCallback(
    (event) => {
      setWithinMenu(!1), onItemMouseEnter(event), setOpen(!0);
    },
    [onItemMouseEnter]
  ), handleMenuKeyDown = react.useCallback(
    (event) => {
      event.key === "ArrowLeft" && (event.stopPropagation(), setOpen(!1), requestAnimationFrame(() => {
        rootElement == null || rootElement.focus();
      }));
    },
    [rootElement]
  ), handleClick = react.useCallback(
    (event) => {
      onClick && onClick(event), shouldFocusRef.current = "first", setOpen(!0), requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
    },
    [onClick]
  ), handleChildItemClick = react.useCallback(() => {
    setOpen(!1), onItemClick && onItemClick();
  }, [onItemClick]), handleMenuMouseEnter = react.useCallback(() => setWithinMenu(!0), []);
  react.useEffect(() => mount(rootElement), [mount, rootElement]), react.useEffect(() => {
    active || setOpen(!1);
  }, [active]), react.useEffect(() => {
    open || setWithinMenu(!1);
  }, [open]);
  const childMenu = /* @__PURE__ */ jsxRuntime.jsx(
    Menu,
    {
      onClickOutside,
      onEscape,
      onItemClick: handleChildItemClick,
      onKeyDown: handleMenuKeyDown,
      onMouseEnter: handleMenuMouseEnter,
      registerElement,
      shouldFocus: shouldFocusRef.current,
      children
    }
  ), handleKeyDown = react.useCallback((event) => {
    const target = event.currentTarget;
    if (document.activeElement === target && event.key === "ArrowRight") {
      shouldFocusRef.current = "first", setOpen(!0), setWithinMenu(!0), requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
      return;
    }
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsx(Popover, { ...popover, content: childMenu, "data-ui": "MenuGroup__popover", open, children: /* @__PURE__ */ jsxRuntime.jsx(
    Selectable,
    {
      "data-as": as,
      "data-ui": "MenuGroup",
      forwardedAs: as,
      ...restProps,
      "aria-pressed": as === "button" ? withinMenu : void 0,
      "data-pressed": as !== "button" ? withinMenu : void 0,
      "data-selected": !withinMenu && active ? "" : void 0,
      $radius: useArrayProp(radius),
      $tone: tone,
      $scheme: scheme,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseEnter: handleMouseEnter,
      ref: setRootElement,
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: /* @__PURE__ */ jsxRuntime.jsxs(Flex, { gap: space, padding, children: [
        icon && /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
          react.isValidElement(icon) && icon,
          ReactIs.isValidElementType(icon) && react.createElement(icon)
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
        /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) })
      ] })
    }
  ) });
}
const MenuItem = react.forwardRef(function(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize: fontSize2 = 1,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props, { scheme } = useRootTheme(), menu = useMenu(), {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu, [rootElement, setRootElement] = react.useState(null), active = !!activeElement && activeElement === rootElement;
  react.useEffect(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef), handleClick = react.useCallback(
    (event) => {
      disabled || (onClick && onClick(event), onItemClick && onItemClick());
    },
    [disabled, onClick, onItemClick]
  ), paddingProps = react.useMemo(
    () => ({
      padding,
      paddingX,
      paddingY,
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft
    }),
    [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]
  ), hotkeysFontSize = useArrayProp(fontSize2).map((s) => s - 1), setRef = react.useCallback(
    (el) => {
      ref.current = el, setRootElement(el);
    },
    [ref]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Selectable,
    {
      "data-ui": "MenuItem",
      ...restProps,
      "aria-pressed": as === "button" && pressed,
      "data-pressed": as !== "button" && pressed ? "" : void 0,
      "data-selected": active ? "" : void 0,
      "data-disabled": disabled ? "" : void 0,
      forwardedAs: as,
      $radius: useArrayProp(radius),
      $padding: useArrayProp(0),
      $tone: disabled ? "default" : tone,
      $scheme: scheme,
      disabled,
      onClick: handleClick,
      onMouseEnter: onItemMouseEnter,
      onMouseLeave: onItemMouseLeave,
      ref: setRef,
      role: "menuitem",
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: [
        (icon || text || iconRight) && /* @__PURE__ */ jsxRuntime.jsxs(Flex, { as: "span", gap: space, align: "center", ...paddingProps, children: [
          icon && /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(icon) && icon,
            ReactIs.isValidElementType(icon) && react.createElement(icon)
          ] }),
          text && /* @__PURE__ */ jsxRuntime.jsx(Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
          hotkeys && /* @__PURE__ */ jsxRuntime.jsx(
            Hotkeys,
            {
              fontSize: hotkeysFontSize,
              keys: hotkeys,
              style: { marginTop: -4, marginBottom: -4 }
            }
          ),
          iconRight && /* @__PURE__ */ jsxRuntime.jsxs(Text, { size: fontSize2, children: [
            react.isValidElement(iconRight) && iconRight,
            ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)
          ] })
        ] }),
        children && /* @__PURE__ */ jsxRuntime.jsx(Box, { as: "span", ...paddingProps, children })
      ]
    }
  );
}), keyframe = styled.keyframes`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`, animation = styled.css`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`, skeletonStyle = styled.css`
  opacity: ${({ $visible }) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({ $animated }) => $animated ? animation : styled.css`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`, Root$4 = styled__default.default(Box)(
  responsiveRadiusStyle,
  skeletonStyle
), Skeleton = react.forwardRef(function(props, ref) {
  const { animated = !1, delay, radius, ...restProps } = props, [visible, setVisible] = react.useState(!delay);
  return react.useEffect(() => {
    if (!delay)
      return setVisible(!0);
    const timeout = setTimeout(() => {
      setVisible(!0);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay]), /* @__PURE__ */ jsxRuntime.jsx(
    Root$4,
    {
      ...restProps,
      $animated: animated,
      $radius: useArrayProp(radius),
      $visible: visible,
      ref
    }
  );
}), Root$3 = styled__default.default(Skeleton)((props) => {
  const { $size, $style } = props, { font, media } = theme.getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = fontStyle.sizes[sizeIndex];
    return { height: fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight };
  });
}), TextSkeleton = react.forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$3, { ...restProps, $size, ref, $style: "text" });
}), LabelSkeleton = react.forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$3, { ...restProps, $size, ref, $style: "label" });
}), HeadingSkeleton = react.forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$3, { ...restProps, $size, ref, $style: "heading" });
}), CodeSkeleton = react.forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$3, { ...restProps, $size, ref, $style: "code" });
}), CustomButton = styled__default.default(Button)`
  max-width: 100%;
`, Tab = react.forwardRef(function(props, forwardedRef) {
  const {
    icon,
    id,
    focused,
    fontSize: fontSize2 = 1,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props, elementRef = react.useRef(null), focusedRef = react.useRef(!1), handleBlur = react.useCallback(() => {
    focusedRef.current = !1;
  }, []), handleFocus = react.useCallback(
    (event) => {
      focusedRef.current = !0, onFocus && onFocus(event);
    },
    [onFocus]
  ), ref = useForwardedRef(forwardedRef);
  return react.useEffect(() => {
    focused && !focusedRef.current && (elementRef.current && elementRef.current.focus(), focusedRef.current = !0);
  }, [focused]), /* @__PURE__ */ jsxRuntime.jsx(
    CustomButton,
    {
      "data-ui": "Tab",
      ...restProps,
      "aria-selected": selected ? "true" : "false",
      fontSize: fontSize2,
      icon,
      id,
      mode: "bleed",
      onClick,
      onBlur: handleBlur,
      onFocus: handleFocus,
      padding,
      ref: (el) => {
        elementRef.current = el, ref.current = el;
      },
      role: "tab",
      selected,
      tabIndex: selected ? 0 : -1,
      text: label,
      type: "button"
    }
  );
});
function _isReactElement(node) {
  return !!node;
}
const CustomInline = styled__default.default(Inline)`
  & > div {
    display: inline-block;
    vertical-align: middle;
    max-width: 100%;
    box-sizing: border-box;
  }
`, TabList = react.forwardRef(function(props, ref) {
  const { children: childrenProp, ...restProps } = props, [focusedIndex, setFocusedIndex] = react.useState(-1), tabs = react.useMemo(() => childrenProp.filter(_isReactElement), [childrenProp]).map(
    (child, childIndex) => react.cloneElement(child, {
      focused: focusedIndex === childIndex,
      key: childIndex,
      onFocus: () => handleTabFocus(childIndex)
    })
  ), numTabs = tabs.length, handleTabFocus = react.useCallback((tabIdx) => {
    setFocusedIndex(tabIdx);
  }, []), handleKeyDown = react.useCallback(
    (event) => {
      event.key === "ArrowLeft" && setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs), event.key === "ArrowRight" && setFocusedIndex((prevIndex) => (prevIndex + 1) % numTabs);
    },
    [numTabs]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CustomInline,
    {
      "data-ui": "TabList",
      ...restProps,
      onKeyDown: handleKeyDown,
      ref,
      role: "tablist",
      children: tabs
    }
  );
}), TabPanel = react.forwardRef(function(props, ref) {
  const { flex, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    Box,
    {
      "data-ui": "TabPanel",
      ...restProps,
      flex,
      ref,
      role: "tabpanel",
      tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
      children: props.children
    }
  );
}), STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
}, BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
}, ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
}, Root$2 = styled__default.default(Card)`
  pointer-events: all;
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, TextBox = styled__default.default(Flex)`
  overflow-x: auto;
`;
function Toast(props) {
  const { closable, description, onClose, radius = 3, title, status, ...restProps } = props, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status";
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$2,
    {
      "data-ui": "Toast",
      role,
      ...restProps,
      marginTop: 3,
      radius,
      shadow: 2,
      tone: cardTone,
      children: /* @__PURE__ */ jsxRuntime.jsxs(Flex, { align: "flex-start", children: [
        /* @__PURE__ */ jsxRuntime.jsx(TextBox, { flex: 1, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(Stack, { space: 3, children: [
          title && /* @__PURE__ */ jsxRuntime.jsx(Text, { size: 1, weight: "medium", children: title }),
          description && /* @__PURE__ */ jsxRuntime.jsx(Text, { muted: !0, size: 1, children: description })
        ] }) }),
        closable && /* @__PURE__ */ jsxRuntime.jsx(Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Button,
          {
            as: "button",
            icon: icons.CloseIcon,
            mode: "bleed",
            padding: 2,
            tone: buttonTone,
            onClick: onClose,
            style: { verticalAlign: "top" }
          }
        ) })
      ] })
    }
  );
}
function useMounted() {
  return react.useSyncExternalStore(
    subscribe,
    () => !0,
    () => !1
  );
}
const subscribe = () => () => {
}, key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || react.createContext(null);
const ToastContext = globalScope[key$1], Root$1 = styled__default.default(Layer)`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
`, ToastContainer = styled__default.default.div`
  box-sizing: border-box;
  position: absolute;
  right: 0;
  bottom: 0;
  max-width: 420px;
  width: 100%;
`;
let toastId = 0;
function ToastProvider(props) {
  const { children, padding = 4, paddingX, paddingY, zOffset } = props, [state, _setState] = react.useState([]), toastsRef = react.useRef({}), mounted = useMounted(), prefersReducedMotion = usePrefersReducedMotion(), variants = react.useMemo(
    () => ({
      initial: {
        opacity: 0,
        [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
        y: 32,
        scale: 0.25,
        willChange: "transform"
      },
      animate: {
        opacity: [0, 1, 1],
        [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [0, 0, 1],
        y: 0,
        scale: 1
      },
      exit: {
        opacity: [1, 1, 0],
        [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [1, 0, 0],
        scale: 0.5,
        transition: prefersReducedMotion ? { duration: 0 } : { duration: 0.2 }
      }
    }),
    [prefersReducedMotion]
  ), value = react.useMemo(() => ({ version: 0, push: (params) => {
    const setState = (state2) => react.startTransition(() => _setState(state2)), id = params.id || String(toastId++), duration = params.duration || 5e3, dismiss = () => {
      var _a;
      const timeoutId = (_a = toastsRef.current[id]) == null ? void 0 : _a.timeoutId;
      setState((prevState) => {
        const idx = prevState.findIndex((t) => t.id === id);
        if (idx > -1) {
          const toasts = prevState.slice(0);
          return toasts.splice(idx, 1), toasts;
        }
        return prevState;
      }), timeoutId !== void 0 && (clearTimeout(timeoutId), delete toastsRef.current[id]);
    };
    return setState((prevState) => prevState.filter((t) => t.id !== id).concat([
      {
        dismiss,
        id,
        params: { ...params, duration }
      }
    ])), toastsRef.current[id] && (clearTimeout(toastsRef.current[id].timeoutId), delete toastsRef.current[id]), toastsRef.current[id] = { timeoutId: setTimeout(dismiss, duration) }, id;
  } }), []);
  return react.useEffect(
    () => () => {
      for (const { timeoutId } of Object.values(toastsRef.current))
        clearTimeout(timeoutId);
      toastsRef.current = {};
    },
    []
  ), /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Provider, { value, children: [
    children,
    mounted && /* @__PURE__ */ jsxRuntime.jsx(Root$1, { "data-ui": "ToastProvider", zOffset, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(Box, { padding, paddingX, paddingY, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: state.map(({ dismiss, id, params }) => /* @__PURE__ */ jsxRuntime.jsx(
      framerMotion.motion.div,
      {
        layout: "position",
        initial: "initial",
        animate: "animate",
        exit: "exit",
        variants,
        transition: prefersReducedMotion ? { duration: 0 } : { type: "spring", damping: 30, stiffness: 400 },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          Toast,
          {
            closable: params.closable,
            description: params.description,
            onClose: dismiss,
            status: params.status,
            title: params.title
          }
        )
      },
      id
    )) }) }) }) })
  ] });
}
function useToast() {
  const value = react.useContext(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) != null && _a.expanded)) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i])
      continue;
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) != null && _a.expanded)) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
const key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || react.createContext(null);
const TreeContext = globalScope[key], Tree = react.memo(
  react.forwardRef(function(props, ref) {
    const { children, space = 1, onFocus, ...restProps } = props, forwardedRef = useForwardedRef(ref), [focusedElement, setFocusedElement] = react.useState(null), focusedElementRef = react.useRef(focusedElement), path = react.useMemo(() => [], []), [itemElements, setItemElements] = react.useState([]), [state, setState] = react.useState({}), stateRef = react.useRef(state);
    react.useEffect(() => {
      focusedElementRef.current = focusedElement;
    }, [focusedElement]), react.useEffect(() => {
      stateRef.current = state;
    }, [state]);
    const registerItem = react.useCallback(
      (element, path2, expanded, selected) => (setState((s) => ({ ...s, [path2]: { element, expanded } })), selected && setFocusedElement(element), () => {
        setState((s) => {
          const newState = { ...s };
          return delete newState[path2], newState;
        });
      }),
      []
    ), setExpanded = react.useCallback((path2, expanded) => {
      setState((s) => {
        const itemState = s[path2];
        return itemState ? { ...s, [path2]: { ...itemState, expanded } } : s;
      });
    }, []), contextValue = react.useMemo(
      () => ({
        version: 0,
        focusedElement: focusedElement || itemElements[0] || null,
        level: 0,
        path,
        registerItem,
        setExpanded,
        setFocusedElement,
        space,
        state
      }),
      [focusedElement, itemElements, path, registerItem, setExpanded, space, state]
    ), handleKeyDown = react.useCallback(
      (event) => {
        var _a;
        if (focusedElementRef.current) {
          if (event.key === "ArrowDown") {
            event.preventDefault();
            const nextEl = _findNextItemElement(
              stateRef.current,
              itemElements,
              focusedElementRef.current
            );
            nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            const prevEl = _findPrevItemElement(
              stateRef.current,
              itemElements,
              focusedElementRef.current
            );
            prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
            return;
          }
          if (event.key === "ArrowLeft") {
            event.preventDefault();
            const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
            if (!itemKey)
              return;
            const itemState = stateRef.current[itemKey];
            if (!itemState)
              return;
            if (itemState.expanded)
              setState((s) => {
                const itemState2 = s[itemKey];
                return itemState2 ? { ...s, [itemKey]: { ...itemState2, expanded: !1 } } : s;
              });
            else {
              const itemPath = itemKey.split("/");
              itemPath.pop();
              const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
              parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
            }
            return;
          }
          if (event.key === "ArrowRight") {
            event.preventDefault();
            const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
            if (!focusedKey)
              return;
            (_a = stateRef.current[focusedKey]) != null && _a.expanded || setState((s) => {
              const itemState = s[focusedKey];
              return itemState ? { ...s, [focusedKey]: { ...itemState, expanded: !0 } } : s;
            });
            return;
          }
        }
      },
      [itemElements]
    ), handleFocus = react.useCallback(
      (event) => {
        setFocusedElement(event.target), onFocus == null || onFocus(event);
      },
      [onFocus]
    );
    return react.useEffect(() => {
      if (!forwardedRef.current)
        return;
      const _itemElements = Array.from(
        forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]')
      );
      setItemElements(_itemElements);
    }, [children, forwardedRef]), /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntime.jsx(
      Stack,
      {
        as: "ul",
        "data-ui": "Tree",
        ...restProps,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        ref: forwardedRef,
        role: "tree",
        space,
        children
      }
    ) });
  })
);
Tree.displayName = "Tree";
function treeItemRootStyle() {
  return styled.css`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", { color } = theme.getTheme_v2(props.theme), tone = color.selectable[$tone];
  return styled.css`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const { $level } = props, { space } = theme.getTheme_v2(props.theme);
  return styled.css`
    padding-left: ${rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = react.useContext(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
const TreeGroup = react.memo(function(props) {
  const { children, expanded = !1, ...restProps } = props, tree = useTree();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Stack,
    {
      as: "ul",
      "data-ui": "TreeGroup",
      ...restProps,
      hidden: !expanded,
      marginTop: tree.space,
      role: "group",
      space: tree.space,
      children
    }
  );
}), Root = react.memo(styled__default.default.li(treeItemRootStyle, treeItemRootColorStyle)), TreeItemBox = styled__default.default(Box).attrs({ forwardedAs: "a" })(treeItemBoxStyle), ToggleArrowText = styled__default.default(Text)`
  & > svg {
    transition: transform 100ms;
  }
`, TreeItem = react.memo(function(props) {
  const {
    children,
    expanded: expandedProp = !1,
    fontSize: fontSize2 = 1,
    href,
    icon,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = !1,
    space = 2,
    text,
    weight,
    ...restProps
  } = props, rootRef = react.useRef(null), treeitemRef = react.useRef(null), tree = useTree(), { path, registerItem, setExpanded, setFocusedElement } = tree, _id = react.useId(), id = idProp || _id, itemPath = react.useMemo(() => path.concat([id || ""]), [id, path]), itemKey = itemPath.join("/"), itemState = tree.state[itemKey], focused = tree.focusedElement === rootRef.current, expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || !1, tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1, contextValue = react.useMemo(
    () => ({ ...tree, level: tree.level + 1, path: itemPath }),
    [itemPath, tree]
  ), handleClick = react.useCallback(
    (event) => {
      onClick && onClick(event);
      const target = event.target;
      target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootRef.current));
    },
    [expanded, itemKey, onClick, setExpanded, setFocusedElement]
  ), handleKeyDown = react.useCallback(
    (event) => {
      if (focused && event.key === "Enter") {
        const el = treeitemRef.current || rootRef.current;
        el == null || el.click();
      }
    },
    [focused]
  );
  react.useEffect(() => {
    if (rootRef.current)
      return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */ jsxRuntime.jsxs(Flex, { padding, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      Box,
      {
        marginRight: space,
        style: { visibility: icon || children ? "visible" : "hidden", pointerEvents: "none" },
        children: [
          icon && /* @__PURE__ */ jsxRuntime.jsx(Text, { muted, size: fontSize2, weight, children: react.createElement(icon) }),
          !icon && /* @__PURE__ */ jsxRuntime.jsx(ToggleArrowText, { muted, size: fontSize2, weight, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ToggleArrowRightIcon, { style: { transform: expanded ? "rotate(90deg)" : void 0 } }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Text, { muted, size: fontSize2, textOverflow: "ellipsis", weight, children: text }) })
  ] });
  return href ? /* @__PURE__ */ jsxRuntime.jsxs(
    Root,
    {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TreeItemBox,
          {
            $level: tree.level,
            "aria-expanded": expanded,
            as: linkAs,
            "data-ui": "TreeItem__box",
            href,
            ref: treeitemRef,
            role: "treeitem",
            tabIndex,
            children: content
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsxRuntime.jsx(TreeGroup, { hidden: !expanded, children }) })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(
    Root,
    {
      "data-selected": selected ? "" : void 0,
      "data-ui": "TreeItem",
      "data-tree-id": id,
      "data-tree-key": itemKey,
      ...restProps,
      "aria-expanded": expanded,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      ref: rootRef,
      role: "treeitem",
      tabIndex,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content }),
        /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsxRuntime.jsx(TreeGroup, { expanded, children }) })
      ]
    }
  );
});
exports.Arrow = Arrow;
exports.Autocomplete = Autocomplete;
exports.Avatar = Avatar;
exports.AvatarCounter = AvatarCounter;
exports.AvatarStack = AvatarStack;
exports.Badge = Badge;
exports.BoundaryElementProvider = BoundaryElementProvider;
exports.Box = Box;
exports.Breadcrumbs = Breadcrumbs;
exports.Button = Button;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.Code = Code;
exports.CodeSkeleton = CodeSkeleton;
exports.ConditionalWrapper = ConditionalWrapper;
exports.Container = Container;
exports.Dialog = Dialog;
exports.DialogContext = DialogContext;
exports.DialogProvider = DialogProvider;
exports.ElementQuery = ElementQuery;
exports.ErrorBoundary = ErrorBoundary;
exports.Flex = Flex;
exports.Grid = Grid;
exports.Heading = Heading;
exports.HeadingSkeleton = HeadingSkeleton;
exports.Hotkeys = Hotkeys;
exports.Inline = Inline;
exports.KBD = KBD;
exports.Label = Label;
exports.LabelSkeleton = LabelSkeleton;
exports.Layer = Layer;
exports.LayerProvider = LayerProvider;
exports.Menu = Menu;
exports.MenuButton = MenuButton;
exports.MenuDivider = MenuDivider;
exports.MenuGroup = MenuGroup;
exports.MenuItem = MenuItem;
exports.Popover = Popover;
exports.Portal = Portal;
exports.PortalProvider = PortalProvider;
exports.Radio = Radio;
exports.Select = Select;
exports.Skeleton = Skeleton;
exports.Spinner = Spinner;
exports.SrOnly = SrOnly;
exports.Stack = Stack;
exports.Switch = Switch;
exports.Tab = Tab;
exports.TabList = TabList;
exports.TabPanel = TabPanel;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextInput = TextInput;
exports.TextSkeleton = TextSkeleton;
exports.ThemeColorProvider = ThemeColorProvider;
exports.ThemeProvider = ThemeProvider;
exports.Toast = Toast;
exports.ToastProvider = ToastProvider;
exports.Tooltip = Tooltip;
exports.TooltipDelayGroupContext = TooltipDelayGroupContext;
exports.TooltipDelayGroupProvider = TooltipDelayGroupProvider;
exports.Tree = Tree;
exports.TreeItem = TreeItem;
exports.VirtualList = VirtualList;
exports._ResizeObserver = _ResizeObserver;
exports._elementSizeObserver = _elementSizeObserver;
exports._fillCSSObject = _fillCSSObject;
exports._getArrayProp = _getArrayProp;
exports._getResponsiveSpace = _getResponsiveSpace;
exports._hasFocus = _hasFocus;
exports._isEnterToClickElement = _isEnterToClickElement;
exports._isScrollable = _isScrollable;
exports._raf = _raf;
exports._raf2 = _raf2;
exports._responsive = _responsive;
exports.attemptFocus = attemptFocus;
exports.containsOrEqualsElement = containsOrEqualsElement;
exports.createColorTheme = createColorTheme;
exports.focusFirstDescendant = focusFirstDescendant;
exports.focusLastDescendant = focusLastDescendant;
exports.hexToRgb = hexToRgb;
exports.hslToRgb = hslToRgb;
exports.isFocusable = isFocusable;
exports.isHTMLAnchorElement = isHTMLAnchorElement;
exports.isHTMLButtonElement = isHTMLButtonElement;
exports.isHTMLElement = isHTMLElement;
exports.isHTMLInputElement = isHTMLInputElement;
exports.isHTMLSelectElement = isHTMLSelectElement;
exports.isHTMLTextAreaElement = isHTMLTextAreaElement;
exports.multiply = multiply;
exports.parseColor = parseColor;
exports.rem = rem;
exports.responsiveCodeFontStyle = responsiveCodeFontStyle;
exports.responsiveHeadingFont = responsiveHeadingFont;
exports.responsiveLabelFont = responsiveLabelFont;
exports.responsiveTextAlignStyle = responsiveTextAlignStyle;
exports.responsiveTextFont = responsiveTextFont;
exports.rgbToHex = rgbToHex;
exports.rgbToHsl = rgbToHsl;
exports.rgba = rgba;
exports.screen = screen;
exports.studioTheme = studioTheme;
exports.useArrayProp = useArrayProp;
exports.useBoundaryElement = useBoundaryElement;
exports.useClickOutside = useClickOutside;
exports.useCustomValidity = useCustomValidity;
exports.useDialog = useDialog;
exports.useElementRect = useElementRect;
exports.useElementSize = useElementSize;
exports.useForwardedRef = useForwardedRef;
exports.useGlobalKeyDown = useGlobalKeyDown;
exports.useLayer = useLayer;
exports.useMediaIndex = useMediaIndex;
exports.usePortal = usePortal;
exports.usePrefersDark = usePrefersDark;
exports.usePrefersReducedMotion = usePrefersReducedMotion;
exports.useRootTheme = useRootTheme;
exports.useTheme = useTheme;
exports.useTheme_v2 = useTheme_v2;
exports.useToast = useToast;
exports.useTooltipDelayGroup = useTooltipDelayGroup;
exports.useTree = useTree;
//# sourceMappingURL=index.js.map
