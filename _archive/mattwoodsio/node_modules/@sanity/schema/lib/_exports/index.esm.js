import omit from 'lodash/omit.js';
import pick from 'lodash/pick.js';
import arrify from 'arrify';
import isUndefined from 'lodash/isUndefined.js';
import omitBy from 'lodash/omitBy.js';
import capitalize from 'lodash/capitalize.js';
import { resolveSearchConfigForBaseFieldPaths, resolveSearchConfig } from '../_chunks/resolve-ouJP351U.js';
import castArray from 'lodash/castArray.js';
import flatMap from 'lodash/flatMap.js';
import startCase from 'lodash/startCase.js';
import isPlainObject from 'lodash/isPlainObject.js';
import toPath from 'lodash/toPath.js';
const DEFAULT_OVERRIDEABLE_FIELDS = ["jsonType", "type", "name", "title", "description", "options", "fieldsets", "validation", "readOnly", "hidden", "components", "diffComponent", "initialValue", "deprecated"];
const OVERRIDABLE_FIELDS$e = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ANY_CORE = {
  name: "any",
  type: null,
  jsonType: "any"
};
const AnyType = {
  get() {
    return ANY_CORE;
  },
  extend(subTypeDef, extendMember) {
    const parsed = Object.assign(pick(ANY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
      type: ANY_CORE,
      of: subTypeDef.of.map(fieldDef => {
        return {
          name: fieldDef.name,
          type: extendMember(omit(fieldDef, "name"))
        };
      })
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$e), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function lazyGetter(target, key, getter) {
  let config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  Object.defineProperty(target, key, {
    configurable: true,
    enumerable: config.enumerable !== false,
    get() {
      const val = getter();
      Object.defineProperty(target, key, {
        value: val,
        writable: Boolean(config.writable),
        configurable: false
      });
      return val;
    }
  });
  return target;
}
const OVERRIDABLE_FIELDS$d = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ARRAY_CORE = {
  name: "array",
  type: null,
  jsonType: "array",
  of: []
};
const ArrayType = {
  get() {
    return ARRAY_CORE;
  },
  extend(subTypeDef, createMemberType) {
    const parsed = Object.assign(pick(ARRAY_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
      type: ARRAY_CORE
    });
    lazyGetter(parsed, "of", () => {
      return subTypeDef.of.map(ofTypeDef => {
        return createMemberType(ofTypeDef);
      });
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$d), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function warnIfPreviewOnOptions(type) {
  if (type.options && type.options.preview) {
    console.warn('Heads up! The preview config is no longer defined on "options", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of "'.concat(type.name, '".\n'));
  }
}
function warnIfPreviewHasFields(type) {
  const preview = type.preview || (type.options || {}).preview;
  if (preview && "fields" in preview) {
    console.warn('Heads up! "preview.fields" should be renamed to "preview.select". Please update the preview config for "'.concat(type.name, '".\n'));
  }
}
function isEmpty(object) {
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function _stringify(value, options, depth) {
  if (depth > options.maxDepth) {
    return "...";
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "[empty]";
    }
    const capLength = Math.max(value.length - options.maxBreadth);
    const asString2 = value.slice(0, options.maxBreadth).map((item, index) => _stringify(item, options, depth + 1)).concat(capLength > 0 ? "\u2026+".concat(capLength) : []).join(", ");
    return depth === 0 ? asString2 : "[".concat(asString2, "]");
  }
  if (typeof value === "object" && value !== null) {
    const keys = Object.keys(value).filter(key => !options.ignoreKeys.includes(key) && typeof value[key] !== "undefined");
    if (isEmpty(pick(value, keys))) {
      return "{empty}";
    }
    const asString2 = keys.slice(0, options.maxBreadth).map(key => "".concat(key, ": ").concat(_stringify(value[key], options, depth + 1))).join(", ");
    return depth === 0 ? asString2 : "{".concat(asString2, "}");
  }
  const asString = String(value);
  return asString === "" ? '""' : asString;
}
function stringify(value) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const opts = {
    maxDepth: "maxDepth" in options ? options.maxDepth : 2,
    maxBreadth: "maxBreadth" in options ? options.maxBreadth : 2,
    ignoreKeys: "ignoreKeys" in options ? options.ignoreKeys : []
  };
  return _stringify(value, opts, 0);
}
const OPTIONS = {
  maxEntries: 2,
  maxDepth: 2,
  maxBreadth: 2,
  ignoreKeys: ["_id", "_type", "_key", "_ref"]
};
function createFallbackPrepare(fieldNames) {
  return value => ({
    title: stringify(pick(value, fieldNames), OPTIONS)
  });
}
function isBlockField(field) {
  return field.type === "array" && field.of && field.of.some(member => member.type === "block");
}
const TITLE_CANDIDATES = ["title", "name", "label", "heading", "header", "caption"];
const DESCRIPTION_CANDIDATES = ["description", ...TITLE_CANDIDATES];
function fieldHasReferenceTo(fieldDef, refType) {
  return arrify(fieldDef.to || []).some(memberTypeDef => memberTypeDef.type === refType);
}
function isImageAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.imageAsset");
}
function resolveImageAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const imageAssetField = fields.find(isImageAssetField);
  if (imageAssetField) {
    return imageAssetField.name;
  }
  const fieldWithImageAsset = fields.find(fieldDef => (fieldDef.fields || []).some(isImageAssetField));
  return fieldWithImageAsset ? "".concat(fieldWithImageAsset.name, ".asset") : void 0;
}
function isFileAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.fileAsset");
}
function resolveFileAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const assetField = fields.find(isFileAssetField);
  if (assetField) {
    return assetField.name;
  }
  const fieldWithFileAsset = fields.find(fieldDef => (fieldDef.fields || []).some(isFileAssetField));
  return fieldWithFileAsset ? "".concat(fieldWithFileAsset.name, ".asset") : void 0;
}
function guessPreviewFields(rawObjectTypeDef) {
  const objectTypeDef = {
    fields: [],
    ...rawObjectTypeDef
  };
  const stringFieldNames = objectTypeDef.fields.filter(field => field.type === "string").map(field => field.name);
  const blockFieldNames = objectTypeDef.fields.filter(isBlockField).map(field => field.name);
  let titleField = TITLE_CANDIDATES.find(candidate => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate));
  let descField = DESCRIPTION_CANDIDATES.find(candidate => candidate !== titleField && (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)));
  if (!titleField) {
    titleField = stringFieldNames[0] || blockFieldNames[0];
    descField = stringFieldNames[1] || blockFieldNames[1];
  }
  const mediaField = objectTypeDef.fields.find(field => field.type === "image");
  const imageAssetPath = resolveImageAssetPath(objectTypeDef);
  if (!titleField) {
    const fileAssetPath = resolveFileAssetPath(objectTypeDef);
    if (fileAssetPath) {
      titleField = "".concat(fileAssetPath, ".originalFilename");
    }
    if (imageAssetPath) {
      titleField = "".concat(imageAssetPath, ".originalFilename");
    }
  }
  if (!titleField && !imageAssetPath) {
    const fieldNames = objectTypeDef.fields.map(field => field.name);
    const fieldMapping = fieldNames.reduce((acc, fieldName) => {
      acc[fieldName] = fieldName;
      return acc;
    }, {});
    return {
      select: fieldMapping,
      prepare: createFallbackPrepare(fieldNames)
    };
  }
  const select = omitBy({
    title: titleField,
    description: descField,
    media: mediaField ? mediaField.name : imageAssetPath
  }, isUndefined);
  return {
    select
  };
}
function parseSelection(selection) {
  return selection.reduce((acc, field) => {
    acc[field] = field;
    return acc;
  }, {});
}
function parsePreview(preview) {
  if (!preview) {
    return preview;
  }
  const select = preview.select || preview.fields || {};
  if (Array.isArray(select)) {
    return {
      ...pick(preview, ["prepare", "component"]),
      select: parseSelection(select)
    };
  }
  return {
    ...pick(preview, ["prepare", "component"]),
    select
  };
}
function createPreviewGetter(objectTypeDef) {
  return function previewGetter() {
    warnIfPreviewOnOptions(objectTypeDef);
    warnIfPreviewHasFields(objectTypeDef);
    const preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview);
    return preview || guessPreviewFields(objectTypeDef);
  };
}
const DEFAULT_LINK_ANNOTATION = {
  type: "object",
  name: "link",
  title: "Link",
  i18nTitleKey: "inputs.portable-text.annotation.link",
  options: {
    modal: {
      type: "popover"
    }
  },
  fields: [{
    name: "href",
    type: "url",
    title: "Link",
    description: "A valid web, email, phone, or relative link.",
    validation: Rule => Rule.uri({
      scheme: ["http", "https", "tel", "mailto"],
      allowRelative: true
    })
  }]
};
const DEFAULT_TEXT_FIELD = {
  type: "text",
  name: "text",
  title: "Text"
};
const DEFAULT_MARKS_FIELD = {
  name: "marks",
  type: "array",
  of: [{
    type: "string"
  }],
  title: "Marks"
};
const LIST_TYPES = {
  bullet: {
    title: "Bulleted list",
    value: "bullet",
    i18nTitleKey: "inputs.portable-text.list-type.bullet"
  },
  numbered: {
    title: "Numbered list",
    value: "number",
    i18nTitleKey: "inputs.portable-text.list-type.number"
  }
};
const DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered];
const BLOCK_STYLES = {
  normal: {
    title: "Normal",
    value: "normal",
    i18nTitleKey: "inputs.portable-text.style.normal"
  },
  h1: {
    title: "Heading 1",
    value: "h1",
    i18nTitleKey: "inputs.portable-text.style.h1"
  },
  h2: {
    title: "Heading 2",
    value: "h2",
    i18nTitleKey: "inputs.portable-text.style.h2"
  },
  h3: {
    title: "Heading 3",
    value: "h3",
    i18nTitleKey: "inputs.portable-text.style.h3"
  },
  h4: {
    title: "Heading 4",
    value: "h4",
    i18nTitleKey: "inputs.portable-text.style.h4"
  },
  h5: {
    title: "Heading 5",
    value: "h5",
    i18nTitleKey: "inputs.portable-text.style.h5"
  },
  h6: {
    title: "Heading 6",
    value: "h6",
    i18nTitleKey: "inputs.portable-text.style.h6"
  },
  blockquote: {
    title: "Quote",
    value: "blockquote",
    i18nTitleKey: "inputs.portable-text.style.quote"
  }
};
const DEFAULT_BLOCK_STYLES = [BLOCK_STYLES.normal, BLOCK_STYLES.h1, BLOCK_STYLES.h2, BLOCK_STYLES.h3, BLOCK_STYLES.h4, BLOCK_STYLES.h5, BLOCK_STYLES.h6, BLOCK_STYLES.blockquote];
const DECORATOR_STRONG = {
  title: "Strong",
  value: "strong",
  i18nTitleKey: "inputs.portable-text.decorator.strong"
};
const DECORATOR_EMPHASIS = {
  title: "Italic",
  value: "em",
  i18nTitleKey: "inputs.portable-text.decorator.emphasis"
};
const DECORATOR_CODE = {
  title: "Code",
  value: "code",
  i18nTitleKey: "inputs.portable-text.decorator.code"
};
const DECORATOR_UNDERLINE = {
  title: "Underline",
  value: "underline",
  i18nTitleKey: "inputs.portable-text.decorator.underline"
};
const DECORATOR_STRIKE = {
  title: "Strike",
  value: "strike-through",
  i18nTitleKey: "inputs.portable-text.decorator.strike-through"
};
const DECORATORS = {
  strong: DECORATOR_STRONG,
  em: DECORATOR_EMPHASIS,
  code: DECORATOR_CODE,
  underline: DECORATOR_UNDERLINE,
  strikeThrough: DECORATOR_STRIKE
};
const DEFAULT_DECORATORS = [DECORATORS.strong, DECORATORS.em, DECORATORS.code, DECORATORS.underline, DECORATORS.strikeThrough];
const INHERITED_FIELDS$1 = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
const BLOCK_CORE = {
  name: "block",
  title: "Block",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS$3 = {};
const BlockType = {
  get() {
    return BLOCK_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = {
      ...(subTypeDef.options || DEFAULT_OPTIONS$3)
    };
    const {
      marks,
      styles,
      lists,
      of,
      ...rest
    } = subTypeDef;
    const childrenField = createChildrenField(marks, of);
    const styleField = createStyleField(styles);
    const listItemField = createListItemField(lists);
    const markDefsField = {
      name: "markDefs",
      title: "Mark definitions",
      type: "array",
      of: (marks == null ? void 0 : marks.annotations) || DEFAULT_ANNOTATIONS
    };
    const levelField = {
      name: "level",
      title: "Indentation",
      type: "number"
    };
    const fields = [childrenField, styleField, listItemField, markDefsField, levelField].concat(subTypeDef.fields || []);
    const parsed = Object.assign(pick(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
      type: BLOCK_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "block"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function ensureNormalStyle(styles) {
  return styles.some(style => style.value === "normal") ? styles : [BLOCK_STYLES.normal, ...styles];
}
function createStyleField(styles) {
  return {
    name: "style",
    title: "Style",
    type: "string",
    options: {
      list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES)
    }
  };
}
function createListItemField(lists) {
  return {
    name: "listItem",
    title: "List type",
    type: "string",
    options: {
      list: lists || DEFAULT_LIST_TYPES
    }
  };
}
const DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];
function createChildrenField(marks) {
  let of = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    name: "children",
    title: "Content",
    type: "array",
    of: [{
      type: "span",
      fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],
      annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
      decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS
    }, ...of.filter(memberType => memberType.type !== "span")]
  };
}
const INHERITED_FIELDS = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
const SPAN_CORE = {
  name: "span",
  title: "Span",
  type: null,
  jsonType: "object"
};
const MARKS_FIELD = {
  name: "marks",
  title: "Marks",
  type: "array",
  of: [{
    type: "string"
  }]
};
const TEXT_FIELD = {
  name: "text",
  title: "Text",
  type: "string"
};
const DEFAULT_OPTIONS$2 = {};
const SpanType = {
  get() {
    return SPAN_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = {
      ...(subTypeDef.options || DEFAULT_OPTIONS$2)
    };
    const {
      annotations = [],
      marks = []
    } = subTypeDef;
    const fields = [MARKS_FIELD, TEXT_FIELD];
    const parsed = Object.assign(pick(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
      type: SPAN_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "annotations", () => annotations.map(extendMember));
    lazyGetter(parsed, "marks", () => marks.map(extendMember));
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "span"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var primitivePreview = {
  prepare: val => ({
    title: String(val)
  })
};
const OVERRIDABLE_FIELDS$c = [...DEFAULT_OVERRIDEABLE_FIELDS];
const BOOLEAN_CORE = {
  name: "boolean",
  title: "Boolean",
  type: null,
  jsonType: "boolean"
};
const BooleanType = {
  get() {
    return BOOLEAN_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(BOOLEAN_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
      type: BOOLEAN_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$c), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const REF_FIELD$1 = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
const WEAK_FIELD$1 = {
  name: "_weak",
  title: "Weak reference marker",
  type: "boolean"
};
const DATASET_FIELD = {
  name: "_dataset",
  title: "Target dataset",
  type: "string"
};
const PROJECT_ID_FIELD = {
  name: "_projectId",
  title: "Target project ID",
  type: "string",
  hidden: true
};
const REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1, DATASET_FIELD, PROJECT_ID_FIELD];
const OVERRIDABLE_FIELDS$b = [...DEFAULT_OVERRIDEABLE_FIELDS];
const CROSS_DATASET_REFERENCE_CORE = {
  name: "crossDatasetReference",
  type: null,
  jsonType: "object"
};
function humanize$1(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first = arr.slice(0, len - 1);
  const last = arr[len - 1];
  return "".concat(first.join(", "), " ").concat(conjunction, " ").concat(last);
}
function buildTitle$1(type) {
  if (!type.to || type.to.length === 0) {
    return "Cross dataset Reference";
  }
  return "Cross dataset reference to ".concat(humanize$1(arrify(type.to).map(toType => toType.title || capitalize(toType.type)), "or").toLowerCase());
}
const CrossDatasetReferenceType = {
  get() {
    return CROSS_DATASET_REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error('Missing "to" field in cross dataset reference definition. Check the type '.concat(subTypeDef.name));
    }
    const parsed = Object.assign(pick(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
      type: CROSS_DATASET_REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS$1.map(fieldDef => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "to", () => {
      return arrify(subTypeDef.to).map(toType => {
        return {
          ...toType,
          // eslint-disable-next-line camelcase
          __experimental_search: resolveSearchConfigForBaseFieldPaths(toType)
        };
      });
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle$1(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$b), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$a = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATE_CORE = {
  name: "date",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
const DateType = {
  get() {
    return DATE_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(DATE_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
      type: DATE_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$a), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$9 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATETIME_CORE = {
  name: "datetime",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
const DateTimeType = {
  get() {
    return DATETIME_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(DATETIME_CORE, OVERRIDABLE_FIELDS$9), subTypeDef, {
      type: DATETIME_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$9), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const CANDIDATES = ["title", "name", "label", "heading", "header", "caption", "description"];
const PRIMITIVES = ["string", "boolean", "number"];
const isPrimitive = field => PRIMITIVES.includes(field.type);
function guessOrderingConfig(objectTypeDef) {
  let candidates = CANDIDATES.filter(candidate => objectTypeDef.fields.some(field => isPrimitive(field) && field.name === candidate));
  if (candidates.length === 0) {
    candidates = objectTypeDef.fields.filter(isPrimitive).map(field => field.name);
  }
  return candidates.map(name => ({
    name,
    i18n: {
      title: {
        key: "default-orderings.".concat(name),
        ns: "studio"
      }
    },
    title: capitalize(startCase(name)),
    by: [{
      field: name,
      direction: "asc"
    }]
  }));
}
function normalizeSearchConfigs(configs) {
  if (!Array.isArray(configs)) {
    throw new Error("The search config of a document type must be an array of search config objects");
  }
  return configs.map(conf => {
    if (conf === "defaults") {
      return conf;
    }
    if (!isPlainObject(conf)) {
      throw new Error("Search config must be an object of {path: string, weight: number}");
    }
    return {
      weight: "weight" in conf ? conf.weight : 1,
      path: toPath(conf.path),
      mapWith: typeof conf.mapWith === "string" ? conf.mapWith : void 0
    };
  });
}
const OVERRIDABLE_FIELDS$8 = [...DEFAULT_OVERRIDEABLE_FIELDS, "orderings", "__experimental_search", "blockEditor", "icon"];
const ObjectType = {
  get() {
    return {
      name: "object",
      title: "Object",
      type: null,
      jsonType: "object"
    };
  },
  extend(rawSubTypeDef, createMemberType) {
    const subTypeDef = {
      fields: [],
      ...rawSubTypeDef
    };
    const options = {
      ...(subTypeDef.options || {})
    };
    const parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS$8), subTypeDef, {
      type: this.get(),
      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
      options,
      orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
      fields: subTypeDef.fields.map(fieldDef => {
        const {
          name,
          fieldset,
          group,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          group,
          fieldset
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || startCase(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "groups", () => {
      return createFieldsGroups(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    lazyGetter(parsed, "__experimental_search", () => {
      const userProvidedSearchConfig = subTypeDef.__experimental_search ? normalizeSearchConfigs(subTypeDef.__experimental_search) : null;
      if (userProvidedSearchConfig) {
        return userProvidedSearchConfig.map(entry => entry === "defaults" ? normalizeSearchConfigs(subTypeDef) : entry);
      }
      return resolveSearchConfig(parsed);
    }, {
      enumerable: false
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "object"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$8), {
            title: extensionDef.title || subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
            type: parent
          });
          lazyGetter(current, "__experimental_search", () => parent.__experimental_search);
          return subtype(current);
        }
      };
    }
  }
};
function createFieldsets(typeDef, fields) {
  const fieldsetsByName = {};
  for (const fieldset of typeDef.fieldsets || []) {
    if (fieldsetsByName[fieldset.name]) {
      throw new Error('Duplicate fieldset name "'.concat(fieldset.name, "\" found for type '").concat(typeDef.title ? typeDef.title : startCase(typeDef.name), "'"));
    }
    fieldsetsByName[fieldset.name] = {
      title: startCase(fieldset.name),
      ...fieldset,
      fields: []
    };
  }
  const fieldsets = /* @__PURE__ */new Set();
  for (const field of fields) {
    if (!field.fieldset) {
      fieldsets.add({
        single: true,
        field
      });
      continue;
    }
    const fieldset = fieldsetsByName[field.fieldset];
    if (!fieldset) {
      throw new Error("Fieldset '".concat(field.fieldset, "' is not defined in schema for type '").concat(typeDef.name, "'"));
    }
    fieldset.fields.push(field);
    fieldsets.add(fieldset);
  }
  return Array.from(fieldsets);
}
function createFieldsGroups(typeDef, fields) {
  const groupsByName = {};
  let numDefaultGroups = 0;
  for (const group of typeDef.groups || []) {
    if (groupsByName[group.name]) {
      throw new Error('Duplicate group name "'.concat(group.name, "\" found for type '").concat(typeDef.title ? typeDef.title : startCase(typeDef.name), "'"));
    }
    groupsByName[group.name] = {
      title: startCase(group.name),
      ...group,
      fields: []
    };
    if (group.default && ++numDefaultGroups > 1) {
      throw new Error("More than one field group defined as default for type '".concat(typeDef.title ? typeDef.title : startCase(typeDef.name), "' - only 1 is supported"));
    }
  }
  fields.forEach(field => {
    const fieldGroupNames = castArray(field.group || []);
    if (fieldGroupNames.length === 0) {
      return;
    }
    fieldGroupNames.forEach(fieldGroupName => {
      const currentGroup = groupsByName[fieldGroupName];
      if (!currentGroup) {
        throw new Error("Field group '".concat(fieldGroupName, "' is not defined in schema for type '").concat(typeDef.title ? typeDef.name : startCase(typeDef.name), "'"));
      }
      currentGroup.fields.push(field);
    });
  });
  return flatMap(groupsByName).filter(group => group.fields.length > 0);
}
const DOCUMENT_CORE = {
  name: "document",
  title: "Document",
  type: null,
  jsonType: "object"
};
const DocumentType = {
  get() {
    return DOCUMENT_CORE;
  },
  extend: ObjectType.extend
};
const OVERRIDABLE_FIELDS$7 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const EMAIL_CORE = {
  name: "email",
  title: "Email",
  type: null,
  jsonType: "string"
};
const EmailType = {
  get() {
    return EMAIL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(EMAIL_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
      type: EMAIL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$7), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const ASSET_FIELD$1 = {
  name: "asset",
  type: "reference",
  to: {
    type: "sanity.fileAsset"
  }
};
const OVERRIDABLE_FIELDS$6 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const FILE_CORE = {
  name: "file",
  title: "File",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS$1 = {
  accept: ""
};
const FileType = {
  get() {
    return FILE_CORE;
  },
  extend(rawSubTypeDef, createMemberType) {
    const options = {
      ...(rawSubTypeDef.options || DEFAULT_OPTIONS$1)
    };
    const fields = [ASSET_FIELD$1, ...(rawSubTypeDef.fields || [])];
    const subTypeDef = {
      ...rawSubTypeDef,
      fields
    };
    const parsed = Object.assign(pick(FILE_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
      type: FILE_CORE,
      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
      options,
      fields: subTypeDef.fields.map(fieldDef => {
        const {
          name,
          fieldset,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          fieldset,
          isCustomized: Boolean(rawSubTypeDef.fields)
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || startCase(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "file"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$6), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const ASSET_FIELD = {
  name: "asset",
  type: "reference",
  to: [{
    type: "sanity.imageAsset"
  }]
};
const HOTSPOT_FIELD = {
  name: "hotspot",
  type: "sanity.imageHotspot"
};
const CROP_FIELD = {
  name: "crop",
  type: "sanity.imageCrop"
};
const OVERRIDABLE_FIELDS$5 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const IMAGE_CORE = {
  name: "image",
  title: "Image",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS = {};
const ImageType = {
  get() {
    return IMAGE_CORE;
  },
  extend(rawSubTypeDef, createMemberType) {
    const options = {
      ...(rawSubTypeDef.options || DEFAULT_OPTIONS)
    };
    let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];
    if (!options.hotspot) {
      hotspotFields = hotspotFields.map(field => ({
        ...field,
        hidden: true
      }));
    }
    const fields = [ASSET_FIELD, ...hotspotFields, ...(rawSubTypeDef.fields || [])];
    const subTypeDef = {
      ...rawSubTypeDef,
      fields
    };
    const parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
      type: IMAGE_CORE,
      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
      options,
      fields: subTypeDef.fields.map(fieldDef => {
        const {
          name,
          fieldset,
          ...rest
        } = fieldDef;
        const compiledField = {
          name,
          fieldset,
          isCustomized: Boolean(rawSubTypeDef.fields)
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType({
            ...rest,
            title: fieldDef.title || startCase(name)
          });
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "image"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$5), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$4 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const NUMBER_CORE = {
  name: "number",
  title: "Number",
  type: null,
  jsonType: "number"
};
const NumberType = {
  get() {
    return NUMBER_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(NUMBER_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
      type: NUMBER_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$4), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const REF_FIELD = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
const WEAK_FIELD = {
  name: "_weak",
  title: "Weak reference",
  type: "boolean"
};
const REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD];
const OVERRIDABLE_FIELDS$3 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const REFERENCE_CORE = {
  name: "reference",
  title: "Reference",
  type: null,
  jsonType: "object"
};
function humanize(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first = arr.slice(0, len - 1);
  const last = arr[len - 1];
  return "".concat(first.join(", "), " ").concat(conjunction, " ").concat(last);
}
function buildTitle(type) {
  if (!type.to || type.to.length === 0) {
    return "Reference";
  }
  return "Reference to ".concat(humanize(arrify(type.to).map(toType => toType.title), "or").toLowerCase());
}
const ReferenceType = {
  get() {
    return REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error('Missing "to" field in reference definition. Check the type '.concat(subTypeDef.name));
    }
    const parsed = Object.assign(pick(REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
      type: REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS.map(fieldDef => {
        const {
          name,
          ...type
        } = fieldDef;
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "to", () => {
      return arrify(subTypeDef.to).map(toType => createMemberType(toType));
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$3), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$2 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const STRING_CORE = {
  name: "string",
  title: "String",
  type: null,
  jsonType: "string"
};
const StringType = {
  get() {
    return STRING_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(STRING_CORE, OVERRIDABLE_FIELDS$2), subTypeDef, {
      type: STRING_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$2), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$1 = [...DEFAULT_OVERRIDEABLE_FIELDS, "rows"];
const TEXT_CORE = {
  name: "text",
  title: "Text",
  type: null,
  jsonType: "string"
};
const TextType = {
  get() {
    return TEXT_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(TEXT_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
      type: TEXT_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS];
const URL_CORE = {
  name: "url",
  title: "Url",
  type: null,
  jsonType: "string"
};
const UrlType = {
  get() {
    return URL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(URL_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
      type: URL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  any: AnyType,
  array: ArrayType,
  block: BlockType,
  boolean: BooleanType,
  crossDatasetReference: CrossDatasetReferenceType,
  date: DateType,
  datetime: DateTimeType,
  document: DocumentType,
  email: EmailType,
  file: FileType,
  image: ImageType,
  number: NumberType,
  object: ObjectType,
  reference: ReferenceType,
  span: SpanType,
  string: StringType,
  text: TextType,
  url: UrlType
});
function compileRegistry(schemaDef) {
  const registry = Object.assign( /* @__PURE__ */Object.create(null), types);
  const defsByName = schemaDef.types.reduce((acc, def) => {
    if (acc[def.name]) {
      throw new Error("Duplicate type name added to schema: ".concat(def.name));
    }
    acc[def.name] = def;
    return acc;
  }, {});
  schemaDef.types.forEach(add);
  return registry;
  function ensure(typeName) {
    if (!registry[typeName]) {
      if (!defsByName[typeName]) {
        throw new Error("Unknown type: ".concat(typeName));
      }
      add(defsByName[typeName]);
    }
  }
  function extendMember(memberDef) {
    ensure(memberDef.type);
    return registry[memberDef.type].extend(memberDef, extendMember).get();
  }
  function add(typeDef) {
    ensure(typeDef.type);
    if (registry[typeDef.name]) {
      return;
    }
    registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
  }
}
let Schema$1 = class Schema {
  static compile(schemaDef) {
    return new Schema(schemaDef);
  }
  constructor(schemaDef) {
    this._original = schemaDef;
    this._registry = compileRegistry(schemaDef);
  }
  get name() {
    return this._original.name;
  }
  get(name) {
    return this._registry[name] && this._registry[name].get();
  }
  has(name) {
    return name in this._registry;
  }
  getTypeNames() {
    return Object.keys(this._registry);
  }
};
class DeprecatedDefaultSchema extends Schema$1 {
  static compile(schemaDef) {
    return new DeprecatedDefaultSchema(schemaDef);
  }
  constructor(schemaDef) {
    super(schemaDef);
    const stack = new Error('The default export of `@sanity/schema` is deprecated. Use `import {Schema} from "@sanity/schema"` instead.').stack.replace(/^Error/, "Warning");
    console.warn(stack);
  }
}
const Schema = Schema$1;
export { Schema, DeprecatedDefaultSchema as default };
//# sourceMappingURL=index.esm.js.map
