'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
require('@sanity/generate-help-url');
var difference = require('lodash/difference.js');
var resolve = require('../_chunks/resolve-BRccvP_d.js');
var flatten = require('lodash/flatten.js');
var get = require('lodash/get.js');
var uniq = require('lodash/uniq.js');
var humanizeList = require('humanize-list');
var partition = require('lodash/partition.js');
var isPlainObject = require('lodash/isPlainObject.js');
var omit = require('lodash/omit.js');
var leven = require('leven');
var inspect = require('object-inspect');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var difference__default = /*#__PURE__*/_interopDefaultCompat(difference);
var flatten__default = /*#__PURE__*/_interopDefaultCompat(flatten);
var get__default = /*#__PURE__*/_interopDefaultCompat(get);
var uniq__default = /*#__PURE__*/_interopDefaultCompat(uniq);
var humanizeList__default = /*#__PURE__*/_interopDefaultCompat(humanizeList);
var partition__default = /*#__PURE__*/_interopDefaultCompat(partition);
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var omit__default = /*#__PURE__*/_interopDefaultCompat(omit);
var leven__default = /*#__PURE__*/_interopDefaultCompat(leven);
var inspect__default = /*#__PURE__*/_interopDefaultCompat(inspect);
const ACTIONS_FLAG = "__experimental_actions";
const DEFAULT_ACTIONS = ["create", "update", "delete", "publish"];
const VALID_ACTIONS = DEFAULT_ACTIONS;
const readActions = schemaType => {
  return ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS;
};
const validateActions = (typeName, actions) => {
  if (!Array.isArray(actions)) {
    throw new Error("The value of <type>.".concat(ACTIONS_FLAG, " should be an array with any of the actions ").concat(VALID_ACTIONS.join(", ")));
  }
  const invalid = difference__default.default(actions, VALID_ACTIONS);
  if (invalid.length > 0) {
    throw new Error("Invalid action".concat(invalid.length > 1 ? "s" : "", ' configured for schema type "').concat(typeName, '": ').concat(invalid.join(", "), ". Valid actions are: ").concat(VALID_ACTIONS.join(", ")));
  }
  return actions;
};
const resolveEnabledActions = schemaType => validateActions(schemaType.name, readActions(schemaType));
const isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action);
const HELP_IDS = {
  TYPE_INVALID: "schema-type-invalid",
  TYPE_IS_ESM_MODULE: "schema-type-is-esm-module",
  TYPE_NAME_RESERVED: "schema-type-name-reserved",
  TYPE_MISSING_NAME: "schema-type-missing-name-or-type",
  TYPE_MISSING_TYPE: "schema-type-missing-name-or-type",
  TYPE_TITLE_RECOMMENDED: "schema-type-title-is-recommended",
  TYPE_TITLE_INVALID: "schema-type-title-is-recommended",
  OBJECT_FIELDS_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_NOT_UNIQUE: "schema-object-fields-invalid",
  OBJECT_FIELD_NAME_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_DEFINITION_INVALID_TYPE: "schema-object-fields-invalid",
  ARRAY_PREDEFINED_CHOICES_INVALID: "schema-predefined-choices-invalid",
  ARRAY_OF_ARRAY: "schema-array-of-array",
  ARRAY_OF_INVALID: "schema-array-of-invalid",
  ARRAY_OF_NOT_UNIQUE: "schema-array-of-invalid",
  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: "schema-array-of-type-global-type-conflict",
  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: "schema-array-of-type-builtin-type-conflict",
  REFERENCE_TO_INVALID: "schema-reference-to-invalid",
  REFERENCE_TO_NOT_UNIQUE: "schema-reference-to-invalid",
  REFERENCE_INVALID_OPTIONS: "schema-reference-invalid-options",
  REFERENCE_INVALID_OPTIONS_LOCATION: "schema-reference-options-nesting",
  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: "schema-reference-filter-params-combination",
  SLUG_SLUGIFY_FN_RENAMED: "slug-slugifyfn-renamed",
  ASSET_METADATA_FIELD_INVALID: "asset-metadata-field-invalid",
  CROSS_DATASET_REFERENCE_INVALID: "cross-dataset-reference-invalid",
  DEPRECATED_BLOCKEDITOR_KEY: "schema-deprecated-blockeditor-key",
  STANDALONE_BLOCK_TYPE: "schema-standalone-block-type"
};
function createValidationResult(severity, message, helpId) {
  if (helpId && !Object.keys(HELP_IDS).some(id => HELP_IDS[id] === helpId)) {
    throw new Error('Used the unknown helpId "'.concat(helpId, '", please add it to the array in createValidationResult.js'));
  }
  return {
    severity,
    message,
    helpId
  };
}
const error = (message, helpId) => createValidationResult("error", message, helpId);
const warning = (message, helpId) => createValidationResult("warning", message, helpId);
function groupProblems(types) {
  return flatten__default.default(types.map(type => getTypeProblems(type))).filter(type => type.problems.length > 0);
}
function createTypeWithMembersProblemsAccessor(memberPropertyName) {
  let getMembers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : type => get__default.default(type, memberPropertyName);
  return function getProblems(type, parentPath) {
    const currentPath = [...parentPath, {
      kind: "type",
      type: type.type,
      name: type.name
    }];
    const members = getMembers(type) || [];
    const memberProblems = Array.isArray(members) ? members.map(memberType => {
      const propertySegment = {
        kind: "property",
        name: memberPropertyName
      };
      const memberPath = [...currentPath, propertySegment];
      return getTypeProblems(memberType, memberPath);
    }) : [[{
      path: currentPath,
      problems: [error("Member declaration (".concat(memberPropertyName, ") is not an array"))]
    }]];
    return [{
      path: currentPath,
      problems: type._problems || []
    }, ...flatten__default.default(memberProblems)];
  };
}
const arrify = val => Array.isArray(val) ? val : typeof val === "undefined" && [] || [val];
const getObjectProblems = createTypeWithMembersProblemsAccessor("fields");
const getImageProblems = createTypeWithMembersProblemsAccessor("fields");
const getFileProblems = createTypeWithMembersProblemsAccessor("fields");
const getArrayProblems = createTypeWithMembersProblemsAccessor("of");
const getReferenceProblems = createTypeWithMembersProblemsAccessor("to", type => "to" in type ? arrify(type.to) : []);
const getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor("marks.annotations");
const getBlockMemberProblems = createTypeWithMembersProblemsAccessor("of");
const getBlockProblems = (type, problems) => [...getBlockAnnotationProblems(type, problems), ...getBlockMemberProblems(type, problems)];
function getDefaultProblems(type) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return [{
    path: [...path, {
      kind: "type",
      type: type.type,
      name: type.name
    }],
    problems: type._problems || []
  }];
}
function getTypeProblems(type) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  switch (type.type) {
    case "object":
      {
        return getObjectProblems(type, path);
      }
    case "document":
      {
        return getObjectProblems(type, path);
      }
    case "array":
      {
        return getArrayProblems(type, path);
      }
    case "reference":
      {
        return getReferenceProblems(type, path);
      }
    case "block":
      {
        return getBlockProblems(type, path);
      }
    case "image":
      {
        return getImageProblems(type, path);
      }
    case "file":
      {
        return getFileProblems(type, path);
      }
    default:
      {
        return getDefaultProblems(type, path);
      }
  }
}
function getDupes(array) {
  let selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;
  const dupes = array.reduce((acc, item) => {
    const key = selector(item);
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(item);
    return acc;
  }, {});
  return Object.keys(dupes).map(key => dupes[key].length > 1 ? dupes[key] : null).filter(Boolean);
}
const NOOP_VISITOR = typeDef => typeDef;
const TYPE_TYPE = {
  name: "type",
  type: null
};
const FUTURE_RESERVED = ["any", "time", "date"];
function traverseSchema() {
  let types = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let coreTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let visitor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP_VISITOR;
  const coreTypesRegistry = /* @__PURE__ */Object.create(null);
  const registry = /* @__PURE__ */Object.create(null);
  const coreTypeNames = coreTypes.map(typeDef => typeDef.name);
  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames);
  const typeNames = types.map(typeDef => typeDef && typeDef.name).filter(Boolean);
  coreTypes.forEach(coreType => {
    coreTypesRegistry[coreType.name] = coreType;
  });
  types.forEach((type, i) => {
    registry[type && type.name || "__unnamed_".concat(i)] = {};
  });
  function getType(typeName) {
    return typeName === "type" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;
  }
  const duplicateNames = uniq__default.default(flatten__default.default(getDupes(typeNames)));
  function isDuplicate(typeName) {
    return duplicateNames.includes(typeName);
  }
  function getTypeNames() {
    return typeNames.concat(coreTypeNames);
  }
  function isReserved(typeName) {
    return typeName === "type" || reservedTypeNames.includes(typeName);
  }
  const visitType = isRoot => (typeDef, index) => {
    return visitor(typeDef, {
      visit: visitType(false),
      isRoot,
      getType,
      getTypeNames,
      isReserved,
      isDuplicate,
      index
    });
  };
  coreTypes.forEach(coreTypeDef => {
    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
  });
  types.forEach((typeDef, i) => {
    Object.assign(registry[typeDef && typeDef.name || "__unnamed_".concat(i)], visitType(true)(typeDef, i));
  });
  return {
    get(typeName) {
      const res = registry[typeName] || coreTypesRegistry[typeName];
      if (res) {
        return res;
      }
      throw new Error("No such type: ".concat(typeName));
    },
    has(typeName) {
      return typeName in registry || typeName in coreTypesRegistry;
    },
    getTypeNames() {
      return Object.keys(registry);
    },
    getTypes() {
      return this.getTypeNames().map(this.get);
    },
    toJSON() {
      return this.getTypes();
    }
  };
}
const coreTypes = [{
  name: "array",
  jsonType: "array",
  type: "type"
}, {
  name: "block",
  jsonType: "object",
  type: "type"
}, {
  name: "boolean",
  jsonType: "boolean",
  type: "type"
}, {
  name: "datetime",
  jsonType: "string",
  type: "type"
}, {
  name: "date",
  jsonType: "string",
  type: "type"
}, {
  name: "document",
  jsonType: "object",
  type: "type"
}, {
  name: "email",
  jsonType: "string",
  type: "type"
}, {
  name: "file",
  jsonType: "object",
  type: "type"
}, {
  name: "geopoint",
  jsonType: "object",
  type: "type"
}, {
  name: "image",
  jsonType: "object",
  type: "type"
}, {
  name: "number",
  jsonType: "number",
  type: "type"
}, {
  name: "object",
  jsonType: "object",
  type: "type"
}, {
  name: "reference",
  jsonType: "object",
  type: "type"
}, {
  name: "crossDatasetReference",
  jsonType: "object",
  type: "type"
}, {
  name: "slug",
  jsonType: "object",
  type: "type"
}, {
  name: "span",
  jsonType: "object",
  type: "type"
}, {
  name: "string",
  jsonType: "string",
  type: "type"
}, {
  name: "telephone",
  jsonType: "string",
  type: "type"
}, {
  name: "text",
  jsonType: "string",
  type: "type"
}, {
  name: "url",
  jsonType: "string",
  type: "type"
}];
const coreTypeNames = coreTypes.map(t => t.name);
function traverseSanitySchema(schemaTypes, visitor) {
  return traverseSchema(schemaTypes, coreTypes, visitor);
}
function isPrimitiveTypeName(typeName) {
  return typeName === "string" || typeName === "number" || typeName === "boolean";
}
function isAssignable(typeName, type) {
  return (typeof type.name === "string" ? type.name : type.type) === typeName;
}
function quote$2(n) {
  return '"'.concat(n, '"');
}
function pluralize(arr) {
  let suf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "s";
  return arr.length === 1 ? "" : suf;
}
function format(value) {
  if (Array.isArray(value)) {
    return "array with ".concat(value.length, " entries");
  }
  if (typeof value === "object" && value !== null) {
    return "object with keys ".concat(humanizeList__default.default(Object.keys(value).map(quote$2)));
  }
  return quote$2(value);
}
var array = (typeDef, visitorContext) => {
  var _a, _b, _c;
  const ofIsArray = Array.isArray(typeDef.of);
  if (ofIsArray) {
    const invalid = typeDef.of.reduce((errs, def, idx) => {
      if (typeof def.name === "string") {
        if (
        // specifying the same name as the type is redundant, but should not be a hard error at this point
        // Consider showing a warning for this and deprecate this ability eventually
        def.name !== def.type && coreTypeNames.includes(def.name)) {
          return errs.concat(error('Found array member declaration with the same type name as a built-in type ("'.concat(def.name, '"). Array members can not be given the same name as a built-in type.'), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
        }
      }
      if (def.type === "object" && def.name && visitorContext.getType(def.name)) {
        return errs.concat(warning('Found array member declaration with the same name as the global schema type "'.concat(def.name, "\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name."), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
      }
      if (def.type === "array") {
        return errs.concat(error('Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity', HELP_IDS.ARRAY_OF_ARRAY));
      }
      if (def) {
        return errs;
      }
      const err = "Found ".concat(def === null ? "null" : typeof def, ", expected member declaration");
      return errs.concat(error("Found invalid type member declaration in array at index ".concat(idx, ": ").concat(err), HELP_IDS.ARRAY_OF_INVALID));
    }, []);
    if (invalid.length > 0) {
      return {
        ...typeDef,
        of: [],
        _problems: invalid
      };
    }
  }
  const problems = flatten__default.default([ofIsArray ? getDupes(typeDef.of, t => "".concat(t.name, ";").concat(t.type)).map(dupes => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in array. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.ARRAY_OF_NOT_UNIQUE)) : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID)]);
  const of = ofIsArray ? typeDef.of : [];
  const hasObjectTypesWithoutName = of.some(type => type.type === "object" && typeof type.name === "undefined");
  const hasBlockType = of.some(ofType => ofType.type === "block");
  if (hasBlockType && hasObjectTypesWithoutName) {
    problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
  }
  const [primitiveTypes, objectTypes] = partition__default.default(of, ofType => {
    var _a2;
    return isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName((_a2 = visitorContext.getType(ofType.type)) == null ? void 0 : _a2.jsonType);
  });
  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;
  if (isMixedArray) {
    const primitiveTypeNames = primitiveTypes.map(t => t.type);
    const objectTypeNames = objectTypes.map(t => t.type);
    problems.push(error("The array type's 'of' property can't have both object types and primitive types (found primitive type ".concat(pluralize(primitiveTypeNames), " ").concat(humanizeList__default.default(primitiveTypeNames.map(quote$2)), " and object type").concat(pluralize(objectTypeNames), " ").concat(humanizeList__default.default(objectTypeNames.map(quote$2)), ")"), HELP_IDS.ARRAY_OF_INVALID));
  }
  const list = (_a = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _a.list;
  if (!isMixedArray && Array.isArray(list)) {
    const isArrayOfPrimitives = primitiveTypes.length > 0;
    if (isArrayOfPrimitives) {
      list.forEach(option => {
        var _a2;
        const value = (_a2 = option == null ? void 0 : option.value) != null ? _a2 : option;
        const isDeclared = primitiveTypes.some(primitiveType => {
          return typeof value === visitorContext.getType(primitiveType.type).jsonType;
        });
        if (!isDeclared) {
          const formattedTypeList = humanizeList__default.default(primitiveTypes.map(t => t.name || t.type), {
            conjunction: "or"
          });
          problems.push(error("An invalid entry found in options.list: ".concat(format(value), ". Must be either a value of type ").concat(formattedTypeList, ", or an object with {title: string, value: ").concat(formattedTypeList, "}"), HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
        }
      });
    } else {
      list.forEach(option => {
        const optionTypeName = option._type || "object";
        const isDeclared = objectTypes.some(validObjectType => isAssignable(optionTypeName, validObjectType));
        if (!isDeclared) {
          problems.push(error("An invalid entry found in options.list: ".concat(format(option), '. Must be an object with "_type" set to ').concat(humanizeList__default.default(objectTypes.map(t => t.name || t.type).map(t => t === "object" ? "undefined" : quote$2(t)), {
            conjunction: "or"
          })), HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
        }
      });
    }
  }
  if (((_b = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _b.list) && ((_c = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _c.layout) === "tags") {
    problems.push(warning("Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`."));
  }
  return {
    ...typeDef,
    of: of.map(visitorContext.visit),
    _problems: problems
  };
};
function isJSONTypeOf(type, jsonType, visitorContext) {
  if ("jsonType" in type) {
    return type.jsonType === jsonType;
  }
  const parentType = visitorContext.getType(type.type);
  if (!parentType) {
    throw new Error("Could not resolve jsonType of ".concat(type.name, ". No parent type found"));
  }
  return isJSONTypeOf(parentType, jsonType, visitorContext);
}
const getTypeOf = thing => Array.isArray(thing) ? "array" : typeof thing;
const quote$1 = str => '"'.concat(str, '"');
const allowedKeys = ["components", "lists", "marks", "name", "of", "options", "styles", "title", "type", "validation"];
const allowedMarkKeys = ["decorators", "annotations"];
const allowedStyleKeys = ["blockEditor", "title", "value", "component"];
const allowedDecoratorKeys = ["blockEditor", "title", "value", "icon", "component"];
const allowedListKeys = ["title", "value", "icon", "component"];
const supportedBuiltInObjectTypes = ["file", "image", "object", "reference"];
function validateBlockType(typeDef, visitorContext) {
  const problems = [];
  let styles = typeDef.styles;
  let lists = typeDef.lists;
  let marks = typeDef.marks;
  let members = typeDef.of;
  const disallowedKeys = Object.keys(typeDef).filter(key => !allowedKeys.includes(key) && !key.startsWith("_"));
  if (disallowedKeys.length > 0) {
    problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList__default.default(disallowedKeys.map(quote$1)))));
  }
  if (marks) {
    marks = validateMarks(typeDef.marks, visitorContext, problems);
  }
  if (styles) {
    styles = validateStyles(styles, visitorContext, problems);
  }
  if (lists) {
    lists = validateLists(lists, visitorContext, problems);
  }
  if (members) {
    members = validateMembers(members, visitorContext, problems);
  }
  return {
    ...omit__default.default(typeDef, disallowedKeys),
    marks,
    styles,
    name: typeDef.name || typeDef.type,
    of: members,
    _problems: problems
  };
}
function validateMarks(marks, visitorContext, problems) {
  let decorators = marks.decorators;
  let annotations = marks.annotations;
  if (!isPlainObject__default.default(marks)) {
    problems.push(error('"marks" declaration should be an object, got '.concat(getTypeOf(marks))));
    return problems;
  }
  const disallowedMarkKeys = Object.keys(marks).filter(key => !allowedMarkKeys.includes(key) && !key.startsWith("_"));
  if (disallowedMarkKeys.length > 0) {
    problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList__default.default(disallowedMarkKeys.map(quote$1)))));
  }
  if (decorators && !Array.isArray(decorators)) {
    problems.push(error('"marks.decorators" declaration should be an array, got '.concat(getTypeOf(decorators))));
  } else if (decorators) {
    decorators.filter(dec => !!dec.blockEditor).forEach(dec => {
      dec.icon = dec.blockEditor.icon;
      dec.component = dec.blockEditor.render;
    });
    decorators = validateDecorators(decorators, visitorContext, problems);
  }
  if (annotations && !Array.isArray(annotations)) {
    problems.push(error('"marks.annotations" declaration should be an array, got '.concat(getTypeOf(annotations))));
  } else if (annotations) {
    annotations = validateAnnotations(annotations, visitorContext, problems);
  }
  return {
    ...marks,
    decorators,
    annotations
  };
}
function validateLists(lists, visitorContext, problems) {
  if (!Array.isArray(lists)) {
    problems.push(error('"lists" declaration should be an array, got '.concat(getTypeOf(lists))));
    return problems;
  }
  lists.forEach((list, index) => {
    if (!isPlainObject__default.default(list)) {
      problems.push(error("List must be an object, got ".concat(getTypeOf(list))));
      return;
    }
    const name = list.value || "#".concat(index);
    const disallowedKeys = Object.keys(list).filter(key => !allowedListKeys.includes(key) && !key.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for list ".concat(name, ": ").concat(humanizeList__default.default(disallowedKeys.map(quote$1)))));
    }
    if (!list.value) {
      problems.push(error("List #".concat(index, ' is missing required "value" property')));
    } else if (typeof list.value !== "string") {
      problems.push(error("List type #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(list.value))));
    } else if (!list.title) {
      problems.push(warning("List type ".concat(name, ' is missing recommended "title" property')));
    }
  });
  return lists;
}
function validateStyles(styles, visitorContext, problems) {
  if (!Array.isArray(styles)) {
    problems.push(error('"styles" declaration should be an array, got '.concat(getTypeOf(styles))));
    return problems;
  }
  styles.forEach((style, index) => {
    if (!isPlainObject__default.default(style)) {
      problems.push(error("Style must be an object, got ".concat(getTypeOf(style))));
      return;
    }
    const name = style.value || "#".concat(index);
    const disallowedKeys = Object.keys(style).filter(key => !allowedStyleKeys.includes(key) && !key.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for style ".concat(name, ": ").concat(humanizeList__default.default(disallowedKeys.map(quote$1)))));
    }
    if (!style.value) {
      problems.push(error("Style #".concat(index, ' is missing required "value" property')));
    } else if (typeof style.value !== "string") {
      problems.push(error("Style #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(style.value))));
    } else if (!style.title) {
      problems.push(warning("Style ".concat(name, ' is missing recommended "title" property')));
    }
    if (typeof style.blockEditor !== "undefined") {
      problems.push(warning('Style has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      style.component = style.component || style.blockEditor.render;
    }
  });
  return styles;
}
function validateDecorators(decorators, visitorContext, problems) {
  decorators.forEach((decorator, index) => {
    if (!isPlainObject__default.default(decorator)) {
      problems.push(error("Annotation must be an object, got ".concat(getTypeOf(decorator))));
      return;
    }
    const name = decorator.value || "#".concat(index);
    const disallowedKeys = Object.keys(decorator).filter(key => !allowedDecoratorKeys.includes(key) && !key.startsWith("_"));
    if (disallowedKeys.length > 0) {
      problems.push(error("Found unknown properties for decorator ".concat(name, ": ").concat(humanizeList__default.default(disallowedKeys.map(quote$1)))));
    }
    if (!decorator.value) {
      problems.push(error("Decorator #".concat(index, ' is missing required "value" property')));
    } else if (typeof decorator.value !== "string") {
      problems.push(error("Decorator #".concat(index, ' has an invalid "value" property, expected string, got ').concat(getTypeOf(decorator.value))));
    } else if (!decorator.title) {
      problems.push(warning("Decorator ".concat(name, ' is missing recommended "title" property')));
    }
    if (typeof decorator.blockEditor !== "undefined") {
      problems.push(warning('Decorator "'.concat(name, '" has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.'), HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      decorator.icon = decorator.icon || decorator.blockEditor.icon;
      decorator.component = decorator.component || decorator.blockEditor.render;
    }
  });
  return decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
  return annotations.map(annotation => {
    var _a, _b;
    if (!isPlainObject__default.default(annotation)) {
      return {
        ...annotation,
        _problems: [error("Annotation must be an object, got ".concat(getTypeOf(annotation)))]
      };
    }
    const {
      _problems
    } = visitorContext.visit(annotation, visitorContext);
    const targetType = annotation.type && visitorContext.getType(annotation.type);
    if (targetType && !isJSONTypeOf(targetType, "object", visitorContext)) {
      _problems.push(error('Annotation cannot have type "'.concat(annotation.type, '" - annotation types must inherit from object')));
    }
    if (typeof annotation.blockEditor !== "undefined") {
      problems.push(warning('Annotation has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY));
      annotation.icon = annotation.icon || annotation.blockEditor.icon;
      if (((_a = annotation.blockEditor) == null ? void 0 : _a.render) && !((_b = annotation.components) == null ? void 0 : _b.annotation)) {
        annotation.components = annotation.components || {};
        annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render;
      }
    }
    return {
      ...annotation,
      _problems
    };
  });
}
function validateMembers(members, visitorContext, problems) {
  if (!Array.isArray(members)) {
    problems.push(error('"of" declaration should be an array, got '.concat(getTypeOf(members))));
    return void 0;
  }
  return members.map(member => {
    const {
      _problems
    } = visitorContext.visit(member, visitorContext);
    if (member.type === "object" && member.name && visitorContext.getType(member.name)) {
      return {
        ...member,
        _problems: [warning('Found array member declaration with the same name as the global schema type "'.concat(member.name, "\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name."), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT)]
      };
    }
    let type = member;
    while (type && !type.jsonType) {
      type = visitorContext.getType(type.type);
    }
    const nonObjectCoreTypes = coreTypeNames.filter(n => !supportedBuiltInObjectTypes.includes(n));
    if (
    // Must be object-like type (to validate hoisted types)
    type && type.jsonType !== "object" ||
    // Can't be a core type, or core object type that isn't supported (like 'span')
    nonObjectCoreTypes.some(coreName => coreName === member.type)) {
      return {
        ...member,
        _problems: [error("Block member types must be a supported object-like type. The following built-in types are supported: '".concat(supportedBuiltInObjectTypes.join("', '"), "'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}"), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT)]
      };
    }
    return {
      ...member,
      _problems
    };
  });
}
function validateNonObjectFieldsProp(typeDef, visitorContext) {
  if (!("fields" in typeDef)) {
    return [];
  }
  let type = typeDef;
  while (type && !type.jsonType) {
    type = visitorContext.getType(type.type);
  }
  if (type && type.jsonType !== "object") {
    return [error('Type has propery "fields", but is not an object/document type.')];
  }
  return [];
}
const quote = str => '"'.concat(str, '"');
function validateTypeName(typeName, visitorContext) {
  const possibleTypeNames = visitorContext.getTypeNames();
  if (!typeName) {
    return [error("Type is missing a type.", HELP_IDS.TYPE_MISSING_TYPE)];
  }
  if (typeof typeName !== "string") {
    return [error('Type has an invalid "type"-property - should be a string.', HELP_IDS.TYPE_MISSING_TYPE)];
  }
  const isValid = possibleTypeNames.includes(typeName);
  if (!isValid) {
    const suggestions = possibleTypeNames.map(possibleTypeName => {
      return [leven__default.default(typeName, possibleTypeName), possibleTypeName];
    }).filter(_ref => {
      let [distance] = _ref;
      return distance < 3;
    }).map(_ref2 => {
      let [_, name] = _ref2;
      return name;
    });
    const suggestion = suggestions.length > 0 ? " Did you mean ".concat(humanizeList__default.default(suggestions.map(quote), {
      conjunction: "or"
    }), "?") : "";
    return [error("Unknown type: ".concat(typeName, ".").concat(suggestion))];
  }
  return [];
}
function validateDeprecatedProperties(type) {
  var _a, _b, _c;
  const warnings = [];
  if (type == null ? void 0 : type.inputComponent) {
    warnings.push(warning('The "inputComponent" property is deprecated. Use "components.input" instead.'));
  }
  if ((_a = type == null ? void 0 : type.preview) == null ? void 0 : _a.component) {
    warnings.push(warning('The "preview.component" property is deprecated. Use "components.preview" instead.'));
  }
  if (type == null ? void 0 : type.diffComponent) {
    warnings.push(warning('The "diffComponent" property is deprecated. Use "components.diff" instead.'));
  }
  if ((_b = type == null ? void 0 : type.options) == null ? void 0 : _b.editModal) {
    warnings.push(warning('The "options.editModal" property is deprecated. Use "options.modal" instead.'));
  }
  if ((_c = type == null ? void 0 : type.options) == null ? void 0 : _c.isHighlighted) {
    warnings.push(warning('The "options.isHighlighted" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.'));
  }
  return warnings;
}
var common = (typeDef, visitorContext) => {
  return {
    ...typeDef,
    _problems: [...validateTypeName(typeDef.type, visitorContext), ...validateNonObjectFieldsProp(typeDef, visitorContext), ...validateDeprecatedProperties(typeDef)].filter(Boolean)
  };
};
function normalizeToProp$1(typeDef) {
  if (Array.isArray(typeDef.to)) {
    return typeDef.to;
  }
  return typeDef.to ? [typeDef.to] : typeDef.to;
}
const VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
  const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name);
  return isValid || 'The provided dataset "'.concat(name, "\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore");
}
var crossDatasetReference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject__default.default(typeDef.to);
  const normalizedTo = normalizeToProp$1(typeDef);
  const problems = flatten__default.default([isValidTo ? getDupes(normalizedTo, t => "".concat(t.name, ";").concat(t.type)).map(dupes => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in reference. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)) : error('The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)]);
  if (isValidTo && normalizedTo.length === 0) {
    problems.push(error('The cross dataset reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  normalizedTo.forEach((crossDatasetTypeDef, index) => {
    if (!crossDatasetTypeDef.type) {
      problems.push(error("The referenced type at index ".concat(index, " must be named. Specify the name of the type you want to create references to."), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (!isPlainObject__default.default(crossDatasetTypeDef.preview)) {
      problems.push(error('Missing required preview config for the referenced type "'.concat(crossDatasetTypeDef.type || "<unknown type>", '"'), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
  });
  if (typeof typeDef.dataset === "string") {
    const datasetValidation = isValidDatasetName(typeDef.dataset);
    if (datasetValidation !== true) {
      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
  } else {
    problems.push(error("A cross dataset reference must specify a `dataset`", HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  if (typeDef.studioUrl && typeof typeDef.studioUrl !== "function") {
    problems.push(error('The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  }
  problems.push(...getOptionErrors$1(typeDef));
  return {
    ...typeDef,
    _problems: problems
  };
};
function getOptionErrors$1(typeDef) {
  const {
    options
  } = typeDef;
  const problems = [];
  problems.push(...["filter", "filterParams"].filter(key => key in typeDef).map(key => error("`".concat(key, "` is not allowed on a reference type definition - did you mean `options.").concat(key, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
  if (!options) {
    return problems;
  }
  if (!isPlainObject__default.default(options)) {
    return problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS));
  }
  if (typeof options.filter === "function" && typeof options.filterParams !== "undefined") {
    return problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
  }
  if (typeof options.filter === "function" || !options.filter && !options.filterParams) {
    return problems;
  }
  if (typeof options.filter !== "string") {
    return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
  }
  if (typeof options.filterParams !== "undefined" && !isPlainObject__default.default(options.filterParams)) {
    return problems.concat(error("If set, `filterParams` must be an object."));
  }
  if (options.filterParams) {
    return problems.concat(Object.keys(options.filterParams).filter(key => key.startsWith("__") || key.startsWith("$")).map(key => error('Filter parameter cannot be prefixed with "$" or "__". Got '.concat(key, '".'))));
  }
  return problems;
}
const REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isComponentLike(value) {
  const type = typeof value;
  return type === "function" || typeof (value == null ? void 0 : value.$$typeof) === "symbol" && REACT_SYM_RE.test(String(value == null ? void 0 : value.$$typeof));
}
function validateComponent(typeDef) {
  const components = "components" in typeDef ? typeDef.components : false;
  if (!components) {
    return [];
  }
  const warnings = [];
  if (components.input && !isComponentLike(components.input)) {
    warnings.push(warning("The `components.input` property is set but does not appear to be a valid React component (expected a function, but saw ".concat(inspect__default.default(components.input), "). If you have imported a custom input component, please verify that you have imported the correct named/default export.")));
  }
  if (components.field && !isComponentLike(components.field)) {
    warnings.push(warning("The `components.field` property is set but does not appear to be a valid React component (expected a function, but saw ".concat(inspect__default.default(components.field), "). If you have imported a custom field component, please verify that you have imported the correct named/default export.")));
  }
  if (components.item && !isComponentLike(components.item)) {
    warnings.push(warning("The `components.item` property is set but does not appear to be a valid React component (expected a function, but saw ".concat(inspect__default.default(components.item), "). If you have imported a custom item component, please verify that you have imported the correct named/default export.")));
  }
  if (components.preview && !isComponentLike(components.preview)) {
    warnings.push(warning("The `components.preview` property is set but does not appear to be a valid React component (expected a function, but saw ".concat(inspect__default.default(components.preview), "). If you have imported a custom preview component, please verify that you have imported the correct named/default export.")));
  }
  return warnings;
}
const VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
const CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
  if (typeof name !== "string") {
    return [error('Field names must be strings. Saw "'.concat(inspect__default.default(name), '"'), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (name.startsWith("_")) {
    return [error('Invalid field name "'.concat(name, '". Field names cannot start with underscores "_" as it\'s reserved for system fields.'), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (!VALID_FIELD_RE.test(name)) {
    return [error('Invalid field name: "'.concat(name, '". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ').concat(String(VALID_FIELD_RE), ")."), HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }
  if (!CONVENTIONAL_FIELD_RE.test(name)) {
    return [warning("Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on."), HELP_IDS.OBJECT_FIELD_NAME_INVALID];
  }
  return [];
}
function validateField(field, _visitorContext) {
  if (!isPlainObject__default.default(field)) {
    return [error("Incorrect type for field definition - should be an object, saw ".concat(inspect__default.default(field)), HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE)];
  }
  const problems = [];
  problems.push(...("name" in field ? validateFieldName(field.name) : [error("Missing field name", HELP_IDS.OBJECT_FIELD_NAME_INVALID)]));
  problems.push(...validateComponent(field));
  return problems;
}
function getDuplicateFields(array) {
  const dupes = {};
  array.forEach(field => {
    if (!dupes[field.name]) {
      dupes[field.name] = [];
    }
    dupes[field.name].push(field);
  });
  return Object.keys(dupes).map(fieldName => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}
function validateFields(fields) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    allowEmpty: false
  };
  const problems = [];
  const fieldsIsArray = Array.isArray(fields);
  if (!fieldsIsArray) {
    return [error('The "fields" property must be an array of fields. Instead saw "'.concat(typeof fields, '"'), HELP_IDS.OBJECT_FIELDS_INVALID)];
  }
  const fieldsWithNames = fields.filter(field => typeof field.name === "string");
  getDuplicateFields(fieldsWithNames).forEach(dupes => {
    problems.push(error("Found ".concat(dupes.length, ' fields with name "').concat(dupes[0].name, '" in object'), HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
  });
  if (fields.length === 0 && !options.allowEmpty) {
    problems.push(error("Object should have at least one field", HELP_IDS.OBJECT_FIELDS_INVALID));
  }
  const standaloneBlockFields = fields.filter(field => field.type === "block").map(field => '"'.concat(field.name, '"'));
  if (standaloneBlockFields.length > 0) {
    const fmtFields = standaloneBlockFields.join(", ");
    problems.push(error("Invalid standalone block field(s) ".concat(fmtFields, ". Block content must be defined as an array of blocks"), HELP_IDS.STANDALONE_BLOCK_TYPE));
  }
  return problems;
}
function validatePreview(preview) {
  if (!isPlainObject__default.default(preview)) {
    return [error('The "preview" property must be an object, instead saw "'.concat(typeof preview, '"'))];
  }
  if (typeof preview.prepare !== "undefined" && typeof preview.prepare !== "function") {
    return [error('The "preview.prepare" property must be a function, instead saw "'.concat(typeof preview.prepare, '"'))];
  }
  if (!preview.select) {
    return [];
  }
  if (!isPlainObject__default.default(preview.select)) {
    return [error('The "preview.select" property must be an object, instead saw "'.concat(typeof preview.prepare, '"'))];
  }
  return Object.keys(preview.select).reduce((errs, key) => {
    return typeof preview.select[key] === "string" ? errs : errs.concat(error('The key "'.concat(key, '" of "preview.select" must be a string, instead saw "').concat(typeof preview.select[key], '"')));
  }, []);
}
var object = (typeDef, visitorContext) => {
  let problems = validateFields(typeDef.fields);
  let preview = typeDef.preview;
  if (preview) {
    const previewErrors = validatePreview(typeDef.preview);
    problems = problems.concat(previewErrors);
    preview = previewErrors.some(err => err.severity === "error") ? {} : preview;
  }
  if (typeDef.type !== "document" && typeDef.type !== "object" && typeof typeDef.initialValue !== "undefined") {
    problems.push(error('The "initialValue" property is currently only supported for document & object types.'));
  }
  return {
    ...typeDef,
    preview,
    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
var documentVisitor = (typeDefinition, visitorContext) => {
  const typeDef = object(typeDefinition, visitorContext);
  const {
    initialValue,
    initialValues
  } = typeDef;
  const hasInitialValue = typeof initialValue !== "undefined";
  if (hasInitialValue && !isPlainObject__default.default(initialValue) && typeof initialValue !== "function") {
    typeDef._problems.push(error('The "initialValue" property must be either a plain object or a function'));
  }
  if (typeof initialValues !== "undefined") {
    typeDef._problems.push(error('Found property "initialValues" - did you mean "initialValue"?'));
  }
  return typeDef;
};
var file = (typeDef, visitorContext) => {
  const problems = [];
  const fields = typeDef.fields;
  if (fields) {
    problems.push(...validateFields(fields, {
      allowEmpty: true
    }));
  }
  const invalidFieldNames = Array.isArray(fields) ? fields == null ? void 0 : fields.filter(field => field.name === "asset") : [];
  if (typeDef.options && typeof typeDef.options.metadata !== "undefined" && !Array.isArray(typeDef.options.metadata)) {
    problems.push(error("Invalid type for file `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
  } else if (invalidFieldNames.length > 0) {
    problems.push(error("The name `asset` is not a valid field name for type `file`."));
  }
  return {
    ...typeDef,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
const autoMeta = ["dimensions", "hasAlpha", "isOpaque"];
var image = (typeDef, visitorContext) => {
  const problems = [];
  const fields = typeDef.fields;
  if (fields) {
    problems.push(...validateFields(fields, {
      allowEmpty: true
    }));
  }
  let options = typeDef.options;
  const metadata = options == null ? void 0 : options.metadata;
  const superfluousMeta = Array.isArray(metadata) ? metadata.filter(meta => autoMeta.includes(meta)) : [];
  const invalidFieldNames = ["asset", "hotspot", "crop"];
  const fieldsWithInvalidName = Array.isArray(fields) ? fields == null ? void 0 : fields.filter(field => invalidFieldNames.includes(field.name)) : [];
  if (typeof metadata !== "undefined" && !Array.isArray(metadata)) {
    problems.push(error("Invalid type for image `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
  } else if (superfluousMeta.length > 0) {
    problems.push(warning("Image `metadata` field contains superfluous properties (they are always included): ".concat(superfluousMeta.join(", "))));
    options = {
      ...options,
      metadata: metadata.filter(meta => !autoMeta.includes(meta))
    };
  } else if (fieldsWithInvalidName.length > 0) {
    problems.push(error("The names `".concat(invalidFieldNames.join("`, `"), "` are invalid field names for type `image`.")));
  }
  return {
    ...typeDef,
    options,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const {
        name,
        ...fieldTypeDef
      } = field;
      const {
        _problems,
        ...fieldType
      } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
function normalizeToProp(typeDef) {
  if (Array.isArray(typeDef.to)) {
    return typeDef.to;
  }
  return typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject__default.default(typeDef.to);
  const normalizedTo = normalizeToProp(typeDef);
  const problems = flatten__default.default([isValidTo ? getDupes(normalizedTo, t => "".concat(t.name, ";").concat(t.type)).map(dupes => error("Found ".concat(dupes.length, ' members with same type, but not unique names "').concat(dupes[0].type, '" in reference. This makes it impossible to tell their values apart and you should consider naming them'), HELP_IDS.REFERENCE_TO_INVALID)) : error('The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.REFERENCE_TO_INVALID)]);
  if (isValidTo && normalizedTo.length === 0) {
    problems.push(error('The reference type should define at least one accepted type. Please check the "to" property.', HELP_IDS.REFERENCE_TO_INVALID));
  }
  problems.push(...getOptionErrors(typeDef));
  return {
    ...typeDef,
    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
    _problems: problems
  };
};
function getOptionErrors(typeDef) {
  const {
    options
  } = typeDef;
  const problems = [];
  problems.push(...["filter", "filterParams"].filter(key => key in typeDef).map(key => error("`".concat(key, "` is not allowed on a reference type definition - did you mean `options.").concat(key, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
  if (!options) {
    return problems;
  }
  if (!isPlainObject__default.default(options)) {
    return problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS));
  }
  if (typeof options.filter === "function" && typeof options.filterParams !== "undefined") {
    return problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
  }
  if (typeof options.filter === "function" || !options.filter && !options.filterParams) {
    return problems;
  }
  if (typeof options.filter !== "string") {
    return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
  }
  if (typeof options.filterParams !== "undefined" && !isPlainObject__default.default(options.filterParams)) {
    return problems.concat(error("If set, `filterParams` must be an object."));
  }
  if (options.filterParams) {
    return problems.concat(Object.keys(options.filterParams).filter(key => key.startsWith("__") || key.startsWith("$")).map(key => error('Filter parameter cannot be prefixed with "$" or "__". Got '.concat(key, '".'))));
  }
  return problems;
}
var rootType = (typeDef, visitorContext) => {
  const hasName = Boolean(typeDef.name);
  if (!hasName && Object.keys(typeDef).length === 1) {
    return {
      ...typeDef,
      _problems: [error("Invalid/undefined type declaration, check declaration or the import/export of the schema type.", HELP_IDS.TYPE_INVALID)]
    };
  }
  const problems = [];
  if (looksLikeEsmModule(typeDef)) {
    problems.push(error("Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property", HELP_IDS.TYPE_IS_ESM_MODULE));
  } else if (!hasName) {
    problems.push(error("Missing type name", HELP_IDS.TYPE_MISSING_NAME));
  } else if (visitorContext.isReserved(typeDef.name)) {
    problems.push(error('Invalid type name: "'.concat(typeDef.name, '" is a reserved name.'), HELP_IDS.TYPE_NAME_RESERVED));
  }
  if (visitorContext.isDuplicate(typeDef.name)) {
    problems.push(error('Invalid type name: A type with name "'.concat(typeDef.name, '" is already defined in the schema.')));
  }
  problems.push(...validateComponent(typeDef));
  if ("title" in typeDef && typeof typeDef.title !== "string") {
    problems.push(warning("Type title is not a string.", HELP_IDS.TYPE_TITLE_INVALID));
  }
  return {
    ...typeDef,
    _problems: problems
  };
};
function looksLikeEsmModule(typeDef) {
  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}
var slug = (typeDef, visitorContext) => {
  const problems = [];
  if (typeDef.options && typeDef.options.slugifyFn) {
    problems.push(warning('Heads up! The "slugifyFn" option has been renamed to "slugify".', HELP_IDS.SLUG_SLUGIFY_FN_RENAMED));
    typeDef.options.slugify = typeDef.options.slugifyFn;
  }
  return {
    ...typeDef,
    _problems: problems
  };
};
const typeVisitors = {
  array,
  object,
  slug,
  file,
  image,
  block: validateBlockType,
  document: documentVisitor,
  reference,
  crossDatasetReference
};
const getNoopVisitor = visitorContext => schemaDef => ({
  name: "<unnamed_type_@_index_".concat(visitorContext.index, ">"),
  ...schemaDef,
  _problems: []
});
function combine() {
  for (var _len = arguments.length, visitors = new Array(_len), _key = 0; _key < _len; _key++) {
    visitors[_key] = arguments[_key];
  }
  return (schemaType, visitorContext) => {
    return visitors.reduce((result, visitor) => {
      const res = visitor(result, visitorContext);
      return {
        ...res,
        _problems: result._problems.concat(res._problems)
      };
    }, {
      _problems: [],
      ...schemaType
    });
  };
}
function validateSchema(schemaTypes) {
  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {
    const typeVisitor = schemaDef && schemaDef.type && typeVisitors[schemaDef.type] || getNoopVisitor(visitorContext);
    if (visitorContext.isRoot) {
      return combine(rootType, common, typeVisitor)(schemaDef, visitorContext);
    }
    return combine(common, typeVisitor)(schemaDef, visitorContext);
  });
}
exports.DEFAULT_MAX_FIELD_DEPTH = resolve.DEFAULT_MAX_FIELD_DEPTH;
exports.resolveSearchConfig = resolve.resolveSearchConfig;
exports.resolveSearchConfigForBaseFieldPaths = resolve.resolveSearchConfigForBaseFieldPaths;
exports.groupProblems = groupProblems;
exports.isActionEnabled = isActionEnabled;
exports.validateSchema = validateSchema;
//# sourceMappingURL=_internal.js.map
