import { typeid } from 'typeid-js';
import { Subject, tap, map, throttle, concatMap, Observable, EMPTY, combineLatest, of, mergeMap, from, catchError, lastValueFrom } from 'rxjs';
export { noopLogger, onPageHide, onVisibilityHidden, registerLifecycleEvents } from './_chunks/noopLogger-b5b1676e.js';
function createSessionId() {
  return typeid("session").toString();
}
function createTraceId() {
  return typeid("trace").toString();
}
function splitAt(str, index) {
  return index < 1 ? [str, ""] : [str.substring(0, index), str.substring(index)];
}
const MAX_LENGTH = 1024;
function trimErrorMessage(errorMessage) {
  const newLineIndex = errorMessage.indexOf("\n");
  const splitIndex = newLineIndex === -1 ? MAX_LENGTH : Math.min(newLineIndex, MAX_LENGTH);
  const [first, rest] = splitAt(errorMessage, splitIndex);
  return first + (rest ? "\u2026 (+".concat(rest.length, ")") : "");
}
function createStore(sessionId) {
  const logEntries$ = new Subject();
  function pushTraceError(traceId, telemetryTrace, error, context) {
    logEntries$.next({
      sessionId,
      type: "trace.error",
      traceId,
      name: telemetryTrace.name,
      version: telemetryTrace.version,
      data: {
        message: trimErrorMessage(error.message)
      },
      context,
      createdAt: /* @__PURE__ */new Date().toISOString()
    });
  }
  function pushTraceEntry(type, traceId, telemetryTrace, data, context) {
    logEntries$.next({
      sessionId,
      type,
      traceId,
      name: telemetryTrace.name,
      version: telemetryTrace.version,
      data,
      context,
      createdAt: /* @__PURE__ */new Date().toISOString()
    });
  }
  function pushLogEntry(type, event, data) {
    logEntries$.next({
      sessionId,
      type,
      version: event.version,
      name: event.name,
      data,
      createdAt: /* @__PURE__ */new Date().toISOString()
    });
  }
  function pushUserPropertiesEntry(properties) {
    logEntries$.next({
      sessionId,
      type: "userProperties",
      properties,
      createdAt: /* @__PURE__ */new Date().toISOString()
    });
  }
  function createTrace(traceId, traceDef, context) {
    return {
      start() {
        pushTraceEntry("trace.start", traceId, traceDef, void 0, context);
      },
      newContext(name) {
        return {
          trace(innerTraceDef) {
            return createTrace("".concat(traceId, ".").concat(name), innerTraceDef, context);
          },
          updateUserProperties() {},
          log
        };
      },
      log(data) {
        pushTraceEntry("trace.log", traceId, traceDef, data, context);
      },
      complete() {
        pushTraceEntry("trace.complete", traceId, traceDef, void 0, context);
      },
      error(error) {
        pushTraceError(traceId, traceDef, error, context);
      },
      await(promise, data) {
        this.start();
        promise.then(result => {
          this.log(data ? data : result);
          this.complete();
          return result;
        }, error => {
          this.error(error);
          throw error;
        });
        return promise;
      }
    };
  }
  function log(event, data) {
    pushLogEntry("log", event, data);
  }
  return {
    events$: logEntries$.asObservable(),
    logger: {
      updateUserProperties(properties) {
        pushUserPropertiesEntry(properties);
      },
      trace: (traceDef, context) => {
        const traceId = createTraceId();
        return createTrace(traceId, traceDef, context);
      },
      log
    }
  };
}
const unrefTimer = ms => new Observable(subscriber => {
  const timeout = setTimeout(() => {
    subscriber.next();
    subscriber.complete();
  }, ms);
  if (typeof timeout.unref === "function") {
    timeout.unref();
  }
  return () => clearTimeout(timeout);
});
function createBatchedStore(sessionId, options) {
  var _a;
  const store = createStore(sessionId);
  function resolveConsent() {
    return options.resolveConsent().catch(err => (
    // if we for some reason can't fetch consent we treat it as "undetermined", and try again at next flush
    {
      status: "undetermined"
    }));
  }
  const _buffer = [];
  function consume() {
    const buf = _buffer.slice();
    _buffer.length = 0;
    return buf;
  }
  function submit() {
    const pending = consume();
    if (pending.length === 0) {
      return EMPTY;
    }
    return combineLatest([of(pending), resolveConsent()]).pipe(mergeMap(_ref => {
      let [events, consent] = _ref;
      if (events.length === 0 || consent.status !== "granted") {
        return EMPTY;
      }
      return from(options.sendEvents(events)).pipe(catchError(err => {
        _buffer.unshift(...events);
        return EMPTY;
      }));
    }));
  }
  const flushInterval = (_a = options.flushInterval) != null ? _a : 3e4;
  const flush$ = store.events$.pipe(tap(ev => _buffer.push(ev)), map(() => {}),
  // void to avoid accidental use of events further down the pipe
  throttle(() => unrefTimer(flushInterval), {
    leading: false,
    trailing: true
  }), concatMap(() => submit()));
  function flush() {
    return lastValueFrom(submit(), {
      defaultValue: void 0
    }).then(() => {});
  }
  const subscription = flush$.subscribe();
  function endWithBeacon() {
    if (!options.sendBeacon) {
      end();
      return true;
    }
    const events = consume();
    subscription.unsubscribe();
    return events.length > 0 ? options.sendBeacon(events) : true;
  }
  function end() {
    return flush().then(() => {},
    // void promise
    () => {}
    // ignore errors
    ).finally(() => {
      subscription.unsubscribe();
    });
  }
  return {
    end,
    endWithBeacon,
    // Note: flush may fail
    flush,
    logger: store.logger
  };
}
function defineEvent(options) {
  return {
    type: "log",
    name: options.name,
    version: options.version,
    description: options.description,
    schema: void 0
  };
}
function defineTrace(options) {
  return {
    type: "trace",
    name: options.name,
    version: options.version,
    description: options.description,
    schema: void 0,
    context: void 0
  };
}
export { createBatchedStore, createSessionId, defineEvent, defineTrace };
//# sourceMappingURL=index.js.map
