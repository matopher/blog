{"version":3,"file":"index.js","sources":["../src/helpers.ts","../src/reference/asserters.ts","../src/assets/asserters.ts","../src/crossDatasetReference/asserters.ts","../src/documents/asserters.ts","../src/markers/asserters.ts","../src/mutations/asserters.ts","../src/paths/asserters.ts","../src/portableText/asserters.ts","../src/schema/asserters.ts","../src/schema/define.ts","../src/slug/asserters.ts","../src/transactionLog/asserters.ts","../src/validation/asserters.ts"],"sourcesContent":["export function isObject(obj: unknown): obj is Record<string, unknown> {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj)\n}\n","import {isObject} from '../helpers'\nimport {type Reference} from './types'\n\n/** @internal */\nexport function isReference(reference: unknown): reference is Reference {\n  return isObject(reference) && typeof reference._ref === 'string'\n}\n","import {isObject} from '../helpers'\nimport {isReference} from '../reference'\nimport {type Image} from './types'\n\n/** @public */\nexport function isImage(value: unknown): value is Image {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith('image-')\n}\n","import {isObject} from '../helpers'\nimport {type CrossDatasetReferenceValue} from './types'\n\n/** @beta */\nexport function isCrossDatasetReference(\n  reference: unknown,\n): reference is CrossDatasetReferenceValue {\n  return (\n    isObject(reference) &&\n    typeof reference._ref === 'string' &&\n    typeof reference._dataset === 'string' &&\n    typeof reference._projectId === 'string'\n  )\n}\n","import {isObject} from '../helpers'\nimport {type KeyedObject, type SanityDocument, type TypedObject} from './types'\n\n/** @public */\nexport function isSanityDocument(document: unknown): document is SanityDocument {\n  return (\n    isObject(document) && typeof document._id === 'string' && typeof document._type === 'string'\n  )\n}\n\n/** @public */\nexport function isTypedObject(obj: unknown): obj is TypedObject {\n  return isObject(obj) && typeof obj._type === 'string'\n}\n\n/** @public */\nexport function isKeyedObject(obj: unknown): obj is KeyedObject {\n  return isObject(obj) && typeof obj._key === 'string'\n}\n","import {type ValidationMarker} from './types'\n\n/** @internal */\nexport function isValidationErrorMarker(\n  marker: ValidationMarker,\n): marker is ValidationMarker & {level: 'error'} {\n  return marker.level === 'error'\n}\n\n/** @internal */\nexport function isValidationWarningMarker(\n  marker: ValidationMarker,\n): marker is ValidationMarker & {level: 'warning'} {\n  return marker.level === 'warning'\n}\n\n/** @internal */\nexport function isValidationInfoMarker(\n  marker: ValidationMarker,\n): marker is ValidationMarker & {level: 'info'} {\n  return marker.level === 'info'\n}\n","import {type TransactionLogMutation} from '../transactionLog'\nimport {\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type Mutation,\n  type PatchMutation,\n} from './types'\n\n/** @internal */\nexport function isCreateMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is CreateMutation {\n  return 'create' in mutation\n}\n\n/** @internal */\nexport function isCreateIfNotExistsMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is CreateIfNotExistsMutation {\n  return 'createIfNotExists' in mutation\n}\n\n/** @internal */\nexport function isCreateOrReplaceMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is CreateOrReplaceMutation {\n  return 'createOrReplace' in mutation\n}\n\n/** @internal */\nexport function isDeleteMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is DeleteMutation {\n  return 'delete' in mutation\n}\n\n/** @internal */\nexport function isPatchMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is PatchMutation {\n  return 'patch' in mutation\n}\n","import {type IndexTuple, type KeyedSegment, type PathSegment} from './types'\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n","import {type PortableTextObject, type PortableTextSpan, type PortableTextTextBlock} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\n/**\n * Assert that a given object is a portable-text text-block type object\n *\n * @remarks\n * * The `markDefs` and `style` property of a block is optional.\n * * Block types can be named, so expect anything of the _type property.\n *\n * @alpha\n */\nexport function isPortableTextTextBlock<T = PortableTextSpan | PortableTextObject>(\n  value: unknown,\n): value is PortableTextTextBlock<T> {\n  return (\n    isRecord(value) &&\n    typeof value._type === 'string' && // block types can be named, so expect anything here.\n    Array.isArray(value.children) &&\n    value.children.every((child) => isRecord(child)) &&\n    ('markDefs' in value // optional property\n      ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord(def))\n      : false) &&\n    ('style' in value ? typeof value.style === 'string' : true) // optional property\n  )\n}\n\n/**\n * Assert that a given object is a portable-text span-type object\n *\n * @remarks\n * The `marks` property of a block is optional.\n *\n * @alpha\n */\nexport function isPortableTextSpan(value: unknown): value is PortableTextSpan {\n  return (\n    isRecord(value) &&\n    value._type === 'span' &&\n    typeof value.text === 'string' &&\n    ('marks' in value // optional property\n      ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark === 'string')\n      : true)\n  )\n}\n\n/**\n * Assert that a given object is a portable-text list-text-block-type object\n *\n * @remarks\n * Uses `isPortableTextTextBlock` and checks for `listItem` and `level`\n *\n * @see isPortableTextTextBlock\n *\n * @alpha\n */\nexport function isPortableTextListBlock<T = PortableTextSpan | PortableTextObject>(\n  value: unknown,\n): value is PortableTextTextBlock<T> {\n  return (\n    isPortableTextTextBlock(value) &&\n    'listItem' in value &&\n    typeof value.listItem === 'string' &&\n    'level' in value &&\n    Number.isInteger(value.level)\n  )\n}\n","import {type CrossDatasetReferenceSchemaType} from '../crossDatasetReference'\nimport {type TitledListValue} from './definition'\nimport {\n  type ArraySchemaType,\n  type BaseSchemaType,\n  type BlockChildrenObjectField,\n  type BlockListObjectField,\n  type BlockSchemaType,\n  type BlockStyleObjectField,\n  type BooleanSchemaType,\n  type DeprecatedSchemaType,\n  type DeprecationConfiguration,\n  type NumberSchemaType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type SchemaType,\n  type SpanSchemaType,\n  type StringSchemaType,\n} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\n/**\n * Returns wether or not the given type is a document type\n * (eg that it was defined as `type: 'document'`)\n *\n * @param type - Schema type to test\n * @returns True if type is a document type, false otherwise\n *\n * @public\n */\nexport function isDocumentSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isObjectSchemaType(type)) {\n    return false\n  }\n\n  let current: SchemaType | undefined = type as SchemaType\n  while (current) {\n    if (current.name === 'document') {\n      return true\n    }\n\n    current = current.type\n  }\n  return false\n}\n\n/** @internal */\nexport function isObjectSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'object'\n}\n\n/** @internal */\nexport function isArraySchemaType(type: unknown): type is ArraySchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'array'\n}\n\n/** @internal */\nexport function isArrayOfBlocksSchemaType(\n  type: unknown,\n): type is ArraySchemaType<ObjectSchemaType> {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType))\n}\n\n/** @internal */\nexport function isArrayOfObjectsSchemaType(\n  type: unknown,\n): type is ArraySchemaType<ObjectSchemaType> {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType))\n}\n\n/** @internal */\nexport function isArrayOfPrimitivesSchemaType(type: unknown): type is ArraySchemaType {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType))\n}\n\n/** @internal */\nexport function isBooleanSchemaType(type: unknown): type is BooleanSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'boolean'\n}\n\n/** @internal */\nexport function isStringSchemaType(type: unknown): type is StringSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isNumberSchemaType(type: unknown): type is NumberSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'number'\n}\n\n/** @internal */\nexport function isPrimitiveSchemaType(\n  type: unknown,\n): type is BooleanSchemaType | StringSchemaType | NumberSchemaType {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type)\n}\n\n/** @internal */\nexport function isReferenceSchemaType(type: unknown): type is ReferenceSchemaType {\n  return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type))\n}\n\n/** @internal */\nexport function isDeprecatedSchemaType<TSchemaType extends BaseSchemaType>(\n  type: TSchemaType,\n): type is DeprecatedSchemaType<TSchemaType> {\n  if (!isRecord(type)) return false\n  return typeof type.deprecated !== 'undefined'\n}\n\n/** @internal */\nexport function isDeprecationConfiguration(type: unknown): type is DeprecationConfiguration {\n  if (!isRecord(type)) return false\n  return typeof type.deprecated !== 'undefined'\n}\n\n/** @internal */\nexport function isCrossDatasetReferenceSchemaType(\n  type: unknown,\n): type is CrossDatasetReferenceSchemaType {\n  return (\n    isRecord(type) &&\n    (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type))\n  )\n}\n\n/** @internal */\nexport function isTitledListValue(item: unknown): item is TitledListValue {\n  return typeof item === 'object' && item !== null && 'title' in item && 'value' in item\n}\n\n/** @internal */\nexport function isSpanSchemaType(type: unknown): type is SpanSchemaType {\n  if (!isRecord(type)) return false\n  // we check for `annotations` and `decorators` instead of `type.name` because\n  // schema names can technically change if someone extends the type\n  return Array.isArray(type.annotations) && Array.isArray(type.decorators)\n}\n\n/** @internal */\nexport function isBlockSchemaType(type: unknown): type is BlockSchemaType {\n  if (!isRecord(type)) return false\n  if (!Array.isArray(type.fields)) return false\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField)\n  const maybeStyle = type.fields.find(isBlockStyleObjectField)\n  const maybeList = type.fields.find(isBlockListObjectField)\n  return (\n    isBlockChildrenObjectField(maybeSpanChildren) &&\n    isBlockStyleObjectField(maybeStyle) &&\n    isBlockListObjectField(maybeList)\n  )\n}\n\n/** @internal */\nexport function isBlockStyleObjectField(field: unknown): field is BlockStyleObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'style') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isBlockListObjectField(field: unknown): field is BlockListObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'listItem') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isBlockChildrenObjectField(field: unknown): field is BlockChildrenObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'children') return false\n  if (!isArraySchemaType(field.type)) return false\n  // there will always be a span item in `SpanChildrenObjectField`\n  return field.type.of.some(isSpanSchemaType)\n}\n","import {\n  type DefineArrayMemberBase,\n  type DefineSchemaBase,\n  type DefineSchemaOptions,\n  type MaybeAllowUnknownProps,\n  type NarrowPreview,\n  type StrictDefinition,\n  type WidenInitialValue,\n  type WidenValidation,\n} from './defineTypes'\nimport {type FieldDefinitionBase, type IntrinsicTypeName} from './definition'\n\n/**\n * Helper function for defining a Sanity type definition. This function does not do anything on its own;\n * it exists to check that your schema definition is correct, and help autocompletion in your IDE.\n *\n * This function will narrow the schema type down to fields and options based on the provided type-string.\n *\n * Schema types defined using `defineType` should typically be added to the Studio config under `schema.types`.\n * Defined types can be referenced by their `name`. This is referred to as a type-alias.\n *\n * When using type-aliases as `type`, `defineType` cannot know the base-type, so type-safety will be reduced.\n * If you know the base type of the type-alias, provide `defineOptions.aliasFor: <base type name>`.\n * This will enforce that the schema definition conforms with the provided type.\n *\n * By default, `defineType` only allows known properties and options.\n * Use `defineOptions.strict: false` to allow unknown properties and options.\n *\n * ### Basic usage\n *\n * ```ts\n * defineType({\n *   type: 'object',\n *   name: 'custom-object',\n *   fields: [ {type: 'string', name: 'title', title: 'Title'}],\n * })\n * ```\n *\n * ### Usage with aliasFor narrowing\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   options: {\n *     columns: 2\n *   }\n * }, {aliasFor: 'object' })\n * ```\n *\n * ### Allow unknown properties\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   allowsUnknownProperties: true\n *   options: {\n *     columns: 2,\n *     allowsUnknownOptions: true\n *   }\n * }, {strict: false})\n * ```\n * ### Maximum safety and best autocompletion\n *\n * Use {@link defineType}, {@link defineField} and {@link defineArrayMember}:\n *\n * ```ts\n *  defineType({\n *    type: 'object',\n *    name: 'custom-object',\n *    fields: [\n *      defineField({\n *        type: 'array',\n *        name: 'arrayField',\n *        title: 'Things',\n *        of: [\n *          defineArrayMember({\n *            type: 'object',\n *            name: 'type-name-in-array',\n *            fields: [defineField({type: 'string', name: 'title', title: 'Title'})],\n *          }),\n *        ],\n *      }),\n *    ],\n *  })\n * ```\n *\n * ## Note on type-safety in the current implementation\n *\n * Type-safety inside array-like properties (schema properties like `fields` and `of`) can only be guaranteed when\n * {@link defineField} and {@link defineArrayMember} are used to wrap each value in the array.\n *\n * For array-values without a function-wrapper, TypeScript will resolve to a union type of all possible properties across\n * all schema types. This result in less precise typing.\n *\n * ### Extending the Sanity Schema types\n *\n * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,\n * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).\n *\n * With declaration merging, properties and options will be available in a type-safe manner, and\n * `strict: false` will not be necessary.\n *\n * #### Example: Add option to StringOptions\n *\n * ```ts\n * // string.ts\n *\n * //redeclare the sanity module\n * declare module 'sanity' {\n *  // redeclare StringOptions; it will be merged with StringOptions in the sanity module\n *  export interface StringOptions {\n *    myCustomOption?: boolean\n *  }\n * }\n *\n * // the option is now part of the StringOptions type, just as if it was declared in the sanity codebase:\n * defineType({\n *   type: 'string',\n *   name: 'my-string',\n *   options: {\n *     myCustomOption: true // this does not give an error anymore\n *   }\n * })\n *\n * ```\n *\n * #### Example: Add a schema definition to \"intrinsic-types\"\n *\n * ```ts\n * //my-custom-type-definition.ts\n *\n * // create a new schema definition based on object (we remove the ability to assign field, change the type add some options)\n *  export type MagicallyAddedDefinition = Omit<Schema.ObjectDefinition, 'type' | 'fields'> & {\n *    type: 'magically-added-type'\n *    options?: {\n *      sparkles?: boolean\n *    }\n *  }\n *\n *  // redeclares sanity module so we can add interfaces props to it\n * declare module 'sanity' {\n *     // redeclares IntrinsicDefinitions and adds a named definition to it\n *     // it is important that the key is the same as the type in the definition ('magically-added-type')\n *     export interface IntrinsicDefinitions {\n *       'magically-added-type': MagicallyAddedDefinition\n *     }\n * }\n *\n * // defineType will now narrow `type: 'magically-added-type'` to `MagicallyAddedDefinition`\n * defineType({\n *   type: 'magically-added-type'\n *   name: 'magic',\n *   options: {\n *     sparkles: true // this is allowed,\n *     //@ts-expect-error this is not allowed in MagicallyAddedDefinition.options\n *     sparks: true\n *   }\n * })\n * ```\n *\n * @param schemaDefinition - should be a valid schema type definition.\n * @param defineOptions - optional param to provide type hints for `schemaDefinition`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n *\n * @beta\n */\nexport function defineType<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition,\n>(\n  schemaDefinition: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>,\n): typeof schemaDefinition {\n  return schemaDefinition\n}\n\n/**\n * Define a field within a document, object, image or file definition `fields` array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * type-string.\n *\n * Using `defineField` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field-properties like `validation` and `initialValue`will also be more specific.\n *\n * See {@link defineType} for more examples.\n *\n * @param schemaField - should be a valid field type definition.\n * @param defineOptions - optional param to provide type hints for `schemaField`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n *\n * @beta\n */\nexport function defineField<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition,\n>(\n  schemaField: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict> &\n    FieldDefinitionBase,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>,\n): typeof schemaField & WidenValidation & WidenInitialValue {\n  return schemaField\n}\n\n/**\n * Define an array item member type within an array definition `of`-array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * `type` string.\n *\n * Using `defineArrayMember` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field properties like `validation` and `initialValue` will also be more specific.\n *\n * See {@link defineType} for example usage.\n *\n * @param arrayOfSchema - should be a valid `array.of` member definition.\n * @param defineOptions - optional param to provide type hints for `arrayOfSchema`.\n *\n * @see defineType\n * @see defineField\n * @see typed\n *\n * @beta\n */\nexport function defineArrayMember<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition,\n>(\n  arrayOfSchema: {\n    type: TType\n    /**\n     * When provided, `name` is used as `_type` for the array item when stored.\n     *\n     * Necessary when an array contains multiple entries with the same `type`, each with\n     * different configuration (title and initialValue for instance).\n     */\n    name?: TName\n  } & DefineArrayMemberBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>,\n): typeof arrayOfSchema & WidenValidation & WidenInitialValue {\n  return arrayOfSchema\n}\n\n/**\n * `typed` can be used to ensure that an object conforms to an exact interface.\n *\n * It can be useful when working with `defineType` and `defineField` on occasions where a wider type with\n * custom options or properties is required.\n *\n * ## Example  usage\n * ```ts\n *  defineField({\n *    type: 'string',\n *    name: 'nestedField',\n *    options: typed<StringOptions & {myCustomOption: boolean}>({\n *      layout: 'radio',\n *      // allowed\n *      myCustomOption: true,\n *      //@ts-expect-error unknownProp is not part of StringOptions & {myCustomOption: boolean}\n *      unknownProp: 'not allowed in typed context',\n *    }),\n *  }),\n * ```\n *\n * @param input - returned directly\n *\n * @internal\n */\nexport function typed<T>(input: T): T {\n  return input\n}\n","import {isObject} from '../helpers'\nimport {type Slug} from './types'\n\n/**\n * Checks whether the given `thing` is a slug, eg an object with a `current` string property.\n *\n * @param thing - The thing to check\n * @returns True if slug, false otherwise\n * @public\n */\nexport function isSlug(thing: unknown): thing is Slug {\n  return isObject(thing) && typeof thing.current === 'string'\n}\n","import {type Mutation} from '../mutations'\nimport {type CreateSquashedMutation, type TransactionLogMutation} from './types'\n\n/** @internal */\nexport function isCreateSquashedMutation(\n  mutation: Mutation | TransactionLogMutation,\n): mutation is CreateSquashedMutation {\n  return 'createSquashed' in mutation\n}\n","import {type FormNodeValidation} from './types'\n\n/** @internal */\nexport function isValidationError(\n  node: FormNodeValidation,\n): node is FormNodeValidation & {level: 'error'} {\n  return node.level === 'error'\n}\n\n/** @internal */\nexport function isValidationWarning(\n  node: FormNodeValidation,\n): node is FormNodeValidation & {level: 'warning'} {\n  return node.level === 'warning'\n}\n\n/** @internal */\nexport function isValidationInfo(\n  node: FormNodeValidation,\n): node is FormNodeValidation & {level: 'info'} {\n  return node.level === 'info'\n}\n"],"names":["isObject","obj","Array","isArray","isReference","reference","_ref","isImage","value","asset","startsWith","isCrossDatasetReference","_dataset","_projectId","isSanityDocument","document","_id","_type","isTypedObject","isKeyedObject","_key","isValidationErrorMarker","marker","level","isValidationWarningMarker","isValidationInfoMarker","isCreateMutation","mutation","isCreateIfNotExistsMutation","isCreateOrReplaceMutation","isDeleteMutation","isPatchMutation","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","isIndexTuple","length","from","to","isRecord","isPortableTextTextBlock","children","every","child","markDefs","def","style","isPortableTextSpan","text","marks","mark","isPortableTextListBlock","listItem","Number","isInteger","isDocumentSchemaType","type","isObjectSchemaType","current","name","jsonType","isArraySchemaType","isArrayOfBlocksSchemaType","of","some","memberType","isBlockSchemaType","isArrayOfObjectsSchemaType","isArrayOfPrimitivesSchemaType","isPrimitiveSchemaType","isBooleanSchemaType","isStringSchemaType","isNumberSchemaType","isReferenceSchemaType","isDeprecatedSchemaType","deprecated","isDeprecationConfiguration","isCrossDatasetReferenceSchemaType","isTitledListValue","item","isSpanSchemaType","annotations","decorators","fields","maybeSpanChildren","find","isBlockChildrenObjectField","maybeStyle","isBlockStyleObjectField","maybeList","isBlockListObjectField","field","defineType","schemaDefinition","defineOptions","defineField","schemaField","defineArrayMember","arrayOfSchema","typed","input","isSlug","thing","isCreateSquashedMutation","isValidationError","node","isValidationWarning","isValidationInfo"],"mappings":"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"}