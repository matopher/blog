{"version":3,"file":"index.js","sources":["../src/util/findBlockType.ts","../src/util/resolveJsType.ts","../../types/lib/index.esm.js","../src/constants.ts","../src/util/blockContentTypeFeatures.ts","../src/HtmlDeserializer/preprocessors/xpathResult.ts","../src/HtmlDeserializer/preprocessors/gdocs.ts","../src/HtmlDeserializer/preprocessors/html.ts","../src/HtmlDeserializer/preprocessors/notion.ts","../src/HtmlDeserializer/preprocessors/whitespace.ts","../src/HtmlDeserializer/preprocessors/word.ts","../src/HtmlDeserializer/preprocessors/index.ts","../src/HtmlDeserializer/helpers.ts","../src/HtmlDeserializer/rules/gdocs.ts","../src/util/randomKey.ts","../src/HtmlDeserializer/rules/html.ts","../src/HtmlDeserializer/rules/notion.ts","../src/HtmlDeserializer/rules/word.ts","../src/HtmlDeserializer/rules/index.ts","../src/HtmlDeserializer/index.ts","../src/util/normalizeBlock.ts","../src/index.ts"],"sourcesContent":["import {type BlockSchemaType, type SchemaType} from '@sanity/types'\n\nexport function findBlockType(type: SchemaType): type is BlockSchemaType {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return true\n  }\n\n  return false\n}\n","const toString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (toString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","function isObject(obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref === \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref === \"string\" && typeof reference._dataset === \"string\" && typeof reference._projectId === \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id === \"string\" && typeof document._type === \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type === \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key === \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nconst reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment === \"number\" || typeof segment === \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment === \"string\" && reIndexTuple.test(segment)) {\n    return true;\n  }\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false;\n  }\n  const [from, to] = segment;\n  return (typeof from === \"number\" || from === \"\") && (typeof to === \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type === \"string\" &&\n  // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every(child => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every(def => isRecord$1(def)) : false) && (\"style\" in value ? typeof value.style === \"string\" : true);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text === \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every(mark => typeof mark === \"string\") : true);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem === \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type)) {\n    return false;\n  }\n  let current = type;\n  while (current) {\n    if (current.name === \"document\") {\n      return true;\n    }\n    current = current.type;\n  }\n  return false;\n}\nfunction isObjectSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"object\";\n}\nfunction isArraySchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"array\";\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some(memberType => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every(memberType => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every(memberType => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"boolean\";\n}\nfunction isStringSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"string\";\n}\nfunction isNumberSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"number\";\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return typeof type.deprecated !== \"undefined\";\n}\nfunction isDeprecationConfiguration(type) {\n  if (!isRecord(type)) return false;\n  return typeof type.deprecated !== \"undefined\";\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item === \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return Array.isArray(type.annotations) && Array.isArray(type.decorators);\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type)) return false;\n  if (!Array.isArray(type.fields)) return false;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField);\n  const maybeStyle = type.fields.find(isBlockStyleObjectField);\n  const maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"style\") return false;\n  return isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"listItem\") return false;\n  return isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"children\") return false;\n  if (!isArraySchemaType(field.type)) return false;\n  return field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current === \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport { defineArrayMember, defineField, defineType, isArrayOfBlocksSchemaType, isArrayOfObjectsSchemaType, isArrayOfPrimitivesSchemaType, isArraySchemaType, isBlockChildrenObjectField, isBlockListObjectField, isBlockSchemaType, isBlockStyleObjectField, isBooleanSchemaType, isCreateIfNotExistsMutation, isCreateMutation, isCreateOrReplaceMutation, isCreateSquashedMutation, isCrossDatasetReference, isCrossDatasetReferenceSchemaType, isDeleteMutation, isDeprecatedSchemaType, isDeprecationConfiguration, isDocumentSchemaType, isImage, isIndexSegment, isIndexTuple, isKeySegment, isKeyedObject, isNumberSchemaType, isObjectSchemaType, isPatchMutation, isPortableTextListBlock, isPortableTextSpan, isPortableTextTextBlock, isPrimitiveSchemaType, isReference, isReferenceSchemaType, isSanityDocument, isSlug, isSpanSchemaType, isStringSchemaType, isTitledListValue, isTypedObject, isValidationError, isValidationErrorMarker, isValidationInfo, isValidationInfoMarker, isValidationWarning, isValidationWarningMarker, typed };\n//# sourceMappingURL=index.esm.js.map\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<string, {object: null} | undefined> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style),\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(Object.values(HTML_DECORATOR_TAGS))\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import {\n  type ArraySchemaType,\n  type BlockSchemaType,\n  type EnumListProps,\n  type I18nTitledListValue,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isObjectSchemaType,\n  isTitledListValue,\n  type ObjectSchemaType,\n  type SpanSchemaType,\n  type TitledListValue,\n} from '@sanity/types'\n\nimport {type BlockContentFeatures, type ResolvedAnnotationType} from '../types'\nimport {findBlockType} from './findBlockType'\n\n// Helper method for describing a blockContentType's feature set\nexport default function blockContentFeatures(\n  blockContentType: ArraySchemaType,\n): BlockContentFeatures {\n  if (!blockContentType) {\n    throw new Error(\"Parameter 'blockContentType' required\")\n  }\n\n  const blockType = blockContentType.of.find(findBlockType)\n  if (!isBlockSchemaType(blockType)) {\n    throw new Error(\"'block' type is not defined in this schema (required).\")\n  }\n\n  const ofType = blockType.fields.find(isBlockChildrenObjectField)?.type?.of\n  if (!ofType) {\n    throw new Error('No `of` declaration found for blocks `children` field')\n  }\n\n  const spanType = ofType.find((member): member is SpanSchemaType => member.name === 'span')\n  if (!spanType) {\n    throw new Error('No `span` type found in `block` schema type `children` definition')\n  }\n\n  const inlineObjectTypes = ofType.filter(\n    (inlineType): inlineType is ObjectSchemaType =>\n      inlineType.name !== 'span' && isObjectSchemaType(inlineType),\n  )\n\n  const blockObjectTypes = blockContentType.of.filter(\n    (memberType): memberType is ObjectSchemaType =>\n      memberType.name !== blockType.name && isObjectSchemaType(memberType),\n  )\n\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes,\n    },\n  }\n}\n\nfunction resolveEnabledStyles(blockType: BlockSchemaType): TitledListValue<string>[] {\n  const styleField = blockType.fields.find(isBlockStyleObjectField)\n  if (!styleField) {\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\")\n  }\n\n  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options)\n  if (textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n\n  return textStyles\n}\n\nfunction resolveEnabledAnnotationTypes(spanType: SpanSchemaType): ResolvedAnnotationType[] {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon,\n  }))\n}\n\nfunction resolveEnabledDecorators(spanType: SpanSchemaType): TitledListValue<string>[] {\n  return spanType.decorators\n}\n\nfunction resolveEnabledListItems(blockType: BlockSchemaType): I18nTitledListValue<string>[] {\n  const listField = blockType.fields.find(isBlockListObjectField)\n  if (!listField) {\n    throw new Error(\"A field with name 'list' is not defined in the block type (required).\")\n  }\n\n  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n\n  return listItems\n}\n\nfunction getTitledListValuesFromEnumListOptions(\n  options: EnumListProps<string> | undefined,\n): I18nTitledListValue<string>[] {\n  const list = options ? options.list : undefined\n  if (!Array.isArray(list)) {\n    return []\n  }\n\n  return list.map((item) => (isTitledListValue(item) ? item : {title: item, value: item}))\n}\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {type HtmlPreprocessorOptions} from '../../types'\nimport {normalizeWhitespace, removeAllWhitespace, tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document, options: HtmlPreprocessorOptions): Document => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || 'preserve'\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    switch (whitespaceOnPasteMode) {\n      case 'normalize':\n        // Keep only 1 empty block between content nodes\n        normalizeWhitespace(gDocsRootOrSiblingNode)\n        break\n      case 'remove':\n        // Remove all whitespace nodes\n        removeAllWhitespace(gDocsRootOrSiblingNode)\n        break\n      default:\n        break\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (tagName(elm) === 'li' && elm.firstChild && tagName(elm?.firstChild) === 'img') {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(...Array.from(gDocsRootOrSiblingNode.childNodes))\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport default (html: string, doc: Document): Document => {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document): Document => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\nexport default (_: string, doc: Document): Document => {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(node.parentElement?.tagName.toLowerCase() || '')\n    ) {\n      node.textContent =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = new Text(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = document.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = document.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import preprocessGDocs from './gdocs'\nimport preprocessHTML from './html'\nimport preprocessNotion from './notion'\nimport preprocessWhitespace from './whitespace'\nimport preprocessWord from './word'\n\nexport default [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import {\n  type ArraySchemaType,\n  isPortableTextTextBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual} from 'lodash'\n\nimport {DEFAULT_BLOCK} from '../constants'\nimport {\n  type BlockEnabledFeatures,\n  type HtmlParser,\n  type HtmlPreprocessorOptions,\n  type MinimalBlock,\n  type MinimalSpan,\n  type PlaceholderAnnotation,\n  type PlaceholderDecorator,\n  type TypedObject,\n} from '../types'\nimport blockContentTypeFeatures from '../util/blockContentTypeFeatures'\nimport {resolveJsType} from '../util/resolveJsType'\nimport preprocessors from './preprocessors'\n\n/**\n * A utility function to create the options needed for the various rule sets,\n * based on the structure of the blockContentType\n *\n * @param blockContentType - Schema type for array containing _at least_ a block child type\n * @returns\n */\nexport function createRuleOptions(blockContentType: ArraySchemaType): BlockEnabledFeatures {\n  const features = blockContentTypeFeatures(blockContentType)\n  const enabledBlockStyles = features.styles.map((item) => item.value || item.title)\n  const enabledSpanDecorators = features.decorators.map((item) => item.value || item.title)\n  const enabledBlockAnnotations = features.annotations.map((item) => item.value || item.title || '')\n  const enabledListTypes = features.lists.map((item) => item.value || item.title || '')\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes,\n  }\n}\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n// TODO: make this plugin-style\nexport function preprocess(\n  html: string,\n  parseHtml: HtmlParser,\n  options: HtmlPreprocessorOptions,\n): Document {\n  const doc = parseHtml(normalizeHtmlBeforePreprocess(html))\n  preprocessors.forEach((processor) => {\n    processor(html, doc, options)\n  })\n  return doc\n}\n\nfunction normalizeHtmlBeforePreprocess(html: string): string {\n  return html.trim()\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function flattenNestedBlocks(blocks: TypedObject[]): TypedObject[] {\n  let depth = 0\n  const flattened: TypedObject[] = []\n  const traverse = (nodes: TypedObject[]) => {\n    const toRemove: TypedObject[] = []\n    nodes.forEach((node) => {\n      if (depth === 0) {\n        flattened.push(node)\n      }\n      if (isPortableTextTextBlock(node)) {\n        if (depth > 0) {\n          toRemove.push(node)\n          flattened.push(node)\n        }\n        depth++\n        traverse(node.children)\n      }\n      if (node._type === '__block') {\n        toRemove.push(node)\n        flattened.push((node as any).block)\n      }\n    })\n    toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1)\n    })\n    depth--\n  }\n  traverse(blocks)\n  return flattened\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n\n/**\n * NOTE: _mutates_ passed blocks!\n *\n * @param blocks - Array of blocks to trim whitespace for\n * @returns\n */\nexport function trimWhitespace(blocks: TypedObject[]): TypedObject[] {\n  blocks.forEach((block) => {\n    if (!isPortableTextTextBlock(block)) {\n      return\n    }\n\n    // eslint-disable-next-line complexity\n    block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child)) {\n        return\n      }\n      const nextChild = nextSpan(block, index)\n      const prevChild = prevSpan(block, index)\n      if (index === 0) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (index === block.children.length - 1) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.substring(child.text.length - 1)) &&\n        nextChild &&\n        isMinimalSpan(nextChild) &&\n        /\\s/.test(nextChild.text.substring(0, 1))\n      ) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.substring(0, 1)) &&\n        prevChild &&\n        isMinimalSpan(prevChild) &&\n        /\\s/.test(prevChild.text.substring(prevChild.text.length - 1))\n      ) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (!child.text) {\n        block.children.splice(index, 1)\n      }\n      if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {\n        prevChild.text += ' '\n        block.children.splice(index, 1)\n      } else if (\n        nextChild &&\n        isEqual(nextChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        nextChild.text = ` ${nextChild.text}`\n        block.children.splice(index, 1)\n      }\n    })\n  })\n\n  return blocks\n}\n\nexport function ensureRootIsBlocks(blocks: TypedObject[]): TypedObject[] {\n  return blocks.reduce((memo, node, i, original) => {\n    if (node._type === 'block') {\n      memo.push(node)\n      return memo\n    }\n\n    if (node._type === '__block') {\n      memo.push((node as any).block)\n      return memo\n    }\n\n    const lastBlock = memo[memo.length - 1]\n    if (\n      i > 0 &&\n      !isPortableTextTextBlock(original[i - 1]) &&\n      isPortableTextTextBlock<TypedObject>(lastBlock)\n    ) {\n      lastBlock.children.push(node)\n      return memo\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    memo.push(block)\n    return memo\n  }, [] as TypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) == '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(node: TypedObject): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(node: TypedObject): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n\n/**\n * Helper to normalize whitespace to only 1 empty block between content nodes\n * @param node - Root node to process\n */\nexport function normalizeWhitespace(rootNode: Node) {\n  let emptyBlockCount = 0\n  let lastParent = null\n  const nodesToRemove: Node[] = []\n\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child)\n      emptyBlockCount = 0\n      continue\n    }\n\n    const elm = child as HTMLElement\n\n    if (isWhitespaceBlock(elm)) {\n      if (lastParent && elm.parentElement === lastParent) {\n        emptyBlockCount++\n        if (emptyBlockCount > 1) {\n          nodesToRemove.push(elm)\n        }\n      } else {\n        // Different parent, reset counter\n        emptyBlockCount = 1\n      }\n\n      lastParent = elm.parentElement\n    } else {\n      // Recurse into child nodes\n      normalizeWhitespace(child)\n      // Reset counter for siblings\n      emptyBlockCount = 0\n    }\n  }\n\n  // Remove marked nodes\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node))\n}\n\n/**\n * Helper to remove all whitespace nodes\n * @param node - Root node to process\n */\nexport function removeAllWhitespace(rootNode: Node) {\n  const nodesToRemove: Node[] = []\n\n  function collectNodesToRemove(currentNode: Node) {\n    if (isElement(currentNode)) {\n      const elm = currentNode as HTMLElement\n\n      // Handle <br> tags that is between <p> tags\n      if (\n        tagName(elm) === 'br' &&\n        (tagName(elm.nextElementSibling) === 'p' || tagName(elm.previousElementSibling) === 'p')\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Handle empty blocks\n      if (\n        (tagName(elm) === 'p' || tagName(elm) === 'br') &&\n        elm?.firstChild?.textContent?.trim() === ''\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Recursively process child nodes\n      for (let child = elm.firstChild; child; child = child.nextSibling) {\n        collectNodesToRemove(child)\n      }\n    }\n  }\n\n  collectNodesToRemove(rootNode)\n\n  // Remove the collected nodes\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node))\n}\n\nfunction isWhitespaceBlock(elm: HTMLElement): boolean {\n  return ['p', 'br'].includes(tagName(elm) || '') && !elm.textContent?.trim()\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*line-through/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(el: Node, enabledBlockStyles: string[]): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!enabledBlockStyles.includes(block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport default function createGDocsRules(\n  _blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (tagName(el) === 'br' && isGoogleDocs(el) && isElement(el) && isRootNode(el)) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substring(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport {randomKey} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\n\nexport function resolveListItem(\n  listNodeTagName: string,\n  enabledListTypes: string[],\n): string | undefined {\n  if (listNodeTagName === 'ul' && enabledListTypes.includes('bullet')) {\n    return 'bullet'\n  }\n  if (listNodeTagName === 'ol' && enabledListTypes.includes('number')) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport default function createHTMLRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    // Text nodes\n    {\n      deserialize(el) {\n        if (tagName(el) === 'pre') {\n          return undefined\n        }\n        const isValidWhiteSpace =\n          el.nodeType === 3 &&\n          (el.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') === ' ' &&\n          el.nextSibling &&\n          el.nextSibling.nodeType !== 3 &&\n          el.previousSibling &&\n          el.previousSibling.nodeType !== 3\n        const isValidText =\n          (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body'\n        if (el.nodeName === '#text' && isValidText) {\n          return {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: (el.textContent || '').replace(/\\s\\s+/g, ' '),\n          }\n        }\n        return undefined\n      },\n    }, // Pre element\n    {\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = options.enabledBlockStyles.includes('code')\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n\n        const children: HTMLElement[] = []\n        el.childNodes.forEach((node, index) => {\n          if (\n            node.nodeType === 1 &&\n            Object.keys(blocks).includes((node as Element).localName.toLowerCase())\n          ) {\n            if (!el.ownerDocument) {\n              return\n            }\n\n            const span = el.ownerDocument.createElement('span')\n            span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n            if (index !== el.childNodes.length) {\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        // If style is not supported, return a defaultBlockType\n        if (!options.enabledBlockStyles.includes(block.style)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(parentTag, options.enabledListTypes)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) != 'a') {\n          return undefined\n        }\n        const linkEnabled = options.enabledBlockAnnotations.includes('link')\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        let markDef\n        if (linkEnabled) {\n          markDef = {\n            _key: randomKey(12),\n            _type: 'link',\n            href: href,\n          }\n          return {\n            _type: '__annotation',\n            markDef: markDef,\n            children: next(el.childNodes),\n          }\n        }\n        return el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes)\n      },\n    },\n  ]\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS} from '../../constants'\nimport {type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nexport default function createNotionRules(_blockContentType: ArraySchemaType): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {BLOCK_DEFAULT_STYLE, DEFAULT_BLOCK} from '../../constants'\nimport {type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  return isElement(el) && el.className\n    ? el.className === 'MsoListParagraphCxSpFirst' ||\n        el.className === 'MsoListParagraphCxSpMiddle' ||\n        el.className === 'MsoListParagraphCxSpLast'\n    : false\n}\n\nexport default function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'p' && isWordListElement(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport createGDocsRules from './gdocs'\nimport createHTMLRules from './html'\nimport createNotionRules from './notion'\nimport createWordRules from './word'\n\nexport function createRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(blockContentType),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options),\n  ]\n}\n","import {\n  type ArraySchemaType,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {flatten} from 'lodash'\n\nimport {\n  type ArbitraryTypedObject,\n  type DeserializerRule,\n  type HtmlDeserializerOptions,\n  type PlaceholderAnnotation,\n  type PlaceholderDecorator,\n  type TypedObject,\n} from '../types'\nimport {findBlockType} from '../util/findBlockType'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {\n  createRuleOptions,\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  flattenNestedBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  preprocess,\n  tagName,\n  trimWhitespace,\n} from './helpers'\nimport {createRules} from './rules'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  blockContentType: ArraySchemaType\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType: ArraySchemaType, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    if (!blockContentType) {\n      throw new Error(\"Parameter 'blockContentType' is required\")\n    }\n    const standardRules = createRules(blockContentType, createRuleOptions(blockContentType))\n    this.rules = [...rules, ...standardRules]\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.blockContentType = blockContentType\n    this.parseHtml = (html) => {\n      const doc = preprocess(html, parseHtml, {unstable_whitespaceOnPasteMode})\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n    // Ensure that there are no blocks within blocks, and trim whitespace\n    const blocks = trimWhitespace(\n      flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block): block is PortableTextTextBlock => block._type === 'block')\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(block.children.map((child) => child.marks || [])).includes(def._key)\n            }),\n          )\n        })\n    }\n\n    // Set back the potentially hoisted block type\n    const type = this.blockContentType.of.find(findBlockType)\n    if (!type) {\n      return blocks\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = type.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (elements: Node | Node[] | NodeList): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n        throw new Error(`A rule returned an invalid deserialized representation: \"${node}\".`)\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if ('children' in node && Array.isArray((node as PortableTextBlock).children)) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation: PlaceholderAnnotation): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if ('children' in node && Array.isArray((node as PortableTextBlock).children)) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import {isPortableTextSpan, type PortableTextSpan, type PortableTextTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\n\nimport {type TypedObject} from '../types'\nimport {randomKey} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>, '_key'> & {\n  _key: string\n} {\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node ? (node as TypedObject & {_key: string}) : {...node, _key: randomKey(12)}\n  }\n\n  const block: Omit<PortableTextTextBlock<TypedObject | PortableTextSpan>, 'style'> = {\n    _key: randomKey(12),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: `${block._key}${0}`,\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isPortableTextSpan(child) &&\n          isPortableTextSpan(previousChild) &&\n          isEqual(previousChild.marks, child.marks)\n        ) {\n          if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child, index) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = `${block._key}${index}`\n      if (isPortableTextSpan(child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) => usedMarkDefs.includes(markDef._key))\n  return block\n}\n","import {type ArraySchemaType, type PortableTextTextBlock} from '@sanity/types'\n\nimport HtmlDeserializer from './HtmlDeserializer'\nimport {type BlockContentFeatures, type HtmlDeserializerOptions, type TypedObject} from './types'\nimport blockContentTypeFeatures from './util/blockContentTypeFeatures'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param blockContentType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  blockContentType: ArraySchemaType,\n  options: HtmlDeserializerOptions = {},\n): (TypedObject | PortableTextTextBlock)[] {\n  const deserializer = new HtmlDeserializer(blockContentType, options)\n  return deserializer.deserialize(html).map((block) => normalizeBlock(block))\n}\n\n/**\n * Normalize and extract features of an schema type containing a block type\n *\n * @param blockContentType - Schema type for the block type\n * @returns Returns the featureset of a compiled block content type.\n * @public\n */\nexport function getBlockContentFeatures(blockContentType: ArraySchemaType): BlockContentFeatures {\n  return blockContentTypeFeatures(blockContentType)\n}\n\nexport {normalizeBlock}\nexport {randomKey} from './util/randomKey'\nexport type {BlockContentFeatures, HtmlDeserializerOptions, TypedObject}\nexport type {\n  ArbitraryTypedObject,\n  BlockEditorSchemaProps,\n  DeserializerRule,\n  HtmlParser,\n  ResolvedAnnotationType,\n} from './types'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\n"],"names":["findBlockType","type","name","toString","Object","prototype","resolveJsType","val","call","nodeType","isRecord$1","value","isPortableTextTextBlock","_type","Array","isArray","children","every","child","markDefs","def","style","isPortableTextSpan","text","marks","mark","isRecord","isObjectSchemaType","jsonType","isArraySchemaType","isTitledListValue","item","isSpanSchemaType","annotations","decorators","isBlockSchemaType","fields","maybeSpanChildren","find","isBlockChildrenObjectField","maybeStyle","isBlockStyleObjectField","maybeList","isBlockListObjectField","field","of","some","PRESERVE_WHITESPACE_TAGS","BLOCK_DEFAULT_STYLE","DEFAULT_BLOCK","freeze","DEFAULT_SPAN","HTML_BLOCK_TAGS","p","blockquote","HTML_SPAN_TAGS","span","object","HTML_LIST_CONTAINER_TAGS","ol","ul","HTML_HEADER_TAGS","h1","h2","h3","h4","h5","h6","HTML_MISC_TAGS","br","HTML_DECORATOR_TAGS","b","strong","i","em","u","s","strike","del","code","sup","sub","ins","small","HTML_LIST_ITEM_TAGS","li","level","listItem","ELEMENT_MAP","uniq","default","values","filter","tag","map","blockContentFeatures","blockContentType","_a","_b","Error","blockType","ofType","spanType","member","inlineObjectTypes","inlineType","blockObjectTypes","memberType","styles","resolveEnabledStyles","resolveEnabledDecorators","resolveEnabledAnnotationTypes","lists","resolveEnabledListItems","types","block","inlineObjects","blockObjects","styleField","textStyles","getTitledListValuesFromEnumListOptions","options","length","annotation","title","icon","listField","listItems","list","_XPathResult","ANY_TYPE","NUMBER_TYPE","STRING_TYPE","BOOLEAN_TYPE","UNORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","ANY_UNORDERED_NODE_TYPE","FIRST_ORDERED_NODE_TYPE","preprocessGDocs","html","doc","whitespaceOnPasteMode","unstable_whitespaceOnPasteMode","gDocsRootOrSiblingNode","evaluate","iterateNext","isWrappedRootTag","tagName","body","normalizeWhitespace","removeAllWhitespace","childNodes","snapshotLength","elm","snapshotItem","setAttribute","parentElement","firstChild","removeChild","firstElementChild","replaceWith","from","unwantedWordDocumentPaths","preprocessHTML","_c","bodyTextNodes","node","textContent","replace","newNode","createElement","appendChild","createTextNode","parentNode","replaceChild","unwantedNodes","join","unwanted","preprocessNotion","NOTION_REGEX","match","preprocessWhitespace","_","processNode","includes","toLowerCase","WORD_HTML_REGEX","unwantedPaths","mappedPaths","elementMap","MsoTocHeading","MsoTitle","MsoToaHeading","MsoSubtitle","MsoSubtleEmphasis","MsoIntenseEmphasis","isWordHtml","test","preprocessWord","prefix","mappedElements","mappedElm","tags","className","Text","document","parent","slice","forEach","preprocessors","createRuleOptions","features","blockContentTypeFeatures","enabledBlockStyles","enabledSpanDecorators","enabledBlockAnnotations","enabledListTypes","el","preprocess","parseHtml","normalizeHtmlBeforePreprocess","processor","trim","defaultParseHtml","DOMParser","parseFromString","flattenNestedBlocks","blocks","depth","flattened","traverse","nodes","toRemove","push","splice","indexOf","nextSpan","index","next","prevSpan","prev","isWhiteSpaceChar","trimWhitespace","isMinimalSpan","nextChild","prevChild","substring","isEqual","concat","ensureRootIsBlocks","reduce","memo","original","lastBlock","isNodeList","isMinimalBlock","isPlaceholderDecorator","isPlaceholderAnnotation","isElement","rootNode","emptyBlockCount","lastParent","nodesToRemove","nextSibling","isWhitespaceBlock","collectNodesToRemove","currentNode","nextElementSibling","previousElementSibling","LIST_CONTAINER_TAGS","keys","isEmphasis","getAttribute","isStrong","isUnderline","isStrikethrough","isGoogleDocs","Boolean","isRootNode","getListItemStyle","parentTag","getListItemLevel","getBlockStyle","childTag","createGDocsRules","_blockContentType","deserialize","classList","contains","whatwgRNG","rnds8","Uint8Array","getRandomValues","byteToHex","randomKey","str","n","resolveListItem","listNodeTagName","createHTMLRules","isValidWhiteSpace","previousSibling","isValidText","nodeName","isCodeEnabled","localName","ownerDocument","cn","cloneNode","div","enabledListItem","decorator","linkEnabled","href","markDef","_key","isNotion","createNotionRules","levelMatch","levelNum","parseInt","isWordListElement","createWordRules","createRules","HtmlDeserializer","constructor","_this","arguments","undefined","_markDefs","fragment","deserializeElements","flatten","elements","element","deserializeElement","props","rules","rule","ret","deserializeDecorator","deserializeAnnotation","applyDecorator","unshift","applyAnnotation","standardRules","normalizeBlock","blockTypeName","lastChild","usedMarkDefs","allowedDecorators","acc","previousChild","isAllowed","isUsed","htmlToBlocks","deserializer","getBlockContentFeatures"],"mappings":"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"}