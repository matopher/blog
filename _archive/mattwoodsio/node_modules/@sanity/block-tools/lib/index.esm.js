import flatten from 'lodash/flatten.js';
import isEqual from 'lodash/isEqual.js';
import uniq from 'lodash/uniq.js';
import getRandomValues from 'get-random-values-esm';
function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }
  if (type.name === "block") {
    return true;
  }
  return false;
}
const toString = Object.prototype.toString;
function resolveJsType(val) {
  switch (toString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  if (val === null) {
    return "null";
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val && typeof val === "object" && "nodeType" in val && val.nodeType === 1) {
    return "element";
  }
  if (val === Object(val)) {
    return "object";
  }
  return typeof val;
}
function isRecord$1(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isPortableTextTextBlock(value) {
  return isRecord$1(value) && typeof value._type === "string" &&
  // block types can be named, so expect anything here.
  Array.isArray(value.children) && value.children.every(child => isRecord$1(child)) && ("markDefs" in value ? Array.isArray(value.markDefs) && value.markDefs.every(def => isRecord$1(def)) : false) && ("style" in value ? typeof value.style === "string" : true);
}
function isPortableTextSpan(value) {
  return isRecord$1(value) && value._type === "span" && typeof value.text === "string" && ("marks" in value ? Array.isArray(value.marks) && value.marks.every(mark => typeof mark === "string") : true);
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isObjectSchemaType(type) {
  if (!isRecord(type)) return false;
  return type.jsonType === "object";
}
function isArraySchemaType(type) {
  if (!isRecord(type)) return false;
  return type.jsonType === "array";
}
function isTitledListValue(item) {
  return typeof item === "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType(type) {
  if (!isRecord(type)) return false;
  return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType(type) {
  if (!isRecord(type)) return false;
  if (!Array.isArray(type.fields)) return false;
  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField);
  const maybeStyle = type.fields.find(isBlockStyleObjectField);
  const maybeList = type.fields.find(isBlockListObjectField);
  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);
}
function isBlockStyleObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "style") return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockListObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "listItem") return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "children") return false;
  if (!isArraySchemaType(field.type)) return false;
  return field.type.of.some(isSpanSchemaType);
}
const PRESERVE_WHITESPACE_TAGS = ["pre", "textarea", "code"];
const BLOCK_DEFAULT_STYLE = "normal";
const DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
});
const DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
});
const HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: {
    ...DEFAULT_BLOCK,
    style: "blockquote"
  }
};
const HTML_SPAN_TAGS = {
  span: {
    object: "text"
  }
};
const HTML_LIST_CONTAINER_TAGS = {
  ol: {
    object: null
  },
  ul: {
    object: null
  }
};
const HTML_HEADER_TAGS = {
  h1: {
    ...DEFAULT_BLOCK,
    style: "h1"
  },
  h2: {
    ...DEFAULT_BLOCK,
    style: "h2"
  },
  h3: {
    ...DEFAULT_BLOCK,
    style: "h3"
  },
  h4: {
    ...DEFAULT_BLOCK,
    style: "h4"
  },
  h5: {
    ...DEFAULT_BLOCK,
    style: "h5"
  },
  h6: {
    ...DEFAULT_BLOCK,
    style: "h6"
  }
};
const HTML_MISC_TAGS = {
  br: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE
  }
};
const HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code",
  sup: "sup",
  sub: "sub",
  ins: "ins",
  mark: "mark",
  small: "small"
};
const HTML_LIST_ITEM_TAGS = {
  li: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  }
};
const ELEMENT_MAP = {
  ...HTML_BLOCK_TAGS,
  ...HTML_SPAN_TAGS,
  ...HTML_LIST_CONTAINER_TAGS,
  ...HTML_LIST_ITEM_TAGS,
  ...HTML_HEADER_TAGS,
  ...HTML_MISC_TAGS
};
uniq(Object.values(ELEMENT_MAP).filter(tag => "style" in tag).map(tag => tag.style));
uniq(Object.values(HTML_DECORATOR_TAGS));
function blockContentFeatures(blockContentType) {
  var _a, _b;
  if (!blockContentType) {
    throw new Error("Parameter 'blockContentType' required");
  }
  const blockType = blockContentType.of.find(findBlockType);
  if (!isBlockSchemaType(blockType)) {
    throw new Error("'block' type is not defined in this schema (required).");
  }
  const ofType = (_b = (_a = blockType.fields.find(isBlockChildrenObjectField)) == null ? void 0 : _a.type) == null ? void 0 : _b.of;
  if (!ofType) {
    throw new Error("No `of` declaration found for blocks `children` field");
  }
  const spanType = ofType.find(member => member.name === "span");
  if (!spanType) {
    throw new Error("No `span` type found in `block` schema type `children` definition");
  }
  const inlineObjectTypes = ofType.filter(inlineType => inlineType.name !== "span" && isObjectSchemaType(inlineType));
  const blockObjectTypes = blockContentType.of.filter(memberType => memberType.name !== blockType.name && isObjectSchemaType(memberType));
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    annotations: resolveEnabledAnnotationTypes(spanType),
    lists: resolveEnabledListItems(blockType),
    types: {
      block: blockContentType,
      span: spanType,
      inlineObjects: inlineObjectTypes,
      blockObjects: blockObjectTypes
    }
  };
}
function resolveEnabledStyles(blockType) {
  const styleField = blockType.fields.find(isBlockStyleObjectField);
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
  if (textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
  return spanType.annotations.map(annotation => ({
    title: annotation.title,
    type: annotation,
    value: annotation.name,
    icon: annotation.icon
  }));
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  const listField = blockType.fields.find(isBlockListObjectField);
  if (!listField) {
    throw new Error("A field with name 'list' is not defined in the block type (required).");
  }
  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
  const list = options ? options.list : void 0;
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map(item => isTitledListValue(item) ? item : {
    title: item,
    value: item
  });
}
const _XPathResult = {
  ANY_TYPE: 0,
  NUMBER_TYPE: 1,
  STRING_TYPE: 2,
  BOOLEAN_TYPE: 3,
  UNORDERED_NODE_ITERATOR_TYPE: 4,
  ORDERED_NODE_ITERATOR_TYPE: 5,
  UNORDERED_NODE_SNAPSHOT_TYPE: 6,
  ORDERED_NODE_SNAPSHOT_TYPE: 7,
  ANY_UNORDERED_NODE_TYPE: 8,
  FIRST_ORDERED_NODE_TYPE: 9
};
var preprocessGDocs = (html, doc, options) => {
  var _a;
  const whitespaceOnPasteMode = (options == null ? void 0 : options.unstable_whitespaceOnPasteMode) || "preserve";
  let gDocsRootOrSiblingNode = doc.evaluate('//*[@id and contains(@id, "docs-internal-guid")]', doc, null, _XPathResult.ORDERED_NODE_ITERATOR_TYPE, null).iterateNext();
  if (gDocsRootOrSiblingNode) {
    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === "b";
    if (!isWrappedRootTag) {
      gDocsRootOrSiblingNode = doc.body;
    }
    switch (whitespaceOnPasteMode) {
      case "normalize":
        normalizeWhitespace(gDocsRootOrSiblingNode);
        break;
      case "remove":
        removeAllWhitespace(gDocsRootOrSiblingNode);
        break;
    }
    const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
      const elm = childNodes.snapshotItem(i);
      elm == null ? void 0 : elm.setAttribute("data-is-google-docs", "true");
      if ((elm == null ? void 0 : elm.parentElement) === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) {
        elm == null ? void 0 : elm.setAttribute("data-is-root-node", "true");
        tagName(elm);
      }
      if (tagName(elm) === "li" && elm.firstChild && tagName(elm == null ? void 0 : elm.firstChild) === "img") {
        elm.removeChild(elm.firstChild);
      }
    }
    if (isWrappedRootTag) {
      (_a = doc.body.firstElementChild) == null ? void 0 : _a.replaceWith(...Array.from(gDocsRootOrSiblingNode.childNodes));
    }
    return doc;
  }
  return doc;
};
const unwantedWordDocumentPaths = ["/html/text()", "/html/head/text()", "/html/body/text()", "/html/body/ul/text()", "/html/body/ol/text()", "//comment()", "//style", "//xml", "//script", "//meta", "//link"];
var preprocessHTML = (html, doc) => {
  var _a, _b, _c;
  const bodyTextNodes = doc.evaluate("/html/body/text()", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
    const node = bodyTextNodes.snapshotItem(i);
    const text = node.textContent || "";
    if (text.replace(/[^\S\n]+$/g, "")) {
      const newNode = doc.createElement("span");
      newNode.appendChild(doc.createTextNode(text));
      (_a = node.parentNode) == null ? void 0 : _a.replaceChild(newNode, node);
    } else {
      (_b = node.parentNode) == null ? void 0 : _b.removeChild(node);
    }
  }
  const unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (!unwanted) {
      continue;
    }
    (_c = unwanted.parentNode) == null ? void 0 : _c.removeChild(unwanted);
  }
  return doc;
};
var preprocessNotion = (html, doc) => {
  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;
  if (html.match(NOTION_REGEX)) {
    const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
      const elm = childNodes.snapshotItem(i);
      elm == null ? void 0 : elm.setAttribute("data-is-notion", "true");
    }
    return doc;
  }
  return doc;
};
var preprocessWhitespace = (_, doc) => {
  function processNode(node) {
    var _a, _b;
    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(((_a = node.parentElement) == null ? void 0 : _a.tagName.toLowerCase()) || "")) {
      node.textContent = ((_b = node.textContent) == null ? void 0 : _b.replace(/\s\s+/g, " ").replace(/[\r\n]+/g, " ")) || "";
    } else {
      for (let i = 0; i < node.childNodes.length; i++) {
        processNode(node.childNodes[i]);
      }
    }
  }
  processNode(doc.body);
  return doc;
};
const WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/;
const unwantedPaths = ["//o:p", "//span[@style='mso-list:Ignore']", "//span[@style='mso-list: Ignore']"];
const mappedPaths = ["//p[@class='MsoTocHeading']", "//p[@class='MsoTitle']", "//p[@class='MsoToaHeading']", "//p[@class='MsoSubtitle']", "//span[@class='MsoSubtleEmphasis']", "//span[@class='MsoIntenseEmphasis']"];
const elementMap = {
  MsoTocHeading: ["h3"],
  MsoTitle: ["h1"],
  MsoToaHeading: ["h2"],
  MsoSubtitle: ["h5"],
  MsoSubtleEmphasis: ["span", "em"],
  MsoIntenseEmphasis: ["span", "em", "strong"]
  // Remove cruft
};
function isWordHtml(html) {
  return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc) => {
  var _a;
  if (!isWordHtml(html)) {
    return doc;
  }
  const unwantedNodes = doc.evaluate(unwantedPaths.join("|"), doc, prefix => {
    if (prefix === "o") {
      return "urn:schemas-microsoft-com:office:office";
    }
    return null;
  }, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (unwanted == null ? void 0 : unwanted.parentNode) {
      unwanted.parentNode.removeChild(unwanted);
    }
  }
  const mappedElements = doc.evaluate(mappedPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {
    const mappedElm = mappedElements.snapshotItem(i);
    const tags = elementMap[mappedElm.className];
    const text = new Text(mappedElm.textContent || "");
    if (!tags) {
      continue;
    }
    const parentElement = document.createElement(tags[0]);
    let parent = parentElement;
    let child = parentElement;
    tags.slice(1).forEach(tag => {
      child = document.createElement(tag);
      parent.appendChild(child);
      parent = child;
    });
    child.appendChild(text);
    (_a = mappedElm == null ? void 0 : mappedElm.parentNode) == null ? void 0 : _a.replaceChild(parentElement, mappedElm);
  }
  return doc;
};
var preprocessors = [preprocessWhitespace, preprocessNotion, preprocessWord, preprocessGDocs, preprocessHTML];
function createRuleOptions(blockContentType) {
  const features = blockContentFeatures(blockContentType);
  const enabledBlockStyles = features.styles.map(item => item.value || item.title);
  const enabledSpanDecorators = features.decorators.map(item => item.value || item.title);
  const enabledBlockAnnotations = features.annotations.map(item => item.value || item.title || "");
  const enabledListTypes = features.lists.map(item => item.value || item.title || "");
  return {
    enabledBlockStyles,
    enabledSpanDecorators,
    enabledBlockAnnotations,
    enabledListTypes
  };
}
function tagName(el) {
  if (el && "tagName" in el) {
    return el.tagName.toLowerCase();
  }
  return void 0;
}
function preprocess(html, parseHtml, options) {
  const doc = parseHtml(normalizeHtmlBeforePreprocess(html));
  preprocessors.forEach(processor => {
    processor(html, doc, options);
  });
  return doc;
}
function normalizeHtmlBeforePreprocess(html) {
  return html.trim();
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined") {
    throw new Error("The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.");
  }
  return html => {
    return new DOMParser().parseFromString(html, "text/html");
  };
}
function flattenNestedBlocks(blocks) {
  let depth = 0;
  const flattened = [];
  const traverse = nodes => {
    const toRemove = [];
    nodes.forEach(node => {
      if (depth === 0) {
        flattened.push(node);
      }
      if (isPortableTextTextBlock(node)) {
        if (depth > 0) {
          toRemove.push(node);
          flattened.push(node);
        }
        depth++;
        traverse(node.children);
      }
      if (node._type === "__block") {
        toRemove.push(node);
        flattened.push(node.block);
      }
    });
    toRemove.forEach(node => {
      nodes.splice(nodes.indexOf(node), 1);
    });
    depth--;
  };
  traverse(blocks);
  return flattened;
}
function nextSpan(block, index) {
  const next = block.children[index + 1];
  return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
  const prev = block.children[index - 1];
  return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
  return ["\xA0", " "].includes(text);
}
function trimWhitespace(blocks) {
  blocks.forEach(block => {
    if (!isPortableTextTextBlock(block)) {
      return;
    }
    block.children.forEach((child, index) => {
      if (!isMinimalSpan(child)) {
        return;
      }
      const nextChild = nextSpan(block, index);
      const prevChild = prevSpan(block, index);
      if (index === 0) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (index === block.children.length - 1) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(child.text.length - 1)) && nextChild && isMinimalSpan(nextChild) && /\s/.test(nextChild.text.substring(0, 1))) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (!child.text) {
        block.children.splice(index, 1);
      }
      if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        prevChild.text += " ";
        block.children.splice(index, 1);
      } else if (nextChild && isEqual(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        nextChild.text = " ".concat(nextChild.text);
        block.children.splice(index, 1);
      }
    });
  });
  return blocks;
}
function ensureRootIsBlocks(blocks) {
  return blocks.reduce((memo, node, i, original) => {
    if (node._type === "block") {
      memo.push(node);
      return memo;
    }
    if (node._type === "__block") {
      memo.push(node.block);
      return memo;
    }
    const lastBlock = memo[memo.length - 1];
    if (i > 0 && !isPortableTextTextBlock(original[i - 1]) && isPortableTextTextBlock(lastBlock)) {
      lastBlock.children.push(node);
      return memo;
    }
    const block = {
      ...DEFAULT_BLOCK,
      children: [node]
    };
    memo.push(block);
    return memo;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) == "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement(node) {
  return node.nodeType === 1;
}
function normalizeWhitespace(rootNode) {
  let emptyBlockCount = 0;
  let lastParent = null;
  const nodesToRemove = [];
  for (let child = rootNode.firstChild; child; child = child.nextSibling) {
    if (!isElement(child)) {
      normalizeWhitespace(child);
      emptyBlockCount = 0;
      continue;
    }
    const elm = child;
    if (isWhitespaceBlock(elm)) {
      if (lastParent && elm.parentElement === lastParent) {
        emptyBlockCount++;
        if (emptyBlockCount > 1) {
          nodesToRemove.push(elm);
        }
      } else {
        emptyBlockCount = 1;
      }
      lastParent = elm.parentElement;
    } else {
      normalizeWhitespace(child);
      emptyBlockCount = 0;
    }
  }
  nodesToRemove.forEach(node => {
    var _a;
    return (_a = node.parentElement) == null ? void 0 : _a.removeChild(node);
  });
}
function removeAllWhitespace(rootNode) {
  const nodesToRemove = [];
  function collectNodesToRemove(currentNode) {
    var _a, _b;
    if (isElement(currentNode)) {
      const elm = currentNode;
      if (tagName(elm) === "br" && (tagName(elm.nextElementSibling) === "p" || tagName(elm.previousElementSibling) === "p")) {
        nodesToRemove.push(elm);
        return;
      }
      if ((tagName(elm) === "p" || tagName(elm) === "br") && ((_b = (_a = elm == null ? void 0 : elm.firstChild) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim()) === "") {
        nodesToRemove.push(elm);
        return;
      }
      for (let child = elm.firstChild; child; child = child.nextSibling) {
        collectNodesToRemove(child);
      }
    }
  }
  collectNodesToRemove(rootNode);
  nodesToRemove.forEach(node => {
    var _a;
    return (_a = node.parentElement) == null ? void 0 : _a.removeChild(node);
  });
}
function isWhitespaceBlock(elm) {
  var _a;
  return ["p", "br"].includes(tagName(elm) || "") && !((_a = elm.textContent) == null ? void 0 : _a.trim());
}
const LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
function isEmphasis$1(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-style\s*:\s*italic/.test(style || "");
}
function isStrong$1(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-weight\s*:\s*700/.test(style || "");
}
function isUnderline$1(el) {
  if (!isElement(el) || tagName(el.parentNode) === "a") {
    return false;
  }
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration\s*:\s*underline/.test(style || "");
}
function isStrikethrough(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration\s*:\s*line-through/.test(style || "");
}
function isGoogleDocs(el) {
  return isElement(el) && Boolean(el.getAttribute("data-is-google-docs"));
}
function isRootNode(el) {
  return isElement(el) && Boolean(el.getAttribute("data-is-root-node"));
}
function getListItemStyle$1(el) {
  const parentTag = tagName(el.parentNode);
  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {
    return void 0;
  }
  return tagName(el.parentNode) === "ul" ? "bullet" : "number";
}
function getListItemLevel$1(el) {
  let level = 0;
  if (tagName(el) === "li") {
    let parentNode = el.parentNode;
    while (parentNode) {
      const parentTag = tagName(parentNode);
      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {
        level++;
      }
      parentNode = parentNode.parentNode;
    }
  } else {
    level = 1;
  }
  return level;
}
const blocks = {
  ...HTML_BLOCK_TAGS,
  ...HTML_HEADER_TAGS
};
function getBlockStyle(el, enabledBlockStyles) {
  const childTag = tagName(el.firstChild);
  const block = childTag && blocks[childTag];
  if (!block) {
    return BLOCK_DEFAULT_STYLE;
  }
  if (!enabledBlockStyles.includes(block.style)) {
    return BLOCK_DEFAULT_STYLE;
  }
  return block.style;
}
function createGDocsRules(_blockContentType, options) {
  return [{
    deserialize(el) {
      if (isElement(el) && tagName(el) === "span" && isGoogleDocs(el)) {
        const span = {
          ...DEFAULT_SPAN,
          marks: [],
          text: el.textContent
        };
        if (isStrong$1(el)) {
          span.marks.push("strong");
        }
        if (isUnderline$1(el)) {
          span.marks.push("underline");
        }
        if (isStrikethrough(el)) {
          span.marks.push("strike-through");
        }
        if (isEmphasis$1(el)) {
          span.marks.push("em");
        }
        return span;
      }
      return void 0;
    }
  }, {
    deserialize(el, next) {
      var _a;
      if (tagName(el) === "li" && isGoogleDocs(el)) {
        return {
          ...DEFAULT_BLOCK,
          listItem: getListItemStyle$1(el),
          level: getListItemLevel$1(el),
          style: getBlockStyle(el, options.enabledBlockStyles),
          children: next(((_a = el.firstChild) == null ? void 0 : _a.childNodes) || [])
        };
      }
      return void 0;
    }
  }, {
    deserialize(el) {
      var _a;
      if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && el.classList.contains("apple-interchange-newline")) {
        return {
          ...DEFAULT_SPAN,
          text: ""
        };
      }
      if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && ((_a = el == null ? void 0 : el.parentNode) == null ? void 0 : _a.textContent) === "") {
        return {
          ...DEFAULT_SPAN,
          text: ""
        };
      }
      if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && isRootNode(el)) {
        return {
          ...DEFAULT_SPAN,
          text: ""
        };
      }
      return void 0;
    }
  }];
}
function whatwgRNG() {
  let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length);
  getRandomValues(rnds8);
  return rnds8;
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substring(1);
}
function randomKey(length) {
  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], "").slice(0, length);
}
function resolveListItem(listNodeTagName, enabledListTypes) {
  if (listNodeTagName === "ul" && enabledListTypes.includes("bullet")) {
    return "bullet";
  }
  if (listNodeTagName === "ol" && enabledListTypes.includes("number")) {
    return "number";
  }
  return void 0;
}
function createHTMLRules(blockContentType, options) {
  return [
  // Text nodes
  {
    deserialize(el) {
      if (tagName(el) === "pre") {
        return void 0;
      }
      const isValidWhiteSpace = el.nodeType === 3 && (el.textContent || "").replace(/[\r\n]/g, " ").replace(/\s\s+/g, " ") === " " && el.nextSibling && el.nextSibling.nodeType !== 3 && el.previousSibling && el.previousSibling.nodeType !== 3;
      const isValidText = (isValidWhiteSpace || el.textContent !== " ") && tagName(el.parentNode) !== "body";
      if (el.nodeName === "#text" && isValidText) {
        return {
          ...DEFAULT_SPAN,
          marks: [],
          text: (el.textContent || "").replace(/\s\s+/g, " ")
        };
      }
      return void 0;
    }
  },
  // Pre element
  {
    deserialize(el) {
      if (tagName(el) !== "pre") {
        return void 0;
      }
      const isCodeEnabled = options.enabledBlockStyles.includes("code");
      return {
        _type: "block",
        style: "normal",
        markDefs: [],
        children: [{
          ...DEFAULT_SPAN,
          marks: isCodeEnabled ? ["code"] : [],
          text: el.textContent || ""
        }]
      };
    }
  },
  // Blockquote element
  {
    deserialize(el, next) {
      if (tagName(el) !== "blockquote") {
        return void 0;
      }
      const blocks = {
        ...HTML_BLOCK_TAGS,
        ...HTML_HEADER_TAGS
      };
      delete blocks.blockquote;
      const children = [];
      el.childNodes.forEach((node, index) => {
        if (node.nodeType === 1 && Object.keys(blocks).includes(node.localName.toLowerCase())) {
          if (!el.ownerDocument) {
            return;
          }
          const span = el.ownerDocument.createElement("span");
          span.appendChild(el.ownerDocument.createTextNode("\r"));
          node.childNodes.forEach(cn => {
            span.appendChild(cn.cloneNode(true));
          });
          if (index !== el.childNodes.length) {
            span.appendChild(el.ownerDocument.createTextNode("\r"));
          }
          children.push(span);
        } else {
          children.push(node);
        }
      });
      return {
        _type: "block",
        style: "blockquote",
        markDefs: [],
        children: next(children)
      };
    }
  },
  // Block elements
  {
    deserialize(el, next) {
      const blocks = {
        ...HTML_BLOCK_TAGS,
        ...HTML_HEADER_TAGS
      };
      const tag = tagName(el);
      let block = tag ? blocks[tag] : void 0;
      if (!block) {
        return void 0;
      }
      if (el.parentNode && tagName(el.parentNode) === "li") {
        return next(el.childNodes);
      }
      if (!options.enabledBlockStyles.includes(block.style)) {
        block = DEFAULT_BLOCK;
      }
      return {
        ...block,
        children: next(el.childNodes)
      };
    }
  },
  // Ignore span tags
  {
    deserialize(el, next) {
      const tag = tagName(el);
      if (!tag || !(tag in HTML_SPAN_TAGS)) {
        return void 0;
      }
      return next(el.childNodes);
    }
  },
  // Ignore div tags
  {
    deserialize(el, next) {
      const div = tagName(el) === "div";
      if (!div) {
        return void 0;
      }
      return next(el.childNodes);
    }
  },
  // Ignore list containers
  {
    deserialize(el, next) {
      const tag = tagName(el);
      if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
        return void 0;
      }
      return next(el.childNodes);
    }
  },
  // Deal with br's
  {
    deserialize(el) {
      if (tagName(el) === "br") {
        return {
          ...DEFAULT_SPAN,
          text: "\n"
        };
      }
      return void 0;
    }
  },
  // Deal with list items
  {
    deserialize(el, next, block) {
      const tag = tagName(el);
      const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0;
      const parentTag = tagName(el.parentNode) || "";
      if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
        return void 0;
      }
      const enabledListItem = resolveListItem(parentTag, options.enabledListTypes);
      if (!enabledListItem) {
        return block({
          _type: "block",
          children: next(el.childNodes)
        });
      }
      listItem.listItem = enabledListItem;
      return {
        ...listItem,
        children: next(el.childNodes)
      };
    }
  },
  // Deal with decorators - this is a limited set of known html elements that we know how to deserialize
  {
    deserialize(el, next) {
      const decorator = HTML_DECORATOR_TAGS[tagName(el) || ""];
      if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
        return void 0;
      }
      return {
        _type: "__decorator",
        name: decorator,
        children: next(el.childNodes)
      };
    }
  },
  // Special case for hyperlinks, add annotation (if allowed by schema),
  // If not supported just write out the link text and href in plain text.
  {
    deserialize(el, next) {
      if (tagName(el) != "a") {
        return void 0;
      }
      const linkEnabled = options.enabledBlockAnnotations.includes("link");
      const href = isElement(el) && el.getAttribute("href");
      if (!href) {
        return next(el.childNodes);
      }
      let markDef;
      if (linkEnabled) {
        markDef = {
          _key: randomKey(12),
          _type: "link",
          href
        };
        return {
          _type: "__annotation",
          markDef,
          children: next(el.childNodes)
        };
      }
      return el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
    }
  }];
}
function isEmphasis(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-style:italic/.test(style || "");
}
function isStrong(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-weight:700/.test(style || "") || /font-weight:600/.test(style || "");
}
function isUnderline(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /text-decoration:underline/.test(style || "");
}
function isNotion(el) {
  return isElement(el) && Boolean(el.getAttribute("data-is-notion"));
}
function createNotionRules(_blockContentType) {
  return [{
    deserialize(el) {
      if (isElement(el) && tagName(el) === "span" && isNotion(el)) {
        const span = {
          ...DEFAULT_SPAN,
          marks: [],
          text: el.textContent
        };
        if (isStrong(el)) {
          span.marks.push("strong");
        }
        if (isUnderline(el)) {
          span.marks.push("underline");
        }
        if (isEmphasis(el)) {
          span.marks.push("em");
        }
        return span;
      }
      return void 0;
    }
  }];
}
function getListItemStyle(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  if (!style.match(/lfo\d+/)) {
    return void 0;
  }
  return style.match("lfo1") ? "bullet" : "number";
}
function getListItemLevel(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  const levelMatch = style.match(/level\d+/);
  if (!levelMatch) {
    return void 0;
  }
  const [level] = levelMatch[0].match(/\d/) || [];
  const levelNum = level ? parseInt(level, 10) : 1;
  return levelNum || 1;
}
function isWordListElement(el) {
  return isElement(el) && el.className ? el.className === "MsoListParagraphCxSpFirst" || el.className === "MsoListParagraphCxSpMiddle" || el.className === "MsoListParagraphCxSpLast" : false;
}
function createWordRules() {
  return [{
    deserialize(el, next) {
      if (tagName(el) === "p" && isWordListElement(el)) {
        return {
          ...DEFAULT_BLOCK,
          listItem: getListItemStyle(el),
          level: getListItemLevel(el),
          style: BLOCK_DEFAULT_STYLE,
          children: next(el.childNodes)
        };
      }
      return void 0;
    }
  }];
}
function createRules(blockContentType, options) {
  return [...createWordRules(), ...createNotionRules(), ...createGDocsRules(blockContentType, options), ...createHTMLRules(blockContentType, options)];
}
class HtmlDeserializer {
  /**
   * Create a new serializer respecting a Sanity block content type's schema
   *
   * @param blockContentType - Schema type for array containing _at least_ a block child type
   * @param options - Options for the deserialization process
   */
  constructor(blockContentType) {
    var _this = this;
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this._markDefs = [];
    /**
     * Deserialize HTML.
     *
     * @param html - The HTML to deserialize, as a string
     * @returns Array of blocks - either portable text blocks or other allowed blocks
     */
    this.deserialize = html => {
      this._markDefs = [];
      const {
        parseHtml
      } = this;
      const fragment = parseHtml(html);
      const children = Array.from(fragment.childNodes);
      const blocks = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))));
      if (this._markDefs.length > 0) {
        blocks.filter(block => block._type === "block").forEach(block => {
          block.markDefs = block.markDefs || [];
          block.markDefs = block.markDefs.concat(this._markDefs.filter(def => {
            return flatten(block.children.map(child => child.marks || [])).includes(def._key);
          }));
        });
      }
      const type = this.blockContentType.of.find(findBlockType);
      if (!type) {
        return blocks;
      }
      return blocks.map(block => {
        if (block._type === "block") {
          block._type = type.name;
        }
        return block;
      });
    };
    /**
     * Deserialize an array of DOM elements.
     *
     * @param elements - Array of DOM elements to deserialize
     * @returns
     */
    this.deserializeElements = function () {
      let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let nodes = [];
      elements.forEach(element => {
        nodes = nodes.concat(_this.deserializeElement(element));
      });
      return nodes;
    };
    /**
     * Deserialize a DOM element
     *
     * @param element - Deserialize a DOM element
     * @returns
     */
    this.deserializeElement = element => {
      var _a, _b;
      const next = elements => {
        if (isNodeList(elements)) {
          return this.deserializeElements(Array.from(elements));
        }
        if (Array.isArray(elements)) {
          return this.deserializeElements(elements);
        }
        if (!elements) {
          return void 0;
        }
        return this.deserializeElement(elements);
      };
      const block = props => {
        return {
          _type: "__block",
          block: props
        };
      };
      let node;
      for (let i = 0; i < this.rules.length; i++) {
        const rule = this.rules[i];
        if (!rule.deserialize) {
          continue;
        }
        const ret = rule.deserialize(element, next, block);
        const type = resolveJsType(ret);
        if (type !== "array" && type !== "object" && type !== "null" && type !== "undefined") {
          throw new Error('A rule returned an invalid deserialized representation: "'.concat(node, '".'));
        }
        if (ret === void 0) {
          continue;
        } else if (ret === null) {
          throw new Error("Deserializer rule returned `null`");
        } else if (Array.isArray(ret)) {
          node = ret;
        } else if (isPlaceholderDecorator(ret)) {
          node = this.deserializeDecorator(ret);
        } else if (isPlaceholderAnnotation(ret)) {
          node = this.deserializeAnnotation(ret);
        } else {
          node = ret;
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && "listItem" in ret) {
          let parent = (_a = element.parentNode) == null ? void 0 : _a.parentNode;
          while (parent && tagName(parent) === "li") {
            parent = (_b = parent.parentNode) == null ? void 0 : _b.parentNode;
            ret.level = ret.level ? ret.level + 1 : 1;
          }
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === "blockquote") {
          ret.children.forEach((child, index) => {
            if (isMinimalSpan(child) && child.text === "\r") {
              child.text = "\n\n";
              if (index === 0 || index === ret.children.length - 1) {
                ret.children.splice(index, 1);
              }
            }
          });
        }
        break;
      }
      return node || next(element.childNodes) || [];
    };
    /**
     * Deserialize a `__decorator` type
     * (an internal made up type to process decorators exclusively)
     *
     * @param decorator -
     * @returns array of ...
     */
    this.deserializeDecorator = decorator => {
      const {
        name
      } = decorator;
      const applyDecorator = node => {
        if (isPlaceholderDecorator(node)) {
          return this.deserializeDecorator(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(name);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyDecorator);
        }
        return node;
      };
      return decorator.children.reduce((children, node) => {
        const ret = applyDecorator(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    /**
     * Deserialize a `__annotation` object.
     * (an internal made up type to process annotations exclusively)
     *
     * @param annotation -
     * @returns Array of...
     */
    this.deserializeAnnotation = annotation => {
      const {
        markDef
      } = annotation;
      this._markDefs.push(markDef);
      const applyAnnotation = node => {
        if (isPlaceholderAnnotation(node)) {
          return this.deserializeAnnotation(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(markDef._key);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyAnnotation);
        }
        return node;
      };
      return annotation.children.reduce((children, node) => {
        const ret = applyAnnotation(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    const {
      rules = [],
      unstable_whitespaceOnPasteMode = "preserve"
    } = options;
    if (!blockContentType) {
      throw new Error("Parameter 'blockContentType' is required");
    }
    const standardRules = createRules(blockContentType, createRuleOptions(blockContentType));
    this.rules = [...rules, ...standardRules];
    const parseHtml = options.parseHtml || defaultParseHtml();
    this.blockContentType = blockContentType;
    this.parseHtml = html => {
      const doc = preprocess(html, parseHtml, {
        unstable_whitespaceOnPasteMode
      });
      return doc.body;
    };
  }
}
function normalizeBlock(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (node._type !== (options.blockTypeName || "block")) {
    return "_key" in node ? node : {
      ...node,
      _key: randomKey(12)
    };
  }
  const block = {
    _key: randomKey(12),
    children: [],
    markDefs: [],
    ...node
  };
  const lastChild = block.children[block.children.length - 1];
  if (!lastChild) {
    block.children = [{
      _type: "span",
      _key: "".concat(block._key).concat(0),
      text: "",
      marks: []
    }];
    return block;
  }
  const usedMarkDefs = [];
  const allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : false;
  block.children = block.children.reduce((acc, child) => {
    const previousChild = acc[acc.length - 1];
    if (previousChild && isPortableTextSpan(child) && isPortableTextSpan(previousChild) && isEqual(previousChild.marks, child.marks)) {
      if (lastChild && lastChild === child && child.text === "" && block.children.length > 1) {
        return acc;
      }
      previousChild.text += child.text;
      return acc;
    }
    acc.push(child);
    return acc;
  }, []).map((child, index) => {
    if (!child) {
      throw new Error("missing child");
    }
    child._key = "".concat(block._key).concat(index);
    if (isPortableTextSpan(child)) {
      if (!child.marks) {
        child.marks = [];
      } else if (allowedDecorators) {
        child.marks = child.marks.filter(mark => {
          var _a;
          const isAllowed = allowedDecorators.includes(mark);
          const isUsed = (_a = block.markDefs) == null ? void 0 : _a.some(def => def._key === mark);
          return isAllowed || isUsed;
        });
      }
      usedMarkDefs.push(...child.marks);
    }
    return child;
  });
  block.markDefs = (block.markDefs || []).filter(markDef => usedMarkDefs.includes(markDef._key));
  return block;
}
function htmlToBlocks(html, blockContentType) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const deserializer = new HtmlDeserializer(blockContentType, options);
  return deserializer.deserialize(html).map(block => normalizeBlock(block));
}
function getBlockContentFeatures(blockContentType) {
  return blockContentFeatures(blockContentType);
}
export { getBlockContentFeatures, htmlToBlocks, normalizeBlock, randomKey };
//# sourceMappingURL=index.esm.js.map
