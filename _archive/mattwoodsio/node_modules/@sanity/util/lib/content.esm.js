import getRandomValues from 'get-random-values-esm';
var hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isDeepEmptyObject(value) {
  for (const key in value) {
    if (key === "_type" || key === "_key") {
      continue;
    }
    if (hasOwn(value, key) && !isDeepEmpty(value[key])) {
      return false;
    }
  }
  return true;
}
function isDeepEmptyArray(value) {
  for (let i = 0; i < value.length; i++) {
    if (!isDeepEmpty(value[i])) {
      return false;
    }
  }
  return true;
}
function isDeepEmpty(value) {
  if (value === void 0 || value === null) {
    return true;
  }
  const type = typeof value;
  if (Array.isArray(value)) {
    return isDeepEmptyArray(value);
  }
  if (type === "object") {
    return isDeepEmptyObject(value);
  }
  return false;
}
const isEmptyArray = isDeepEmptyArray;
const isEmpty = isDeepEmpty;
const isEmptyObject = isDeepEmptyObject;
function isShallowEmptyObject(value) {
  for (const key in value) {
    if (key === "_type" || key === "_key") {
      continue;
    }
    if (hasOwn(value, key) && value[key] !== void 0) {
      return false;
    }
  }
  return true;
}
const getByteHexTable = /* @__PURE__ */(() => {
  let table;
  return () => {
    if (table) {
      return table;
    }
    table = [];
    for (let i = 0; i < 256; ++i) {
      table[i] = (i + 256).toString(16).substring(1);
    }
    return table;
  };
})();
function whatwgRNG() {
  let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length);
  getRandomValues(rnds8);
  return rnds8;
}
function randomKey(length) {
  const table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], "").slice(0, length);
}
const toString = Object.prototype.toString;
function resolveJSType(val) {
  switch (toString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  if (typeof val == "object" && val && typeof val.length == "number") {
    try {
      if (typeof val.callee == "function") {
        return "arguments";
      }
    } catch (ex) {
      if (ex instanceof TypeError) {
        return "arguments";
      }
    }
  }
  if (val === null) {
    return "null";
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val && val.nodeType === 1) {
    return "element";
  }
  if (val === Object(val)) {
    return "object";
  }
  return typeof val;
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object") {
    return jsType;
  }
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
export { isDeepEmpty, isEmpty, isEmptyArray, isEmptyObject, isShallowEmptyObject, randomKey, resolveTypeName };
//# sourceMappingURL=content.esm.js.map
