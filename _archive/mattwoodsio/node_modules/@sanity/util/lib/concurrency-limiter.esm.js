class ConcurrencyLimiter {
  constructor(max) {
    this.max = max;
    this.current = 0;
    this.resolvers = [];
    /**
     * Indicates when a slot for a new operation is ready.
     * If under the limit, it resolves immediately; otherwise, it waits until a slot is free.
     */
    this.ready = () => {
      if (this.max === Infinity) return Promise.resolve();
      if (this.current < this.max) {
        this.current++;
        return Promise.resolve();
      }
      return new Promise(resolve => {
        this.resolvers.push(resolve);
      });
    };
    /**
     * Releases a slot, decrementing the current count of operations if nothing is in the queue.
     * If there are operations waiting, it allows the next one in the queue to proceed.
     */
    this.release = () => {
      if (this.max === Infinity) return;
      const nextResolver = this.resolvers.shift();
      if (nextResolver) {
        nextResolver();
        return;
      }
      this.current = Math.max(0, this.current - 1);
    };
  }
}
export { ConcurrencyLimiter };
//# sourceMappingURL=concurrency-limiter.esm.js.map
