{"version":3,"file":"paths.esm.js","sources":["../src/paths.ts"],"sourcesContent":["import {\n  type IndexTuple,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  type KeyedSegment,\n  type Path,\n  type PathSegment,\n} from '@sanity/types'\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst EMPTY_PATH: Path = []\n\nexport const FOCUS_TERMINATOR = '$'\n\nexport function get<R>(obj: unknown, path: Path | string): R | undefined\nexport function get<R>(obj: unknown, path: Path | string, defaultValue: R): R\nexport function get(obj: unknown, path: Path | string, defaultVal?: unknown): unknown {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Record<string, unknown>)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc\n}\n\nconst pathsMemo = new Map<string, Path>()\nexport function pathFor(path: Path): Path {\n  if (path.length === 0) {\n    return EMPTY_PATH\n  }\n  const asString = toString(path)\n  if (pathsMemo.has(asString)) {\n    return pathsMemo.get(asString)!\n  }\n  pathsMemo.set(asString, path)\n  Object.freeze(path)\n  return path\n}\n\nexport function isEqual(path: Path, otherPath: Path): boolean {\n  return (\n    path.length === otherPath.length &&\n    path.every((segment, i) => isSegmentEqual(segment, otherPath[i]))\n  )\n}\n\nexport function numEqualSegments(path: Path, otherPath: Path): number {\n  const length = Math.min(path.length, otherPath.length)\n  for (let i = 0; i < length; i++) {\n    if (!isSegmentEqual(path[i], otherPath[i])) {\n      return i\n    }\n  }\n  return length\n}\n\nexport function isSegmentEqual(segmentA: PathSegment, segmentB: PathSegment): boolean {\n  if (isKeySegment(segmentA) && isKeySegment(segmentB)) {\n    return segmentA._key === segmentB._key\n  }\n\n  if (isIndexSegment(segmentA)) {\n    return Number(segmentA) === Number(segmentB)\n  }\n\n  if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {\n    return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1]\n  }\n\n  return segmentA === segmentB\n}\n\nexport function hasFocus(focusPath: Path, path: Path): boolean {\n  const withoutTerminator =\n    focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath\n  return isEqual(withoutTerminator, path)\n}\n\nexport function hasItemFocus(focusPath: Path, item: PathSegment): boolean {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item)\n}\n\nexport function isExpanded(segment: PathSegment, focusPath: Path): boolean {\n  const [head, ...tail] = focusPath\n  return tail.length > 0 && isSegmentEqual(segment, head)\n}\n\nexport function startsWith(prefix: Path, path: Path): boolean {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]))\n}\n\nexport function trimLeft(prefix: Path, path: Path): Path {\n  if (prefix.length === 0 || path.length === 0) {\n    return path\n  }\n  const [prefixHead, ...prefixTail] = prefix\n  const [pathHead, ...pathTail] = path\n  if (!isSegmentEqual(prefixHead, pathHead)) {\n    return path\n  }\n  return pathFor(trimLeft(prefixTail, pathTail))\n}\n\nexport function trimRight(suffix: Path, path: Path): Path {\n  const sufLen = suffix.length\n  const pathLen = path.length\n  if (sufLen === 0 || pathLen === 0) {\n    return path\n  }\n\n  let i = 0\n  while (\n    i < sufLen &&\n    i < pathLen &&\n    isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])\n  ) {\n    i++\n  }\n\n  return pathFor(path.slice(0, pathLen - i))\n}\n\nexport function trimChildPath(path: Path, childPath: Path): Path {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH\n}\n\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\nexport function _resolveKeyedPath(value: unknown, path: Path): Path {\n  if (path.length === 0) {\n    return path\n  }\n  const [next, ...rest] = path\n  if (typeof next === 'number') {\n    if (!Array.isArray(value) || !(next in value)) {\n      return []\n    }\n    const item = value[next]\n    const key = item?._key\n    return [typeof key === 'string' ? {_key: item._key} : next, ..._resolveKeyedPath(item, rest)]\n  }\n  const nextVal = get(value, [next])\n  return [next, ..._resolveKeyedPath(nextVal, rest)]\n}\n\n/**\n * Takes a value and a path that may include numeric indices and attempts to replace numeric indices with keyed paths\n *\n * @param value - any json value\n * @param path - a Path that may include numeric indices\n * @returns a path where numeric indices has been replaced by keyed segments (e.g. `{_key: <key>}`)\n * Will do as good attempt as possible, but in case of missing array items, it will return the best possible match:\n * - `resolveKeyedPath([0, 'bar'], [])` will return [] since array has no value at index 0\n * - `resolveKeyedPath([0, 'foo'], [{_key: 'xyz', 'foo': 'bar'}, {_key: 'abc'}])` will return `[{_key: 'xyz'}, 'foo']` since array has no value at index 0\n * - `resolveKeyedPath([0, 'foo', 'bar'], [{_key: 'xyz'}])` will return `[{_key: 'xyz'}, 'foo', 'bar']` since array has no value at index 0\n * Object keys will be preserved as-is, e.g. `resolveKeyedPath(['foo', 'bar'], undefined)` will return `['foo', 'bar']`\n */\nexport function resolveKeyedPath(value: unknown, path: Path): Path {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n  return pathFor(_resolveKeyedPath(value, path))\n}\n\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(normalizePathSegment)\n}\n\nfunction normalizePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return normalizeIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return normalizeKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return normalizeIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction normalizeIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction normalizeKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction normalizeIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n"],"names":["rePropName","reKeySegment","EMPTY_PATH","FOCUS_TERMINATOR","get","obj","path","defaultVal","select","fromString","Array","isArray","Error","acc","i","length","segment","isIndexSegment","isKeySegment","find","item","_key","pathsMemo","Map","pathFor","asString","toString","has","set","Object","freeze","isEqual","otherPath","every","isSegmentEqual","numEqualSegments","Math","min","segmentA","segmentB","Number","isIndexTuple","hasFocus","focusPath","withoutTerminator","slice","hasItemFocus","isExpanded","head","tail","startsWith","prefix","trimLeft","prefixHead","prefixTail","pathHead","pathTail","trimRight","suffix","sufLen","pathLen","trimChildPath","childPath","reduce","target","segmentType","concat","separator","from","to","stringify","_resolveKeyedPath","value","next","rest","key","nextVal","resolveKeyedPath","segments","match","map","normalizePathSegment","normalizeIndexSegment","normalizeKeySegment","normalizeIndexTupleSegment","replace","split","seg"],"mappings":"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"}