'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var rxjs = require('rxjs');
var concurrencyLimiter = require('./concurrency-limiter.js');
function createClientConcurrencyLimiter(maxConcurrency) {
  const limiter = new concurrencyLimiter.ConcurrencyLimiter(maxConcurrency);
  function wrapClient(client) {
    return new Proxy(client, {
      get: (target, property) => {
        switch (property) {
          case "fetch":
            {
              return async function () {
                await limiter.ready();
                try {
                  return await target.fetch(...arguments);
                } finally {
                  limiter.release();
                }
              };
            }
          case "clone":
            {
              return function () {
                return wrapClient(target.clone(...arguments));
              };
            }
          case "config":
            {
              return function () {
                const result = target.config(...arguments);
                if (arguments.length <= 0 ? undefined : arguments[0]) return wrapClient(result);
                return result;
              };
            }
          case "withConfig":
            {
              return function () {
                return wrapClient(target.withConfig(...arguments));
              };
            }
          case "observable":
            {
              return wrapObservableClient(target.observable);
            }
          default:
            {
              return target[property];
            }
        }
      }
    });
  }
  function wrapObservableClient(observableSanityClient) {
    return new Proxy(observableSanityClient, {
      get: (target, property) => {
        switch (property) {
          case "fetch":
            {
              return function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return rxjs.from(limiter.ready()).pipe(rxjs.switchMap(() => target.fetch(...args)), rxjs.finalize(() => limiter.release()));
              };
            }
          case "clone":
            {
              return function () {
                return wrapObservableClient(target.clone(...arguments));
              };
            }
          case "config":
            {
              return function () {
                const result = target.config(...arguments);
                if (arguments.length <= 0 ? undefined : arguments[0]) return wrapObservableClient(result);
                return result;
              };
            }
          case "withConfig":
            {
              return function () {
                return wrapObservableClient(target.withConfig(...arguments));
              };
            }
          default:
            {
              return target[property];
            }
        }
      }
    });
  }
  return wrapClient;
}
exports.createClientConcurrencyLimiter = createClientConcurrencyLimiter;
//# sourceMappingURL=client.js.map
