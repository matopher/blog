{"version":3,"file":"index.esm.js","sources":["../src/document/debug.ts","../src/patch/ImmutableAccessor.ts","../src/util.ts","../src/jsonpath/arrayToJSONMatchPath.ts","../src/jsonpath/descend.ts","../src/jsonpath/tokenize.ts","../src/jsonpath/parse.ts","../src/jsonpath/toPath.ts","../src/jsonpath/Expression.ts","../src/jsonpath/Descender.ts","../src/jsonpath/Matcher.ts","../src/jsonpath/PlainProbe.ts","../src/jsonpath/extractAccessors.ts","../src/jsonpath/extract.ts","../src/jsonpath/extractWithPath.ts","../src/patch/DiffMatchPatch.ts","../src/patch/IncPatch.ts","../src/patch/util.ts","../src/patch/InsertPatch.ts","../src/patch/SetIfMissingPatch.ts","../src/patch/SetPatch.ts","../src/patch/UnsetPatch.ts","../src/patch/parse.ts","../src/patch/Patcher.ts","../src/document/luid.ts","../src/document/Mutation.ts","../src/document/Document.ts","../src/document/SquashingBuffer.ts","../src/document/BufferedDocument.ts"],"sourcesContent":["import debugIt from 'debug'\n\nexport const debug = debugIt('mutator-document')\n","import {type Probe} from '../jsonpath/Probe'\n\n/**\n * An immutable probe/writer for plain JS objects that will never mutate\n * the provided _value in place. Each setter returns a new (wrapped) version\n * of the value.\n */\nexport class ImmutableAccessor implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  // Common reader, supported by all containers\n  get(): unknown {\n    return this._value\n  }\n\n  // Array reader\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): ImmutableAccessor | false | null {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[i], this.path.concat(i))\n  }\n\n  // Object reader\n  hasAttribute(key: string): boolean {\n    return isRecord(this._value) ? this._value.hasOwnProperty(key) : false\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): ImmutableAccessor | null {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[key], this.path.concat(key))\n  }\n\n  // Common writer, supported by all containers\n  set(value: unknown): ImmutableAccessor {\n    return value === this._value ? this : new ImmutableAccessor(value, this.path)\n  }\n\n  // array writer interface\n  setIndex(i: number, value: unknown): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('setIndex only applies to arrays')\n    }\n\n    if (Object.is(value, this._value[i])) {\n      return this\n    }\n\n    const nextValue = this._value.slice()\n    nextValue[i] = value\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setIndexAccessor(i: number, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setIndex(i, accessor.get())\n  }\n\n  unsetIndices(indices: number[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('unsetIndices only applies to arrays')\n    }\n\n    const length = this._value.length\n    const nextValue = []\n    // Copy every _value _not_ in the indices array over to the newValue\n    for (let i = 0; i < length; i++) {\n      if (indices.indexOf(i) === -1) {\n        nextValue.push(this._value[i])\n      }\n    }\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  insertItemsAt(pos: number, items: unknown[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('insertItemsAt only applies to arrays')\n    }\n\n    let nextValue\n    if (this._value.length === 0 && pos === 0) {\n      nextValue = items\n    } else {\n      nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos))\n    }\n\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  // Object writer interface\n  setAttribute(key: string, value: unknown): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to set attribute of non-object container')\n    }\n\n    if (Object.is(value, this._value[key])) {\n      return this\n    }\n\n    const nextValue = Object.assign({}, this._value, {[key]: value})\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setAttributeAccessor(key: string, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setAttribute(key, accessor.get())\n  }\n\n  unsetAttribute(key: string): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to unset attribute of non-object container')\n    }\n\n    const nextValue = Object.assign({}, this._value)\n    delete nextValue[key]\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n}\n\nfunction isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","export function isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","import {type Path, type PathSegment} from '@sanity/types'\n\nimport {isRecord} from '../util'\n\nconst IS_DOTTABLE = /^[a-z_$]+/\n\n/**\n * Converts a path in array form to a JSONPath string\n *\n * @param pathArray - Array of path segments\n * @returns String representation of the path\n * @internal\n */\nexport function arrayToJSONMatchPath(pathArray: Path): string {\n  let path = ''\n  pathArray.forEach((segment, index) => {\n    path += stringifySegment(segment, index === 0)\n  })\n  return path\n}\n\n// Converts an array of simple values (strings, numbers only) to a jsonmatch path string.\nfunction stringifySegment(\n  segment: PathSegment | Record<string, unknown>,\n  hasLeading: boolean,\n): string {\n  if (typeof segment === 'number') {\n    return `[${segment}]`\n  }\n\n  if (isRecord(segment)) {\n    const seg = segment as Record<string, unknown>\n    return Object.keys(segment)\n      .map((key) => (isPrimitiveValue(seg[key]) ? `[${key}==\"${seg[key]}\"]` : ''))\n      .join('')\n  }\n\n  if (typeof segment === 'string' && IS_DOTTABLE.test(segment)) {\n    return hasLeading ? segment : `.${segment}`\n  }\n\n  return `['${segment}']`\n}\n\nfunction isPrimitiveValue(val: unknown): val is string | number | boolean {\n  switch (typeof val) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n      return true\n    default:\n      return false\n  }\n}\n","import {type Expr, type PathExpr} from './types'\n\n/**\n * Splits an expression into a set of heads, tails. A head is the next leaf node to\n * check for matches, and a tail is everything that follows it. Matching is done by\n * matching heads, then proceedint to the matching value, splitting the tail into\n * heads and tails and checking the heads against the new value, and so on.\n */\nexport function descend(tail: Expr): [Expr | null, PathExpr | null][] {\n  const [head, newTail] = splitIfPath(tail)\n  if (!head) {\n    throw new Error('Head cannot be null')\n  }\n\n  return spreadIfUnionHead(head, newTail)\n}\n\n// Split path in [head, tail]\nfunction splitIfPath(tail: Expr): [Expr | null, PathExpr | null] {\n  if (tail.type !== 'path') {\n    return [tail, null]\n  }\n\n  const nodes = tail.nodes\n  if (nodes.length === 0) {\n    return [null, null]\n  }\n\n  if (nodes.length === 1) {\n    return [nodes[0], null]\n  }\n\n  return [nodes[0], {type: 'path', nodes: nodes.slice(1)}]\n}\n\nfunction concatPaths(path1: PathExpr | null, path2: PathExpr | null): PathExpr | null {\n  if (!path1 && !path2) {\n    return null\n  }\n\n  const nodes1 = path1 ? path1.nodes : []\n  const nodes2 = path2 ? path2.nodes : []\n  return {\n    type: 'path',\n    nodes: nodes1.concat(nodes2),\n  }\n}\n\n// Spreads a union head into several heads/tails\nfunction spreadIfUnionHead(head: Expr, tail: PathExpr | null): [Expr | null, PathExpr | null][] {\n  if (head.type !== 'union') {\n    return [[head, tail]]\n  }\n\n  return head.nodes.map((node) => {\n    if (node.type === 'path') {\n      const [subHead, subTail] = splitIfPath(node)\n      return [subHead, concatPaths(subTail, tail)]\n    }\n\n    return [node, tail]\n  })\n}\n","import {\n  type IdentifierToken,\n  type NumberToken,\n  type QuotedToken,\n  type SymbolClass,\n  type SymbolToken,\n  type Token,\n} from './types'\n\n// TODO: Support '*'\n\nconst digitChar = /[0-9]/\nconst attributeCharMatcher = /^[a-zA-Z0-9_]$/\nconst attributeFirstCharMatcher = /^[a-zA-Z_]$/\n\nconst symbols: Record<SymbolClass, string[]> = {\n  // NOTE: These are compared against in order of definition,\n  // thus '==' must come before '=', '>=' before '>', etc.\n  operator: ['..', '.', ',', ':', '?'],\n  comparator: ['>=', '<=', '<', '>', '==', '!='],\n  keyword: ['$', '@'],\n  boolean: ['true', 'false'],\n  paren: ['[', ']'],\n}\n\nconst symbolClasses = Object.keys(symbols) as SymbolClass[]\n\ntype TokenizerFn = () => Token | null\n\n/**\n * Tokenizes a jsonpath2 expression\n */\nclass Tokenizer {\n  source: string\n  i: number\n  length: number\n  tokenizers: TokenizerFn[]\n\n  constructor(path: string) {\n    this.source = path\n    this.length = path.length\n    this.i = 0\n    this.tokenizers = [\n      this.tokenizeSymbol,\n      this.tokenizeIdentifier,\n      this.tokenizeNumber,\n      this.tokenizeQuoted,\n    ].map((fn) => fn.bind(this))\n  }\n\n  tokenize(): Token[] {\n    const result: Token[] = []\n    while (!this.EOF()) {\n      this.chompWhitespace()\n      let token: Token | null = null\n      // @todo refactor into a simpler `.find()`?\n      const found = this.tokenizers.some((tokenizer) => {\n        token = tokenizer()\n        return Boolean(token)\n      })\n      if (!found || !token) {\n        throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`)\n      }\n      result.push(token)\n    }\n    return result\n  }\n\n  takeWhile(fn: (character: string) => string | null): string | null {\n    const start = this.i\n    let result = ''\n    while (!this.EOF()) {\n      const nextChar = fn(this.source[this.i])\n      if (nextChar === null) {\n        break\n      }\n      result += nextChar\n      this.i++\n    }\n    if (this.i === start) {\n      return null\n    }\n    return result\n  }\n\n  EOF(): boolean {\n    return this.i >= this.length\n  }\n\n  peek(): string | null {\n    if (this.EOF()) {\n      return null\n    }\n    return this.source[this.i]\n  }\n\n  consume(str: string) {\n    if (this.i + str.length > this.length) {\n      throw new Error(`Expected ${str} at end of jsonpath`)\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n    } else {\n      throw new Error(`Expected \"${str}\", but source contained \"${this.source.slice()}`)\n    }\n  }\n\n  // Tries to match the upcoming bit of string with the provided string. If it matches, returns\n  // the string, then advances the read pointer to the next bit. If not, returns null and nothing\n  // happens.\n  tryConsume(str: string) {\n    if (this.i + str.length > this.length) {\n      return null\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n      return str\n    }\n    return null\n  }\n\n  chompWhitespace(): void {\n    this.takeWhile((char): string | null => {\n      return char === ' ' ? '' : null\n    })\n  }\n\n  tokenizeQuoted(): QuotedToken | null {\n    const quote = this.peek()\n    if (quote === \"'\" || quote === '\"') {\n      this.consume(quote)\n      let escape = false\n      const inner = this.takeWhile((char) => {\n        if (escape) {\n          escape = false\n          return char\n        }\n        if (char === '\\\\') {\n          escape = true\n          return ''\n        }\n        if (char != quote) {\n          return char\n        }\n        return null\n      })\n      this.consume(quote)\n      return {\n        type: 'quoted',\n        value: inner,\n        quote: quote === '\"' ? 'double' : 'single',\n      }\n    }\n    return null\n  }\n\n  tokenizeIdentifier(): IdentifierToken | null {\n    let first = true\n    const identifier = this.takeWhile((char) => {\n      if (first) {\n        first = false\n        return char.match(attributeFirstCharMatcher) ? char : null\n      }\n      return char.match(attributeCharMatcher) ? char : null\n    })\n    if (identifier !== null) {\n      return {\n        type: 'identifier',\n        name: identifier,\n      }\n    }\n    return null\n  }\n\n  tokenizeNumber(): NumberToken | null {\n    const start = this.i\n    let dotSeen = false\n    let digitSeen = false\n    let negative = false\n    if (this.peek() === '-') {\n      negative = true\n      this.consume('-')\n    }\n    const number = this.takeWhile((char) => {\n      if (char === '.' && !dotSeen && digitSeen) {\n        dotSeen = true\n        return char\n      }\n      digitSeen = true\n      return char.match(digitChar) ? char : null\n    })\n    if (number !== null) {\n      return {\n        type: 'number',\n        value: negative ? -number : +number,\n        raw: negative ? `-${number}` : number,\n      }\n    }\n    // No number, rewind\n    this.i = start\n    return null\n  }\n\n  tokenizeSymbol(): SymbolToken | null {\n    for (const symbolClass of symbolClasses) {\n      const patterns = symbols[symbolClass]\n      const symbol = patterns.find((pattern) => this.tryConsume(pattern))\n      if (symbol) {\n        return {\n          type: symbolClass,\n          symbol,\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nexport function tokenize(jsonpath: string): Token[] {\n  return new Tokenizer(jsonpath).tokenize()\n}\n","// Converts a string into an abstract syntax tree representation\n\nimport {tokenize} from './tokenize'\nimport {\n  type AliasExpr,\n  type AttributeExpr,\n  type BooleanExpr,\n  type ConstraintExpr,\n  type IndexExpr,\n  type NumberExpr,\n  type PathExpr,\n  type RangeExpr,\n  type RecursiveExpr,\n  type StringExpr,\n  type Token,\n  type UnionExpr,\n} from './types'\n\n// TODO: Support '*'\n\nclass Parser {\n  tokens: Token[]\n  length: number\n  i: number\n\n  constructor(path: string) {\n    this.tokens = tokenize(path)\n    this.length = this.tokens.length\n    this.i = 0\n  }\n\n  parse() {\n    return this.parsePath()\n  }\n\n  EOF() {\n    return this.i >= this.length\n  }\n\n  // Look at upcoming token\n  peek() {\n    if (this.EOF()) {\n      return null\n    }\n    return this.tokens[this.i]\n  }\n\n  consume() {\n    const result = this.peek()\n    this.i += 1\n    return result\n  }\n\n  // Return next token if it matches the pattern\n  probe(pattern: Record<string, unknown>): Token | null {\n    const token = this.peek()\n    if (!token) {\n      return null\n    }\n\n    const record = token as unknown as Record<string, unknown>\n    const match = Object.keys(pattern).every((key) => {\n      return key in token && pattern[key] === record[key]\n    })\n\n    return match ? token : null\n  }\n\n  // Return and consume next token if it matches the pattern\n  match(pattern: Partial<Token>): Token | null {\n    return this.probe(pattern) ? this.consume() : null\n  }\n\n  parseAttribute(): AttributeExpr | null {\n    const token = this.match({type: 'identifier'})\n    if (token && token.type === 'identifier') {\n      return {\n        type: 'attribute',\n        name: token.name,\n      }\n    }\n    const quoted = this.match({type: 'quoted', quote: 'single'})\n    if (quoted && quoted.type === 'quoted') {\n      return {\n        type: 'attribute',\n        name: quoted.value || '',\n      }\n    }\n    return null\n  }\n\n  parseAlias(): AliasExpr | null {\n    if (this.match({type: 'keyword', symbol: '@'}) || this.match({type: 'keyword', symbol: '$'})) {\n      return {\n        type: 'alias',\n        target: 'self',\n      }\n    }\n    return null\n  }\n\n  parseNumber(): NumberExpr | null {\n    const token = this.match({type: 'number'})\n    if (token && token.type === 'number') {\n      return {\n        type: 'number',\n        value: token.value,\n      }\n    }\n    return null\n  }\n\n  parseNumberValue(): number | null {\n    const expr = this.parseNumber()\n    if (expr) {\n      return expr.value\n    }\n    return null\n  }\n\n  parseSliceSelector(): RangeExpr | IndexExpr | null {\n    const start = this.i\n    const rangeStart = this.parseNumberValue()\n\n    const colon1 = this.match({type: 'operator', symbol: ':'})\n    if (!colon1) {\n      if (rangeStart === null) {\n        // Rewind, this was actually nothing\n        this.i = start\n        return null\n      }\n\n      // Unwrap, this was just a single index not followed by colon\n      return {type: 'index', value: rangeStart}\n    }\n\n    const result: RangeExpr = {\n      type: 'range',\n      start: rangeStart,\n      end: this.parseNumberValue(),\n    }\n\n    const colon2 = this.match({type: 'operator', symbol: ':'})\n    if (colon2) {\n      result.step = this.parseNumberValue()\n    }\n\n    if (result.start === null && result.end === null) {\n      // rewind, this wasnt' a slice selector\n      this.i = start\n      return null\n    }\n\n    return result\n  }\n\n  parseValueReference(): AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseAttribute() || this.parseSliceSelector()\n  }\n\n  parseLiteralValue(): StringExpr | BooleanExpr | NumberExpr | null {\n    const literalString = this.match({type: 'quoted', quote: 'double'})\n    if (literalString && literalString.type === 'quoted') {\n      return {\n        type: 'string',\n        value: literalString.value || '',\n      }\n    }\n    const literalBoolean = this.match({type: 'boolean'})\n    if (literalBoolean && literalBoolean.type === 'boolean') {\n      return {\n        type: 'boolean',\n        value: literalBoolean.symbol === 'true',\n      }\n    }\n    return this.parseNumber()\n  }\n\n  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always\n  // on lhs.\n  parseFilterExpression(): ConstraintExpr | null {\n    const start = this.i\n    const expr = this.parseAttribute() || this.parseAlias()\n    if (!expr) {\n      return null\n    }\n\n    if (this.match({type: 'operator', symbol: '?'})) {\n      return {\n        type: 'constraint',\n        operator: '?',\n        lhs: expr,\n      }\n    }\n\n    const binOp = this.match({type: 'comparator'})\n    if (!binOp || binOp.type !== 'comparator') {\n      // No expression, rewind!\n      this.i = start\n      return null\n    }\n\n    const lhs = expr\n    const rhs = this.parseLiteralValue()\n    if (!rhs) {\n      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`)\n    }\n\n    return {\n      type: 'constraint',\n      operator: binOp.symbol,\n      lhs: lhs,\n      rhs: rhs,\n    }\n  }\n\n  parseExpression(): ConstraintExpr | AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseFilterExpression() || this.parseValueReference()\n  }\n\n  parseUnion(): UnionExpr | null {\n    if (!this.match({type: 'paren', symbol: '['})) {\n      return null\n    }\n\n    const terms = []\n    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n    while (expr) {\n      terms.push(expr)\n      // End of union?\n      if (this.match({type: 'paren', symbol: ']'})) {\n        break\n      }\n\n      if (!this.match({type: 'operator', symbol: ','})) {\n        throw new Error('Expected ]')\n      }\n\n      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n      if (!expr) {\n        throw new Error(\"Expected expression following ','\")\n      }\n    }\n\n    return {\n      type: 'union',\n      nodes: terms,\n    }\n  }\n\n  parseRecursive(): RecursiveExpr | null {\n    if (!this.match({type: 'operator', symbol: '..'})) {\n      return null\n    }\n\n    const subpath = this.parsePath()\n    if (!subpath) {\n      throw new Error(\"Expected path following '..' operator\")\n    }\n\n    return {\n      type: 'recursive',\n      term: subpath,\n    }\n  }\n\n  parsePath(): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr | null {\n    const nodes: (AttributeExpr | UnionExpr | RecursiveExpr)[] = []\n    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive()\n    if (!expr) {\n      return null\n    }\n\n    nodes.push(expr)\n    while (!this.EOF()) {\n      if (this.match({type: 'operator', symbol: '.'})) {\n        const attr = this.parseAttribute()\n        if (!attr) {\n          throw new Error(\"Expected attribute name following '.\")\n        }\n        nodes.push(attr)\n        continue\n      } else if (this.probe({type: 'paren', symbol: '['})) {\n        const union = this.parseUnion()\n        if (!union) {\n          throw new Error(\"Expected union following '['\")\n        }\n        nodes.push(union)\n      } else {\n        const recursive = this.parseRecursive()\n        if (recursive) {\n          nodes.push(recursive)\n        }\n        break\n      }\n    }\n\n    if (nodes.length === 1) {\n      return nodes[0]\n    }\n\n    return {\n      type: 'path',\n      nodes: nodes,\n    }\n  }\n}\n\nexport function parseJsonPath(path: string): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr {\n  const parsed = new Parser(path).parse()\n  if (!parsed) {\n    throw new Error(`Failed to parse JSON path \"${path}\"`)\n  }\n  return parsed\n}\n","import {type Expr} from './types'\n\n/**\n * Converts a parsed expression back into jsonpath2, roughly -\n * mostly for use with tests.\n *\n * @param expr - Expression to convert to path\n * @returns a string representation of the path\n * @internal\n */\nexport function toPath(expr: Expr): string {\n  return toPathInner(expr, false)\n}\n\nfunction toPathInner(expr: Expr, inUnion: boolean): string {\n  switch (expr.type) {\n    case 'attribute':\n      return expr.name\n    case 'alias':\n      return expr.target === 'self' ? '@' : '$'\n    case 'number':\n      return `${expr.value}`\n    case 'range': {\n      const result = []\n      if (!inUnion) {\n        result.push('[')\n      }\n      if (expr.start) {\n        result.push(`${expr.start}`)\n      }\n      result.push(':')\n      if (expr.end) {\n        result.push(`${expr.end}`)\n      }\n      if (expr.step) {\n        result.push(`:${expr.step}`)\n      }\n      if (!inUnion) {\n        result.push(']')\n      }\n      return result.join('')\n    }\n    case 'index':\n      if (inUnion) {\n        return `${expr.value}`\n      }\n\n      return `[${expr.value}]`\n    case 'constraint': {\n      const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, false)}` : ''\n      const inner = `${toPathInner(expr.lhs, false)} ${expr.operator}${rhs}`\n\n      if (inUnion) {\n        return inner\n      }\n\n      return `[${inner}]`\n    }\n    case 'string':\n      return JSON.stringify(expr.value)\n    case 'path': {\n      const result = []\n      const nodes = expr.nodes.slice()\n      while (nodes.length > 0) {\n        const node = nodes.shift()\n        if (node) {\n          result.push(toPath(node))\n        }\n\n        const upcoming = nodes[0]\n        if (upcoming && toPathInner(upcoming, false)[0] !== '[') {\n          result.push('.')\n        }\n      }\n      return result.join('')\n    }\n    case 'union':\n      return `[${expr.nodes.map((e) => toPathInner(e, true)).join(',')}]`\n    default:\n      throw new Error(`Unknown node type ${expr.type}`)\n    case 'recursive':\n      return `..${toPathInner(expr.term, false)}`\n  }\n}\n","// A utility wrapper class to process parsed jsonpath expressions\n\nimport {descend} from './descend'\nimport {parseJsonPath} from './parse'\nimport {type Probe} from './Probe'\nimport {toPath} from './toPath'\nimport {type Expr, type HeadTail} from './types'\n\nexport interface Range {\n  start: number\n  end: number\n  step: number\n}\n\nexport class Expression {\n  expr: Expr\n\n  constructor(expr: Expr | Expression | null) {\n    if (!expr) {\n      throw new Error('Attempted to create Expression from null-value')\n    }\n\n    // This is a wrapped expr\n    if ('expr' in expr) {\n      this.expr = expr.expr\n    } else {\n      this.expr = expr\n    }\n\n    if (!('type' in this.expr)) {\n      throw new Error('Attempt to create Expression for expression with no type')\n    }\n  }\n\n  isPath(): boolean {\n    return this.expr.type === 'path'\n  }\n\n  isUnion(): boolean {\n    return this.expr.type === 'union'\n  }\n\n  isCollection(): boolean {\n    return this.isPath() || this.isUnion()\n  }\n\n  isConstraint(): boolean {\n    return this.expr.type === 'constraint'\n  }\n\n  isRecursive(): boolean {\n    return this.expr.type === 'recursive'\n  }\n\n  isExistenceConstraint(): boolean {\n    return this.expr.type === 'constraint' && this.expr.operator === '?'\n  }\n\n  isIndex(): boolean {\n    return this.expr.type === 'index'\n  }\n\n  isRange(): boolean {\n    return this.expr.type === 'range'\n  }\n\n  expandRange(probe?: Probe): Range {\n    const probeLength = () => {\n      if (!probe) {\n        throw new Error('expandRange() required a probe that was not passed')\n      }\n\n      return probe.length()\n    }\n\n    let start = 'start' in this.expr ? this.expr.start || 0 : 0\n    start = interpretNegativeIndex(start, probe)\n    let end = 'end' in this.expr ? this.expr.end || probeLength() : probeLength()\n    end = interpretNegativeIndex(end, probe)\n    const step = 'step' in this.expr ? this.expr.step || 1 : 1\n    return {start, end, step}\n  }\n\n  isAttributeReference(): boolean {\n    return this.expr.type === 'attribute'\n  }\n\n  // Is a range or index -> something referencing indexes\n  isIndexReference(): boolean {\n    return this.isIndex() || this.isRange()\n  }\n\n  name(): string {\n    return 'name' in this.expr ? this.expr.name : ''\n  }\n\n  isSelfReference(): boolean {\n    return this.expr.type === 'alias' && this.expr.target === 'self'\n  }\n\n  constraintTargetIsSelf(): boolean {\n    return (\n      this.expr.type === 'constraint' &&\n      this.expr.lhs.type === 'alias' &&\n      this.expr.lhs.target === 'self'\n    )\n  }\n\n  constraintTargetIsAttribute(): boolean {\n    return this.expr.type === 'constraint' && this.expr.lhs.type === 'attribute'\n  }\n\n  testConstraint(probe: Probe): boolean {\n    const expr = this.expr\n\n    if (expr.type === 'constraint' && expr.lhs.type === 'alias' && expr.lhs.target === 'self') {\n      if (probe.containerType() !== 'primitive') {\n        return false\n      }\n\n      if (expr.type === 'constraint' && expr.operator === '?') {\n        return true\n      }\n\n      const lhs = probe.get()\n      const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n      return testBinaryOperator(lhs, expr.operator, rhs)\n    }\n\n    if (expr.type !== 'constraint') {\n      return false\n    }\n\n    const lhs = expr.lhs\n    if (!lhs) {\n      throw new Error('No LHS of expression')\n    }\n\n    if (lhs.type !== 'attribute') {\n      throw new Error(`Constraint target ${lhs.type} not supported`)\n    }\n\n    if (probe.containerType() !== 'object') {\n      return false\n    }\n\n    const lhsValue = probe.getAttribute(lhs.name)\n    if (lhsValue === undefined || lhsValue === null || lhsValue.containerType() !== 'primitive') {\n      // LHS is void and empty, or it is a collection\n      return false\n    }\n\n    if (this.isExistenceConstraint()) {\n      // There is no rhs, and if we're here the key did exist\n      return true\n    }\n\n    const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n    return testBinaryOperator(lhsValue.get(), expr.operator, rhs)\n  }\n\n  pathNodes(): Expr[] {\n    return this.expr.type === 'path' ? this.expr.nodes : [this.expr]\n  }\n\n  prepend(node: Expression): Expression {\n    if (!node) {\n      return this\n    }\n\n    return new Expression({\n      type: 'path',\n      nodes: node.pathNodes().concat(this.pathNodes()),\n    })\n  }\n\n  concat(other: Expression | null): Expression {\n    return other ? other.prepend(this) : this\n  }\n\n  descend(): HeadTail[] {\n    return descend(this.expr).map((headTail) => {\n      const [head, tail] = headTail\n      return {\n        head: head ? new Expression(head) : null,\n        tail: tail ? new Expression(tail) : null,\n      }\n    })\n  }\n\n  unwrapRecursive(): Expression {\n    if (this.expr.type !== 'recursive') {\n      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`)\n    }\n\n    return new Expression(this.expr.term)\n  }\n\n  toIndicies(probe?: Probe): number[] {\n    if (this.expr.type !== 'index' && this.expr.type !== 'range') {\n      throw new Error('Node cannot be converted to indexes')\n    }\n\n    if (this.expr.type === 'index') {\n      return [interpretNegativeIndex(this.expr.value, probe)]\n    }\n\n    const result: number[] = []\n    const range = this.expandRange(probe)\n    let {start, end} = range\n    if (range.step < 0) {\n      ;[start, end] = [end, start]\n    }\n\n    for (let i = start; i < end; i++) {\n      result.push(i)\n    }\n\n    return result\n  }\n\n  toFieldReferences(): number[] | string[] {\n    if (this.isIndexReference()) {\n      return this.toIndicies()\n    }\n    if (this.expr.type === 'attribute') {\n      return [this.expr.name]\n    }\n    throw new Error(`Can't convert ${this.expr.type} to field references`)\n  }\n\n  toString(): string {\n    return toPath(this.expr)\n  }\n\n  static fromPath(path: string): Expression {\n    const parsed = parseJsonPath(path)\n    if (!parsed) {\n      throw new Error(`Failed to parse path \"${path}\"`)\n    }\n\n    return new Expression(parsed)\n  }\n\n  static attributeReference(name: string): Expression {\n    return new Expression({\n      type: 'attribute',\n      name: name,\n    })\n  }\n\n  static indexReference(i: number): Expression {\n    return new Expression({\n      type: 'index',\n      value: i,\n    })\n  }\n}\n\n// Tests an operator on two given primitive values\nfunction testBinaryOperator(lhsValue: any, operator: string, rhsValue: any) {\n  switch (operator) {\n    case '>':\n      return lhsValue > rhsValue\n    case '>=':\n      return lhsValue >= rhsValue\n    case '<':\n      return lhsValue < rhsValue\n    case '<=':\n      return lhsValue <= rhsValue\n    case '==':\n      return lhsValue === rhsValue\n    case '!=':\n      return lhsValue !== rhsValue\n    default:\n      throw new Error(`Unsupported binary operator ${operator}`)\n  }\n}\n\nfunction interpretNegativeIndex(index: number, probe?: Probe): number {\n  if (index >= 0) {\n    return index\n  }\n\n  if (!probe) {\n    throw new Error('interpretNegativeIndex() must have a probe when < 0')\n  }\n\n  return index + probe.length()\n}\n","import {flatten} from 'lodash'\n\nimport {Expression} from './Expression'\nimport {type Probe} from './Probe'\n\n/**\n * Descender models the state of one partial jsonpath evaluation. Head is the\n * next thing to match, tail is the upcoming things once the head is matched.\n */\nexport class Descender {\n  head: Expression | null\n  tail: Expression | null\n\n  constructor(head: Expression | null, tail: Expression | null) {\n    this.head = head\n    this.tail = tail\n  }\n\n  // Iterate this descender once processing any constraints that are\n  // resolvable on the current value. Returns an array of new descenders\n  // that are guaranteed to be without constraints in the head\n  iterate(probe: Probe): Descender[] {\n    let result: Descender[] = [this]\n    if (this.head && this.head.isConstraint()) {\n      let anyConstraints = true\n      // Keep rewriting constraints until there are none left\n      while (anyConstraints) {\n        result = flatten(\n          result.map((descender) => {\n            return descender.iterateConstraints(probe)\n          }),\n        )\n        anyConstraints = result.some((descender) => {\n          return descender.head && descender.head.isConstraint()\n        })\n      }\n    }\n    return result\n  }\n\n  isRecursive(): boolean {\n    return Boolean(this.head && this.head.isRecursive())\n  }\n\n  hasArrived(): boolean {\n    return this.head === null && this.tail === null\n  }\n\n  extractRecursives(): Descender[] {\n    if (this.head && this.head.isRecursive()) {\n      const term = this.head.unwrapRecursive()\n      return new Descender(null, term.concat(this.tail)).descend()\n    }\n    return []\n  }\n\n  iterateConstraints(probe: Probe): Descender[] {\n    const head = this.head\n    if (head === null || !head.isConstraint()) {\n      // Not a constraint, no rewrite\n      return [this]\n    }\n\n    const result: Descender[] = []\n\n    if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {\n      if (head.testConstraint(probe)) {\n        result.push(...this.descend())\n      }\n      return result\n    }\n\n    // The value is an array\n    if (probe.containerType() === 'array') {\n      const length = probe.length()\n      for (let i = 0; i < length; i++) {\n        // Push new descenders with constraint translated to literal indices\n        // where they match\n        const constraint = probe.getIndex(i)\n        if (constraint && head.testConstraint(constraint)) {\n          result.push(new Descender(new Expression({type: 'index', value: i}), this.tail))\n        }\n      }\n      return result\n    }\n\n    // The value is an object\n    if (probe.containerType() === 'object') {\n      if (head.constraintTargetIsSelf()) {\n        // There are no matches for target self ('@') on a plain object\n        return []\n      }\n\n      if (head.testConstraint(probe)) {\n        return this.descend()\n      }\n\n      return result\n    }\n\n    return result\n  }\n\n  descend(): Descender[] {\n    if (!this.tail) {\n      return [new Descender(null, null)]\n    }\n\n    return this.tail.descend().map((ht) => {\n      return new Descender(ht.head, ht.tail)\n    })\n  }\n\n  toString(): string {\n    const result = ['<']\n    if (this.head) {\n      result.push(this.head.toString())\n    }\n    result.push('|')\n    if (this.tail) {\n      result.push(this.tail.toString())\n    }\n    result.push('>')\n    return result.join('')\n  }\n}\n","import {Descender} from './Descender'\nimport {Expression} from './Expression'\nimport {parseJsonPath} from './parse'\nimport {type Probe} from './Probe'\n\ninterface Result<P = unknown> {\n  leads: {\n    target: Expression\n    matcher: Matcher\n  }[]\n\n  delivery?: {\n    targets: Expression[]\n    payload: P\n  }\n}\n\n/**\n * @internal\n */\nexport class Matcher {\n  active: Descender[]\n  recursives: Descender[]\n  payload: unknown\n\n  constructor(active: Descender[], parent?: Matcher) {\n    this.active = active || []\n    if (parent) {\n      this.recursives = parent.recursives\n      this.payload = parent.payload\n    } else {\n      this.recursives = []\n    }\n    this.extractRecursives()\n  }\n\n  setPayload(payload: unknown): this {\n    this.payload = payload\n    return this\n  }\n\n  // Moves any recursive descenders onto the recursive track, removing them from\n  // the active set\n  extractRecursives(): void {\n    this.active = this.active.filter((descender) => {\n      if (descender.isRecursive()) {\n        this.recursives.push(...descender.extractRecursives())\n        return false\n      }\n      return true\n    })\n  }\n\n  // Find recursives that are relevant now and should be considered part of the active set\n  activeRecursives(probe: Probe): Descender[] {\n    return this.recursives.filter((descender) => {\n      const head = descender.head\n      if (!head) {\n        return false\n      }\n\n      // Constraints are always relevant\n      if (head.isConstraint()) {\n        return true\n      }\n\n      // Index references are only relevant for indexable values\n      if (probe.containerType() === 'array' && head.isIndexReference()) {\n        return true\n      }\n\n      // Attribute references are relevant for plain objects\n      if (probe.containerType() === 'object') {\n        return head.isAttributeReference() && probe.hasAttribute(head.name())\n      }\n\n      return false\n    })\n  }\n\n  match(probe: Probe): Result {\n    return this.iterate(probe).extractMatches(probe)\n  }\n\n  iterate(probe: Probe): Matcher {\n    const newActiveSet: Descender[] = []\n    this.active.concat(this.activeRecursives(probe)).forEach((descender) => {\n      newActiveSet.push(...descender.iterate(probe))\n    })\n    return new Matcher(newActiveSet, this)\n  }\n\n  // Returns true if any of the descenders in the active or recursive set\n  // consider the current state a final destination\n  isDestination(): boolean {\n    return this.active.some((descender) => descender.hasArrived())\n  }\n\n  hasRecursives(): boolean {\n    return this.recursives.length > 0\n  }\n\n  // Returns any payload delivieries and leads that needs to be followed to complete\n  // the process.\n  extractMatches(probe: Probe): Result {\n    const leads: {target: Expression; matcher: Matcher}[] = []\n    const targets: Expression[] = []\n    this.active.forEach((descender) => {\n      if (descender.hasArrived()) {\n        // This was already arrived, so matches this value, not descenders\n        targets.push(\n          new Expression({\n            type: 'alias',\n            target: 'self',\n          }),\n        )\n        return\n      }\n\n      const descenderHead = descender.head\n      if (!descenderHead) {\n        return\n      }\n\n      if (probe.containerType() === 'array' && !descenderHead.isIndexReference()) {\n        // This descender does not match an indexable value\n        return\n      }\n\n      if (probe.containerType() === 'object' && !descenderHead.isAttributeReference()) {\n        // This descender never match a plain object\n        return\n      }\n\n      if (descender.tail) {\n        // Not arrived yet\n        const matcher = new Matcher(descender.descend(), this)\n        descenderHead.toFieldReferences().forEach(() => {\n          leads.push({\n            target: descenderHead,\n            matcher: matcher,\n          })\n        })\n      } else {\n        // arrived\n        targets.push(descenderHead)\n      }\n    })\n\n    // If there are recursive terms, we need to add a lead for every descendant ...\n    if (this.hasRecursives()) {\n      // The recustives matcher will have no active set, only inherit recursives from this\n      const recursivesMatcher = new Matcher([], this)\n      if (probe.containerType() === 'array') {\n        const length = probe.length()\n        for (let i = 0; i < length; i++) {\n          leads.push({\n            target: Expression.indexReference(i),\n            matcher: recursivesMatcher,\n          })\n        }\n      } else if (probe.containerType() === 'object') {\n        probe.attributeKeys().forEach((name) => {\n          leads.push({\n            target: Expression.attributeReference(name),\n            matcher: recursivesMatcher,\n          })\n        })\n      }\n    }\n\n    return targets.length > 0\n      ? {leads: leads, delivery: {targets, payload: this.payload}}\n      : {leads: leads}\n  }\n\n  static fromPath(jsonpath: string): Matcher {\n    const path = parseJsonPath(jsonpath)\n    if (!path) {\n      throw new Error(`Failed to parse path from \"${jsonpath}\"`)\n    }\n\n    const descender = new Descender(null, new Expression(path))\n    return new Matcher(descender.descend())\n  }\n}\n","import {isRecord} from '../util'\nimport {type Probe} from './Probe'\n\n// A default implementation of a probe for vanilla JS _values\nexport class PlainProbe implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): false | null | PlainProbe {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new PlainProbe(this._value[i], this.path.concat(i))\n  }\n\n  hasAttribute(key: string): boolean {\n    if (!isRecord(this._value)) {\n      return false\n    }\n\n    return this._value.hasOwnProperty(key)\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): null | PlainProbe {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new PlainProbe(this._value[key], this.path.concat(key))\n  }\n\n  get(): unknown {\n    return this._value\n  }\n}\n","import {compact} from 'lodash'\n\nimport {type Expression} from './Expression'\nimport {Matcher} from './Matcher'\nimport {PlainProbe} from './PlainProbe'\nimport {type Probe} from './Probe'\n\nexport function extractAccessors(path: string, value: unknown): Probe[] {\n  const result: Probe[] = []\n  const matcher = Matcher.fromPath(path).setPayload(function appendResult(values: Probe[]) {\n    result.push(...values)\n  })\n  const accessor = new PlainProbe(value)\n  descend(matcher, accessor)\n  return result\n}\n\nfunction descend(matcher: Matcher, accessor: Probe) {\n  const {leads, delivery} = matcher.match(accessor)\n\n  leads.forEach((lead) => {\n    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {\n      descend(lead.matcher, childAccessor)\n    })\n  })\n\n  if (delivery) {\n    delivery.targets.forEach((target) => {\n      if (typeof delivery.payload === 'function') {\n        delivery.payload(accessorsFromTarget(target, accessor))\n      }\n    })\n  }\n}\n\nfunction accessorsFromTarget(target: Expression, accessor: Probe) {\n  const result = []\n  if (target.isIndexReference()) {\n    target.toIndicies(accessor).forEach((i) => {\n      result.push(accessor.getIndex(i))\n    })\n  } else if (target.isAttributeReference()) {\n    result.push(accessor.getAttribute(target.name()))\n  } else if (target.isSelfReference()) {\n    result.push(accessor)\n  } else {\n    throw new Error(`Unable to derive accessor for target ${target.toString()}`)\n  }\n  return compact(result)\n}\n","import {extractAccessors} from './extractAccessors'\n\n/**\n * Extracts values matching the given JsonPath\n *\n * @param path - Path to extract\n * @param value - Value to extract from\n * @returns An array of values matching the given path\n * @public\n */\nexport function extract(path: string, value: unknown): unknown[] {\n  const accessors = extractAccessors(path, value)\n  return accessors.map((acc) => acc.get())\n}\n","import {extractAccessors} from './extractAccessors'\n\n/**\n * Extracts a value for the given JsonPath, and includes the specific path of where it was found\n *\n * @param path - Path to extract\n * @param value - Value to extract from\n * @returns An array of objects with `path` and `value` keys\n * @internal\n */\nexport function extractWithPath(\n  path: string,\n  value: unknown,\n): {path: (string | number)[]; value: unknown}[] {\n  const accessors = extractAccessors(path, value)\n  return accessors.map((acc) => ({path: acc.path, value: acc.get()}))\n}\n","import {applyPatches, parsePatch, type Patch} from '@sanity/diff-match-patch'\n\nimport {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\n\nfunction applyPatch(patch: Patch[], oldValue: unknown) {\n  // Silently avoid patching if the value type is not string\n  if (typeof oldValue !== 'string') return oldValue\n  const [result] = applyPatches(patch, oldValue, {allowExceedingIndices: true})\n  return result\n}\n\nexport class DiffMatchPatch {\n  path: string\n  dmpPatch: Patch[]\n  id: string\n\n  constructor(id: string, path: string, dmpPatchSrc: string) {\n    this.id = id\n    this.path = path\n    this.dmpPatch = parsePatch(dmpPatchSrc)\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const oldValue = item.get()\n          const nextValue = applyPatch(this.dmpPatch, oldValue)\n          result = result.setIndex(index, nextValue)\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference() && result.hasAttribute(target.name())) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const oldValue = attribute.get()\n        const nextValue = applyPatch(this.dmpPatch, oldValue)\n        result = result.setAttribute(target.name(), nextValue)\n        continue\n      }\n\n      throw new Error(`Unable to apply diffMatchPatch to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\n\nfunction performIncrement(previousValue: unknown, delta: number): number {\n  if (typeof previousValue !== 'number' || !Number.isFinite(previousValue)) {\n    return previousValue as number\n  }\n\n  return previousValue + delta\n}\n\nexport class IncPatch {\n  path: string\n  value: number\n  id: string\n\n  constructor(id: string, path: string, value: number) {\n    this.path = path\n    this.value = value\n    this.id = id\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const previousValue = item.get()\n          result = result.setIndex(index, performIncrement(previousValue, this.value))\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference()) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const previousValue = attribute.get()\n        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value))\n        continue\n      }\n\n      throw new Error(`Unable to apply to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\n\nexport function targetsToIndicies(targets: Expression[], accessor: ImmutableAccessor): number[] {\n  const result: number[] = []\n  targets.forEach((target) => {\n    if (target.isIndexReference()) {\n      result.push(...target.toIndicies(accessor))\n    }\n  })\n  return result.sort()\n}\n","import {max, min} from 'lodash'\n\nimport {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class InsertPatch {\n  location: string\n  path: string\n  items: unknown[]\n  id: string\n\n  constructor(id: string, location: string, path: string, items: unknown[]) {\n    this.id = id\n    this.location = location\n    this.path = path\n    this.items = items\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    if (accessor.containerType() !== 'array') {\n      throw new Error('Attempt to apply insert patch to non-array value')\n    }\n\n    switch (this.location) {\n      case 'before': {\n        const pos = minIndex(targets, accessor)\n        result = result.insertItemsAt(pos, this.items)\n        break\n      }\n      case 'after': {\n        const pos = maxIndex(targets, accessor)\n        result = result.insertItemsAt(pos + 1, this.items)\n        break\n      }\n      case 'replace': {\n        // TODO: Properly implement ranges in compliance with content lake\n        // This will only properly support single contiguous ranges\n        const indicies = targetsToIndicies(targets, accessor)\n        result = result.unsetIndices(indicies)\n        result = result.insertItemsAt(indicies[0], this.items)\n        break\n      }\n      default: {\n        throw new Error(`Unsupported location atm: ${this.location}`)\n      }\n    }\n    return result\n  }\n}\n\nfunction minIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = min(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {start} = target.expandRange()\n      if (start < result) {\n        result = start\n      }\n    }\n  })\n  return result\n}\n\nfunction maxIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = max(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {end} = target.expandRange()\n      if (end > result) {\n        result = end\n      }\n    }\n  })\n  return result\n}\n","import {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetIfMissingPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isIndexReference()) {\n        // setIfMissing do not apply to arrays, since Content Lake will reject nulls in arrays\n      } else if (target.isAttributeReference()) {\n        // setting a subproperty on a primitive value overwrites it, eg\n        // `{setIfMissing: {'address.street': 'California St'}}` on `{address: 'Fiction St'}` will\n        // result in `{address: {street: 'California St'}}`\n        if (result.containerType() === 'primitive') {\n          result = result.set({[target.name()]: this.value})\n        } else if (!result.hasAttribute(target.name())) {\n          result = accessor.setAttribute(target.name(), this.value)\n        }\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isSelfReference()) {\n        result = result.set(this.value)\n      } else if (target.isIndexReference()) {\n        target.toIndicies(accessor).forEach((i) => {\n          result = result.setIndex(i, this.value)\n        })\n      } else if (target.isAttributeReference()) {\n        // setting a subproperty on a primitive value overwrites it, eg\n        // `{set: {'address.street': 'California St'}}` on `{address: 'Fiction St'}` will result in\n        // `{address: {street: 'California St'}}`\n        if (result.containerType() === 'primitive') {\n          result = result.set({[target.name()]: this.value})\n        } else {\n          result = result.setAttribute(target.name(), this.value)\n        }\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import {type Expression} from '../jsonpath'\nimport {type ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class UnsetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string) {\n    this.id = id\n    this.path = path\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    switch (accessor.containerType()) {\n      case 'array':\n        result = result.unsetIndices(targetsToIndicies(targets, accessor))\n        break\n      case 'object':\n        targets.forEach((target) => {\n          result = result.unsetAttribute(target.name())\n        })\n        break\n      default:\n        throw new Error(\n          'Target value is neither indexable or an object. This error should potentially just be silently ignored?',\n        )\n    }\n    return result\n  }\n}\n","import {DiffMatchPatch} from './DiffMatchPatch'\nimport {IncPatch} from './IncPatch'\nimport {InsertPatch} from './InsertPatch'\nimport {SetIfMissingPatch} from './SetIfMissingPatch'\nimport {SetPatch} from './SetPatch'\nimport {type PatchTypes, type SingleDocumentPatch} from './types'\nimport {UnsetPatch} from './UnsetPatch'\n\n// Parses a content lake patch into our own personal patch implementations\nexport function parsePatch(patch: SingleDocumentPatch | SingleDocumentPatch[]): PatchTypes[] {\n  const result: PatchTypes[] = []\n  if (Array.isArray(patch)) {\n    return patch.reduce((r, p) => r.concat(parsePatch(p)), result)\n  }\n\n  const {set, setIfMissing, unset, diffMatchPatch, inc, dec, insert} = patch\n  if (setIfMissing) {\n    Object.keys(setIfMissing).forEach((path) => {\n      result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]))\n    })\n  }\n\n  if (set) {\n    Object.keys(set).forEach((path) => {\n      result.push(new SetPatch(patch.id, path, set[path]))\n    })\n  }\n\n  if (unset) {\n    unset.forEach((path) => {\n      result.push(new UnsetPatch(patch.id, path))\n    })\n  }\n\n  if (diffMatchPatch) {\n    Object.keys(diffMatchPatch).forEach((path) => {\n      result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]))\n    })\n  }\n\n  if (inc) {\n    Object.keys(inc).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, inc[path]))\n    })\n  }\n\n  if (dec) {\n    Object.keys(dec).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, -dec[path]))\n    })\n  }\n\n  if (insert) {\n    let location: string\n    let path: string\n    const spec = insert\n    if ('before' in spec) {\n      location = 'before'\n      path = spec.before\n    } else if ('after' in spec) {\n      location = 'after'\n      path = spec.after\n    } else if ('replace' in spec) {\n      location = 'replace'\n      path = spec.replace\n    } else {\n      throw new Error('Invalid insert patch')\n    }\n\n    result.push(new InsertPatch(patch.id, location, path, spec.items))\n  }\n\n  return result\n}\n","import {type Doc} from '../document/types'\nimport {Matcher} from '../jsonpath'\nimport {ImmutableAccessor} from './ImmutableAccessor'\nimport {parsePatch} from './parse'\nimport {SetIfMissingPatch} from './SetIfMissingPatch'\nimport {SetPatch} from './SetPatch'\nimport {type PatchTypes, type SingleDocumentPatch} from './types'\n\nexport interface Patch {\n  id: string\n  path: string\n}\n\nexport class Patcher {\n  patches: PatchTypes[]\n\n  constructor(patch: SingleDocumentPatch | SingleDocumentPatch[]) {\n    this.patches = parsePatch(patch)\n  }\n\n  apply(value: Doc | null): unknown {\n    // Apply just makes a root accessor around the provided\n    // value, then applies the patches. Due to the use of\n    // ImmutableAccessor it is guaranteed to return either the\n    // exact same object it was provided (in the case of no changes),\n    // or a completely new object. It will never mutate the object in place.\n    const accessor = new ImmutableAccessor(value)\n    return this.applyViaAccessor(accessor).get()\n  }\n\n  // If you want to use your own accessor implementation, you can use this method\n  // to invoke the patcher. Since all subsequent accessors for children of this accessor\n  // are obtained through the methods in the accessors, you retain full control of the\n  // implementation throguhgout the application. Have a look in ImmutableAccessor\n  // to see an example of how accessors are implemented.\n  applyViaAccessor(accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    const idAccessor = accessor.getAttribute('_id')\n    if (!idAccessor) {\n      throw new Error('Cannot apply patch to document with no _id')\n    }\n\n    const id = idAccessor.get()\n    for (const patch of this.patches) {\n      if (patch.id !== id) {\n        // Ignore patches that are not targetted at this document\n        continue\n      }\n\n      const matcher = Matcher.fromPath(patch.path).setPayload(patch)\n      result = process(matcher, result)\n    }\n\n    return result\n  }\n}\n\n// Recursively (depth first) follows any leads generated by the matcher, expecting\n// a patch to be the payload. When matchers report a delivery, the\n// apply(targets, accessor) is called on the patch\nfunction process(matcher: Matcher, accessor: ImmutableAccessor) {\n  const isSetPatch =\n    matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch\n\n  let result = accessor\n  // Every time we execute the matcher a new set of leads is generated. Each lead\n  // is a target (being an index, an attribute name or a range) in the form of an\n  // Expression instance. For each lead target there is also a matcher. Our job is to obtain\n  // accessor(s) for each target (there might be more than one, since the targets may\n  // be ranges) and run the provided matcher on those accessors.\n  const {leads, delivery} = matcher.match(accessor)\n  leads.forEach((lead) => {\n    if (lead.target.isIndexReference()) {\n      lead.target.toIndicies().forEach((i) => {\n        const item = result.getIndex(i)\n        if (!item) {\n          throw new Error('Index out of bounds')\n        }\n\n        result = result.setIndexAccessor(i, process(lead.matcher, item))\n      })\n    } else if (lead.target.isAttributeReference()) {\n      // `set`/`setIfMissing` on a primitive value overwrites it\n      if (isSetPatch && result.containerType() === 'primitive') {\n        result = result.set({})\n      }\n\n      let oldValueAccessor = result.getAttribute(lead.target.name())\n\n      // If the patch is a set/setIfMissing patch, we allow deeply setting properties,\n      // creating missing segments as we go.\n      if (!oldValueAccessor && isSetPatch) {\n        result = result.setAttribute(lead.target.name(), {})\n        oldValueAccessor = result.getAttribute(lead.target.name())\n      }\n\n      if (!oldValueAccessor) {\n        // Don't follow lead, no such attribute\n        return\n      }\n\n      const newValueAccessor = process(lead.matcher, oldValueAccessor)\n      if (oldValueAccessor !== newValueAccessor) {\n        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor)\n      }\n    } else {\n      throw new Error(`Unable to handle target ${lead.target.toString()}`)\n    }\n  })\n\n  // Each time we run the matcher, we might also get a delivery. This means that a\n  // term in the jsonpath terminated here and the patch should be applied. The delivery\n  // arrives in the form of an array of targets and a payload (which in this application\n  // is the patch). Conveniently the patches accept an array of targets and an accessor\n  // to do its work, so here we just pass those to the patch and we're done.\n  if (delivery && isPatcher(delivery.payload)) {\n    const patch = delivery.payload\n    result = patch.apply(delivery.targets, result)\n  }\n\n  return result\n}\n\nfunction isPatcher(payload: unknown): payload is PatchTypes {\n  return Boolean(\n    payload &&\n      typeof payload === 'object' &&\n      payload !== null &&\n      'apply' in payload &&\n      typeof (payload as PatchTypes).apply === 'function',\n  )\n}\n","import {uuid} from '@sanity/uuid'\n\n/**\n * Locally unique id's. We use this to generate transaction ids, and they don't have to be\n * cryptographically unique, as the worst that can happen is that they get rejected because\n * of a collision, and then we should just retry with a new id.\n */\nexport const luid: typeof uuid = uuid\n","import {Patcher} from '../patch'\nimport {debug} from './debug'\nimport {luid} from './luid'\nimport {type Doc, type Mut} from './types'\n\n/**\n * Parameters attached to the mutation\n *\n * @internal\n */\nexport interface MutationParams {\n  transactionId?: string\n  transition?: string\n  identity?: string\n  previousRev?: string\n  resultRev?: string\n  mutations: Mut[]\n  timestamp?: string\n  effects?: {apply: unknown; revert: unknown}\n}\n\n/**\n * A mutation describing a number of operations on a single document.\n * This should be considered an immutable structure. Mutations are compiled\n * on first application, and any changes in properties will not effectively\n * change its behavior after that.\n *\n * @internal\n */\nexport class Mutation {\n  params: MutationParams\n\n  compiled?: (doc: Doc | null) => Doc | null\n\n  _appliesToMissingDocument: boolean | undefined\n\n  constructor(options: MutationParams) {\n    this.params = options\n  }\n\n  get transactionId(): string | undefined {\n    return this.params.transactionId\n  }\n\n  get transition(): string | undefined {\n    return this.params.transition\n  }\n\n  get identity(): string | undefined {\n    return this.params.identity\n  }\n\n  get previousRev(): string | undefined {\n    return this.params.previousRev\n  }\n\n  get resultRev(): string | undefined {\n    return this.params.resultRev\n  }\n\n  get mutations(): Mut[] {\n    return this.params.mutations\n  }\n\n  get timestamp(): Date | undefined {\n    if (typeof this.params.timestamp === 'string') {\n      return new Date(this.params.timestamp)\n    }\n\n    return undefined\n  }\n\n  get effects():\n    | {\n        apply: unknown\n        revert: unknown\n      }\n    | undefined {\n    return this.params.effects\n  }\n\n  assignRandomTransactionId(): void {\n    this.params.transactionId = luid()\n    this.params.resultRev = this.params.transactionId\n  }\n\n  appliesToMissingDocument(): boolean {\n    if (typeof this._appliesToMissingDocument !== 'undefined') {\n      return this._appliesToMissingDocument\n    }\n\n    // Only mutations starting with a create operation apply to documents that do not exist ...\n    const firstMut = this.mutations[0]\n    if (firstMut) {\n      this._appliesToMissingDocument = Boolean(\n        firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace,\n      )\n    } else {\n      this._appliesToMissingDocument = true\n    }\n\n    return this._appliesToMissingDocument\n  }\n\n  // Compiles all mutations into a handy function\n  compile(): void {\n    const operations: ((doc: Doc | null) => Doc | null)[] = []\n\n    this.mutations.forEach((mutation) => {\n      if (mutation.create) {\n        // TODO: Fail entire patch if document did exist\n        const create = mutation.create || {}\n        operations.push((doc): Doc => {\n          if (doc) {\n            return doc\n          }\n\n          return Object.assign(create as Doc, {\n            _createdAt: create._createdAt || this.params.timestamp,\n          })\n        })\n        return\n      }\n\n      if (mutation.createIfNotExists) {\n        const createIfNotExists = mutation.createIfNotExists || {}\n        operations.push((doc) =>\n          doc === null\n            ? Object.assign(createIfNotExists, {\n                _createdAt: createIfNotExists._createdAt || this.params.timestamp,\n              })\n            : doc,\n        )\n        return\n      }\n\n      if (mutation.createOrReplace) {\n        const createOrReplace = mutation.createOrReplace || {}\n        operations.push(() =>\n          Object.assign(createOrReplace, {\n            _createdAt: createOrReplace._createdAt || this.params.timestamp,\n          }),\n        )\n        return\n      }\n\n      if (mutation.delete) {\n        operations.push(() => null)\n        return\n      }\n\n      if (mutation.patch) {\n        if ('query' in mutation.patch) {\n          // @todo Warn/throw? Investigate if this can ever happen\n          return\n        }\n\n        const patch = new Patcher(mutation.patch)\n        operations.push((doc) => patch.apply(doc) as Doc | null)\n        return\n      }\n\n      throw new Error(`Unsupported mutation ${JSON.stringify(mutation, null, 2)}`)\n    })\n\n    // Assign `_updatedAt` to the timestamp of the mutation if set\n    if (typeof this.params.timestamp === 'string') {\n      operations.push((doc) => {\n        return doc ? Object.assign(doc, {_updatedAt: this.params.timestamp}) : null\n      })\n    }\n\n    const prevRev = this.previousRev\n    const rev = this.resultRev || this.transactionId\n    this.compiled = (doc: Doc | null) => {\n      if (prevRev && doc && prevRev !== doc._rev) {\n        throw new Error(\n          `Previous revision for this mutation was ${prevRev}, but the document revision is ${doc._rev}`,\n        )\n      }\n\n      let result: Doc | null = doc\n      for (const operation of operations) {\n        result = operation(result)\n      }\n\n      // Should update _rev?\n      if (result && rev) {\n        // Ensure that result is a unique object, even if the operation was a no-op\n        if (result === doc) {\n          result = Object.assign({}, doc)\n        }\n        result._rev = rev\n      }\n\n      return result\n    }\n  }\n\n  apply(document: Doc | null): Doc | null {\n    debug('Applying mutation %O to document %O', this.mutations, document)\n    if (!this.compiled) {\n      this.compile()\n    }\n\n    const result = this.compiled!(document)\n    debug('  => %O', result)\n    return result\n  }\n\n  static applyAll(document: Doc | null, mutations: Mutation[]): Doc | null {\n    return mutations.reduce((doc, mutation) => mutation.apply(doc), document)\n  }\n\n  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation\n  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed\n  // that all mutations are on the same document.\n  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!\n  static squash(document: Doc | null, mutations: Mutation[]): Mutation {\n    const squashed = mutations.reduce(\n      (result, mutation) => result.concat(...mutation.mutations),\n      [] as Mut[],\n    )\n    return new Mutation({mutations: squashed})\n  }\n}\n","// TODO: When we have timestamps on mutation notifications, we can reject incoming mutations that are older\n// than the document we are seeing.\n\nimport {isEqual} from 'lodash'\n\nimport {debug} from './debug'\nimport {Mutation} from './Mutation'\nimport {type Doc} from './types'\n\n/**\n * @internal\n */\nexport interface SubmissionResponder {\n  success: () => void\n  failure: () => void\n}\n\n/**\n * Models a document as it is changed by our own local patches and remote patches coming in from\n * the server. Consolidates incoming patches with our own submitted patches and maintains two\n * versions of the document. EDGE is the optimistic document that the user sees that will always\n * immediately reflect whatever she is doing to it, and HEAD which is the confirmed version of the\n * document consistent with the mutations we have received from the server. As long as nothing out of\n * the ordinary happens, we can track all changes by hooking into the onMutation callback, but we\n * must also respect onRebase events that fire when we have to backtrack because one of our optimistically\n * applied patches were rejected, or some bastard was able to slip a mutation in between ours own.\n *\n * @internal\n */\nexport class Document {\n  /**\n   * Incoming patches from the server waiting to be applied to HEAD\n   */\n  incoming: Mutation[] = []\n\n  /**\n   * Patches we know has been subitted to the server, but has not been seen yet in the return channel\n   * so we can't be sure about the ordering yet (someone else might have slipped something between them)\n   */\n  submitted: Mutation[] = []\n\n  /**\n   * Pending mutations\n   */\n  pending: Mutation[] = []\n\n  /**\n   * Our model of the document according to the incoming patches from the server\n   */\n  HEAD: Doc | null\n\n  /**\n   * Our optimistic model of what the document will probably look like as soon as all our patches\n   * have been processed. Updated every time we stage a new mutation, but also might revert back\n   * to previous states if our mutations fail, or could change if unexpected mutations arrive\n   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.\n   */\n  EDGE: Doc | null\n\n  /**\n   * Called with the EDGE document when that document changes for a reason other than us staging\n   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:\n   * I.e. when EDGE changes because the order of mutations has changed in relation to our\n   * optimistic predictions.\n   */\n  onRebase?: (edge: Doc | null, incomingMutations: Mutation[], pendingMutations: Mutation[]) => void\n\n  /**\n   * Called when we receive a patch in the normal order of things, but the mutation is not ours\n   */\n  onMutation?: (msg: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Called when consistency state changes with the boolean value of the current consistency state\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Called whenever a new incoming mutation comes in. These are always ordered correctly.\n   */\n  onRemoteMutation?: (mut: Mutation) => void\n\n  /**\n   * We are consistent when there are no unresolved mutations of our own, and no un-applicable\n   * incoming mutations. When this has been going on for too long, and there has been a while\n   * since we staged a new mutation, it is time to reset your state.\n   */\n  inconsistentAt: Date | null = null\n\n  /**\n   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it\n   * hasn't been long since we staged a new mutation, the reason is probably just because the user\n   * is typing or something.\n   *\n   * Should be used as a guard against resetting state for inconsistency reasons.\n   */\n  lastStagedAt: Date | null = null\n\n  constructor(doc: Doc | null) {\n    this.reset(doc)\n    this.HEAD = doc\n    this.EDGE = doc\n  }\n\n  // Reset the state of the Document, used to recover from unsavory states by reloading the document\n  reset(doc: Doc | null): void {\n    this.incoming = []\n    this.submitted = []\n    this.pending = []\n    this.inconsistentAt = null\n    this.HEAD = doc\n    this.EDGE = doc\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    this.incoming.push(mutation)\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call to signal that we are submitting a mutation. Returns a callback object with a\n  // success and failure handler that must be called according to the outcome of our\n  // submission.\n  stage(mutation: Mutation, silent?: boolean): SubmissionResponder {\n    if (!mutation.transactionId) {\n      throw new Error('Mutations _must_ have transactionId when submitted')\n    }\n    this.lastStagedAt = new Date()\n\n    debug('Staging mutation %s (pushed to pending)', mutation.transactionId)\n    this.pending.push(mutation)\n    this.EDGE = mutation.apply(this.EDGE)\n\n    if (this.onMutation && !silent) {\n      this.onMutation({\n        mutation,\n        document: this.EDGE,\n        remote: false,\n      })\n    }\n\n    const txnId = mutation.transactionId\n\n    this.updateConsistencyFlag()\n\n    return {\n      success: () => {\n        this.pendingSuccessfullySubmitted(txnId)\n        this.updateConsistencyFlag()\n      },\n      failure: () => {\n        this.pendingFailed(txnId)\n        this.updateConsistencyFlag()\n      },\n    }\n  }\n\n  // Call to check if everything is nice and quiet and there are no unresolved mutations.\n  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.\n  isConsistent(): boolean {\n    return !this.inconsistentAt\n  }\n\n  // Private\n\n  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there\n  // are applicable patches to be applied\n  considerIncoming(): void {\n    let mustRebase = false\n    let nextMut: Mutation | undefined\n    const rebaseMutations: Mutation[] = []\n\n    // Filter mutations that are older than the document\n    if (this.HEAD && this.HEAD._updatedAt) {\n      const updatedAt = new Date(this.HEAD._updatedAt)\n      if (this.incoming.find((mut) => mut.timestamp && mut.timestamp < updatedAt)) {\n        this.incoming = this.incoming.filter((mut) => mut.timestamp && mut.timestamp < updatedAt)\n      }\n    }\n\n    // Keep applying mutations as long as any apply\n    let protect = 0\n    do {\n      // Find next mutation that can be applied to HEAD (if any)\n      if (this.HEAD) {\n        const HEAD = this.HEAD\n        nextMut = HEAD._rev ? this.incoming.find((mut) => mut.previousRev === HEAD._rev) : undefined\n      } else {\n        // When HEAD is null, that means the document is currently deleted. Only mutations that start with a create\n        // operation will be considered.\n        nextMut = this.incoming.find((mut) => mut.appliesToMissingDocument())\n      }\n\n      if (nextMut) {\n        const applied = this.applyIncoming(nextMut)\n        mustRebase = mustRebase || applied\n        if (mustRebase) {\n          rebaseMutations.push(nextMut)\n        }\n\n        if (protect++ > 10) {\n          throw new Error(\n            `Mutator stuck flushing incoming mutations. Probably stuck here: ${JSON.stringify(\n              nextMut,\n            )}`,\n          )\n        }\n      }\n    } while (nextMut)\n\n    if (this.incoming.length > 0 && debug.enabled) {\n      debug(\n        'Unable to apply mutations %s',\n        this.incoming.map((mut) => mut.transactionId).join(', '),\n      )\n    }\n\n    if (mustRebase) {\n      this.rebase(rebaseMutations)\n    }\n  }\n\n  // check current consistency state, update flag and invoke callback if needed\n  updateConsistencyFlag(): void {\n    const wasConsistent = this.isConsistent()\n    const isConsistent =\n      this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0\n    // Update the consistency state, taking care not to update the timestamp if we were inconsistent and still are\n    if (isConsistent) {\n      this.inconsistentAt = null\n    } else if (!this.inconsistentAt) {\n      this.inconsistentAt = new Date()\n    }\n    // Handle onConsistencyChanged callback\n    if (wasConsistent != isConsistent && this.onConsistencyChanged) {\n      if (isConsistent) {\n        debug('Buffered document is inconsistent')\n      } else {\n        debug('Buffered document is consistent')\n      }\n      this.onConsistencyChanged(isConsistent)\n    }\n  }\n\n  // apply an incoming patch that has been prequalified as the next in line for this document\n  applyIncoming(mut: Mutation | undefined): boolean {\n    if (!mut) {\n      return false\n    }\n\n    if (!mut.transactionId) {\n      throw new Error('Received incoming mutation without a transaction ID')\n    }\n\n    debug(\n      'Applying mutation %s -> %s to rev %s',\n      mut.previousRev,\n      mut.resultRev,\n      this.HEAD && this.HEAD._rev,\n    )\n\n    this.HEAD = mut.apply(this.HEAD)\n\n    if (this.onRemoteMutation) {\n      this.onRemoteMutation(mut)\n    }\n\n    // Eliminate from incoming set\n    this.incoming = this.incoming.filter((m) => m.transactionId !== mut.transactionId)\n\n    if (this.hasUnresolvedMutations()) {\n      const needRebase = this.consumeUnresolved(mut.transactionId)\n      if (debug.enabled) {\n        debug(\n          `Incoming mutation ${mut.transactionId} appeared while there were pending or submitted local mutations`,\n        )\n        debug(`Submitted txnIds: ${this.submitted.map((m) => m.transactionId).join(', ')}`)\n        debug(`Pending txnIds: ${this.pending.map((m) => m.transactionId).join(', ')}`)\n        debug(`needRebase === %s`, needRebase)\n      }\n      return needRebase\n    }\n    debug(\n      `Remote mutation %s arrived w/o any pending or submitted local mutations`,\n      mut.transactionId,\n    )\n    this.EDGE = this.HEAD\n    if (this.onMutation) {\n      this.onMutation({\n        mutation: mut,\n        document: this.EDGE,\n        remote: true,\n      })\n    }\n    return false\n  }\n\n  /**\n   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have\n   * mutations that are still waiting to be either submitted, or to be confirmed by the server.\n   *\n   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise\n   */\n  hasUnresolvedMutations(): boolean {\n    return this.submitted.length > 0 || this.pending.length > 0\n  }\n\n  /**\n   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from\n   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,\n   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in\n   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of\n   * order in terms of our optimistic version, so a rebase is needed.\n   *\n   * @param txnId - Transaction ID of the remote mutation\n   * @returns true if rebase is needed, false otherwise\n   */\n  consumeUnresolved(txnId: string): boolean {\n    // If we have nothing queued up, we are in sync and can apply patch with no\n    // rebasing\n    if (this.submitted.length === 0 && this.pending.length === 0) {\n      return false\n    }\n\n    // If we can consume the directly upcoming mutation, we won't have to rebase\n    if (this.submitted.length !== 0) {\n      if (this.submitted[0].transactionId === txnId) {\n        debug(\n          `Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer`,\n          txnId,\n        )\n        this.submitted.shift()\n        return false\n      }\n    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) {\n      // There are no submitted, but some are pending so let's check the upcoming pending\n      debug(\n        `Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer`,\n        txnId,\n      )\n      this.pending.shift()\n      return false\n    }\n\n    debug(\n      'The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d',\n      this.pending.length,\n      this.submitted.length,\n    )\n\n    // The mutation was not the upcoming mutation, so we'll have to check everything to\n    // see if we have an out of order situation\n    this.submitted = this.submitted.filter((mut) => mut.transactionId !== txnId)\n    this.pending = this.pending.filter((mut) => mut.transactionId !== txnId)\n    debug(`After scrubbing: Pending: %d, Submitted: %d`, this.pending.length, this.submitted.length)\n\n    // Whether we had it or not we have either a reordering, or an unexpected mutation\n    // so must rebase\n    return true\n  }\n\n  pendingSuccessfullySubmitted(pendingTxnId: string): void {\n    if (this.pending.length === 0) {\n      // If there are no pending, it has probably arrived allready\n      return\n    }\n\n    const first = this.pending[0]\n    if (first.transactionId === pendingTxnId) {\n      // Nice, the pending transaction arrived in order\n      this.pending.shift()\n      this.submitted.push(first)\n      return\n    }\n\n    // Oh, no. Submitted out of order.\n    let justSubmitted: Mutation | undefined\n    const stillPending: Mutation[] = []\n    this.pending.forEach((mutation) => {\n      if (mutation.transactionId === pendingTxnId) {\n        justSubmitted = mutation\n        return\n      }\n\n      stillPending.push(mutation)\n    })\n\n    // Not found? Hopefully it has already arrived. Might have been forgotten by now\n    if (justSubmitted) {\n      this.submitted.push(justSubmitted)\n    }\n\n    this.pending = stillPending\n\n    // Must rebase since mutation order has changed\n    this.rebase([])\n  }\n\n  pendingFailed(pendingTxnId: string): void {\n    this.pending = this.pending.filter((mutation) => mutation.transactionId !== pendingTxnId)\n\n    // Rebase to revert document to what it looked like before the failed mutation\n    this.rebase([])\n  }\n\n  rebase(incomingMutations: Mutation[]): void {\n    const oldEdge = this.EDGE\n    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending))\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldEdge !== null && this.EDGE !== null) {\n      oldEdge._rev = this.EDGE._rev\n    }\n\n    const changed = !isEqual(this.EDGE, oldEdge)\n    if (changed && this.onRebase) {\n      this.onRebase(this.EDGE, incomingMutations, this.pending)\n    }\n  }\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\n\nimport {arrayToJSONMatchPath} from '../jsonpath/arrayToJSONMatchPath'\nimport {extractWithPath} from '../jsonpath/extractWithPath'\nimport {debug} from './debug'\nimport {Mutation} from './Mutation'\nimport {type Doc, type Mut} from './types'\n\n/**\n * Implements a buffer for mutations that incrementally optimises the mutations by\n * eliminating set-operations that overwrite earlier set-operations, and rewrite\n * set-operations that change strings into other strings into diffMatchPatch operations.\n *\n * @internal\n */\nexport class SquashingBuffer {\n  /**\n   * The document forming the basis of this squash\n   */\n  BASIS: Doc | null\n\n  /**\n   * The document after the out-Mutation has been applied, but before the staged\n   * operations are committed.\n   */\n  PRESTAGE: Doc | null\n\n  /**\n   * setOperations contain the latest set operation by path. If the set-operations are\n   * updating strings to new strings, they are rewritten as diffMatchPatch operations,\n   * any new set operations on the same paths overwrites any older set operations.\n   * Only set-operations assigning plain values to plain values gets optimized like this.\n   */\n  setOperations: Record<string, Mut | undefined>\n\n  /**\n   * `documentPresent` is true whenever we know that the document must be present due\n   * to preceeding mutations. `false` implies that it may or may not already exist.\n   */\n  documentPresent: boolean\n\n  /**\n   * The operations in the out-Mutation are not able to be optimized any further\n   */\n  out: Mut[] = []\n\n  /**\n   * Staged mutation operations\n   */\n  staged: Mut[]\n\n  constructor(doc: Doc | null) {\n    if (doc) {\n      debug('Reset mutation buffer to rev %s', doc._rev)\n    } else {\n      debug('Reset mutation buffer state to document being deleted')\n    }\n\n    this.staged = []\n    this.setOperations = {}\n    this.documentPresent = false\n\n    this.BASIS = doc\n    this.PRESTAGE = doc\n  }\n\n  add(mut: Mutation): void {\n    mut.mutations.forEach((op) => this.addOperation(op))\n  }\n\n  hasChanges(): boolean {\n    return this.out.length > 0 || Object.keys(this.setOperations).length > 0\n  }\n\n  /**\n   * Extracts the mutations in this buffer.\n   * After this is done, the buffer lifecycle is over and the client should\n   * create an new one with the new, updated BASIS.\n   *\n   * @param txnId - Transaction ID\n   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise\n   */\n  purge(txnId?: string): Mutation | null {\n    this.stashStagedOperations()\n    let result = null\n    if (this.out.length > 0) {\n      debug('Purged mutation buffer')\n      result = new Mutation({\n        mutations: this.out,\n        resultRev: txnId,\n        transactionId: txnId,\n      })\n    }\n    this.out = []\n    this.documentPresent = false\n    return result\n  }\n\n  addOperation(op: Mut): void {\n    // Is this a set patch, and only a set patch, and does it apply to the document at hand?\n    if (\n      op.patch &&\n      op.patch.set &&\n      'id' in op.patch &&\n      op.patch.id === this.PRESTAGE?._id &&\n      Object.keys(op.patch).length === 2 // `id` + `set`\n    ) {\n      const setPatch = op.patch.set\n      const unoptimizable: Record<string, unknown> = {}\n      // Apply all optimisable keys in the patch\n      for (const path of Object.keys(setPatch)) {\n        if (setPatch.hasOwnProperty(path)) {\n          if (!this.optimiseSetOperation(path, setPatch[path])) {\n            // If not optimisable, add to unoptimizable set\n            unoptimizable[path] = setPatch[path]\n          }\n        }\n      }\n\n      // If any weren't optimisable, add them to an unoptimised set-operation, then\n      // stash everything.\n      if (Object.keys(unoptimizable).length > 0) {\n        debug('Unoptimizable set-operation detected, purging optimization buffer')\n        this.staged.push({patch: {id: this.PRESTAGE._id, set: unoptimizable}})\n        this.stashStagedOperations()\n      }\n\n      return\n    }\n\n    // Is this a createIfNotExists for our document?\n    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {\n      if (!this.documentPresent) {\n        // If we don't know that it's present we'll have to stage and stash.\n        this.staged.push(op)\n        this.documentPresent = true\n        this.stashStagedOperations()\n      }\n\n      // Otherwise we can fully ignore it.\n      return\n    }\n\n    debug('Unoptimizable mutation detected, purging optimization buffer')\n    // console.log(\"Unoptimizable operation, stashing\", JSON.stringify(op))\n    // Un-optimisable operations causes everything to be stashed\n    this.staged.push(op)\n    this.stashStagedOperations()\n  }\n\n  /**\n   * Attempt to perform one single set operation in an optimised manner, return value\n   * reflects whether or not the operation could be performed.\n\n   * @param path - The JSONPath to the set operation in question\n   * @param nextValue - The value to be set\n   * @returns True of optimized, false otherwise\n   */\n  optimiseSetOperation(path: string, nextValue: unknown): boolean {\n    // console.log('optimiseSetOperation', path, nextValue)\n    // If target value is not a plain value, unable to optimise\n    if (typeof nextValue === 'object') {\n      // console.log(\"Not optimisable because next value is object\")\n      return false\n    }\n\n    // Check the source values, if there is more than one value being assigned,\n    // we won't optimise\n    const matches = extractWithPath(path, this.PRESTAGE)\n    // If we are not overwriting exactly one key, this cannot be optimised, so we bail\n    if (matches.length !== 1) {\n      // console.log('Not optimisable because match count is != 1', JSON.stringify(matches))\n      return false\n    }\n\n    // Okay, we are assigning exactly one value to exactly one existing slot, so we might optimise\n    const match = matches[0]\n    // If the value of the match is an array or object, we cannot safely optimise this since the meaning\n    // of pre-existing operations might change (in theory, at least), so we bail\n    if (typeof match.value === 'object') {\n      // console.log(\"Not optimisable because old value is object\")\n      return false\n    }\n\n    if (!this.PRESTAGE) {\n      // Shouldn't happen, but makes typescript happy\n      return false\n    }\n\n    // If the new and old value are the equal, we optimise this operation by discarding it\n    // Now, let's build the operation\n    let op: Mut | null = null\n    if (match.value === nextValue) {\n      // If new and old values are equal, we optimise this by deleting the operation\n      // console.log(\"Omitting operation\")\n      op = null\n    } else if (typeof match.value === 'string' && typeof nextValue === 'string') {\n      // console.log(\"Rewriting to dmp\")\n      // We are updating a string to another string, so we are making a diffMatchPatch\n      try {\n        const patch = stringifyPatches(makePatches(match.value, nextValue))\n        op = {patch: {id: this.PRESTAGE._id, diffMatchPatch: {[path]: patch}}}\n      } catch {\n        // patch_make failed due to unicode issue https://github.com/google/diff-match-patch/issues/59\n        return false\n      }\n    } else {\n      // console.log(\"Not able to rewrite to dmp, making normal set\")\n      // We are changing the type of the value, so must make a normal set-operation\n      op = {patch: {id: this.PRESTAGE._id, set: {[path]: nextValue}}}\n    }\n\n    // Let's make a plain, concrete path from the array-path. We use this to keep only the latest set\n    // operation touching this path in the buffer.\n    const canonicalPath = arrayToJSONMatchPath(match.path)\n\n    // Store this operation, overwriting any previous operations touching this same path\n    if (op) {\n      this.setOperations[canonicalPath] = op\n    } else {\n      delete this.setOperations[canonicalPath]\n    }\n\n    // Signal that we succeeded in optimizing this patch\n    return true\n  }\n\n  stashStagedOperations(): void {\n    // Short circuit if there are no staged operations\n    const nextOps: Mut[] = []\n\n    // Extract the existing outgoing operations if any\n    Object.keys(this.setOperations).forEach((key) => {\n      const op = this.setOperations[key]\n      if (op) {\n        nextOps.push(op)\n      }\n    })\n\n    nextOps.push(...this.staged)\n    if (nextOps.length > 0) {\n      this.PRESTAGE = new Mutation({mutations: nextOps}).apply(this.PRESTAGE) as Doc\n      this.staged = []\n      this.setOperations = {}\n    }\n\n    this.out.push(...nextOps)\n  }\n\n  /**\n   * Rebases given the new base-document\n   *\n   * @param newBasis - New base document to rebase on\n   * @returns New \"edge\" document with buffered changes integrated\n   */\n  rebase(newBasis: Doc | null): Doc | null {\n    this.stashStagedOperations()\n\n    if (newBasis === null) {\n      // If document was just deleted, we must throw out local changes\n      this.out = []\n      this.BASIS = newBasis\n      this.PRESTAGE = newBasis\n      this.documentPresent = false\n    } else {\n      this.BASIS = newBasis\n\n      // @todo was this supposed to be `this.out.length > 0`?\n      // surely this is always `true`?\n      if (this.out) {\n        this.PRESTAGE = new Mutation({mutations: this.out}).apply(this.BASIS) as Doc\n      } else {\n        this.PRESTAGE = this.BASIS\n      }\n    }\n\n    return this.PRESTAGE\n  }\n}\n","import {isEqual} from 'lodash'\n\nimport {debug} from './debug'\nimport {Document} from './Document'\nimport {Mutation} from './Mutation'\nimport {SquashingBuffer} from './SquashingBuffer'\nimport {type Doc, type Mut} from './types'\n\nconst ONE_MINUTE = 1000 * 60\n\n/**\n * @internal\n */\nexport interface CommitHandlerMessage {\n  mutation: Mutation\n  success: () => void\n  failure: () => void\n  cancel: (error: Error) => void\n}\n\n/**\n * A wrapper for Document that allows the client to gather mutations on the\n * client side and commit them when it wants to.\n */\nclass Commit {\n  mutations: Mutation[]\n  tries: number\n  resolve: () => void\n  reject: (error: Error) => void\n\n  constructor(\n    mutations: Mutation[],\n    {resolve, reject}: {resolve: () => void; reject: (error: Error) => void},\n  ) {\n    this.mutations = mutations\n    this.tries = 0\n    this.resolve = resolve\n    this.reject = reject\n  }\n\n  apply(doc: Doc | null): Doc | null {\n    return Mutation.applyAll(doc, this.mutations)\n  }\n\n  squash(doc: Doc | null) {\n    const result = Mutation.squash(doc, this.mutations)\n    result.assignRandomTransactionId()\n    return result\n  }\n}\n\nconst mutReducerFn = (acc: Mut[], mut: Mutation): Mut[] => acc.concat(mut.mutations)\n\n/**\n * @internal\n */\nexport class BufferedDocument {\n  private mutations: Mutation[]\n\n  /**\n   * The Document we are wrapping\n   */\n  document: Document\n\n  /**\n   * The Document with local changes applied\n   */\n  LOCAL: Doc | null\n\n  /**\n   * Commits that are waiting to be delivered to the server\n   */\n  private commits: Commit[]\n\n  /**\n   * Local mutations that are not scheduled to be committed yet\n   */\n  buffer: SquashingBuffer\n\n  /**\n   * Assignable event handler for when the buffered document applies a mutation\n   */\n  onMutation?: (message: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Assignable event handler for when a remote mutation happened\n   */\n  onRemoteMutation?: Document['onRemoteMutation']\n\n  /**\n   * Assignable event handler for when the buffered document rebased\n   */\n  onRebase?: (localDoc: Doc | null, remoteMutations: Mut[], localMutations: Mut[]) => void\n\n  /**\n   * Assignable event handler for when the document is deleted\n   */\n  onDelete?: (doc: Doc | null) => void\n\n  /**\n   * Assignable event handler for when the state of consistency changed\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Assignable event handler for when the buffered document should commit changes\n   */\n  commitHandler?: (msg: CommitHandlerMessage) => void\n\n  /**\n   * Whether or not we are currently commiting\n   */\n  committerRunning = false\n\n  constructor(doc: Doc | null) {\n    this.buffer = new SquashingBuffer(doc)\n    this.document = new Document(doc)\n    this.document.onMutation = (msg) => this.handleDocMutation(msg)\n    this.document.onRemoteMutation = (mut) => this.onRemoteMutation && this.onRemoteMutation(mut)\n    this.document.onRebase = (edge, remoteMutations, localMutations) =>\n      this.handleDocRebase(edge, remoteMutations, localMutations)\n    this.document.onConsistencyChanged = (msg) => this.handleDocConsistencyChanged(msg)\n    this.LOCAL = doc\n    this.mutations = []\n    this.commits = []\n  }\n\n  // Used to reset the state of the local document model. If the model has been inconsistent\n  // for too long, it has probably missed a notification, and should reload the document from the server\n  reset(doc: Doc | null): void {\n    if (doc) {\n      debug('Document state reset to revision %s', doc._rev)\n    } else {\n      debug('Document state reset to being deleted')\n    }\n    this.document.reset(doc)\n    this.rebase([], [])\n    this.handleDocConsistencyChanged(this.document.isConsistent())\n  }\n\n  // Add a change to the buffer\n  add(mutation: Mutation): void {\n    if (this.onConsistencyChanged) {\n      this.onConsistencyChanged(false)\n    }\n    debug('Staged local mutation')\n    this.buffer.add(mutation)\n    const oldLocal = this.LOCAL\n    this.LOCAL = mutation.apply(this.LOCAL)\n    if (this.onMutation && oldLocal !== this.LOCAL) {\n      debug('onMutation fired')\n      this.onMutation({\n        mutation,\n        document: this.LOCAL,\n        remote: false,\n      })\n      if (this.LOCAL === null && this.onDelete) {\n        this.onDelete(this.LOCAL)\n      }\n    }\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    debug('Remote mutation arrived %s -> %s', mutation.previousRev, mutation.resultRev)\n    if (mutation.previousRev === mutation.resultRev) {\n      throw new Error(\n        `Mutation ${mutation.transactionId} has previousRev === resultRev (${mutation.previousRev})`,\n      )\n    }\n    return this.document.arrive(mutation)\n  }\n\n  // Submit all mutations in the buffer to be committed\n  commit(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Anything to commit?\n      if (!this.buffer.hasChanges()) {\n        resolve()\n        return\n      }\n      debug('Committing local changes')\n      // Collect current staged mutations into a commit and ...\n      const pendingMutations = this.buffer.purge()\n      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], {resolve, reject}))\n      // ... clear the table for the next commit.\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      this.performCommits()\n    })\n  }\n\n  // Starts the committer that will try to committ all staged commits to the database\n  // by calling the commitHandler. Will keep running until all commits are successfully\n  // committed.\n  performCommits(): void {\n    if (!this.commitHandler) {\n      throw new Error('No commitHandler configured for this BufferedDocument')\n    }\n    if (this.committerRunning) {\n      // We can have only one committer at any given time\n      return\n    }\n    this._cycleCommitter()\n  }\n\n  // TODO: Error handling, right now retries after every error\n  _cycleCommitter(): void {\n    const commit = this.commits.shift()\n    if (!commit) {\n      this.committerRunning = false\n      return\n    }\n\n    this.committerRunning = true\n    const squashed = commit.squash(this.LOCAL)\n    const docResponder = this.document.stage(squashed, true)\n\n    const responder = {\n      success: () => {\n        debug('Commit succeeded')\n        docResponder.success()\n        commit.resolve()\n        // Keep running the committer until no more commits\n        this._cycleCommitter()\n      },\n\n      failure: () => {\n        debug('Commit failed')\n        // Re stage commit\n        commit.tries += 1\n        if (this.LOCAL !== null) {\n          // Only schedule this commit for a retry of the document still exist to avoid looping\n          // indefinitely when the document was deleted from under our noses\n          this.commits.unshift(commit)\n        }\n        docResponder.failure()\n\n        // Todo: Need better error handling (i.e. propagate to user and provide means of retrying)\n        if (commit.tries < 200) {\n          setTimeout(() => this._cycleCommitter(), Math.min(commit.tries * 1000, ONE_MINUTE))\n        }\n      },\n\n      cancel: (error: Error) => {\n        this.commits.forEach((comm) => comm.reject(error))\n\n        // Throw away waiting commits\n        this.commits = []\n\n        // Reset back to last known state from content lake and cause a rebase that will\n        // reset the view in the form\n        this.reset(this.document.HEAD)\n\n        // Clear the buffer of recent mutations\n        this.buffer = new SquashingBuffer(this.LOCAL)\n\n        // Stop the committer loop\n        this.committerRunning = false\n      },\n    }\n\n    debug('Posting commit')\n    if (this.commitHandler) {\n      this.commitHandler({\n        mutation: squashed,\n        success: responder.success,\n        failure: responder.failure,\n        cancel: responder.cancel,\n      })\n    }\n  }\n\n  handleDocRebase(edge: Doc | null, remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    this.rebase(remoteMutations, localMutations)\n  }\n\n  handleDocumentDeleted(): void {\n    debug('Document deleted')\n    // If the document was just deleted, fire the onDelete event with the absolutely latest\n    // version of the document before someone deleted it so that the client may revive the\n    // document in the last state the user saw it, should they so desire.\n    if (this.LOCAL !== null && this.onDelete) {\n      this.onDelete(this.LOCAL)\n    }\n\n    this.commits = []\n    this.mutations = []\n  }\n\n  handleDocMutation(msg: {mutation: Mutation; document: Doc | null; remote: boolean}): void {\n    // If we have no local changes, we can just pass this on to the client\n    if (this.commits.length === 0 && !this.buffer.hasChanges()) {\n      debug('Document mutated from remote with no local changes')\n      this.LOCAL = this.document.EDGE\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      if (this.onMutation) {\n        this.onMutation(msg)\n      }\n      return\n    }\n\n    debug('Document mutated from remote with local changes')\n\n    // If there are local edits, and the document was deleted, we need to purge those local edits now\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    // We had local changes, so need to signal rebase\n    this.rebase([msg.mutation], [])\n  }\n\n  rebase(remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    debug('Rebasing document')\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    const oldLocal = this.LOCAL\n    this.LOCAL = this.commits.reduce((doc, commit) => commit.apply(doc), this.document.EDGE)\n    this.LOCAL = this.buffer.rebase(this.LOCAL)\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldLocal !== null && this.LOCAL !== null) {\n      oldLocal._rev = this.LOCAL._rev\n    }\n\n    const changed = !isEqual(this.LOCAL, oldLocal)\n    if (changed && this.onRebase) {\n      this.onRebase(\n        this.LOCAL,\n        remoteMutations.reduce(mutReducerFn, []),\n        localMutations.reduce(mutReducerFn, []),\n      )\n    }\n  }\n\n  handleDocConsistencyChanged(isConsistent: boolean): void {\n    if (!this.onConsistencyChanged) {\n      return\n    }\n\n    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges()\n\n    if (isConsistent && !hasLocalChanges) {\n      this.onConsistencyChanged(true)\n    }\n\n    if (!isConsistent) {\n      this.onConsistencyChanged(false)\n    }\n  }\n}\n"],"names":["debug","debugIt","ImmutableAccessor","constructor","value","path","_value","containerType","Array","isArray","get","length","Error","getIndex","i","concat","hasAttribute","key","isRecord","hasOwnProperty","attributeKeys","Object","keys","getAttribute","set","setIndex","is","nextValue","slice","setIndexAccessor","accessor","unsetIndices","indices","indexOf","push","insertItemsAt","pos","items","setAttribute","assign","setAttributeAccessor","unsetAttribute","IS_DOTTABLE","arrayToJSONMatchPath","pathArray","forEach","segment","index","stringifySegment","hasLeading","seg","map","isPrimitiveValue","join","test","val","descend","tail","head","newTail","splitIfPath","spreadIfUnionHead","type","nodes","concatPaths","path1","path2","nodes1","nodes2","node","subHead","subTail","digitChar","attributeCharMatcher","attributeFirstCharMatcher","symbols","operator","comparator","keyword","boolean","paren","symbolClasses","Tokenizer","source","tokenizers","tokenizeSymbol","tokenizeIdentifier","tokenizeNumber","tokenizeQuoted","fn","bind","tokenize","result","EOF","chompWhitespace","token","found","some","tokenizer","Boolean","takeWhile","start","nextChar","peek","consume","str","tryConsume","char","quote","escape","inner","first","identifier","match","name","dotSeen","digitSeen","negative","number","raw","symbolClass","patterns","symbol","find","pattern","jsonpath","Parser","tokens","parse","parsePath","probe","record","every","parseAttribute","quoted","parseAlias","target","parseNumber","parseNumberValue","expr","parseSliceSelector","rangeStart","colon1","end","colon2","step","parseValueReference","parseLiteralValue","literalString","literalBoolean","parseFilterExpression","lhs","binOp","rhs","parseExpression","parseUnion","terms","parseRecursive","subpath","term","attr","union","recursive","parseJsonPath","parsed","toPath","toPathInner","inUnion","JSON","stringify","shift","upcoming","e","Expression","isPath","isUnion","isCollection","isConstraint","isRecursive","isExistenceConstraint","isIndex","isRange","expandRange","probeLength","interpretNegativeIndex","isAttributeReference","isIndexReference","isSelfReference","constraintTargetIsSelf","constraintTargetIsAttribute","testConstraint","testBinaryOperator","lhsValue","pathNodes","prepend","other","headTail","unwrapRecursive","toIndicies","range","toFieldReferences","toString","fromPath","attributeReference","indexReference","rhsValue","Descender","iterate","anyConstraints","flatten","descender","iterateConstraints","hasArrived","extractRecursives","constraint","ht","Matcher","active","parent","recursives","payload","setPayload","filter","activeRecursives","extractMatches","newActiveSet","isDestination","hasRecursives","leads","targets","descenderHead","matcher","recursivesMatcher","delivery","PlainProbe","extractAccessors","appendResult","values","lead","accessorsFromTarget","childAccessor","compact","extract","accessors","acc","extractWithPath","applyPatch","patch","oldValue","applyPatches","allowExceedingIndices","DiffMatchPatch","id","dmpPatchSrc","dmpPatch","parsePatch","apply","item","attribute","performIncrement","previousValue","delta","Number","isFinite","IncPatch","targetsToIndicies","sort","InsertPatch","location","minIndex","maxIndex","indicies","min","max","SetIfMissingPatch","SetPatch","UnsetPatch","reduce","r","p","setIfMissing","unset","diffMatchPatch","inc","dec","insert","spec","before","after","replace","Patcher","patches","applyViaAccessor","idAccessor","process","isSetPatch","oldValueAccessor","newValueAccessor","isPatcher","luid","uuid","Mutation","options","params","transactionId","transition","identity","previousRev","resultRev","mutations","timestamp","Date","effects","assignRandomTransactionId","appliesToMissingDocument","_appliesToMissingDocument","firstMut","create","createIfNotExists","createOrReplace","compile","operations","mutation","doc","_createdAt","delete","_updatedAt","prevRev","rev","compiled","_rev","operation","document","applyAll","squash","squashed","Document","incoming","submitted","pending","inconsistentAt","lastStagedAt","reset","HEAD","EDGE","considerIncoming","updateConsistencyFlag","arrive","stage","silent","onMutation","remote","txnId","success","pendingSuccessfullySubmitted","failure","pendingFailed","isConsistent","mustRebase","nextMut","rebaseMutations","updatedAt","mut","protect","applied","applyIncoming","enabled","rebase","wasConsistent","onConsistencyChanged","onRemoteMutation","m","hasUnresolvedMutations","needRebase","consumeUnresolved","pendingTxnId","justSubmitted","stillPending","incomingMutations","oldEdge","changed","isEqual","onRebase","SquashingBuffer","out","staged","setOperations","documentPresent","BASIS","PRESTAGE","add","op","addOperation","hasChanges","purge","stashStagedOperations","_a","_id","setPatch","unoptimizable","optimiseSetOperation","matches","stringifyPatches","makePatches","canonicalPath","nextOps","newBasis","ONE_MINUTE","Commit","_ref","resolve","reject","tries","mutReducerFn","BufferedDocument","committerRunning","buffer","msg","handleDocMutation","edge","remoteMutations","localMutations","handleDocRebase","handleDocConsistencyChanged","LOCAL","commits","oldLocal","onDelete","commit","Promise","pendingMutations","performCommits","commitHandler","_cycleCommitter","docResponder","responder","unshift","setTimeout","Math","cancel","error","comm","handleDocumentDeleted","hasLocalChanges"],"mappings":"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"}