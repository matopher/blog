'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var isEqual = require('lodash/isEqual.js');
var debugIt = require('debug');
var compact = require('lodash/compact.js');
var flatten = require('lodash/flatten.js');
var diffMatchPatch = require('@sanity/diff-match-patch');
var max = require('lodash/max.js');
var min = require('lodash/min.js');
var uuid = require('@sanity/uuid');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);
var debugIt__default = /*#__PURE__*/_interopDefaultCompat(debugIt);
var compact__default = /*#__PURE__*/_interopDefaultCompat(compact);
var flatten__default = /*#__PURE__*/_interopDefaultCompat(flatten);
var max__default = /*#__PURE__*/_interopDefaultCompat(max);
var min__default = /*#__PURE__*/_interopDefaultCompat(min);
const debug = debugIt__default.default("mutator-document");
class ImmutableAccessor {
  constructor(value, path) {
    this._value = value;
    this.path = path || [];
  }
  containerType() {
    if (Array.isArray(this._value)) {
      return "array";
    } else if (this._value !== null && typeof this._value === "object") {
      return "object";
    }
    return "primitive";
  }
  // Common reader, supported by all containers
  get() {
    return this._value;
  }
  // Array reader
  length() {
    if (!Array.isArray(this._value)) {
      throw new Error("Won't return length of non-indexable _value");
    }
    return this._value.length;
  }
  getIndex(i) {
    if (!Array.isArray(this._value)) {
      return false;
    }
    if (i >= this.length()) {
      return null;
    }
    return new ImmutableAccessor(this._value[i], this.path.concat(i));
  }
  // Object reader
  hasAttribute(key) {
    return isRecord$1(this._value) ? this._value.hasOwnProperty(key) : false;
  }
  attributeKeys() {
    return isRecord$1(this._value) ? Object.keys(this._value) : [];
  }
  getAttribute(key) {
    if (!isRecord$1(this._value)) {
      throw new Error("getAttribute only applies to plain objects");
    }
    if (!this.hasAttribute(key)) {
      return null;
    }
    return new ImmutableAccessor(this._value[key], this.path.concat(key));
  }
  // Common writer, supported by all containers
  set(value) {
    return value === this._value ? this : new ImmutableAccessor(value, this.path);
  }
  // array writer interface
  setIndex(i, value) {
    if (!Array.isArray(this._value)) {
      throw new Error("setIndex only applies to arrays");
    }
    if (Object.is(value, this._value[i])) {
      return this;
    }
    const nextValue = this._value.slice();
    nextValue[i] = value;
    return new ImmutableAccessor(nextValue, this.path);
  }
  setIndexAccessor(i, accessor) {
    return this.setIndex(i, accessor.get());
  }
  unsetIndices(indices) {
    if (!Array.isArray(this._value)) {
      throw new Error("unsetIndices only applies to arrays");
    }
    const length = this._value.length;
    const nextValue = [];
    for (let i = 0; i < length; i++) {
      if (indices.indexOf(i) === -1) {
        nextValue.push(this._value[i]);
      }
    }
    return new ImmutableAccessor(nextValue, this.path);
  }
  insertItemsAt(pos, items) {
    if (!Array.isArray(this._value)) {
      throw new Error("insertItemsAt only applies to arrays");
    }
    let nextValue;
    if (this._value.length === 0 && pos === 0) {
      nextValue = items;
    } else {
      nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos));
    }
    return new ImmutableAccessor(nextValue, this.path);
  }
  // Object writer interface
  setAttribute(key, value) {
    if (!isRecord$1(this._value)) {
      throw new Error("Unable to set attribute of non-object container");
    }
    if (Object.is(value, this._value[key])) {
      return this;
    }
    const nextValue = Object.assign({}, this._value, {
      [key]: value
    });
    return new ImmutableAccessor(nextValue, this.path);
  }
  setAttributeAccessor(key, accessor) {
    return this.setAttribute(key, accessor.get());
  }
  unsetAttribute(key) {
    if (!isRecord$1(this._value)) {
      throw new Error("Unable to unset attribute of non-object container");
    }
    const nextValue = Object.assign({}, this._value);
    delete nextValue[key];
    return new ImmutableAccessor(nextValue, this.path);
  }
}
function isRecord$1(value) {
  return value !== null && typeof value === "object";
}
function isRecord(value) {
  return value !== null && typeof value === "object";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function arrayToJSONMatchPath(pathArray) {
  let path = "";
  pathArray.forEach((segment, index) => {
    path += stringifySegment(segment, index === 0);
  });
  return path;
}
function stringifySegment(segment, hasLeading) {
  if (typeof segment === "number") {
    return "[".concat(segment, "]");
  }
  if (isRecord(segment)) {
    const seg = segment;
    return Object.keys(segment).map(key => isPrimitiveValue(seg[key]) ? "[".concat(key, '=="').concat(seg[key], '"]') : "").join("");
  }
  if (typeof segment === "string" && IS_DOTTABLE.test(segment)) {
    return hasLeading ? segment : ".".concat(segment);
  }
  return "['".concat(segment, "']");
}
function isPrimitiveValue(val) {
  switch (typeof val) {
    case "number":
    case "string":
    case "boolean":
      return true;
    default:
      return false;
  }
}
function descend$1(tail) {
  const [head, newTail] = splitIfPath(tail);
  if (!head) {
    throw new Error("Head cannot be null");
  }
  return spreadIfUnionHead(head, newTail);
}
function splitIfPath(tail) {
  if (tail.type !== "path") {
    return [tail, null];
  }
  const nodes = tail.nodes;
  if (nodes.length === 0) {
    return [null, null];
  }
  if (nodes.length === 1) {
    return [nodes[0], null];
  }
  return [nodes[0], {
    type: "path",
    nodes: nodes.slice(1)
  }];
}
function concatPaths(path1, path2) {
  if (!path1 && !path2) {
    return null;
  }
  const nodes1 = path1 ? path1.nodes : [];
  const nodes2 = path2 ? path2.nodes : [];
  return {
    type: "path",
    nodes: nodes1.concat(nodes2)
  };
}
function spreadIfUnionHead(head, tail) {
  if (head.type !== "union") {
    return [[head, tail]];
  }
  return head.nodes.map(node => {
    if (node.type === "path") {
      const [subHead, subTail] = splitIfPath(node);
      return [subHead, concatPaths(subTail, tail)];
    }
    return [node, tail];
  });
}
const digitChar = /[0-9]/;
const attributeCharMatcher = /^[a-zA-Z0-9_]$/;
const attributeFirstCharMatcher = /^[a-zA-Z_]$/;
const symbols = {
  // NOTE: These are compared against in order of definition,
  // thus '==' must come before '=', '>=' before '>', etc.
  operator: ["..", ".", ",", ":", "?"],
  comparator: [">=", "<=", "<", ">", "==", "!="],
  keyword: ["$", "@"],
  boolean: ["true", "false"],
  paren: ["[", "]"]
};
const symbolClasses = Object.keys(symbols);
class Tokenizer {
  constructor(path) {
    this.source = path;
    this.length = path.length;
    this.i = 0;
    this.tokenizers = [this.tokenizeSymbol, this.tokenizeIdentifier, this.tokenizeNumber, this.tokenizeQuoted].map(fn => fn.bind(this));
  }
  tokenize() {
    const result = [];
    while (!this.EOF()) {
      this.chompWhitespace();
      let token = null;
      const found = this.tokenizers.some(tokenizer => {
        token = tokenizer();
        return Boolean(token);
      });
      if (!found || !token) {
        throw new Error("Invalid tokens in jsonpath '".concat(this.source, "' @ ").concat(this.i));
      }
      result.push(token);
    }
    return result;
  }
  takeWhile(fn) {
    const start = this.i;
    let result = "";
    while (!this.EOF()) {
      const nextChar = fn(this.source[this.i]);
      if (nextChar === null) {
        break;
      }
      result += nextChar;
      this.i++;
    }
    if (this.i === start) {
      return null;
    }
    return result;
  }
  EOF() {
    return this.i >= this.length;
  }
  peek() {
    if (this.EOF()) {
      return null;
    }
    return this.source[this.i];
  }
  consume(str) {
    if (this.i + str.length > this.length) {
      throw new Error("Expected ".concat(str, " at end of jsonpath"));
    }
    if (str === this.source.slice(this.i, this.i + str.length)) {
      this.i += str.length;
    } else {
      throw new Error('Expected "'.concat(str, '", but source contained "').concat(this.source.slice()));
    }
  }
  // Tries to match the upcoming bit of string with the provided string. If it matches, returns
  // the string, then advances the read pointer to the next bit. If not, returns null and nothing
  // happens.
  tryConsume(str) {
    if (this.i + str.length > this.length) {
      return null;
    }
    if (str === this.source.slice(this.i, this.i + str.length)) {
      this.i += str.length;
      return str;
    }
    return null;
  }
  chompWhitespace() {
    this.takeWhile(char => {
      return char === " " ? "" : null;
    });
  }
  tokenizeQuoted() {
    const quote = this.peek();
    if (quote === "'" || quote === '"') {
      this.consume(quote);
      let escape = false;
      const inner = this.takeWhile(char => {
        if (escape) {
          escape = false;
          return char;
        }
        if (char === "\\") {
          escape = true;
          return "";
        }
        if (char != quote) {
          return char;
        }
        return null;
      });
      this.consume(quote);
      return {
        type: "quoted",
        value: inner,
        quote: quote === '"' ? "double" : "single"
      };
    }
    return null;
  }
  tokenizeIdentifier() {
    let first = true;
    const identifier = this.takeWhile(char => {
      if (first) {
        first = false;
        return char.match(attributeFirstCharMatcher) ? char : null;
      }
      return char.match(attributeCharMatcher) ? char : null;
    });
    if (identifier !== null) {
      return {
        type: "identifier",
        name: identifier
      };
    }
    return null;
  }
  tokenizeNumber() {
    const start = this.i;
    let dotSeen = false;
    let digitSeen = false;
    let negative = false;
    if (this.peek() === "-") {
      negative = true;
      this.consume("-");
    }
    const number = this.takeWhile(char => {
      if (char === "." && !dotSeen && digitSeen) {
        dotSeen = true;
        return char;
      }
      digitSeen = true;
      return char.match(digitChar) ? char : null;
    });
    if (number !== null) {
      return {
        type: "number",
        value: negative ? -number : +number,
        raw: negative ? "-".concat(number) : number
      };
    }
    this.i = start;
    return null;
  }
  tokenizeSymbol() {
    for (const symbolClass of symbolClasses) {
      const patterns = symbols[symbolClass];
      const symbol = patterns.find(pattern => this.tryConsume(pattern));
      if (symbol) {
        return {
          type: symbolClass,
          symbol
        };
      }
    }
    return null;
  }
}
function tokenize(jsonpath) {
  return new Tokenizer(jsonpath).tokenize();
}
class Parser {
  constructor(path) {
    this.tokens = tokenize(path);
    this.length = this.tokens.length;
    this.i = 0;
  }
  parse() {
    return this.parsePath();
  }
  EOF() {
    return this.i >= this.length;
  }
  // Look at upcoming token
  peek() {
    if (this.EOF()) {
      return null;
    }
    return this.tokens[this.i];
  }
  consume() {
    const result = this.peek();
    this.i += 1;
    return result;
  }
  // Return next token if it matches the pattern
  probe(pattern) {
    const token = this.peek();
    if (!token) {
      return null;
    }
    const record = token;
    const match = Object.keys(pattern).every(key => {
      return key in token && pattern[key] === record[key];
    });
    return match ? token : null;
  }
  // Return and consume next token if it matches the pattern
  match(pattern) {
    return this.probe(pattern) ? this.consume() : null;
  }
  parseAttribute() {
    const token = this.match({
      type: "identifier"
    });
    if (token && token.type === "identifier") {
      return {
        type: "attribute",
        name: token.name
      };
    }
    const quoted = this.match({
      type: "quoted",
      quote: "single"
    });
    if (quoted && quoted.type === "quoted") {
      return {
        type: "attribute",
        name: quoted.value || ""
      };
    }
    return null;
  }
  parseAlias() {
    if (this.match({
      type: "keyword",
      symbol: "@"
    }) || this.match({
      type: "keyword",
      symbol: "$"
    })) {
      return {
        type: "alias",
        target: "self"
      };
    }
    return null;
  }
  parseNumber() {
    const token = this.match({
      type: "number"
    });
    if (token && token.type === "number") {
      return {
        type: "number",
        value: token.value
      };
    }
    return null;
  }
  parseNumberValue() {
    const expr = this.parseNumber();
    if (expr) {
      return expr.value;
    }
    return null;
  }
  parseSliceSelector() {
    const start = this.i;
    const rangeStart = this.parseNumberValue();
    const colon1 = this.match({
      type: "operator",
      symbol: ":"
    });
    if (!colon1) {
      if (rangeStart === null) {
        this.i = start;
        return null;
      }
      return {
        type: "index",
        value: rangeStart
      };
    }
    const result = {
      type: "range",
      start: rangeStart,
      end: this.parseNumberValue()
    };
    const colon2 = this.match({
      type: "operator",
      symbol: ":"
    });
    if (colon2) {
      result.step = this.parseNumberValue();
    }
    if (result.start === null && result.end === null) {
      this.i = start;
      return null;
    }
    return result;
  }
  parseValueReference() {
    return this.parseAttribute() || this.parseSliceSelector();
  }
  parseLiteralValue() {
    const literalString = this.match({
      type: "quoted",
      quote: "double"
    });
    if (literalString && literalString.type === "quoted") {
      return {
        type: "string",
        value: literalString.value || ""
      };
    }
    const literalBoolean = this.match({
      type: "boolean"
    });
    if (literalBoolean && literalBoolean.type === "boolean") {
      return {
        type: "boolean",
        value: literalBoolean.symbol === "true"
      };
    }
    return this.parseNumber();
  }
  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
  // on lhs.
  parseFilterExpression() {
    const start = this.i;
    const expr = this.parseAttribute() || this.parseAlias();
    if (!expr) {
      return null;
    }
    if (this.match({
      type: "operator",
      symbol: "?"
    })) {
      return {
        type: "constraint",
        operator: "?",
        lhs: expr
      };
    }
    const binOp = this.match({
      type: "comparator"
    });
    if (!binOp || binOp.type !== "comparator") {
      this.i = start;
      return null;
    }
    const lhs = expr;
    const rhs = this.parseLiteralValue();
    if (!rhs) {
      throw new Error("Operator ".concat(binOp.symbol, " needs a literal value at the right hand side"));
    }
    return {
      type: "constraint",
      operator: binOp.symbol,
      lhs,
      rhs
    };
  }
  parseExpression() {
    return this.parseFilterExpression() || this.parseValueReference();
  }
  parseUnion() {
    if (!this.match({
      type: "paren",
      symbol: "["
    })) {
      return null;
    }
    const terms = [];
    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
    while (expr) {
      terms.push(expr);
      if (this.match({
        type: "paren",
        symbol: "]"
      })) {
        break;
      }
      if (!this.match({
        type: "operator",
        symbol: ","
      })) {
        throw new Error("Expected ]");
      }
      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
      if (!expr) {
        throw new Error("Expected expression following ','");
      }
    }
    return {
      type: "union",
      nodes: terms
    };
  }
  parseRecursive() {
    if (!this.match({
      type: "operator",
      symbol: ".."
    })) {
      return null;
    }
    const subpath = this.parsePath();
    if (!subpath) {
      throw new Error("Expected path following '..' operator");
    }
    return {
      type: "recursive",
      term: subpath
    };
  }
  parsePath() {
    const nodes = [];
    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
    if (!expr) {
      return null;
    }
    nodes.push(expr);
    while (!this.EOF()) {
      if (this.match({
        type: "operator",
        symbol: "."
      })) {
        const attr = this.parseAttribute();
        if (!attr) {
          throw new Error("Expected attribute name following '.");
        }
        nodes.push(attr);
        continue;
      } else if (this.probe({
        type: "paren",
        symbol: "["
      })) {
        const union = this.parseUnion();
        if (!union) {
          throw new Error("Expected union following '['");
        }
        nodes.push(union);
      } else {
        const recursive = this.parseRecursive();
        if (recursive) {
          nodes.push(recursive);
        }
        break;
      }
    }
    if (nodes.length === 1) {
      return nodes[0];
    }
    return {
      type: "path",
      nodes
    };
  }
}
function parseJsonPath(path) {
  const parsed = new Parser(path).parse();
  if (!parsed) {
    throw new Error('Failed to parse JSON path "'.concat(path, '"'));
  }
  return parsed;
}
function toPath(expr) {
  return toPathInner(expr, false);
}
function toPathInner(expr, inUnion) {
  switch (expr.type) {
    case "attribute":
      return expr.name;
    case "alias":
      return expr.target === "self" ? "@" : "$";
    case "number":
      return "".concat(expr.value);
    case "range":
      {
        const result = [];
        if (!inUnion) {
          result.push("[");
        }
        if (expr.start) {
          result.push("".concat(expr.start));
        }
        result.push(":");
        if (expr.end) {
          result.push("".concat(expr.end));
        }
        if (expr.step) {
          result.push(":".concat(expr.step));
        }
        if (!inUnion) {
          result.push("]");
        }
        return result.join("");
      }
    case "index":
      if (inUnion) {
        return "".concat(expr.value);
      }
      return "[".concat(expr.value, "]");
    case "constraint":
      {
        const rhs = expr.rhs ? " ".concat(toPathInner(expr.rhs, false)) : "";
        const inner = "".concat(toPathInner(expr.lhs, false), " ").concat(expr.operator).concat(rhs);
        if (inUnion) {
          return inner;
        }
        return "[".concat(inner, "]");
      }
    case "string":
      return JSON.stringify(expr.value);
    case "path":
      {
        const result = [];
        const nodes = expr.nodes.slice();
        while (nodes.length > 0) {
          const node = nodes.shift();
          if (node) {
            result.push(toPath(node));
          }
          const upcoming = nodes[0];
          if (upcoming && toPathInner(upcoming, false)[0] !== "[") {
            result.push(".");
          }
        }
        return result.join("");
      }
    case "union":
      return "[".concat(expr.nodes.map(e => toPathInner(e, true)).join(","), "]");
    default:
      throw new Error("Unknown node type ".concat(expr.type));
    case "recursive":
      return "..".concat(toPathInner(expr.term, false));
  }
}
class Expression {
  constructor(expr) {
    if (!expr) {
      throw new Error("Attempted to create Expression from null-value");
    }
    if ("expr" in expr) {
      this.expr = expr.expr;
    } else {
      this.expr = expr;
    }
    if (!("type" in this.expr)) {
      throw new Error("Attempt to create Expression for expression with no type");
    }
  }
  isPath() {
    return this.expr.type === "path";
  }
  isUnion() {
    return this.expr.type === "union";
  }
  isCollection() {
    return this.isPath() || this.isUnion();
  }
  isConstraint() {
    return this.expr.type === "constraint";
  }
  isRecursive() {
    return this.expr.type === "recursive";
  }
  isExistenceConstraint() {
    return this.expr.type === "constraint" && this.expr.operator === "?";
  }
  isIndex() {
    return this.expr.type === "index";
  }
  isRange() {
    return this.expr.type === "range";
  }
  expandRange(probe) {
    const probeLength = () => {
      if (!probe) {
        throw new Error("expandRange() required a probe that was not passed");
      }
      return probe.length();
    };
    let start = "start" in this.expr ? this.expr.start || 0 : 0;
    start = interpretNegativeIndex(start, probe);
    let end = "end" in this.expr ? this.expr.end || probeLength() : probeLength();
    end = interpretNegativeIndex(end, probe);
    const step = "step" in this.expr ? this.expr.step || 1 : 1;
    return {
      start,
      end,
      step
    };
  }
  isAttributeReference() {
    return this.expr.type === "attribute";
  }
  // Is a range or index -> something referencing indexes
  isIndexReference() {
    return this.isIndex() || this.isRange();
  }
  name() {
    return "name" in this.expr ? this.expr.name : "";
  }
  isSelfReference() {
    return this.expr.type === "alias" && this.expr.target === "self";
  }
  constraintTargetIsSelf() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "alias" && this.expr.lhs.target === "self";
  }
  constraintTargetIsAttribute() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "attribute";
  }
  testConstraint(probe) {
    const expr = this.expr;
    if (expr.type === "constraint" && expr.lhs.type === "alias" && expr.lhs.target === "self") {
      if (probe.containerType() !== "primitive") {
        return false;
      }
      if (expr.type === "constraint" && expr.operator === "?") {
        return true;
      }
      const lhs2 = probe.get();
      const rhs2 = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
      return testBinaryOperator(lhs2, expr.operator, rhs2);
    }
    if (expr.type !== "constraint") {
      return false;
    }
    const lhs = expr.lhs;
    if (!lhs) {
      throw new Error("No LHS of expression");
    }
    if (lhs.type !== "attribute") {
      throw new Error("Constraint target ".concat(lhs.type, " not supported"));
    }
    if (probe.containerType() !== "object") {
      return false;
    }
    const lhsValue = probe.getAttribute(lhs.name);
    if (lhsValue === void 0 || lhsValue === null || lhsValue.containerType() !== "primitive") {
      return false;
    }
    if (this.isExistenceConstraint()) {
      return true;
    }
    const rhs = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
    return testBinaryOperator(lhsValue.get(), expr.operator, rhs);
  }
  pathNodes() {
    return this.expr.type === "path" ? this.expr.nodes : [this.expr];
  }
  prepend(node) {
    if (!node) {
      return this;
    }
    return new Expression({
      type: "path",
      nodes: node.pathNodes().concat(this.pathNodes())
    });
  }
  concat(other) {
    return other ? other.prepend(this) : this;
  }
  descend() {
    return descend$1(this.expr).map(headTail => {
      const [head, tail] = headTail;
      return {
        head: head ? new Expression(head) : null,
        tail: tail ? new Expression(tail) : null
      };
    });
  }
  unwrapRecursive() {
    if (this.expr.type !== "recursive") {
      throw new Error("Attempt to unwrap recursive on type ".concat(this.expr.type));
    }
    return new Expression(this.expr.term);
  }
  toIndicies(probe) {
    if (this.expr.type !== "index" && this.expr.type !== "range") {
      throw new Error("Node cannot be converted to indexes");
    }
    if (this.expr.type === "index") {
      return [interpretNegativeIndex(this.expr.value, probe)];
    }
    const result = [];
    const range = this.expandRange(probe);
    let {
      start,
      end
    } = range;
    if (range.step < 0) {
      [start, end] = [end, start];
    }
    for (let i = start; i < end; i++) {
      result.push(i);
    }
    return result;
  }
  toFieldReferences() {
    if (this.isIndexReference()) {
      return this.toIndicies();
    }
    if (this.expr.type === "attribute") {
      return [this.expr.name];
    }
    throw new Error("Can't convert ".concat(this.expr.type, " to field references"));
  }
  toString() {
    return toPath(this.expr);
  }
  static fromPath(path) {
    const parsed = parseJsonPath(path);
    if (!parsed) {
      throw new Error('Failed to parse path "'.concat(path, '"'));
    }
    return new Expression(parsed);
  }
  static attributeReference(name) {
    return new Expression({
      type: "attribute",
      name
    });
  }
  static indexReference(i) {
    return new Expression({
      type: "index",
      value: i
    });
  }
}
function testBinaryOperator(lhsValue, operator, rhsValue) {
  switch (operator) {
    case ">":
      return lhsValue > rhsValue;
    case ">=":
      return lhsValue >= rhsValue;
    case "<":
      return lhsValue < rhsValue;
    case "<=":
      return lhsValue <= rhsValue;
    case "==":
      return lhsValue === rhsValue;
    case "!=":
      return lhsValue !== rhsValue;
    default:
      throw new Error("Unsupported binary operator ".concat(operator));
  }
}
function interpretNegativeIndex(index, probe) {
  if (index >= 0) {
    return index;
  }
  if (!probe) {
    throw new Error("interpretNegativeIndex() must have a probe when < 0");
  }
  return index + probe.length();
}
class Descender {
  constructor(head, tail) {
    this.head = head;
    this.tail = tail;
  }
  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head
  iterate(probe) {
    let result = [this];
    if (this.head && this.head.isConstraint()) {
      let anyConstraints = true;
      while (anyConstraints) {
        result = flatten__default.default(result.map(descender => {
          return descender.iterateConstraints(probe);
        }));
        anyConstraints = result.some(descender => {
          return descender.head && descender.head.isConstraint();
        });
      }
    }
    return result;
  }
  isRecursive() {
    return Boolean(this.head && this.head.isRecursive());
  }
  hasArrived() {
    return this.head === null && this.tail === null;
  }
  extractRecursives() {
    if (this.head && this.head.isRecursive()) {
      const term = this.head.unwrapRecursive();
      return new Descender(null, term.concat(this.tail)).descend();
    }
    return [];
  }
  iterateConstraints(probe) {
    const head = this.head;
    if (head === null || !head.isConstraint()) {
      return [this];
    }
    const result = [];
    if (probe.containerType() === "primitive" && head.constraintTargetIsSelf()) {
      if (head.testConstraint(probe)) {
        result.push(...this.descend());
      }
      return result;
    }
    if (probe.containerType() === "array") {
      const length = probe.length();
      for (let i = 0; i < length; i++) {
        const constraint = probe.getIndex(i);
        if (constraint && head.testConstraint(constraint)) {
          result.push(new Descender(new Expression({
            type: "index",
            value: i
          }), this.tail));
        }
      }
      return result;
    }
    if (probe.containerType() === "object") {
      if (head.constraintTargetIsSelf()) {
        return [];
      }
      if (head.testConstraint(probe)) {
        return this.descend();
      }
      return result;
    }
    return result;
  }
  descend() {
    if (!this.tail) {
      return [new Descender(null, null)];
    }
    return this.tail.descend().map(ht => {
      return new Descender(ht.head, ht.tail);
    });
  }
  toString() {
    const result = ["<"];
    if (this.head) {
      result.push(this.head.toString());
    }
    result.push("|");
    if (this.tail) {
      result.push(this.tail.toString());
    }
    result.push(">");
    return result.join("");
  }
}
class Matcher {
  constructor(active, parent) {
    this.active = active || [];
    if (parent) {
      this.recursives = parent.recursives;
      this.payload = parent.payload;
    } else {
      this.recursives = [];
    }
    this.extractRecursives();
  }
  setPayload(payload) {
    this.payload = payload;
    return this;
  }
  // Moves any recursive descenders onto the recursive track, removing them from
  // the active set
  extractRecursives() {
    this.active = this.active.filter(descender => {
      if (descender.isRecursive()) {
        this.recursives.push(...descender.extractRecursives());
        return false;
      }
      return true;
    });
  }
  // Find recursives that are relevant now and should be considered part of the active set
  activeRecursives(probe) {
    return this.recursives.filter(descender => {
      const head = descender.head;
      if (!head) {
        return false;
      }
      if (head.isConstraint()) {
        return true;
      }
      if (probe.containerType() === "array" && head.isIndexReference()) {
        return true;
      }
      if (probe.containerType() === "object") {
        return head.isAttributeReference() && probe.hasAttribute(head.name());
      }
      return false;
    });
  }
  match(probe) {
    return this.iterate(probe).extractMatches(probe);
  }
  iterate(probe) {
    const newActiveSet = [];
    this.active.concat(this.activeRecursives(probe)).forEach(descender => {
      newActiveSet.push(...descender.iterate(probe));
    });
    return new Matcher(newActiveSet, this);
  }
  // Returns true if any of the descenders in the active or recursive set
  // consider the current state a final destination
  isDestination() {
    return this.active.some(descender => descender.hasArrived());
  }
  hasRecursives() {
    return this.recursives.length > 0;
  }
  // Returns any payload delivieries and leads that needs to be followed to complete
  // the process.
  extractMatches(probe) {
    const leads = [];
    const targets = [];
    this.active.forEach(descender => {
      if (descender.hasArrived()) {
        targets.push(new Expression({
          type: "alias",
          target: "self"
        }));
        return;
      }
      const descenderHead = descender.head;
      if (!descenderHead) {
        return;
      }
      if (probe.containerType() === "array" && !descenderHead.isIndexReference()) {
        return;
      }
      if (probe.containerType() === "object" && !descenderHead.isAttributeReference()) {
        return;
      }
      if (descender.tail) {
        const matcher = new Matcher(descender.descend(), this);
        descenderHead.toFieldReferences().forEach(() => {
          leads.push({
            target: descenderHead,
            matcher
          });
        });
      } else {
        targets.push(descenderHead);
      }
    });
    if (this.hasRecursives()) {
      const recursivesMatcher = new Matcher([], this);
      if (probe.containerType() === "array") {
        const length = probe.length();
        for (let i = 0; i < length; i++) {
          leads.push({
            target: Expression.indexReference(i),
            matcher: recursivesMatcher
          });
        }
      } else if (probe.containerType() === "object") {
        probe.attributeKeys().forEach(name => {
          leads.push({
            target: Expression.attributeReference(name),
            matcher: recursivesMatcher
          });
        });
      }
    }
    return targets.length > 0 ? {
      leads,
      delivery: {
        targets,
        payload: this.payload
      }
    } : {
      leads
    };
  }
  static fromPath(jsonpath) {
    const path = parseJsonPath(jsonpath);
    if (!path) {
      throw new Error('Failed to parse path from "'.concat(jsonpath, '"'));
    }
    const descender = new Descender(null, new Expression(path));
    return new Matcher(descender.descend());
  }
}
class PlainProbe {
  constructor(value, path) {
    this._value = value;
    this.path = path || [];
  }
  containerType() {
    if (Array.isArray(this._value)) {
      return "array";
    } else if (this._value !== null && typeof this._value === "object") {
      return "object";
    }
    return "primitive";
  }
  length() {
    if (!Array.isArray(this._value)) {
      throw new Error("Won't return length of non-indexable _value");
    }
    return this._value.length;
  }
  getIndex(i) {
    if (!Array.isArray(this._value)) {
      return false;
    }
    if (i >= this.length()) {
      return null;
    }
    return new PlainProbe(this._value[i], this.path.concat(i));
  }
  hasAttribute(key) {
    if (!isRecord(this._value)) {
      return false;
    }
    return this._value.hasOwnProperty(key);
  }
  attributeKeys() {
    return isRecord(this._value) ? Object.keys(this._value) : [];
  }
  getAttribute(key) {
    if (!isRecord(this._value)) {
      throw new Error("getAttribute only applies to plain objects");
    }
    if (!this.hasAttribute(key)) {
      return null;
    }
    return new PlainProbe(this._value[key], this.path.concat(key));
  }
  get() {
    return this._value;
  }
}
function extractAccessors(path, value) {
  const result = [];
  const matcher = Matcher.fromPath(path).setPayload(function appendResult(values) {
    result.push(...values);
  });
  const accessor = new PlainProbe(value);
  descend(matcher, accessor);
  return result;
}
function descend(matcher, accessor) {
  const {
    leads,
    delivery
  } = matcher.match(accessor);
  leads.forEach(lead => {
    accessorsFromTarget(lead.target, accessor).forEach(childAccessor => {
      descend(lead.matcher, childAccessor);
    });
  });
  if (delivery) {
    delivery.targets.forEach(target => {
      if (typeof delivery.payload === "function") {
        delivery.payload(accessorsFromTarget(target, accessor));
      }
    });
  }
}
function accessorsFromTarget(target, accessor) {
  const result = [];
  if (target.isIndexReference()) {
    target.toIndicies(accessor).forEach(i => {
      result.push(accessor.getIndex(i));
    });
  } else if (target.isAttributeReference()) {
    result.push(accessor.getAttribute(target.name()));
  } else if (target.isSelfReference()) {
    result.push(accessor);
  } else {
    throw new Error("Unable to derive accessor for target ".concat(target.toString()));
  }
  return compact__default.default(result);
}
function extract(path, value) {
  const accessors = extractAccessors(path, value);
  return accessors.map(acc => acc.get());
}
function extractWithPath(path, value) {
  const accessors = extractAccessors(path, value);
  return accessors.map(acc => ({
    path: acc.path,
    value: acc.get()
  }));
}
function applyPatch(patch, oldValue) {
  if (typeof oldValue !== "string") return oldValue;
  const [result] = diffMatchPatch.applyPatches(patch, oldValue, {
    allowExceedingIndices: true
  });
  return result;
}
class DiffMatchPatch {
  constructor(id, path, dmpPatchSrc) {
    this.id = id;
    this.path = path;
    this.dmpPatch = diffMatchPatch.parsePatch(dmpPatchSrc);
  }
  apply(targets, accessor) {
    let result = accessor;
    if (result.containerType() === "primitive") {
      return result;
    }
    for (const target of targets) {
      if (target.isIndexReference()) {
        for (const index of target.toIndicies(accessor)) {
          const item = result.getIndex(index);
          if (!item) {
            continue;
          }
          const oldValue = item.get();
          const nextValue = applyPatch(this.dmpPatch, oldValue);
          result = result.setIndex(index, nextValue);
        }
        continue;
      }
      if (target.isAttributeReference() && result.hasAttribute(target.name())) {
        const attribute = result.getAttribute(target.name());
        if (!attribute) {
          continue;
        }
        const oldValue = attribute.get();
        const nextValue = applyPatch(this.dmpPatch, oldValue);
        result = result.setAttribute(target.name(), nextValue);
        continue;
      }
      throw new Error("Unable to apply diffMatchPatch to target ".concat(target.toString()));
    }
    return result;
  }
}
function performIncrement(previousValue, delta) {
  if (typeof previousValue !== "number" || !Number.isFinite(previousValue)) {
    return previousValue;
  }
  return previousValue + delta;
}
class IncPatch {
  constructor(id, path, value) {
    this.path = path;
    this.value = value;
    this.id = id;
  }
  apply(targets, accessor) {
    let result = accessor;
    if (result.containerType() === "primitive") {
      return result;
    }
    for (const target of targets) {
      if (target.isIndexReference()) {
        for (const index of target.toIndicies(accessor)) {
          const item = result.getIndex(index);
          if (!item) {
            continue;
          }
          const previousValue = item.get();
          result = result.setIndex(index, performIncrement(previousValue, this.value));
        }
        continue;
      }
      if (target.isAttributeReference()) {
        const attribute = result.getAttribute(target.name());
        if (!attribute) {
          continue;
        }
        const previousValue = attribute.get();
        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value));
        continue;
      }
      throw new Error("Unable to apply to target ".concat(target.toString()));
    }
    return result;
  }
}
function targetsToIndicies(targets, accessor) {
  const result = [];
  targets.forEach(target => {
    if (target.isIndexReference()) {
      result.push(...target.toIndicies(accessor));
    }
  });
  return result.sort();
}
class InsertPatch {
  constructor(id, location, path, items) {
    this.id = id;
    this.location = location;
    this.path = path;
    this.items = items;
  }
  apply(targets, accessor) {
    let result = accessor;
    if (accessor.containerType() !== "array") {
      throw new Error("Attempt to apply insert patch to non-array value");
    }
    switch (this.location) {
      case "before":
        {
          const pos = minIndex(targets, accessor);
          result = result.insertItemsAt(pos, this.items);
          break;
        }
      case "after":
        {
          const pos = maxIndex(targets, accessor);
          result = result.insertItemsAt(pos + 1, this.items);
          break;
        }
      case "replace":
        {
          const indicies = targetsToIndicies(targets, accessor);
          result = result.unsetIndices(indicies);
          result = result.insertItemsAt(indicies[0], this.items);
          break;
        }
      default:
        {
          throw new Error("Unsupported location atm: ".concat(this.location));
        }
    }
    return result;
  }
}
function minIndex(targets, accessor) {
  let result = min__default.default(targetsToIndicies(targets, accessor)) || 0;
  targets.forEach(target => {
    if (target.isRange()) {
      const {
        start
      } = target.expandRange();
      if (start < result) {
        result = start;
      }
    }
  });
  return result;
}
function maxIndex(targets, accessor) {
  let result = max__default.default(targetsToIndicies(targets, accessor)) || 0;
  targets.forEach(target => {
    if (target.isRange()) {
      const {
        end
      } = target.expandRange();
      if (end > result) {
        result = end;
      }
    }
  });
  return result;
}
class SetIfMissingPatch {
  constructor(id, path, value) {
    this.id = id;
    this.path = path;
    this.value = value;
  }
  apply(targets, accessor) {
    let result = accessor;
    targets.forEach(target => {
      if (target.isIndexReference()) ;else if (target.isAttributeReference()) {
        if (result.containerType() === "primitive") {
          result = result.set({
            [target.name()]: this.value
          });
        } else if (!result.hasAttribute(target.name())) {
          result = accessor.setAttribute(target.name(), this.value);
        }
      } else {
        throw new Error("Unable to apply to target ".concat(target.toString()));
      }
    });
    return result;
  }
}
class SetPatch {
  constructor(id, path, value) {
    this.id = id;
    this.path = path;
    this.value = value;
  }
  apply(targets, accessor) {
    let result = accessor;
    targets.forEach(target => {
      if (target.isSelfReference()) {
        result = result.set(this.value);
      } else if (target.isIndexReference()) {
        target.toIndicies(accessor).forEach(i => {
          result = result.setIndex(i, this.value);
        });
      } else if (target.isAttributeReference()) {
        if (result.containerType() === "primitive") {
          result = result.set({
            [target.name()]: this.value
          });
        } else {
          result = result.setAttribute(target.name(), this.value);
        }
      } else {
        throw new Error("Unable to apply to target ".concat(target.toString()));
      }
    });
    return result;
  }
}
class UnsetPatch {
  constructor(id, path) {
    this.id = id;
    this.path = path;
  }
  // eslint-disable-next-line class-methods-use-this
  apply(targets, accessor) {
    let result = accessor;
    switch (accessor.containerType()) {
      case "array":
        result = result.unsetIndices(targetsToIndicies(targets, accessor));
        break;
      case "object":
        targets.forEach(target => {
          result = result.unsetAttribute(target.name());
        });
        break;
      default:
        throw new Error("Target value is neither indexable or an object. This error should potentially just be silently ignored?");
    }
    return result;
  }
}
function parsePatch(patch) {
  const result = [];
  if (Array.isArray(patch)) {
    return patch.reduce((r, p) => r.concat(parsePatch(p)), result);
  }
  const {
    set,
    setIfMissing,
    unset,
    diffMatchPatch,
    inc,
    dec,
    insert
  } = patch;
  if (setIfMissing) {
    Object.keys(setIfMissing).forEach(path => {
      result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]));
    });
  }
  if (set) {
    Object.keys(set).forEach(path => {
      result.push(new SetPatch(patch.id, path, set[path]));
    });
  }
  if (unset) {
    unset.forEach(path => {
      result.push(new UnsetPatch(patch.id, path));
    });
  }
  if (diffMatchPatch) {
    Object.keys(diffMatchPatch).forEach(path => {
      result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]));
    });
  }
  if (inc) {
    Object.keys(inc).forEach(path => {
      result.push(new IncPatch(patch.id, path, inc[path]));
    });
  }
  if (dec) {
    Object.keys(dec).forEach(path => {
      result.push(new IncPatch(patch.id, path, -dec[path]));
    });
  }
  if (insert) {
    let location;
    let path;
    const spec = insert;
    if ("before" in spec) {
      location = "before";
      path = spec.before;
    } else if ("after" in spec) {
      location = "after";
      path = spec.after;
    } else if ("replace" in spec) {
      location = "replace";
      path = spec.replace;
    } else {
      throw new Error("Invalid insert patch");
    }
    result.push(new InsertPatch(patch.id, location, path, spec.items));
  }
  return result;
}
class Patcher {
  constructor(patch) {
    this.patches = parsePatch(patch);
  }
  apply(value) {
    const accessor = new ImmutableAccessor(value);
    return this.applyViaAccessor(accessor).get();
  }
  // If you want to use your own accessor implementation, you can use this method
  // to invoke the patcher. Since all subsequent accessors for children of this accessor
  // are obtained through the methods in the accessors, you retain full control of the
  // implementation throguhgout the application. Have a look in ImmutableAccessor
  // to see an example of how accessors are implemented.
  applyViaAccessor(accessor) {
    let result = accessor;
    const idAccessor = accessor.getAttribute("_id");
    if (!idAccessor) {
      throw new Error("Cannot apply patch to document with no _id");
    }
    const id = idAccessor.get();
    for (const patch of this.patches) {
      if (patch.id !== id) {
        continue;
      }
      const matcher = Matcher.fromPath(patch.path).setPayload(patch);
      result = process(matcher, result);
    }
    return result;
  }
}
function process(matcher, accessor) {
  const isSetPatch = matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch;
  let result = accessor;
  const {
    leads,
    delivery
  } = matcher.match(accessor);
  leads.forEach(lead => {
    if (lead.target.isIndexReference()) {
      lead.target.toIndicies().forEach(i => {
        const item = result.getIndex(i);
        if (!item) {
          throw new Error("Index out of bounds");
        }
        result = result.setIndexAccessor(i, process(lead.matcher, item));
      });
    } else if (lead.target.isAttributeReference()) {
      if (isSetPatch && result.containerType() === "primitive") {
        result = result.set({});
      }
      let oldValueAccessor = result.getAttribute(lead.target.name());
      if (!oldValueAccessor && isSetPatch) {
        result = result.setAttribute(lead.target.name(), {});
        oldValueAccessor = result.getAttribute(lead.target.name());
      }
      if (!oldValueAccessor) {
        return;
      }
      const newValueAccessor = process(lead.matcher, oldValueAccessor);
      if (oldValueAccessor !== newValueAccessor) {
        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor);
      }
    } else {
      throw new Error("Unable to handle target ".concat(lead.target.toString()));
    }
  });
  if (delivery && isPatcher(delivery.payload)) {
    const patch = delivery.payload;
    result = patch.apply(delivery.targets, result);
  }
  return result;
}
function isPatcher(payload) {
  return Boolean(payload && typeof payload === "object" && payload !== null && "apply" in payload && typeof payload.apply === "function");
}
const luid = uuid.uuid;
class Mutation {
  constructor(options) {
    this.params = options;
  }
  get transactionId() {
    return this.params.transactionId;
  }
  get transition() {
    return this.params.transition;
  }
  get identity() {
    return this.params.identity;
  }
  get previousRev() {
    return this.params.previousRev;
  }
  get resultRev() {
    return this.params.resultRev;
  }
  get mutations() {
    return this.params.mutations;
  }
  get timestamp() {
    if (typeof this.params.timestamp === "string") {
      return new Date(this.params.timestamp);
    }
    return void 0;
  }
  get effects() {
    return this.params.effects;
  }
  assignRandomTransactionId() {
    this.params.transactionId = luid();
    this.params.resultRev = this.params.transactionId;
  }
  appliesToMissingDocument() {
    if (typeof this._appliesToMissingDocument !== "undefined") {
      return this._appliesToMissingDocument;
    }
    const firstMut = this.mutations[0];
    if (firstMut) {
      this._appliesToMissingDocument = Boolean(firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace);
    } else {
      this._appliesToMissingDocument = true;
    }
    return this._appliesToMissingDocument;
  }
  // Compiles all mutations into a handy function
  compile() {
    const operations = [];
    this.mutations.forEach(mutation => {
      if (mutation.create) {
        const create = mutation.create || {};
        operations.push(doc => {
          if (doc) {
            return doc;
          }
          return Object.assign(create, {
            _createdAt: create._createdAt || this.params.timestamp
          });
        });
        return;
      }
      if (mutation.createIfNotExists) {
        const createIfNotExists = mutation.createIfNotExists || {};
        operations.push(doc => doc === null ? Object.assign(createIfNotExists, {
          _createdAt: createIfNotExists._createdAt || this.params.timestamp
        }) : doc);
        return;
      }
      if (mutation.createOrReplace) {
        const createOrReplace = mutation.createOrReplace || {};
        operations.push(() => Object.assign(createOrReplace, {
          _createdAt: createOrReplace._createdAt || this.params.timestamp
        }));
        return;
      }
      if (mutation.delete) {
        operations.push(() => null);
        return;
      }
      if (mutation.patch) {
        if ("query" in mutation.patch) {
          return;
        }
        const patch = new Patcher(mutation.patch);
        operations.push(doc => patch.apply(doc));
        return;
      }
      throw new Error("Unsupported mutation ".concat(JSON.stringify(mutation, null, 2)));
    });
    if (typeof this.params.timestamp === "string") {
      operations.push(doc => {
        return doc ? Object.assign(doc, {
          _updatedAt: this.params.timestamp
        }) : null;
      });
    }
    const prevRev = this.previousRev;
    const rev = this.resultRev || this.transactionId;
    this.compiled = doc => {
      if (prevRev && doc && prevRev !== doc._rev) {
        throw new Error("Previous revision for this mutation was ".concat(prevRev, ", but the document revision is ").concat(doc._rev));
      }
      let result = doc;
      for (const operation of operations) {
        result = operation(result);
      }
      if (result && rev) {
        if (result === doc) {
          result = Object.assign({}, doc);
        }
        result._rev = rev;
      }
      return result;
    };
  }
  apply(document) {
    debug("Applying mutation %O to document %O", this.mutations, document);
    if (!this.compiled) {
      this.compile();
    }
    const result = this.compiled(document);
    debug("  => %O", result);
    return result;
  }
  static applyAll(document, mutations) {
    return mutations.reduce((doc, mutation) => mutation.apply(doc), document);
  }
  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
  // that all mutations are on the same document.
  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!
  static squash(document, mutations) {
    const squashed = mutations.reduce((result, mutation) => result.concat(...mutation.mutations), []);
    return new Mutation({
      mutations: squashed
    });
  }
}
class Document {
  constructor(doc) {
    /**
     * Incoming patches from the server waiting to be applied to HEAD
     */
    this.incoming = [];
    /**
     * Patches we know has been subitted to the server, but has not been seen yet in the return channel
     * so we can't be sure about the ordering yet (someone else might have slipped something between them)
     */
    this.submitted = [];
    /**
     * Pending mutations
     */
    this.pending = [];
    /**
     * We are consistent when there are no unresolved mutations of our own, and no un-applicable
     * incoming mutations. When this has been going on for too long, and there has been a while
     * since we staged a new mutation, it is time to reset your state.
     */
    this.inconsistentAt = null;
    /**
     * The last time we staged a patch of our own. If we have been inconsistent for a while, but it
     * hasn't been long since we staged a new mutation, the reason is probably just because the user
     * is typing or something.
     *
     * Should be used as a guard against resetting state for inconsistency reasons.
     */
    this.lastStagedAt = null;
    this.reset(doc);
    this.HEAD = doc;
    this.EDGE = doc;
  }
  // Reset the state of the Document, used to recover from unsavory states by reloading the document
  reset(doc) {
    this.incoming = [];
    this.submitted = [];
    this.pending = [];
    this.inconsistentAt = null;
    this.HEAD = doc;
    this.EDGE = doc;
    this.considerIncoming();
    this.updateConsistencyFlag();
  }
  // Call when a mutation arrives from Sanity
  arrive(mutation) {
    this.incoming.push(mutation);
    this.considerIncoming();
    this.updateConsistencyFlag();
  }
  // Call to signal that we are submitting a mutation. Returns a callback object with a
  // success and failure handler that must be called according to the outcome of our
  // submission.
  stage(mutation, silent) {
    if (!mutation.transactionId) {
      throw new Error("Mutations _must_ have transactionId when submitted");
    }
    this.lastStagedAt = /* @__PURE__ */new Date();
    debug("Staging mutation %s (pushed to pending)", mutation.transactionId);
    this.pending.push(mutation);
    this.EDGE = mutation.apply(this.EDGE);
    if (this.onMutation && !silent) {
      this.onMutation({
        mutation,
        document: this.EDGE,
        remote: false
      });
    }
    const txnId = mutation.transactionId;
    this.updateConsistencyFlag();
    return {
      success: () => {
        this.pendingSuccessfullySubmitted(txnId);
        this.updateConsistencyFlag();
      },
      failure: () => {
        this.pendingFailed(txnId);
        this.updateConsistencyFlag();
      }
    };
  }
  // Call to check if everything is nice and quiet and there are no unresolved mutations.
  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.
  isConsistent() {
    return !this.inconsistentAt;
  }
  // Private
  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there
  // are applicable patches to be applied
  considerIncoming() {
    let mustRebase = false;
    let nextMut;
    const rebaseMutations = [];
    if (this.HEAD && this.HEAD._updatedAt) {
      const updatedAt = new Date(this.HEAD._updatedAt);
      if (this.incoming.find(mut => mut.timestamp && mut.timestamp < updatedAt)) {
        this.incoming = this.incoming.filter(mut => mut.timestamp && mut.timestamp < updatedAt);
      }
    }
    let protect = 0;
    do {
      if (this.HEAD) {
        const HEAD = this.HEAD;
        nextMut = HEAD._rev ? this.incoming.find(mut => mut.previousRev === HEAD._rev) : void 0;
      } else {
        nextMut = this.incoming.find(mut => mut.appliesToMissingDocument());
      }
      if (nextMut) {
        const applied = this.applyIncoming(nextMut);
        mustRebase = mustRebase || applied;
        if (mustRebase) {
          rebaseMutations.push(nextMut);
        }
        if (protect++ > 10) {
          throw new Error("Mutator stuck flushing incoming mutations. Probably stuck here: ".concat(JSON.stringify(nextMut)));
        }
      }
    } while (nextMut);
    if (this.incoming.length > 0 && debug.enabled) {
      debug("Unable to apply mutations %s", this.incoming.map(mut => mut.transactionId).join(", "));
    }
    if (mustRebase) {
      this.rebase(rebaseMutations);
    }
  }
  // check current consistency state, update flag and invoke callback if needed
  updateConsistencyFlag() {
    const wasConsistent = this.isConsistent();
    const isConsistent = this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0;
    if (isConsistent) {
      this.inconsistentAt = null;
    } else if (!this.inconsistentAt) {
      this.inconsistentAt = /* @__PURE__ */new Date();
    }
    if (wasConsistent != isConsistent && this.onConsistencyChanged) {
      if (isConsistent) {
        debug("Buffered document is inconsistent");
      } else {
        debug("Buffered document is consistent");
      }
      this.onConsistencyChanged(isConsistent);
    }
  }
  // apply an incoming patch that has been prequalified as the next in line for this document
  applyIncoming(mut) {
    if (!mut) {
      return false;
    }
    if (!mut.transactionId) {
      throw new Error("Received incoming mutation without a transaction ID");
    }
    debug("Applying mutation %s -> %s to rev %s", mut.previousRev, mut.resultRev, this.HEAD && this.HEAD._rev);
    this.HEAD = mut.apply(this.HEAD);
    if (this.onRemoteMutation) {
      this.onRemoteMutation(mut);
    }
    this.incoming = this.incoming.filter(m => m.transactionId !== mut.transactionId);
    if (this.hasUnresolvedMutations()) {
      const needRebase = this.consumeUnresolved(mut.transactionId);
      if (debug.enabled) {
        debug("Incoming mutation ".concat(mut.transactionId, " appeared while there were pending or submitted local mutations"));
        debug("Submitted txnIds: ".concat(this.submitted.map(m => m.transactionId).join(", ")));
        debug("Pending txnIds: ".concat(this.pending.map(m => m.transactionId).join(", ")));
        debug("needRebase === %s", needRebase);
      }
      return needRebase;
    }
    debug("Remote mutation %s arrived w/o any pending or submitted local mutations", mut.transactionId);
    this.EDGE = this.HEAD;
    if (this.onMutation) {
      this.onMutation({
        mutation: mut,
        document: this.EDGE,
        remote: true
      });
    }
    return false;
  }
  /**
   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
   * mutations that are still waiting to be either submitted, or to be confirmed by the server.
   *
   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise
   */
  hasUnresolvedMutations() {
    return this.submitted.length > 0 || this.pending.length > 0;
  }
  /**
   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from
   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of
   * order in terms of our optimistic version, so a rebase is needed.
   *
   * @param txnId - Transaction ID of the remote mutation
   * @returns true if rebase is needed, false otherwise
   */
  consumeUnresolved(txnId) {
    if (this.submitted.length === 0 && this.pending.length === 0) {
      return false;
    }
    if (this.submitted.length !== 0) {
      if (this.submitted[0].transactionId === txnId) {
        debug("Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer", txnId);
        this.submitted.shift();
        return false;
      }
    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) {
      debug("Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer", txnId);
      this.pending.shift();
      return false;
    }
    debug("The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d", this.pending.length, this.submitted.length);
    this.submitted = this.submitted.filter(mut => mut.transactionId !== txnId);
    this.pending = this.pending.filter(mut => mut.transactionId !== txnId);
    debug("After scrubbing: Pending: %d, Submitted: %d", this.pending.length, this.submitted.length);
    return true;
  }
  pendingSuccessfullySubmitted(pendingTxnId) {
    if (this.pending.length === 0) {
      return;
    }
    const first = this.pending[0];
    if (first.transactionId === pendingTxnId) {
      this.pending.shift();
      this.submitted.push(first);
      return;
    }
    let justSubmitted;
    const stillPending = [];
    this.pending.forEach(mutation => {
      if (mutation.transactionId === pendingTxnId) {
        justSubmitted = mutation;
        return;
      }
      stillPending.push(mutation);
    });
    if (justSubmitted) {
      this.submitted.push(justSubmitted);
    }
    this.pending = stillPending;
    this.rebase([]);
  }
  pendingFailed(pendingTxnId) {
    this.pending = this.pending.filter(mutation => mutation.transactionId !== pendingTxnId);
    this.rebase([]);
  }
  rebase(incomingMutations) {
    const oldEdge = this.EDGE;
    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending));
    if (oldEdge !== null && this.EDGE !== null) {
      oldEdge._rev = this.EDGE._rev;
    }
    const changed = !isEqual__default.default(this.EDGE, oldEdge);
    if (changed && this.onRebase) {
      this.onRebase(this.EDGE, incomingMutations, this.pending);
    }
  }
}
class SquashingBuffer {
  constructor(doc) {
    /**
     * The operations in the out-Mutation are not able to be optimized any further
     */
    this.out = [];
    if (doc) {
      debug("Reset mutation buffer to rev %s", doc._rev);
    } else {
      debug("Reset mutation buffer state to document being deleted");
    }
    this.staged = [];
    this.setOperations = {};
    this.documentPresent = false;
    this.BASIS = doc;
    this.PRESTAGE = doc;
  }
  add(mut) {
    mut.mutations.forEach(op => this.addOperation(op));
  }
  hasChanges() {
    return this.out.length > 0 || Object.keys(this.setOperations).length > 0;
  }
  /**
   * Extracts the mutations in this buffer.
   * After this is done, the buffer lifecycle is over and the client should
   * create an new one with the new, updated BASIS.
   *
   * @param txnId - Transaction ID
   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise
   */
  purge(txnId) {
    this.stashStagedOperations();
    let result = null;
    if (this.out.length > 0) {
      debug("Purged mutation buffer");
      result = new Mutation({
        mutations: this.out,
        resultRev: txnId,
        transactionId: txnId
      });
    }
    this.out = [];
    this.documentPresent = false;
    return result;
  }
  addOperation(op) {
    var _a;
    if (op.patch && op.patch.set && "id" in op.patch && op.patch.id === ((_a = this.PRESTAGE) == null ? void 0 : _a._id) && Object.keys(op.patch).length === 2) {
      const setPatch = op.patch.set;
      const unoptimizable = {};
      for (const path of Object.keys(setPatch)) {
        if (setPatch.hasOwnProperty(path)) {
          if (!this.optimiseSetOperation(path, setPatch[path])) {
            unoptimizable[path] = setPatch[path];
          }
        }
      }
      if (Object.keys(unoptimizable).length > 0) {
        debug("Unoptimizable set-operation detected, purging optimization buffer");
        this.staged.push({
          patch: {
            id: this.PRESTAGE._id,
            set: unoptimizable
          }
        });
        this.stashStagedOperations();
      }
      return;
    }
    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {
      if (!this.documentPresent) {
        this.staged.push(op);
        this.documentPresent = true;
        this.stashStagedOperations();
      }
      return;
    }
    debug("Unoptimizable mutation detected, purging optimization buffer");
    this.staged.push(op);
    this.stashStagedOperations();
  }
  /**
     * Attempt to perform one single set operation in an optimised manner, return value
     * reflects whether or not the operation could be performed.
  
     * @param path - The JSONPath to the set operation in question
     * @param nextValue - The value to be set
     * @returns True of optimized, false otherwise
     */
  optimiseSetOperation(path, nextValue) {
    if (typeof nextValue === "object") {
      return false;
    }
    const matches = extractWithPath(path, this.PRESTAGE);
    if (matches.length !== 1) {
      return false;
    }
    const match = matches[0];
    if (typeof match.value === "object") {
      return false;
    }
    if (!this.PRESTAGE) {
      return false;
    }
    let op = null;
    if (match.value === nextValue) {
      op = null;
    } else if (typeof match.value === "string" && typeof nextValue === "string") {
      try {
        const patch = diffMatchPatch.stringifyPatches(diffMatchPatch.makePatches(match.value, nextValue));
        op = {
          patch: {
            id: this.PRESTAGE._id,
            diffMatchPatch: {
              [path]: patch
            }
          }
        };
      } catch {
        return false;
      }
    } else {
      op = {
        patch: {
          id: this.PRESTAGE._id,
          set: {
            [path]: nextValue
          }
        }
      };
    }
    const canonicalPath = arrayToJSONMatchPath(match.path);
    if (op) {
      this.setOperations[canonicalPath] = op;
    } else {
      delete this.setOperations[canonicalPath];
    }
    return true;
  }
  stashStagedOperations() {
    const nextOps = [];
    Object.keys(this.setOperations).forEach(key => {
      const op = this.setOperations[key];
      if (op) {
        nextOps.push(op);
      }
    });
    nextOps.push(...this.staged);
    if (nextOps.length > 0) {
      this.PRESTAGE = new Mutation({
        mutations: nextOps
      }).apply(this.PRESTAGE);
      this.staged = [];
      this.setOperations = {};
    }
    this.out.push(...nextOps);
  }
  /**
   * Rebases given the new base-document
   *
   * @param newBasis - New base document to rebase on
   * @returns New "edge" document with buffered changes integrated
   */
  rebase(newBasis) {
    this.stashStagedOperations();
    if (newBasis === null) {
      this.out = [];
      this.BASIS = newBasis;
      this.PRESTAGE = newBasis;
      this.documentPresent = false;
    } else {
      this.BASIS = newBasis;
      if (this.out) {
        this.PRESTAGE = new Mutation({
          mutations: this.out
        }).apply(this.BASIS);
      } else {
        this.PRESTAGE = this.BASIS;
      }
    }
    return this.PRESTAGE;
  }
}
const ONE_MINUTE = 1e3 * 60;
class Commit {
  constructor(mutations, _ref) {
    let {
      resolve,
      reject
    } = _ref;
    this.mutations = mutations;
    this.tries = 0;
    this.resolve = resolve;
    this.reject = reject;
  }
  apply(doc) {
    return Mutation.applyAll(doc, this.mutations);
  }
  squash(doc) {
    const result = Mutation.squash(doc, this.mutations);
    result.assignRandomTransactionId();
    return result;
  }
}
const mutReducerFn = (acc, mut) => acc.concat(mut.mutations);
class BufferedDocument {
  constructor(doc) {
    /**
     * Whether or not we are currently commiting
     */
    this.committerRunning = false;
    this.buffer = new SquashingBuffer(doc);
    this.document = new Document(doc);
    this.document.onMutation = msg => this.handleDocMutation(msg);
    this.document.onRemoteMutation = mut => this.onRemoteMutation && this.onRemoteMutation(mut);
    this.document.onRebase = (edge, remoteMutations, localMutations) => this.handleDocRebase(edge, remoteMutations, localMutations);
    this.document.onConsistencyChanged = msg => this.handleDocConsistencyChanged(msg);
    this.LOCAL = doc;
    this.mutations = [];
    this.commits = [];
  }
  // Used to reset the state of the local document model. If the model has been inconsistent
  // for too long, it has probably missed a notification, and should reload the document from the server
  reset(doc) {
    if (doc) {
      debug("Document state reset to revision %s", doc._rev);
    } else {
      debug("Document state reset to being deleted");
    }
    this.document.reset(doc);
    this.rebase([], []);
    this.handleDocConsistencyChanged(this.document.isConsistent());
  }
  // Add a change to the buffer
  add(mutation) {
    if (this.onConsistencyChanged) {
      this.onConsistencyChanged(false);
    }
    debug("Staged local mutation");
    this.buffer.add(mutation);
    const oldLocal = this.LOCAL;
    this.LOCAL = mutation.apply(this.LOCAL);
    if (this.onMutation && oldLocal !== this.LOCAL) {
      debug("onMutation fired");
      this.onMutation({
        mutation,
        document: this.LOCAL,
        remote: false
      });
      if (this.LOCAL === null && this.onDelete) {
        this.onDelete(this.LOCAL);
      }
    }
  }
  // Call when a mutation arrives from Sanity
  arrive(mutation) {
    debug("Remote mutation arrived %s -> %s", mutation.previousRev, mutation.resultRev);
    if (mutation.previousRev === mutation.resultRev) {
      throw new Error("Mutation ".concat(mutation.transactionId, " has previousRev === resultRev (").concat(mutation.previousRev, ")"));
    }
    return this.document.arrive(mutation);
  }
  // Submit all mutations in the buffer to be committed
  commit() {
    return new Promise((resolve, reject) => {
      if (!this.buffer.hasChanges()) {
        resolve();
        return;
      }
      debug("Committing local changes");
      const pendingMutations = this.buffer.purge();
      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], {
        resolve,
        reject
      }));
      this.buffer = new SquashingBuffer(this.LOCAL);
      this.performCommits();
    });
  }
  // Starts the committer that will try to committ all staged commits to the database
  // by calling the commitHandler. Will keep running until all commits are successfully
  // committed.
  performCommits() {
    if (!this.commitHandler) {
      throw new Error("No commitHandler configured for this BufferedDocument");
    }
    if (this.committerRunning) {
      return;
    }
    this._cycleCommitter();
  }
  // TODO: Error handling, right now retries after every error
  _cycleCommitter() {
    const commit = this.commits.shift();
    if (!commit) {
      this.committerRunning = false;
      return;
    }
    this.committerRunning = true;
    const squashed = commit.squash(this.LOCAL);
    const docResponder = this.document.stage(squashed, true);
    const responder = {
      success: () => {
        debug("Commit succeeded");
        docResponder.success();
        commit.resolve();
        this._cycleCommitter();
      },
      failure: () => {
        debug("Commit failed");
        commit.tries += 1;
        if (this.LOCAL !== null) {
          this.commits.unshift(commit);
        }
        docResponder.failure();
        if (commit.tries < 200) {
          setTimeout(() => this._cycleCommitter(), Math.min(commit.tries * 1e3, ONE_MINUTE));
        }
      },
      cancel: error => {
        this.commits.forEach(comm => comm.reject(error));
        this.commits = [];
        this.reset(this.document.HEAD);
        this.buffer = new SquashingBuffer(this.LOCAL);
        this.committerRunning = false;
      }
    };
    debug("Posting commit");
    if (this.commitHandler) {
      this.commitHandler({
        mutation: squashed,
        success: responder.success,
        failure: responder.failure,
        cancel: responder.cancel
      });
    }
  }
  handleDocRebase(edge, remoteMutations, localMutations) {
    this.rebase(remoteMutations, localMutations);
  }
  handleDocumentDeleted() {
    debug("Document deleted");
    if (this.LOCAL !== null && this.onDelete) {
      this.onDelete(this.LOCAL);
    }
    this.commits = [];
    this.mutations = [];
  }
  handleDocMutation(msg) {
    if (this.commits.length === 0 && !this.buffer.hasChanges()) {
      debug("Document mutated from remote with no local changes");
      this.LOCAL = this.document.EDGE;
      this.buffer = new SquashingBuffer(this.LOCAL);
      if (this.onMutation) {
        this.onMutation(msg);
      }
      return;
    }
    debug("Document mutated from remote with local changes");
    if (this.document.EDGE === null) {
      this.handleDocumentDeleted();
    }
    this.rebase([msg.mutation], []);
  }
  rebase(remoteMutations, localMutations) {
    debug("Rebasing document");
    if (this.document.EDGE === null) {
      this.handleDocumentDeleted();
    }
    const oldLocal = this.LOCAL;
    this.LOCAL = this.commits.reduce((doc, commit) => commit.apply(doc), this.document.EDGE);
    this.LOCAL = this.buffer.rebase(this.LOCAL);
    if (oldLocal !== null && this.LOCAL !== null) {
      oldLocal._rev = this.LOCAL._rev;
    }
    const changed = !isEqual__default.default(this.LOCAL, oldLocal);
    if (changed && this.onRebase) {
      this.onRebase(this.LOCAL, remoteMutations.reduce(mutReducerFn, []), localMutations.reduce(mutReducerFn, []));
    }
  }
  handleDocConsistencyChanged(isConsistent) {
    if (!this.onConsistencyChanged) {
      return;
    }
    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges();
    if (isConsistent && !hasLocalChanges) {
      this.onConsistencyChanged(true);
    }
    if (!isConsistent) {
      this.onConsistencyChanged(false);
    }
  }
}
exports.BufferedDocument = BufferedDocument;
exports.Mutation = Mutation;
exports.arrayToJSONMatchPath = arrayToJSONMatchPath;
exports.extract = extract;
exports.extractWithPath = extractWithPath;
//# sourceMappingURL=index.js.map
