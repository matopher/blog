'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var noop = require('lodash/noop.js');
var react = require('react');
var slate = require('slate');
var slateReact = require('slate-react');
var debug$l = require('debug');
var types = require('@sanity/types');
var isEqual = require('lodash/isEqual.js');
var content = require('@sanity/util/content');
var styled = require('styled-components');
var uniq = require('lodash/uniq.js');
var rxjs = require('rxjs');
var schema = require('@sanity/schema');
var get = require('lodash/get.js');
var isUndefined = require('lodash/isUndefined.js');
var omitBy = require('lodash/omitBy.js');
var flatten$1 = require('lodash/flatten.js');
var isObject = require('lodash/isObject.js');
var isString = require('lodash/isString.js');
var findIndex = require('lodash/findIndex.js');
var clone = require('lodash/clone.js');
var omit = require('lodash/omit.js');
var isHotkey = require('is-hotkey');
var blockTools = require('@sanity/block-tools');
var isPlainObject = require('lodash/isPlainObject.js');
var throttle = require('lodash/throttle.js');
var debounce = require('lodash/debounce.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var noop__default = /*#__PURE__*/_interopDefaultCompat(noop);
var debug__default = /*#__PURE__*/_interopDefaultCompat(debug$l);
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);
var styled__default = /*#__PURE__*/_interopDefaultCompat(styled);
var uniq__default = /*#__PURE__*/_interopDefaultCompat(uniq);
var get__default = /*#__PURE__*/_interopDefaultCompat(get);
var isUndefined__default = /*#__PURE__*/_interopDefaultCompat(isUndefined);
var omitBy__default = /*#__PURE__*/_interopDefaultCompat(omitBy);
var flatten__default = /*#__PURE__*/_interopDefaultCompat(flatten$1);
var isObject__default = /*#__PURE__*/_interopDefaultCompat(isObject);
var isString__default = /*#__PURE__*/_interopDefaultCompat(isString);
var findIndex__default = /*#__PURE__*/_interopDefaultCompat(findIndex);
var clone__default = /*#__PURE__*/_interopDefaultCompat(clone);
var omit__default = /*#__PURE__*/_interopDefaultCompat(omit);
var isHotkey__default = /*#__PURE__*/_interopDefaultCompat(isHotkey);
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var throttle__default = /*#__PURE__*/_interopDefaultCompat(throttle);
var debounce__default = /*#__PURE__*/_interopDefaultCompat(debounce);
const rootName = "sanity-pte:";
debug__default.default(rootName);
function debugWithName(name) {
  const namespace = "".concat(rootName).concat(name);
  if (debug__default.default && debug__default.default.enabled(namespace)) {
    return debug__default.default(namespace);
  }
  return debug__default.default(rootName);
}
function createKeyedPath(point, value, types) {
  const blockPath = [point.path[0]];
  if (!value) {
    return null;
  }
  const block = value[blockPath[0]];
  if (!block) {
    return null;
  }
  const keyedBlockPath = [{
    _key: block._key
  }];
  if (block._type !== types.block.name) {
    return keyedBlockPath;
  }
  let keyedChildPath;
  const childPath = point.path.slice(0, 2);
  const child = Array.isArray(block.children) && block.children[childPath[1]];
  if (child) {
    keyedChildPath = ["children", {
      _key: child._key
    }];
  }
  return keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;
}
function createArrayedPath(point, editor) {
  if (!editor) {
    return [];
  }
  const [block, blockPath] = Array.from(slate.Editor.nodes(editor, {
    at: [],
    match: n => types.isKeySegment(point.path[0]) && n._key === point.path[0]._key
  }))[0] || [void 0, void 0];
  if (!block || !slate.Element.isElement(block)) {
    return [];
  }
  if (editor.isVoid(block)) {
    return [blockPath[0], 0];
  }
  const childPath = [point.path[2]];
  const childIndex = block.children.findIndex(child => isEqual__default.default([{
    _key: child._key
  }], childPath));
  if (childIndex >= 0 && block.children[childIndex]) {
    const child = block.children[childIndex];
    if (slate.Element.isElement(child) && editor.isVoid(child)) {
      return blockPath.concat(childIndex).concat(0);
    }
    return blockPath.concat(childIndex);
  }
  return blockPath;
}
function toPortableTextRange(value, range, types) {
  if (!range) {
    return null;
  }
  let anchor = null;
  let focus = null;
  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);
  if (anchorPath && range.anchor) {
    anchor = {
      path: anchorPath,
      offset: range.anchor.offset
    };
  }
  const focusPath = range.focus && createKeyedPath(range.focus, value, types);
  if (focusPath && range.focus) {
    focus = {
      path: focusPath,
      offset: range.focus.offset
    };
  }
  const backward = Boolean(slate.Range.isRange(range) ? slate.Range.isBackward(range) : void 0);
  return anchor && focus ? {
    anchor,
    focus,
    backward
  } : null;
}
function toSlateRange(selection, editor) {
  if (!selection || !editor) {
    return null;
  }
  const anchor = {
    path: createArrayedPath(selection.anchor, editor),
    offset: selection.anchor.offset
  };
  const focus = {
    path: createArrayedPath(selection.focus, editor),
    offset: selection.focus.offset
  };
  const range = anchor && focus ? {
    anchor,
    focus
  } : null;
  return range;
}
function normalizePoint(point, value) {
  if (!point || !value) {
    return null;
  }
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] === "object" && "_key" in point.path[0] && point.path[0]._key;
  const childKey = typeof point.path[2] === "object" && "_key" in point.path[2] && point.path[2]._key;
  const block = value.find(blk => blk._key === blockKey);
  if (block) {
    newPath.push({
      _key: block._key
    });
  } else {
    return null;
  }
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0) {
      return null;
    }
    const child = Array.isArray(block.children) && block.children.find(cld => cld._key === childKey);
    if (child) {
      newPath.push("children");
      newPath.push({
        _key: child._key
      });
      newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    } else {
      return null;
    }
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0) {
    return null;
  }
  let newAnchor = null;
  let newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  if (anchor && value.find(blk => isEqual__default.default({
    _key: blk._key
  }, anchor.path[0]))) {
    newAnchor = normalizePoint(anchor, value);
  }
  if (focus && value.find(blk => isEqual__default.default({
    _key: blk._key
  }, focus.path[0]))) {
    newFocus = normalizePoint(focus, value);
  }
  if (newAnchor && newFocus) {
    return {
      anchor: newAnchor,
      focus: newFocus,
      backward: selection.backward
    };
  }
  return null;
}
const defaultKeyGenerator = () => content.randomKey(12);
const PortableTextEditorKeyGeneratorContext = react.createContext(defaultKeyGenerator);
const usePortableTextEditorKeyGenerator = () => {
  const keyGenerator = react.useContext(PortableTextEditorKeyGeneratorContext);
  if (keyGenerator === void 0) {
    throw new Error("The `usePortableTextEditorKeyGenerator` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return keyGenerator;
};
const EMPTY_MARKDEFS = [];
const EMPTY_MARKS$1 = [];
const VOID_CHILD_KEY = "void-child";
function keepObjectEquality(object, keyMap) {
  const value = keyMap[object._key];
  if (value && isEqual__default.default(object, value)) {
    return value;
  }
  keyMap[object._key] = object;
  return object;
}
function toSlateValue(value, _ref) {
  let {
    schemaTypes
  } = _ref;
  let keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (value && Array.isArray(value)) {
    return value.map(block => {
      const {
        _type,
        _key,
        ...rest
      } = block;
      const voidChildren = [{
        _key: VOID_CHILD_KEY,
        _type: "span",
        text: "",
        marks: []
      }];
      const isPortableText = block && block._type === schemaTypes.block.name;
      if (isPortableText) {
        const textBlock = block;
        let hasInlines = false;
        const hasMissingStyle = typeof textBlock.style === "undefined";
        const hasMissingMarkDefs = typeof textBlock.markDefs === "undefined";
        const hasMissingChildren = typeof textBlock.children === "undefined";
        const children = hasMissingChildren ? [{
          _type: schemaTypes.span.name,
          _key: defaultKeyGenerator(),
          text: "",
          marks: []
        }] : textBlock.children.map(child => {
          const {
            _type: cType,
            _key: cKey,
            ...cRest
          } = child;
          if (cType !== "span") {
            hasInlines = true;
            return keepObjectEquality({
              _type: cType,
              _key: cKey,
              children: voidChildren,
              value: cRest,
              __inline: true
            }, keyMap);
          }
          if (cType === "span" && !("marks" in cRest)) {
            return keepObjectEquality({
              _key: cKey,
              _type: cType,
              ...cRest,
              marks: EMPTY_MARKS$1
            }, keyMap);
          }
          return child;
        });
        if (!hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate.Element.isElement(block)) {
          return block;
        }
        if (hasMissingStyle) {
          rest.style = schemaTypes.styles[0].value;
        }
        if (hasMissingMarkDefs) {
          rest.markDefs = EMPTY_MARKDEFS;
        }
        return keepObjectEquality({
          _type,
          _key,
          ...rest,
          children
        }, keyMap);
      }
      return keepObjectEquality({
        _type,
        _key,
        children: voidChildren,
        value: rest
      }, keyMap);
    });
  }
  return [];
}
function fromSlateValue(value, textBlockType) {
  let keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return value.map(block => {
    const {
      _key,
      _type
    } = block;
    if (!_key || !_type) {
      throw new Error("Not a valid block");
    }
    if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
      let hasInlines = false;
      const children = block.children.map(child => {
        const {
          _type: _cType
        } = child;
        if ("value" in child && _cType !== "span") {
          hasInlines = true;
          const {
            value: v,
            _key: k,
            _type: t,
            __inline: _i,
            children: _c,
            ...rest
          } = child;
          return keepObjectEquality({
            ...rest,
            ...v,
            _key: k,
            _type: t
          }, keyMap);
        }
        return child;
      });
      if (!hasInlines) {
        return block;
      }
      return keepObjectEquality({
        ...block,
        children,
        _key,
        _type
      }, keyMap);
    }
    const blockValue = "value" in block && block.value;
    return keepObjectEquality({
      _key,
      _type,
      ...(typeof blockValue === "object" ? blockValue : {})
    }, keyMap);
  });
}
function isEqualToEmptyEditor(children, schemaTypes) {
  var _a;
  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].value && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate.Text.isText(children[0].children[0]) && children[0].children[0]._type === "span" && !((_a = children[0].children[0].marks) == null ? void 0 : _a.join("")) && children[0].children[0].text === "";
}
const IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */new WeakMap();
const IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */new WeakMap();
const IS_DRAGGING = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */new WeakMap();
const KEY_TO_SLATE_ELEMENT = /* @__PURE__ */new WeakMap();
const KEY_TO_VALUE_ELEMENT = /* @__PURE__ */new WeakMap();
const SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */new WeakMap();
const DefaultObject = props => {
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    children: /* @__PURE__ */jsxRuntime.jsx("pre", {
      children: JSON.stringify(props.value, null, 2)
    })
  });
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a, _b, _c, _d;
const DefaultBlockObject = styled__default.default.div(_a || (_a = __template(["\n  user-select: none;\n  border: ", ";\n"])), props => {
  if (props.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
styled__default.default.span(_b || (_b = __template(["\n  background: #999;\n  border: ", ";\n"])), props => {
  if (props.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
const DefaultListItem = styled__default.default.div(_c || (_c = __template(["\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ", ";\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '", "';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ", ";\n    counter-reset: ", ";\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ", ";\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n"])), props => getLeftPositionForListLevel(props.listLevel), props => getContentForListLevelAndStyle(props.listLevel, props.listStyle), props => getCounterIncrementForListLevel(props.listLevel), props => getCounterResetForListLevel(props.listLevel), props => getCounterContentForListLevel(props.listLevel));
const DefaultListItemInner = styled__default.default.div(_d || (_d = __template([""])));
function getLeftPositionForListLevel(level) {
  switch (Number(level)) {
    case 1:
      return "1.5em";
    case 2:
      return "3em";
    case 3:
      return "4.5em";
    case 4:
      return "6em";
    case 5:
      return "7.5em";
    case 6:
      return "9em";
    case 7:
      return "10.5em";
    case 8:
      return "12em";
    case 9:
      return "13.5em";
    case 10:
      return "15em";
    default:
      return "0em";
  }
}
const bullets = ["\u25CF", "\u25CB", "\u25A0"];
function getContentForListLevelAndStyle(level, style) {
  const normalizedLevel = (level - 1) % 3;
  if (style === "bullet") {
    return bullets[normalizedLevel];
  }
  return "*";
}
function getCounterIncrementForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemNumber";
    case 2:
      return "listItemAlpha";
    case 3:
      return "listItemRoman";
    case 4:
      return "listItemNumberNext";
    case 5:
      return "listItemLetterNext";
    case 6:
      return "listItemRomanNext";
    case 7:
      return "listItemNumberNextNext";
    case 8:
      return "listItemAlphaNextNext";
    case 9:
      return "listItemRomanNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterResetForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemAlpha";
    case 2:
      return "listItemRoman";
    case 3:
      return "listItemNumberNext";
    case 4:
      return "listItemLetterNext";
    case 5:
      return "listItemRomanNext";
    case 6:
      return "listItemNumberNextNext";
    case 7:
      return "listItemAlphaNextNext";
    case 8:
      return "listItemRomanNextNext";
    case 9:
      return "listItemNumberNextNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterContentForListLevel(level) {
  switch (level) {
    case 1:
      return "counter(listItemNumber) '. '";
    case 2:
      return "counter(listItemAlpha, lower-alpha) '. '";
    case 3:
      return "counter(listItemRoman, lower-roman) '. '";
    case 4:
      return "counter(listItemNumberNext) '. '";
    case 5:
      return "counter(listItemLetterNext, lower-alpha) '. '";
    case 6:
      return "counter(listItemRomanNext, lower-roman) '. '";
    case 7:
      return "counter(listItemNumberNextNext) '. '";
    case 8:
      return "counter(listItemAlphaNextNext, lower-alpha) '. '";
    case 9:
      return "counter(listItemRomanNextNext, lower-roman) '. '";
    default:
      return "counter(listItemNumberNextNextNext) '. '";
  }
}
const debug$k = debugWithName("components:DraggableBlock");
const DraggableBlock = _ref2 => {
  let {
    children,
    element,
    readOnly,
    blockRef
  } = _ref2;
  const editor = slateReact.useSlateStatic();
  const dragGhostRef = react.useRef();
  const [isDragOver, setIsDragOver] = react.useState(false);
  const isVoid = react.useMemo(() => slate.Editor.isVoid(editor, element), [editor, element]);
  const isInline = react.useMemo(() => slate.Editor.isInline(editor, element), [editor, element]);
  const [blockElement, setBlockElement] = react.useState(null);
  react.useEffect(() => setBlockElement(blockRef ? blockRef.current : slateReact.ReactEditor.toDOMNode(editor, element)), [editor, element, blockRef]);
  const handleDragOver = react.useCallback(event => {
    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
    if (!isMyDragOver || !blockElement) {
      return;
    }
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
    const elementRect = blockElement.getBoundingClientRect();
    const offset = elementRect.top;
    const height = elementRect.height;
    const Y = event.pageY;
    const loc = Math.abs(offset - Y);
    let position = "bottom";
    if (element === editor.children[0]) {
      position = "top";
    } else if (loc < height / 2) {
      position = "top";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
    } else {
      position = "bottom";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
    }
    if (isMyDragOver === element) {
      event.dataTransfer.dropEffect = "none";
      return;
    }
    setIsDragOver(true);
  }, [blockElement, editor, element]);
  const handleDragLeave = react.useCallback(() => {
    setIsDragOver(false);
  }, []);
  const handleDragEnd = react.useCallback(event => {
    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
    if (targetBlock) {
      IS_DRAGGING.set(editor, false);
      event.preventDefault();
      event.stopPropagation();
      IS_DRAGGING_ELEMENT_TARGET.delete(editor);
      if (dragGhostRef.current) {
        debug$k("Removing drag ghost");
        document.body.removeChild(dragGhostRef.current);
      }
      const dragPosition2 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
      let targetPath = slateReact.ReactEditor.findPath(editor, targetBlock);
      const myPath = slateReact.ReactEditor.findPath(editor, element);
      const isBefore = slate.Path.isBefore(myPath, targetPath);
      if (dragPosition2 === "bottom" && !isBefore) {
        if (targetPath[0] >= editor.children.length - 1) {
          debug$k("target is already at the bottom, not moving");
          return;
        }
        const originalPath = targetPath;
        targetPath = slate.Path.next(targetPath);
        debug$k("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (dragPosition2 === "top" && isBefore && targetPath[0] !== editor.children.length - 1) {
        const originalPath = targetPath;
        targetPath = slate.Path.previous(targetPath);
        debug$k("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (slate.Path.equals(targetPath, myPath)) {
        event.preventDefault();
        debug$k("targetPath and myPath is the same, not moving");
        return;
      }
      debug$k("Moving element ".concat(element._key, " from path ").concat(JSON.stringify(myPath), " to ").concat(JSON.stringify(targetPath), " (").concat(dragPosition2, ")"));
      slate.Transforms.moveNodes(editor, {
        at: myPath,
        to: targetPath
      });
      editor.onChange();
      return;
    }
    debug$k("No target element, not doing anything");
  }, [editor, element]);
  const handleDrop = react.useCallback(event => {
    if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
      debug$k("On drop (prevented)", element);
      event.preventDefault();
      event.stopPropagation();
      setIsDragOver(false);
    }
  }, [editor, element]);
  const handleDrag = react.useCallback(event => {
    if (!isVoid) {
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
      return;
    }
    IS_DRAGGING.set(editor, true);
    IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
    event.stopPropagation();
    const target = event.target;
    if (target instanceof HTMLElement) {
      target.style.opacity = "1";
    }
  }, [editor, element, isVoid]);
  const handleDragStart = react.useCallback(event => {
    if (!isVoid || isInline) {
      debug$k("Not dragging block");
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
      IS_DRAGGING.set(editor, false);
      return;
    }
    debug$k("Drag start");
    IS_DRAGGING.set(editor, true);
    if (event.dataTransfer) {
      event.dataTransfer.setData("application/portable-text", "something");
      event.dataTransfer.effectAllowed = "move";
    }
    if (blockElement && blockElement instanceof HTMLElement) {
      let dragGhost = blockElement.cloneNode(true);
      const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
      if (customGhost) {
        dragGhost = customGhost;
      }
      dragGhost.setAttribute("data-dragged", "");
      if (document.body) {
        dragGhostRef.current = dragGhost;
        dragGhost.style.position = "absolute";
        dragGhost.style.left = "-99999px";
        dragGhost.style.boxSizing = "border-box";
        document.body.appendChild(dragGhost);
        const rect = blockElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        dragGhost.style.width = "".concat(rect.width, "px");
        dragGhost.style.height = "".concat(rect.height, "px");
        event.dataTransfer.setDragImage(dragGhost, x, y);
      }
    }
    handleDrag(event);
  }, [blockElement, editor, handleDrag, isInline, isVoid]);
  const isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
  const isDraggingOverLastBlock = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
  const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
  const isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "top";
  const isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "bottom";
  const dropIndicator = react.useMemo(() => /* @__PURE__ */jsxRuntime.jsx("div", {
    className: "pt-drop-indicator",
    style: {
      position: "absolute",
      width: "100%",
      height: 1,
      borderBottom: "1px solid currentColor",
      zIndex: 5
    }
  }), []);
  if (readOnly) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsxs("div", {
    draggable: isVoid,
    onDragStart: handleDragStart,
    onDrag: handleDrag,
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    children: [isDraggingOverTop && dropIndicator, children, isDraggingOverBottom && dropIndicator]
  });
};
debugWithName("components:Element");
const EMPTY_ANNOTATIONS = [];
const inlineBlockStyle = {
  display: "inline-block"
};
const Element = _ref3 => {
  let {
    attributes,
    children,
    element,
    schemaTypes,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem,
    renderStyle,
    spellCheck
  } = _ref3;
  const editor = slateReact.useSlateStatic();
  const selected = slateReact.useSelected();
  const blockRef = react.useRef(null);
  const inlineBlockObjectRef = react.useRef(null);
  const focused = selected && editor.selection && slate.Range.isCollapsed(editor.selection) || false;
  const value = react.useMemo(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);
  let renderedBlock = children;
  let className;
  const blockPath = react.useMemo(() => [{
    _key: element._key
  }], [element]);
  if (typeof element._type !== "string") {
    throw new Error("Expected element to have a _type property");
  }
  if (typeof element._key !== "string") {
    throw new Error("Expected element to have a _key property");
  }
  if (editor.isInline(element)) {
    const path = slateReact.ReactEditor.findPath(editor, element);
    const [block2] = slate.Editor.node(editor, path, {
      depth: 1
    });
    const schemaType2 = schemaTypes.inlineObjects.find(_type => _type.name === element._type);
    if (!schemaType2) {
      throw new Error("Could not find type for inline block element");
    }
    if (slate.Element.isElement(block2)) {
      const elmPath = [{
        _key: block2._key
      }, "children", {
        _key: element._key
      }];
      return /* @__PURE__ */jsxRuntime.jsxs("span", {
        ...attributes,
        children: [children, /* @__PURE__ */jsxRuntime.jsxs("span", {
          draggable: !readOnly,
          className: "pt-inline-object",
          ref: inlineBlockObjectRef,
          style: inlineBlockStyle,
          contentEditable: false,
          children: [renderChild && renderChild({
            annotations: EMPTY_ANNOTATIONS,
            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
            children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
              value
            }),
            editorElementRef: inlineBlockObjectRef,
            focused,
            path: elmPath,
            schemaType: schemaType2,
            selected,
            type: schemaType2,
            value
          }), !renderChild && /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
            value
          })]
        }, element._key)]
      });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = ("listItem" in element);
    const style = "style" in element && element.style || "normal";
    className = "pt-block pt-text-block pt-text-block-style-".concat(style);
    const blockStyleType = schemaTypes.styles.find(item => item.value === style);
    if (renderStyle && blockStyleType) {
      renderedBlock = renderStyle({
        block: element,
        children,
        focused,
        selected,
        value: style,
        path: blockPath,
        schemaType: blockStyleType,
        editorElementRef: blockRef
      });
    }
    let level;
    if (isListItem) {
      if (typeof element.level === "number") {
        level = element.level;
      }
      className += " pt-list-item pt-list-item-".concat(element.listItem, " pt-list-item-level-").concat(level || 1);
    }
    if (editor.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find(item => item.value === element.listItem);
      if (renderListItem && listType) {
        renderedBlock = renderListItem({
          block: value,
          children: renderedBlock,
          focused,
          selected,
          value: element.listItem,
          path: blockPath,
          schemaType: listType,
          level: value.level || 1,
          editorElementRef: blockRef
        });
      } else {
        renderedBlock = /* @__PURE__ */jsxRuntime.jsx(DefaultListItem, {
          listStyle: value.listItem || schemaTypes.lists[0].value,
          listLevel: value.level || 1,
          children: /* @__PURE__ */jsxRuntime.jsx(DefaultListItemInner, {
            children: renderedBlock
          })
        });
      }
    }
    const renderProps = Object.defineProperty({
      children: renderedBlock,
      editorElementRef: blockRef,
      focused,
      level,
      listItem: isListItem ? element.listItem : void 0,
      path: blockPath,
      selected,
      style,
      schemaType: schemaTypes.block,
      value
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaTypes.block;
      }
    });
    const propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return /* @__PURE__ */jsxRuntime.jsx("div", {
      ...attributes,
      className,
      spellCheck,
      children: /* @__PURE__ */jsxRuntime.jsx(DraggableBlock, {
        element,
        readOnly,
        blockRef,
        children: /* @__PURE__ */jsxRuntime.jsx("div", {
          ref: blockRef,
          children: propsOrDefaultRendered
        })
      })
    }, element._key);
  }
  const schemaType = schemaTypes.blockObjects.find(_type => _type.name === element._type);
  if (!schemaType) {
    throw new Error("Could not find schema type for block element of _type ".concat(element._type));
  }
  className = "pt-block pt-object-block";
  const block = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty({
      children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
        value
      }),
      editorElementRef: blockRef,
      focused,
      path: blockPath,
      schemaType,
      selected,
      value: block
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaType;
      }
    });
    renderedBlockFromProps = renderBlock(_props);
  }
  return /* @__PURE__ */jsxRuntime.jsxs("div", {
    ...attributes,
    className,
    children: [children, /* @__PURE__ */jsxRuntime.jsxs(DraggableBlock, {
      element,
      readOnly,
      blockRef,
      children: [renderedBlockFromProps && /* @__PURE__ */jsxRuntime.jsx("div", {
        ref: blockRef,
        contentEditable: false,
        children: renderedBlockFromProps
      }), !renderedBlockFromProps && /* @__PURE__ */jsxRuntime.jsx(DefaultBlockObject, {
        selected,
        children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
          value
        })
      })]
    })]
  }, element._key);
};
const PortableTextEditorContext = react.createContext(null);
const usePortableTextEditor = () => {
  const editor = react.useContext(PortableTextEditorContext);
  if (!editor) {
    throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return editor;
};
function DefaultAnnotation(props) {
  const handleClick = react.useCallback(() => alert(JSON.stringify(props.annotation)), [props.annotation]);
  return /* @__PURE__ */jsxRuntime.jsx("span", {
    style: {
      color: "blue"
    },
    onClick: handleClick,
    children: props.children
  });
}
function getPortableTextMemberSchemaTypes(portableTextType) {
  var _a, _b, _c;
  if (!portableTextType) {
    throw new Error("Parameter 'portabletextType' missing (required)");
  }
  const blockType = (_a = portableTextType.of) == null ? void 0 : _a.find(findBlockType);
  if (!blockType) {
    throw new Error("Block type is not defined in this schema (required)");
  }
  const childrenField = (_b = blockType.fields) == null ? void 0 : _b.find(field => field.name === "children");
  if (!childrenField) {
    throw new Error("Children field for block type found in schema (required)");
  }
  const ofType = childrenField.type.of;
  if (!ofType) {
    throw new Error("Valid types for block children not found in schema (required)");
  }
  const spanType = ofType.find(memberType => memberType.name === "span");
  if (!spanType) {
    throw new Error("Span type not found in schema (required)");
  }
  const inlineObjectTypes = ofType.filter(memberType => memberType.name !== "span") || [];
  const blockObjectTypes = ((_c = portableTextType.of) == null ? void 0 : _c.filter(field => field.name !== blockType.name)) || [];
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    lists: resolveEnabledListItems(blockType),
    block: blockType,
    span: spanType,
    portableText: portableTextType,
    inlineObjects: inlineObjectTypes,
    blockObjects: blockObjectTypes,
    annotations: spanType.annotations
  };
}
function resolveEnabledStyles(blockType) {
  var _a, _b, _c;
  const styleField = (_a = blockType.fields) == null ? void 0 : _a.find(btField => btField.name === "style");
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = ((_b = styleField.type.options) == null ? void 0 : _b.list) && ((_c = styleField.type.options.list) == null ? void 0 : _c.filter(style => style.value));
  if (!textStyles || textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  var _a, _b;
  const listField = (_a = blockType.fields) == null ? void 0 : _a.find(btField => btField.name === "listItem");
  if (!listField) {
    throw new Error("A field with name 'listItem' is not defined in the block type (required).");
  }
  const listItems = ((_b = listField.type.options) == null ? void 0 : _b.list) && listField.type.options.list.filter(list => list.value);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }
  if (type.name === "block") {
    return type;
  }
  return null;
}
function compileType(rawType) {
  return schema.Schema.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
function isHighSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function cloneDiff(diff) {
  const [type, patch] = diff;
  return [type, patch];
}
function getCommonOverlap(textA, textB) {
  let text1 = textA;
  let text2 = textB;
  const text1Length = text1.length;
  const text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0) {
    return 0;
  }
  if (text1Length > text2Length) {
    text1 = text1.substring(text1Length - text2Length);
  } else if (text1Length < text2Length) {
    text2 = text2.substring(0, text1Length);
  }
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2) {
    return textLength;
  }
  let best = 0;
  let length = 1;
  for (let found = 0; found !== -1;) {
    const pattern = text1.substring(textLength - length);
    found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length += found;
    if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
  return best;
}
function getCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerStart = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid)) {
      pointerMin = pointerMid;
      pointerStart = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function getCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) {
    return 0;
  }
  let pointerMin = 0;
  let pointerMax = Math.min(text1.length, text2.length);
  let pointerMid = pointerMax;
  let pointerEnd = 0;
  while (pointerMin < pointerMid) {
    if (text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd)) {
      pointerMin = pointerMid;
      pointerEnd = pointerMin;
    } else {
      pointerMax = pointerMid;
    }
    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  }
  return pointerMid;
}
function cleanupSemantic(rawDiffs) {
  let diffs = rawDiffs.map(diff => cloneDiff(diff));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let lengthInsertions1 = 0;
  let lengthDeletions1 = 0;
  let lengthInsertions2 = 0;
  let lengthDeletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      lengthInsertions1 = lengthInsertions2;
      lengthDeletions1 = lengthDeletions2;
      lengthInsertions2 = 0;
      lengthDeletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT) {
        lengthInsertions2 += diffs[pointer][1].length;
      } else {
        lengthDeletions2 += diffs[pointer][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        lengthInsertions1 = 0;
        lengthDeletions1 = 0;
        lengthInsertions2 = 0;
        lengthDeletions2 = 0;
        lastEquality = null;
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  diffs = cleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlapLength1 = getCommonOverlap(deletion, insertion);
      const overlapLength2 = getCommonOverlap(insertion, deletion);
      if (overlapLength1 >= overlapLength2) {
        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
          diffs[pointer + 1][1] = insertion.substring(overlapLength1);
          pointer++;
        }
      } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
        diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);
        diffs[pointer - 1][0] = DIFF_INSERT;
        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
        diffs[pointer + 1][0] = DIFF_DELETE;
        diffs[pointer + 1][1] = deletion.substring(overlapLength2);
        pointer++;
      }
      pointer++;
    }
    pointer++;
  }
  return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/;
const whitespaceRegex = /\s/;
const linebreakRegex = /[\r\n]/;
const blanklineEndRegex = /\n\r?\n$/;
const blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
  const diffs = rawDiffs.map(diff => cloneDiff(diff));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge(rawDiffs) {
  let diffs = rawDiffs.map(diff => cloneDiff(diff));
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++;
        textInsert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        countDelete++;
        textDelete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (countDelete + countInsert > 1) {
          if (countDelete !== 0 && countInsert !== 0) {
            commonlength = getCommonPrefix(textInsert, textDelete);
            if (commonlength !== 0) {
              if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);
                pointer++;
              }
              textInsert = textInsert.substring(commonlength);
              textDelete = textDelete.substring(commonlength);
            }
            commonlength = getCommonSuffix(textInsert, textDelete);
            if (commonlength !== 0) {
              diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
              textInsert = textInsert.substring(0, textInsert.length - commonlength);
              textDelete = textDelete.substring(0, textDelete.length - commonlength);
            }
          }
          pointer -= countDelete + countInsert;
          diffs.splice(pointer, countDelete + countInsert);
          if (textDelete.length) {
            diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]);
            pointer++;
          }
          if (textInsert.length) {
            diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]);
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation");
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  let hasChanges = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        hasChanges = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  return diffs;
}
function trueCount() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs) {
  let editCost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  let diffs = rawDiffs.map(diff => cloneDiff(diff));
  let hasChanges = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let preIns = false;
  let preDel = false;
  let postIns = false;
  let postDel = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].length < editCost && (postIns || postDel)) {
        equalities[equalitiesLength++] = pointer;
        preIns = postIns;
        preDel = postDel;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      postIns = false;
      postDel = false;
    } else {
      if (diffs[pointer][0] === DIFF_DELETE) {
        postDel = true;
      } else {
        postIns = true;
      }
      if (lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]);
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (preIns && preDel) {
          postIns = true;
          postDel = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          postIns = false;
          postDel = false;
        }
        hasChanges = true;
      }
    }
    pointer++;
  }
  if (hasChanges) {
    diffs = cleanupMerge(diffs);
  }
  return diffs;
}
function bisect(text1, text2, deadline) {
  const text1Length = text1.length;
  const text2Length = text2.length;
  const maxD = Math.ceil((text1Length + text2Length) / 2);
  const vOffset = maxD;
  const vLength = 2 * maxD;
  const v1 = new Array(vLength);
  const v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[vOffset + 1] = 0;
  v2[vOffset + 1] = 0;
  const delta = text1Length - text2Length;
  const front = delta % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < maxD; d++) {
    if (Date.now() > deadline) {
      break;
    }
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
        x1 = v1[k1Offset + 1];
      } else {
        x1 = v1[k1Offset - 1] + 1;
      }
      let y1 = x1 - k1;
      while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1Offset] = x1;
      if (x1 > text1Length) {
        k1end += 2;
      } else if (y1 > text2Length) {
        k1start += 2;
      } else if (front) {
        const k2Offset = vOffset + delta - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2) {
            return bisectSplit(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
        x2 = v2[k2Offset + 1];
      } else {
        x2 = v2[k2Offset - 1] + 1;
      }
      let y2 = x2 - k2;
      while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2Offset] = x2;
      if (x2 > text1Length) {
        k2end += 2;
      } else if (y2 > text2Length) {
        k2start += 2;
      } else if (!front) {
        const k1Offset = vOffset + delta - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset];
          const y1 = vOffset + x1 - k1Offset;
          x2 = text1Length - x2;
          if (x1 >= x2) {
            return bisectSplit(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function bisectSplit(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = doDiff(text1a, text2a, {
    checkLines: false,
    deadline
  });
  const diffsb = doDiff(text1b, text2b, {
    checkLines: false,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2) {
  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (timeout <= 0) {
    return null;
  }
  const longText = text1.length > text2.length ? text1 : text2;
  const shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length) {
    return null;
  }
  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4));
  const halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2) {
    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  } else if (!halfMatch1 && !halfMatch2) {
    return null;
  } else if (!halfMatch2) {
    halfMatch = halfMatch1;
  } else if (!halfMatch1) {
    halfMatch = halfMatch2;
  }
  if (!halfMatch) {
    throw new Error("Unable to find a half match.");
  }
  let text1A;
  let text1B;
  let text2A;
  let text2B;
  if (text1.length > text2.length) {
    text1A = halfMatch[0];
    text1B = halfMatch[1];
    text2A = halfMatch[2];
    text2B = halfMatch[3];
  } else {
    text2A = halfMatch[0];
    text2B = halfMatch[1];
    text1A = halfMatch[2];
    text1B = halfMatch[3];
  }
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1;
  let bestCommon = "";
  let bestLongTextA;
  let bestLongTextB;
  let bestShortTextA;
  let bestShortTextB;
  while ((j = shortText.indexOf(seed, j + 1)) !== -1) {
    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j));
    const suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
    if (bestCommon.length < suffixLength + prefixLength) {
      bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength);
      bestLongTextA = longText.slice(0, i - suffixLength);
      bestLongTextB = longText.slice(i + prefixLength);
      bestShortTextA = shortText.slice(0, j - suffixLength);
      bestShortTextB = shortText.slice(j + prefixLength);
    }
  }
  if (bestCommon.length * 2 >= longText.length) {
    return [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""];
  }
  return null;
}
function charsToLines(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars = diffs[x][1];
    const text = [];
    for (let y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join("");
  }
}
function linesToChars(textA, textB) {
  const lineArray = [];
  const lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf("\n", lineStart);
      if (lineEnd === -1) {
        lineEnd = text.length - 1;
      }
      let line = text.slice(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text.slice(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff(textA, textB, opts) {
  let text1 = textA;
  let text2 = textB;
  const a = linesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff(text1, text2, {
    checkLines: false,
    deadline: opts.deadline
  });
  charsToLines(diffs, linearray);
  diffs = cleanupSemantic(diffs);
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0;
  let countDelete = 0;
  let countInsert = 0;
  let textDelete = "";
  let textInsert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++;
        textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        countDelete++;
        textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
          pointer = pointer - countDelete - countInsert;
          const aa = doDiff(textDelete, textInsert, {
            checkLines: false,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, aa[j]);
          }
          pointer += aa.length;
        }
        countInsert = 0;
        countDelete = 0;
        textDelete = "";
        textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function computeDiff(text1, text2, opts) {
  let diffs;
  if (!text1) {
    return [[DIFF_INSERT, text2]];
  }
  if (!text2) {
    return [[DIFF_DELETE, text1]];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    if (text1.length > text2.length) {
      diffs[0][0] = DIFF_DELETE;
      diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  if (shorttext.length === 1) {
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  const halfMatch = findHalfMatch(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0];
    const text1B = halfMatch[1];
    const text2A = halfMatch[2];
    const text2B = halfMatch[3];
    const midCommon = halfMatch[4];
    const diffsA = doDiff(text1A, text2A, opts);
    const diffsB = doDiff(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  }
  if (opts.checkLines && text1.length > 100 && text2.length > 100) {
    return doLineModeDiff(text1, text2, opts);
  }
  return bisect(text1, text2, opts.deadline);
}
const DIFF_DELETE = -1;
const DIFF_INSERT = 1;
const DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
  if (textA === null || textB === null) {
    throw new Error("Null input. (diff)");
  }
  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
  adjustDiffForSurrogatePairs(diffs);
  return diffs;
}
function doDiff(textA, textB, options) {
  let text1 = textA;
  let text2 = textB;
  if (text1 === text2) {
    return text1 ? [[DIFF_EQUAL, text1]] : [];
  }
  let commonlength = getCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = getCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff(text1, text2, options);
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diffs = cleanupMerge(diffs);
  return diffs;
}
function createDeadLine(timeout) {
  let t = 1;
  if (typeof timeout !== "undefined") {
    t = timeout <= 0 ? Number.MAX_VALUE : timeout;
  }
  return Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
  return {
    checkLines: true,
    deadline: createDeadLine(opts.timeout || 1),
    ...opts
  };
}
function combineChar(data, char, dir) {
  return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar(diffs, i, j, dir) {
  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
  const inv = dir === 1 ? -1 : 1;
  let insertIdx = null;
  let deleteIdx = null;
  let j = i + dir;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {
    const [op, text2] = diffs[j];
    if (text2.length === 0) {
      continue;
    }
    if (op === DIFF_INSERT) {
      if (insertIdx === null) {
        insertIdx = j;
      }
      continue;
    } else if (op === DIFF_DELETE) {
      if (deleteIdx === null) {
        deleteIdx = j;
      }
      continue;
    } else if (op === DIFF_EQUAL) {
      if (insertIdx === null && deleteIdx === null) {
        const [rest, char2] = splitChar(diffs[i][1], dir);
        diffs[i][1] = rest;
        diffs[j][1] = combineChar(diffs[j][1], char2, inv);
        return;
      }
      break;
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv);
    const [deleteText] = splitChar(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText;
    diffs[deleteIdx][1] = deleteText;
    diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
    return;
  }
  const [text, char] = splitChar(diffs[i][1], dir);
  diffs[i][1] = text;
  if (insertIdx === null) {
    diffs.splice(j, 0, [DIFF_INSERT, char]);
    if (deleteIdx !== null && deleteIdx >= j) deleteIdx++;
  } else {
    diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv);
  }
  if (deleteIdx === null) {
    diffs.splice(j, 0, [DIFF_DELETE, char]);
  } else {
    diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
  }
}
function adjustDiffForSurrogatePairs(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0) continue;
    const firstChar = diffText[0];
    const lastChar = diffText[diffText.length - 1];
    if (isHighSurrogate(lastChar) && diffType === DIFF_EQUAL) {
      deisolateChar(diffs, i, 1);
    }
    if (isLowSurrogate(firstChar) && diffType === DIFF_EQUAL) {
      deisolateChar(diffs, i, -1);
    }
  }
  for (let i = 0; i < diffs.length; i++) {
    if (diffs[i][1].length === 0) {
      diffs.splice(i, 1);
    }
  }
}
const DEFAULT_OPTIONS = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults(options) {
  return {
    ...DEFAULT_OPTIONS,
    ...options
  };
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc) {
  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (pattern.length > MAX_BITS$1) {
    throw new Error("Pattern too long for this browser.");
  }
  const options = applyDefaults(opts);
  const s = getAlphabetFromPattern(pattern);
  function getBitapScore(e, x) {
    const accuracy = e / pattern.length;
    const proximity = Math.abs(loc - x);
    if (!options.distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / options.distance;
  }
  let scoreThreshold = options.threshold;
  let bestLoc = text.indexOf(pattern, loc);
  if (bestLoc !== -1) {
    scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    bestLoc = text.lastIndexOf(pattern, loc + pattern.length);
    if (bestLoc !== -1) {
      scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold);
    }
  }
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin;
  let binMid;
  let binMax = pattern.length + text.length;
  let lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    binMin = 0;
    binMid = binMax;
    while (binMin < binMid) {
      if (getBitapScore(d, loc + binMid) <= scoreThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length;
    const rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0) {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
      } else {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];
      }
      if (rd[j] & matchmask) {
        const score = getBitapScore(d, j - 1);
        if (score <= scoreThreshold) {
          scoreThreshold = score;
          bestLoc = j - 1;
          if (bestLoc > loc) {
            start = Math.max(1, 2 * loc - bestLoc);
          } else {
            break;
          }
        }
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold) {
      break;
    }
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (let i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  }
  return s;
}
function match(text, pattern, searchLocation) {
  if (text === null || pattern === null || searchLocation === null) {
    throw new Error("Null input. (match())");
  }
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern) {
    return 0;
  } else if (!text.length) {
    return -1;
  } else if (text.substring(loc, loc + pattern.length) === pattern) {
    return loc;
  }
  return bitap(text, pattern, loc);
}
function createPatchObject(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function diffText1(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function diffText2(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join("");
}
function countUtf8Bytes(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint === "undefined") {
      throw new Error("Failed to get codepoint");
    }
    bytes += utf8len(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs2(patches, base) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let byteOffset = 0;
  let idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target;) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint === "undefined") {
        return idx;
      }
      byteOffset += utf8len(codePoint);
      if (codePoint > 65535) {
        idx += 2;
      } else {
        idx += 1;
      }
    }
    if (!options.allowExceedingIndices && byteOffset !== target) {
      throw new Error("Failed to determine byte offset");
    }
    return idx;
  }
  const adjusted = [];
  for (const patch of patches) {
    adjusted.push({
      diffs: patch.diffs.map(diff => cloneDiff(diff)),
      start1: advanceTo(patch.start1),
      start2: advanceTo(patch.start2),
      utf8Start1: patch.utf8Start1,
      utf8Start2: patch.utf8Start2,
      length1: patch.length1,
      length2: patch.length2,
      utf8Length1: patch.utf8Length1,
      utf8Length2: patch.utf8Length2
    });
  }
  return adjusted;
}
function utf8len(codePoint) {
  if (codePoint <= 127) return 1;
  if (codePoint <= 2047) return 2;
  if (codePoint <= 65535) return 3;
  return 4;
}
const MAX_BITS = 32;
const DEFAULT_MARGIN = 4;
const DEFAULT_OPTS = {
  margin: 4
};
function getDefaultOpts() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    ...DEFAULT_OPTS,
    ...opts
  };
}
function make(a, b, options) {
  if (typeof a === "string" && typeof b === "string") {
    let diffs = diff(a, b, {
      checkLines: true
    });
    if (diffs.length > 2) {
      diffs = cleanupSemantic(diffs);
      diffs = cleanupEfficiency(diffs);
    }
    return _make(a, diffs, getDefaultOpts(options));
  }
  if (a && Array.isArray(a) && typeof b === "undefined") {
    return _make(diffText1(a), a, getDefaultOpts(options));
  }
  if (typeof a === "string" && b && Array.isArray(b)) {
    return _make(a, b, getDefaultOpts(options));
  }
  throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
  if (diffs.length === 0) {
    return [];
  }
  const patches = [];
  let patch = createPatchObject(0, 0);
  let patchDiffLength = 0;
  let charCount1 = 0;
  let charCount2 = 0;
  let utf8Count1 = 0;
  let utf8Count2 = 0;
  let prepatchText = textA;
  let postpatchText = textA;
  for (let x = 0; x < diffs.length; x++) {
    const currentDiff = diffs[x];
    const [diffType, diffText] = currentDiff;
    const diffTextLength = diffText.length;
    const diffByteLength = countUtf8Bytes(diffText);
    if (!patchDiffLength && diffType !== DIFF_EQUAL) {
      patch.start1 = charCount1;
      patch.start2 = charCount2;
      patch.utf8Start1 = utf8Count1;
      patch.utf8Start2 = utf8Count2;
    }
    switch (diffType) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = currentDiff;
        patch.length2 += diffTextLength;
        patch.utf8Length2 += diffByteLength;
        postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
        break;
      case DIFF_DELETE:
        patch.length1 += diffTextLength;
        patch.utf8Length1 += diffByteLength;
        patch.diffs[patchDiffLength++] = currentDiff;
        postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
        break;
      case DIFF_EQUAL:
        if (diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1) {
          patch.diffs[patchDiffLength++] = currentDiff;
          patch.length1 += diffTextLength;
          patch.length2 += diffTextLength;
          patch.utf8Length1 += diffByteLength;
          patch.utf8Length2 += diffByteLength;
        } else if (diffTextLength >= 2 * options.margin) {
          if (patchDiffLength) {
            addContext(patch, prepatchText, options);
            patches.push(patch);
            patch = createPatchObject(-1, -1);
            patchDiffLength = 0;
            prepatchText = postpatchText;
            charCount1 = charCount2;
            utf8Count1 = utf8Count2;
          }
        }
        break;
      default:
        throw new Error("Unknown diff type");
    }
    if (diffType !== DIFF_INSERT) {
      charCount1 += diffTextLength;
      utf8Count1 += diffByteLength;
    }
    if (diffType !== DIFF_DELETE) {
      charCount2 += diffTextLength;
      utf8Count2 += diffByteLength;
    }
  }
  if (patchDiffLength) {
    addContext(patch, prepatchText, options);
    patches.push(patch);
  }
  return patches;
}
function addContext(patch, text, opts) {
  if (text.length === 0) {
    return;
  }
  let pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  let padding = 0;
  while (text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin) {
    padding += opts.margin;
    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
  }
  padding += opts.margin;
  let prefixStart = patch.start2 - padding;
  if (prefixStart >= 1 && isLowSurrogate(text[prefixStart])) {
    prefixStart--;
  }
  const prefix = text.substring(prefixStart, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  const prefixLength = prefix.length;
  const prefixUtf8Length = countUtf8Bytes(prefix);
  let suffixEnd = patch.start2 + patch.length1 + padding;
  if (suffixEnd < text.length && isLowSurrogate(text[suffixEnd])) {
    suffixEnd++;
  }
  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }
  const suffixLength = suffix.length;
  const suffixUtf8Length = countUtf8Bytes(suffix);
  patch.start1 -= prefixLength;
  patch.start2 -= prefixLength;
  patch.utf8Start1 -= prefixUtf8Length;
  patch.utf8Start2 -= prefixUtf8Length;
  patch.length1 += prefixLength + suffixLength;
  patch.length2 += prefixLength + suffixLength;
  patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length;
  patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
function levenshtein(diffs) {
  let leven = 0;
  let insertions = 0;
  let deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0];
    const data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        leven += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  leven += Math.max(insertions, deletions);
  return leven;
}
function xIndex(diffs, loc) {
  let chars1 = 0;
  let chars2 = 0;
  let lastChars1 = 0;
  let lastChars2 = 0;
  let x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {
      break;
    }
    lastChars1 = chars1;
    lastChars2 = chars2;
  }
  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE) {
    return lastChars2;
  }
  return lastChars2 + (loc - lastChars1);
}
function addPadding(patches) {
  let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MARGIN;
  const paddingLength = margin;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }
  for (const p of patches) {
    p.start1 += paddingLength;
    p.start2 += paddingLength;
    p.utf8Start1 += paddingLength;
    p.utf8Start2 += paddingLength;
  }
  let patch = patches[0];
  let diffs = patch.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) {
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;
    patch.start2 -= paddingLength;
    patch.utf8Start1 -= paddingLength;
    patch.utf8Start2 -= paddingLength;
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
    patch.utf8Length1 += paddingLength;
    patch.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length;
    const extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.utf8Start1 -= extraLength;
    patch.utf8Start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
    patch.utf8Length1 += extraLength;
    patch.utf8Length2 += extraLength;
  }
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) {
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
    patch.utf8Length1 += paddingLength;
    patch.utf8Length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
    patch.utf8Length1 += extraLength;
    patch.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function splitMax(patches) {
  let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MARGIN;
  const patchSize = MAX_BITS;
  for (let x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patchSize) {
      continue;
    }
    const bigpatch = patches[x];
    patches.splice(x--, 1);
    let start1 = bigpatch.start1;
    let start2 = bigpatch.start2;
    let preContext = "";
    while (bigpatch.diffs.length !== 0) {
      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
      let empty = true;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes(preContext);
        patch.length1 = preContext.length;
        patch.utf8Length1 = precontextByteCount;
        patch.length2 = preContext.length;
        patch.utf8Length2 = precontextByteCount;
        patch.diffs.push([DIFF_EQUAL, preContext]);
      }
      while (bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1];
        let diffTextByteCount = countUtf8Bytes(diffText);
        if (diffType === DIFF_INSERT) {
          patch.length2 += diffText.length;
          patch.utf8Length2 += diffTextByteCount;
          start2 += diffText.length;
          const diff = bigpatch.diffs.shift();
          if (diff) {
            patch.diffs.push(diff);
          }
          empty = false;
        } else if (diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize) {
          patch.length1 += diffText.length;
          patch.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          empty = false;
          patch.diffs.push([diffType, diffText]);
          bigpatch.diffs.shift();
        } else {
          diffText = diffText.substring(0, patchSize - patch.length1 - margin);
          diffTextByteCount = countUtf8Bytes(diffText);
          patch.length1 += diffText.length;
          patch.utf8Length1 += diffTextByteCount;
          start1 += diffText.length;
          if (diffType === DIFF_EQUAL) {
            patch.length2 += diffText.length;
            patch.utf8Length2 += diffTextByteCount;
            start2 += diffText.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diffType, diffText]);
          if (diffText === bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length);
          }
        }
      }
      preContext = diffText2(patch.diffs);
      preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText1(bigpatch.diffs).substring(0, margin);
      const postContextByteCount = countUtf8Bytes(postContext);
      if (postContext !== "") {
        patch.length1 += postContext.length;
        patch.length2 += postContext.length;
        patch.utf8Length1 += postContextByteCount;
        patch.utf8Length2 += postContextByteCount;
        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postContext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postContext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
}
function apply$4(patches, originalText) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (typeof patches === "string") {
    throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  }
  let text = originalText;
  if (patches.length === 0) {
    return [text, []];
  }
  const parsed = adjustIndiciesToUcs2(patches, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  });
  const margin = opts.margin || DEFAULT_MARGIN;
  const deleteThreshold = opts.deleteThreshold || 0.4;
  const nullPadding = addPadding(parsed, margin);
  text = nullPadding + text + nullPadding;
  splitMax(parsed, margin);
  let delta = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta;
    const text1 = diffText1(parsed[x].diffs);
    let startLoc;
    let endLoc = -1;
    if (text1.length > MAX_BITS) {
      startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc);
      if (startLoc !== -1) {
        endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS);
        if (endLoc === -1 || startLoc >= endLoc) {
          startLoc = -1;
        }
      }
    } else {
      startLoc = match(text, text1, expectedLoc);
    }
    if (startLoc === -1) {
      results[x] = false;
      delta -= parsed[x].length2 - parsed[x].length1;
    } else {
      results[x] = true;
      delta = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1) {
        text2 = text.substring(startLoc, startLoc + text1.length);
      } else {
        text2 = text.substring(startLoc, endLoc + MAX_BITS);
      }
      if (text1 === text2) {
        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
      } else {
        let diffs = diff(text1, text2, {
          checkLines: false
        });
        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) {
          results[x] = false;
        } else {
          diffs = cleanupSemanticLossless(diffs);
          let index1 = 0;
          let index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {
              text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2);
            } else if (mod[0] === DIFF_DELETE) {
              text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
}
function stringify(patches) {
  return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch) {
  const {
    utf8Length1,
    utf8Length2,
    utf8Start1,
    utf8Start2,
    diffs
  } = patch;
  let coords1;
  if (utf8Length1 === 0) {
    coords1 = "".concat(utf8Start1, ",0");
  } else if (utf8Length1 === 1) {
    coords1 = "".concat(utf8Start1 + 1);
  } else {
    coords1 = "".concat(utf8Start1 + 1, ",").concat(utf8Length1);
  }
  let coords2;
  if (utf8Length2 === 0) {
    coords2 = "".concat(utf8Start2, ",0");
  } else if (utf8Length2 === 1) {
    coords2 = "".concat(utf8Start2 + 1);
  } else {
    coords2 = "".concat(utf8Start2 + 1, ",").concat(utf8Length2);
  }
  const text = ["@@ -".concat(coords1, " +").concat(coords2, " @@\n")];
  let op;
  for (let x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        op = "+";
        break;
      case DIFF_DELETE:
        op = "-";
        break;
      case DIFF_EQUAL:
        op = " ";
        break;
      default:
        throw new Error("Unknown patch operation.");
    }
    text[x + 1] = "".concat(op + encodeURI(diffs[x][1]), "\n");
  }
  return text.join("").replace(/%20/g, " ");
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
  if (!textline) {
    return [];
  }
  const patches = [];
  const lines = textline.split("\n");
  let textPointer = 0;
  while (textPointer < lines.length) {
    const m = lines[textPointer].match(patchHeader);
    if (!m) {
      throw new Error("Invalid patch string: ".concat(lines[textPointer]));
    }
    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
    patches.push(patch);
    if (m[2] === "") {
      patch.start1--;
      patch.utf8Start1--;
      patch.length1 = 1;
      patch.utf8Length1 = 1;
    } else if (m[2] === "0") {
      patch.length1 = 0;
      patch.utf8Length1 = 0;
    } else {
      patch.start1--;
      patch.utf8Start1--;
      patch.utf8Length1 = toInt(m[2]);
      patch.length1 = patch.utf8Length1;
    }
    if (m[4] === "") {
      patch.start2--;
      patch.utf8Start2--;
      patch.length2 = 1;
      patch.utf8Length2 = 1;
    } else if (m[4] === "0") {
      patch.length2 = 0;
      patch.utf8Length2 = 0;
    } else {
      patch.start2--;
      patch.utf8Start2--;
      patch.utf8Length2 = toInt(m[4]);
      patch.length2 = patch.utf8Length2;
    }
    textPointer++;
    while (textPointer < lines.length) {
      const currentLine = lines[textPointer];
      const sign = currentLine.charAt(0);
      if (sign === "@") {
        break;
      }
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch (ex) {
        throw new Error("Illegal escape in parse: ".concat(currentLine));
      }
      const utf8Diff = countUtf8Bytes(line) - line.length;
      if (sign === "-") {
        patch.diffs.push([DIFF_DELETE, line]);
        patch.length1 -= utf8Diff;
      } else if (sign === "+") {
        patch.diffs.push([DIFF_INSERT, line]);
        patch.length2 -= utf8Diff;
      } else if (sign === " ") {
        patch.diffs.push([DIFF_EQUAL, line]);
        patch.length1 -= utf8Diff;
        patch.length2 -= utf8Diff;
      } else {
        throw new Error("Invalid patch mode \"".concat(sign, "\" in: ").concat(line));
      }
      textPointer++;
    }
  }
  return patches;
}
function toInt(num) {
  return parseInt(num, 10);
}
function setIfMissing(value) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    type: "setIfMissing",
    path,
    value
  };
}
function diffMatchPatch$1(currentValue, nextValue) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const patches = make(currentValue, nextValue);
  const patch = stringify(patches);
  return {
    type: "diffMatchPatch",
    path,
    value: patch
  };
}
function insert$1(items, position) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return {
    type: "insert",
    path,
    position,
    items
  };
}
function set(value) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    type: "set",
    path,
    value
  };
}
function unset() {
  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    type: "unset",
    path
  };
}
const debug$j = debugWithName("operationToPatches");
debug$j.enabled = false;
function createOperationToPatches(types) {
  const textBlockName = types.block.name;
  function insertTextPatch(editor, operation, beforeValue) {
    if (debug$j.enabled) {
      debug$j("Operation", JSON.stringify(operation, null, 2));
    }
    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const prevBlock = beforeValue[operation.path[0]];
    const prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
    const prevText = editor.isTextSpan(prevChild) ? prevChild.text : "";
    const patch = diffMatchPatch$1(prevText, textChild.text, path);
    return patch.value.length ? [patch] : [];
  }
  function removeTextPatch(editor, operation, beforeValue) {
    const block = editor && editor.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0;
    const textChild = editor.isTextSpan(child) ? child : void 0;
    if (child && !textChild) {
      throw new Error("Expected span");
    }
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const beforeBlock = beforeValue[operation.path[0]];
    const prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
    const prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text;
    const patch = diffMatchPatch$1(prevText || "", textChild.text, path);
    return patch.value ? [patch] : [];
  }
  function setNodePatch(editor, operation) {
    if (operation.path.length === 1) {
      const block = editor.children[operation.path[0]];
      if (typeof block._key !== "string") {
        throw new Error("Expected block to have a _key");
      }
      const setNode = omitBy__default.default({
        ...editor.children[operation.path[0]],
        ...operation.newProperties
      }, isUndefined__default.default);
      return [set(fromSlateValue([setNode], textBlockName)[0], [{
        _key: block._key
      }])];
    } else if (operation.path.length === 2) {
      const block = editor.children[operation.path[0]];
      if (editor.isTextBlock(block)) {
        const child = block.children[operation.path[1]];
        if (child) {
          const blockKey = block._key;
          const childKey = child._key;
          const patches = [];
          Object.keys(operation.newProperties).forEach(keyName => {
            const val = get__default.default(operation.newProperties, keyName);
            patches.push(set(val, [{
              _key: blockKey
            }, "children", {
              _key: childKey
            }, keyName]));
          });
          return patches;
        }
        throw new Error("Could not find a valid child");
      }
      throw new Error("Could not find a valid block");
    } else {
      throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
    }
  }
  function insertNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    const isTextBlock = editor.isTextBlock(block);
    if (operation.path.length === 1) {
      const position = operation.path[0] === 0 ? "before" : "after";
      const beforeBlock = beforeValue[operation.path[0] - 1];
      const targetKey = operation.path[0] === 0 ? block == null ? void 0 : block._key : beforeBlock == null ? void 0 : beforeBlock._key;
      if (targetKey) {
        return [insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [{
          _key: targetKey
        }])];
      }
      return [setIfMissing(beforeValue, []), insert$1([fromSlateValue([operation.node], textBlockName)[0]], "before", [operation.path[0]])];
    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {
      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after";
      const node = {
        ...operation.node
      };
      if (!node._type && slate.Text.isText(node)) {
        node._type = "span";
        node.marks = [];
      }
      const blk = fromSlateValue([{
        _key: "bogus",
        _type: textBlockName,
        children: [node]
      }], textBlockName)[0];
      const child = blk.children[0];
      return [insert$1([child], position, [{
        _key: block._key
      }, "children", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {
        _key: block.children[operation.path[1] - 1]._key
      }])];
    }
    debug$j("Something was inserted into a void block. Not producing editor patches.");
    return [];
  }
  function splitNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const splitBlock = editor.children[operation.path[0]];
    if (!editor.isTextBlock(splitBlock)) {
      throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
    }
    if (operation.path.length === 1) {
      const oldBlock = beforeValue[operation.path[0]];
      if (editor.isTextBlock(oldBlock)) {
        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
        if (targetValue) {
          patches.push(insert$1([targetValue], "after", [{
            _key: splitBlock._key
          }]));
          const spansToUnset = oldBlock.children.slice(operation.position);
          spansToUnset.forEach(span => {
            const path = [{
              _key: oldBlock._key
            }, "children", {
              _key: span._key
            }];
            patches.push(unset(path));
          });
        }
      }
      return patches;
    }
    if (operation.path.length === 2) {
      const splitSpan = splitBlock.children[operation.path[1]];
      if (editor.isTextSpan(splitSpan)) {
        const targetSpans = fromSlateValue([{
          ...splitBlock,
          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
        }], textBlockName)[0].children;
        patches.push(insert$1(targetSpans, "after", [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }]));
        patches.push(set(splitSpan.text, [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }, "text"]));
      }
      return patches;
    }
    return patches;
  }
  function removeNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
      if (block && block._key) {
        return [unset([{
          _key: block._key
        }])];
      }
      throw new Error("Block not found");
    } else if (editor.isTextBlock(block) && operation.path.length === 2) {
      const spanToRemove = editor.isTextBlock(block) && block.children && block.children[operation.path[1]];
      if (spanToRemove) {
        return [unset([{
          _key: block._key
        }, "children", {
          _key: spanToRemove._key
        }])];
      }
      debug$j("Span not found in editor trying to remove node");
      return [];
    } else {
      debug$j("Not creating patch inside object block");
      return [];
    }
  }
  function mergeNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = editor.children[operation.path[0]];
    if (operation.path.length === 1) {
      if (block == null ? void 0 : block._key) {
        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
        patches.push(set(newBlock, [{
          _key: newBlock._key
        }]));
        patches.push(unset([{
          _key: block._key
        }]));
      } else {
        throw new Error("Target key not found!");
      }
    } else if (operation.path.length === 2 && editor.isTextBlock(targetBlock)) {
      const mergedSpan = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0;
      const targetSpan = targetBlock.children[operation.path[1] - 1];
      if (editor.isTextSpan(targetSpan)) {
        patches.push(set(targetSpan.text, [{
          _key: block._key
        }, "children", {
          _key: targetSpan._key
        }, "text"]));
        if (mergedSpan) {
          patches.push(unset([{
            _key: block._key
          }, "children", {
            _key: mergedSpan._key
          }]));
        }
      }
    } else {
      debug$j("Void nodes can't be merged, not creating any patches");
    }
    return patches;
  }
  function moveNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = beforeValue[operation.newPath[0]];
    if (operation.path.length === 1) {
      const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
      patches.push(unset([{
        _key: block._key
      }]));
      patches.push(insert$1([fromSlateValue([block], textBlockName)[0]], position, [{
        _key: targetBlock._key
      }]));
    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {
      const child = block.children[operation.path[1]];
      const targetChild = targetBlock.children[operation.newPath[1]];
      const position = operation.newPath[1] === targetBlock.children.length ? "after" : "before";
      const childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
      patches.push(unset([{
        _key: block._key
      }, "children", {
        _key: child._key
      }]));
      patches.push(insert$1([childToInsert], position, [{
        _key: targetBlock._key
      }, "children", {
        _key: targetChild._key
      }]));
    }
    return patches;
  }
  return {
    insertNodePatch,
    insertTextPatch,
    mergeNodePatch,
    moveNodePatch,
    removeNodePatch,
    removeTextPatch,
    setNodePatch,
    splitNodePatch
  };
}
const debug$i = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(types, change$) {
  return function withPortableTextMarkModel(editor) {
    const {
      apply,
      normalizeNode
    } = editor;
    const decorators = types.decorators.map(t => t.value);
    const forceNewSelection = () => {
      if (editor.selection) {
        slate.Transforms.select(editor, {
          ...editor.selection
        });
        editor.selection = {
          ...editor.selection
        };
      }
      const ptRange = toPortableTextRange(editor.children, editor.selection, types);
      change$.next({
        type: "selection",
        selection: ptRange
      });
    };
    editor.normalizeNode = nodeEntry => {
      normalizeNode(nodeEntry);
      if (editor.operations.some(op => ["insert_node", "insert_text", "merge_node", "remove_node", "remove_text", "set_node"].includes(op.type))) {
        mergeSpans(editor);
      }
      const [node, path] = nodeEntry;
      const isSpan = slate.Text.isText(node) && node._type === types.span.name;
      const isTextBlock = editor.isTextBlock(node);
      if (isSpan || isTextBlock) {
        if (isSpan && !Array.isArray(node.marks)) {
          debug$i("Adding .marks to span node");
          slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path
          });
          editor.onChange();
        }
        for (const op of editor.operations) {
          if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
            const [targetBlock, targetPath] = slate.Editor.node(editor, [op.path[0] - 1]);
            debug$i("Copying markDefs over to merged block", op);
            if (editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              const newMarkDefs = uniq__default.default([...oldDefs, ...op.properties.markDefs]);
              const isNormalized = isEqual__default.default(newMarkDefs, targetBlock.markDefs);
              if (!isNormalized) {
                slate.Transforms.setNodes(editor, {
                  markDefs: newMarkDefs
                }, {
                  at: targetPath,
                  voids: false
                });
                editor.onChange();
              }
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && slate.Element.isElementProps(op.properties) && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [targetBlock, targetPath] = slate.Editor.node(editor, [op.path[0] + 1]);
            debug$i("Copying markDefs over to split block", op);
            if (editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              slate.Transforms.setNodes(editor, {
                markDefs: uniq__default.default([...oldDefs, ...op.properties.markDefs])
              }, {
                at: targetPath,
                voids: false
              });
              editor.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 2 && op.properties._type === types.span.name && "marks" in op.properties && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [child, childPath] = slate.Editor.node(editor, [op.path[0] + 1, 0]);
            if (slate.Text.isText(child) && child.text === "" && Array.isArray(child.marks) && child.marks.length > 0) {
              slate.Transforms.setNodes(editor, {
                marks: []
              }, {
                at: childPath,
                voids: false
              });
              editor.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0) {
            const [block, blockPath] = slate.Editor.node(editor, [op.path[0]]);
            if (editor.isTextBlock(block) && block.children.length === 1 && block.markDefs && block.markDefs.length > 0 && slate.Text.isText(block.children[0]) && block.children[0].text === "" && (!block.children[0].marks || block.children[0].marks.length === 0)) {
              slate.Transforms.setNodes(editor, {
                markDefs: []
              }, {
                at: blockPath
              });
              editor.onChange();
            }
          }
        }
        if (isSpan && Array.isArray(node.marks) && (!node.marks || node.marks.length > 0 && node.text === "")) {
          slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path,
            voids: false
          });
          editor.onChange();
        }
      }
      if (isTextBlock && editor.operations.some(op => ["split_node", "remove_node", "remove_text", "merge_node"].includes(op.type))) {
        normalizeMarkDefs(editor, types);
      }
    };
    editor.apply = op => {
      var _a, _b;
      if (op.type === "insert_text") {
        const {
          selection
        } = editor;
        if (selection && slate.Range.isCollapsed(selection) && ((_b = (_a = slate.Editor.marks(editor)) == null ? void 0 : _a.marks) == null ? void 0 : _b.some(mark => !decorators.includes(mark)))) {
          const [node] = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: selection.focus,
            match: n => n._type === types.span.name,
            voids: false
          }))[0] || [void 0];
          if (slate.Text.isText(node) && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {
            apply(op);
            slate.Transforms.splitNodes(editor, {
              match: slate.Text.isText,
              at: {
                ...selection.focus,
                offset: selection.focus.offset
              }
            });
            const marksWithoutAnnotationMarks = ({
              ...(slate.Editor.marks(editor) || {})
            }.marks || []).filter(mark => decorators.includes(mark));
            slate.Transforms.setNodes(editor, {
              marks: marksWithoutAnnotationMarks
            }, {
              at: slate.Path.next(selection.focus.path)
            });
            debug$i("Inserting text at end of annotation");
            return;
          }
        }
      }
      apply(op);
    };
    editor.addMark = mark => {
      if (editor.selection) {
        if (slate.Range.isExpanded(editor.selection)) {
          slate.Transforms.setNodes(editor, {}, {
            match: slate.Text.isText,
            split: true
          });
          const splitTextNodes = [...slate.Editor.nodes(editor, {
            at: editor.selection,
            match: slate.Text.isText
          })];
          const shouldRemoveMark = flatten__default.default(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
          if (shouldRemoveMark) {
            editor.removeMark(mark);
            return editor;
          }
          slate.Editor.withoutNormalizing(editor, () => {
            splitTextNodes.forEach(_ref4 => {
              let [node, path] = _ref4;
              const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark), mark];
              slate.Transforms.setNodes(editor, {
                marks
              }, {
                at: path,
                match: slate.Text.isText,
                split: true,
                hanging: true
              });
            });
          });
          slate.Editor.normalize(editor);
        } else {
          const existingMarks = {
            ...(slate.Editor.marks(editor) || {})
          }.marks || [];
          const marks = {
            ...(slate.Editor.marks(editor) || {}),
            marks: [...existingMarks, mark]
          };
          editor.marks = marks;
          forceNewSelection();
          return editor;
        }
        editor.onChange();
        forceNewSelection();
      }
      return editor;
    };
    editor.removeMark = mark => {
      const {
        selection
      } = editor;
      if (selection) {
        if (slate.Range.isExpanded(selection)) {
          slate.Editor.withoutNormalizing(editor, () => {
            slate.Transforms.setNodes(editor, {}, {
              match: slate.Text.isText,
              split: true
            });
            if (editor.selection) {
              const splitTextNodes = [...slate.Editor.nodes(editor, {
                at: editor.selection,
                match: slate.Text.isText
              })];
              splitTextNodes.forEach(_ref5 => {
                let [node, path] = _ref5;
                const block = editor.children[path[0]];
                if (slate.Element.isElement(block) && block.children.includes(node)) {
                  slate.Transforms.setNodes(editor, {
                    marks: (Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark),
                    _type: "span"
                  }, {
                    at: path
                  });
                }
              });
            }
          });
          slate.Editor.normalize(editor);
        } else {
          const existingMarks = {
            ...(slate.Editor.marks(editor) || {})
          }.marks || [];
          const marks = {
            ...(slate.Editor.marks(editor) || {}),
            marks: existingMarks.filter(eMark => eMark !== mark)
          };
          editor.marks = {
            marks: marks.marks,
            _type: "span"
          };
          forceNewSelection();
          return editor;
        }
        editor.onChange();
        forceNewSelection();
      }
      return editor;
    };
    editor.pteIsMarkActive = mark => {
      if (!editor.selection) {
        return false;
      }
      let existingMarks = {
        ...(slate.Editor.marks(editor) || {})
      }.marks || [];
      if (slate.Range.isExpanded(editor.selection)) {
        Array.from(slate.Editor.nodes(editor, {
          match: slate.Text.isText,
          at: editor.selection
        })).forEach(n => {
          const [node] = n;
          existingMarks = uniq__default.default([...existingMarks, ...(node.marks || [])]);
        });
      }
      return existingMarks.includes(mark);
    };
    editor.pteToggleMark = mark => {
      const isActive = editor.pteIsMarkActive(mark);
      if (isActive) {
        debug$i("Remove mark '".concat(mark, "'"));
        slate.Editor.removeMark(editor, mark);
      } else {
        debug$i("Add mark '".concat(mark, "'"));
        slate.Editor.addMark(editor, mark, true);
      }
    };
    return editor;
  };
  function mergeSpans(editor) {
    const {
      selection
    } = editor;
    if (selection) {
      for (const [node, path] of Array.from(slate.Editor.nodes(editor, {
        at: slate.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
      })).reverse()) {
        const [parent] = path.length > 1 ? slate.Editor.node(editor, slate.Path.parent(path)) : [void 0];
        const nextPath = [path[0], path[1] + 1];
        if (editor.isTextBlock(parent)) {
          const nextNode = parent.children[nextPath[1]];
          if (slate.Text.isText(node) && slate.Text.isText(nextNode) && isEqual__default.default(nextNode.marks, node.marks)) {
            debug$i("Merging spans");
            slate.Transforms.mergeNodes(editor, {
              at: nextPath,
              voids: true
            });
            editor.onChange();
          }
        }
      }
    }
  }
}
function normalizeMarkDefs(editor, types) {
  const {
    selection
  } = editor;
  if (selection) {
    const blocks = slate.Editor.nodes(editor, {
      at: selection,
      match: n => n._type === types.block.name
    });
    for (const [block, path] of blocks) {
      if (editor.isTextBlock(block)) {
        const newMarkDefs = (block.markDefs || []).filter(def => {
          return block.children.find(child => {
            return slate.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key);
          });
        });
        if (!isEqual__default.default(newMarkDefs, block.markDefs)) {
          debug$i("Removing markDef not in use");
          slate.Transforms.setNodes(editor, {
            markDefs: newMarkDefs
          }, {
            at: path
          });
          editor.onChange();
        }
      }
    }
  }
}
const debug$h = debugWithName("API:editable");
function createWithEditableAPI(portableTextEditor, types, keyGenerator) {
  return function withEditableAPI(editor) {
    portableTextEditor.setEditable({
      focus: () => {
        slateReact.ReactEditor.focus(editor);
      },
      blur: () => {
        slateReact.ReactEditor.blur(editor);
      },
      toggleMark: mark => {
        editor.pteToggleMark(mark);
      },
      toggleList: listStyle => {
        editor.pteToggleListItem(listStyle);
      },
      toggleBlockStyle: blockStyle => {
        editor.pteToggleBlockStyle(blockStyle);
      },
      isMarkActive: mark => {
        try {
          return editor.pteIsMarkActive(mark);
        } catch (err) {
          console.warn(err);
          return false;
        }
      },
      marks: () => {
        return {
          ...(slate.Editor.marks(editor) || {})
        }.marks || [];
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      select: selection => {
        const slateSelection = toSlateRange(selection, editor);
        if (slateSelection) {
          slate.Transforms.select(editor, slateSelection);
        } else {
          slate.Transforms.deselect(editor);
        }
        editor.onChange();
      },
      focusBlock: () => {
        if (editor.selection) {
          const block = slate.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
          if (block) {
            return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
          }
        }
        return void 0;
      },
      focusChild: () => {
        if (editor.selection) {
          const block = slate.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
          if (block && editor.isTextBlock(block)) {
            const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
            return ptBlock.children[editor.selection.focus.path[1]];
          }
        }
        return void 0;
      },
      insertChild: (type, value) => {
        var _a;
        if (!editor.selection) {
          throw new Error("The editor has no selection");
        }
        const [focusBlock] = Array.from(slate.Editor.nodes(editor, {
          at: editor.selection.focus.path.slice(0, 1),
          match: n => n._type === types.block.name
        }))[0] || [void 0];
        if (!focusBlock) {
          throw new Error("No focused text block");
        }
        if (type.name !== types.span.name && !types.inlineObjects.some(t => t.name === type.name)) {
          throw new Error("This type cannot be inserted as a child to a text block");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: types.block.name,
          children: [{
            _key: keyGenerator(),
            _type: type.name,
            ...(value ? value : {})
          }]
        }], portableTextEditor)[0];
        const child = block.children[0];
        const focusChildPath = editor.selection.focus.path.slice(0, 2);
        const isSpanNode = child._type === types.span.name;
        const focusNode = slate.Node.get(editor, focusChildPath);
        if (isSpanNode && focusNode._type !== types.span.name) {
          debug$h("Inserting span child next to inline object child, moving selection + 1");
          editor.move({
            distance: 1,
            unit: "character"
          });
        }
        slate.Transforms.insertNodes(editor, child, {
          select: true,
          at: editor.selection
        });
        editor.onChange();
        return ((_a = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)) == null ? void 0 : _a.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _a;
        if (!editor.selection) {
          throw new Error("The editor has no selection");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: type.name,
          ...(value ? value : {})
        }], portableTextEditor)[0];
        const [focusBlock] = Array.from(slate.Editor.nodes(editor, {
          at: editor.selection.focus.path.slice(0, 1),
          match: n => n._type === types.block.name
        }))[0] || [void 0];
        const isEmptyTextBlock = focusBlock && isEqualToEmptyEditor([focusBlock], types);
        if (isEmptyTextBlock) {
          slate.Transforms.removeNodes(editor, {
            at: editor.selection
          });
        }
        slate.Editor.insertNode(editor, block);
        editor.onChange();
        return ((_a = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)) == null ? void 0 : _a.focus.path) || [];
      },
      hasBlockStyle: style => {
        try {
          return editor.pteHasBlockStyle(style);
        } catch (err) {
          return false;
        }
      },
      hasListStyle: listStyle => {
        try {
          return editor.pteHasListStyle(listStyle);
        } catch (err) {
          return false;
        }
      },
      isVoid: element => {
        return ![types.block.name, types.span.name].includes(element._type);
      },
      findByPath: path => {
        const slatePath = toSlateRange({
          focus: {
            path,
            offset: 0
          },
          anchor: {
            path,
            offset: 0
          }
        }, editor);
        if (slatePath) {
          const [block, blockPath] = slate.Editor.node(editor, slatePath.focus.path.slice(0, 1));
          if (block && blockPath && typeof block._key === "string") {
            if (path.length === 1 && slatePath.focus.path.length === 1) {
              return [fromSlateValue([block], types.block.name)[0], [{
                _key: block._key
              }]];
            }
            const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
            if (editor.isTextBlock(ptBlock)) {
              const ptChild = ptBlock.children[slatePath.focus.path[1]];
              if (ptChild) {
                return [ptChild, [{
                  _key: block._key
                }, "children", {
                  _key: ptChild._key
                }]];
              }
            }
          }
        }
        return [void 0, void 0];
      },
      findDOMNode: element => {
        let node;
        try {
          const [item] = Array.from(slate.Editor.nodes(editor, {
            at: [],
            match: n => n._key === element._key
          }) || [])[0] || [void 0];
          node = slateReact.ReactEditor.toDOMNode(editor, item);
        } catch (err) {}
        return node;
      },
      activeAnnotations: () => {
        var _a;
        if (!editor.selection || editor.selection.focus.path.length < 2) {
          return [];
        }
        try {
          const activeAnnotations = [];
          const spans = slate.Editor.nodes(editor, {
            at: editor.selection,
            match: node => slate.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
          });
          for (const [span, path] of spans) {
            const [block] = slate.Editor.node(editor, path, {
              depth: 1
            });
            if (editor.isTextBlock(block)) {
              (_a = block.markDefs) == null ? void 0 : _a.forEach(def => {
                if (slate.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                  activeAnnotations.push(def);
                }
              });
            }
          }
          return activeAnnotations;
        } catch (err) {
          return [];
        }
      },
      addAnnotation: (type, value) => {
        const {
          selection
        } = editor;
        if (selection) {
          const [block] = slate.Editor.node(editor, selection.focus, {
            depth: 1
          });
          if (slate.Element.isElement(block) && block._type === types.block.name) {
            const annotationKey = keyGenerator();
            if (editor.isTextBlock(block)) {
              slate.Transforms.setNodes(editor, {
                markDefs: [...(block.markDefs || []), {
                  _type: type.name,
                  _key: annotationKey,
                  ...value
                }]
              }, {
                at: selection.focus
              });
              editor.onChange();
              if (slate.Range.isCollapsed(selection)) {
                editor.pteExpandToWord();
                editor.onChange();
              }
              const [textNode] = slate.Editor.node(editor, selection.focus, {
                depth: 2
              });
              if (editor.selection) {
                slate.Editor.withoutNormalizing(editor, () => {
                  slate.Transforms.setNodes(editor, {}, {
                    match: slate.Text.isText,
                    split: true
                  });
                  if (editor.selection && slate.Text.isText(textNode)) {
                    slate.Transforms.setNodes(editor, {
                      marks: [...(textNode.marks || []), annotationKey]
                    }, {
                      at: editor.selection,
                      match: n => n._type === types.span.name
                    });
                    editor.onChange();
                  }
                });
                slate.Editor.normalize(editor);
                editor.onChange();
                const newSelection = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types);
                if (newSelection && typeof block._key === "string") {
                  slate.Editor.withoutNormalizing(editor, () => {
                    if (editor.selection) {
                      slate.Transforms.insertNodes(editor, [{
                        _type: "span",
                        text: "",
                        marks: [],
                        _key: keyGenerator()
                      }], {
                        at: slate.Range.end(editor.selection)
                      });
                      editor.onChange();
                    }
                  });
                  return {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{
                      _key: block._key
                    }, "markDefs", {
                      _key: annotationKey
                    }]
                  };
                }
              }
            }
          }
        }
        return void 0;
      },
      delete: (selection, options) => {
        if (selection) {
          const range = toSlateRange(selection, editor);
          const hasRange = range && range.anchor.path.length > 0 && range.focus.path.length > 0;
          if (!hasRange) {
            throw new Error("Invalid range");
          }
          if (range) {
            if (!(options == null ? void 0 : options.mode) || (options == null ? void 0 : options.mode) === "selected") {
              debug$h("Deleting content in selection");
              slate.Transforms.delete(editor, {
                at: range,
                hanging: true,
                voids: true
              });
              editor.onChange();
              return;
            }
            if ((options == null ? void 0 : options.mode) === "blocks") {
              debug$h("Deleting blocks touched by selection");
              slate.Transforms.removeNodes(editor, {
                at: range,
                voids: true,
                match: node => {
                  return editor.isTextBlock(node) || !editor.isTextBlock(node) && slate.Element.isElement(node);
                }
              });
            }
            if ((options == null ? void 0 : options.mode) === "children") {
              debug$h("Deleting children touched by selection");
              slate.Transforms.removeNodes(editor, {
                at: range,
                voids: true,
                match: node => {
                  return node._type === types.span.name ||
                  // Text children
                  !editor.isTextBlock(node) && slate.Element.isElement(node);
                }
              });
            }
            if (editor.children.length === 0) {
              editor.children = [editor.createPlaceholderBlock()];
            }
            editor.onChange();
          }
        }
      },
      removeAnnotation: type => {
        let {
          selection
        } = editor;
        debug$h("Removing annotation", type);
        if (selection) {
          if (slate.Range.isCollapsed(selection)) {
            const [node, nodePath] = slate.Editor.node(editor, selection, {
              depth: 2
            });
            if (slate.Text.isText(node) && node.marks && typeof node.text === "string") {
              slate.Transforms.select(editor, nodePath);
              selection = editor.selection;
            }
          }
          slate.Editor.withoutNormalizing(editor, () => {
            if (selection && slate.Range.isExpanded(selection)) {
              selection = editor.selection;
              if (!selection) {
                return;
              }
              const blocks = [...slate.Editor.nodes(editor, {
                at: selection,
                match: node => {
                  return editor.isTextBlock(node) && Array.isArray(node.markDefs) && node.markDefs.some(def => def._type === type.name);
                }
              })];
              blocks.forEach(_ref6 => {
                let [block] = _ref6;
                if (editor.isTextBlock(block) && Array.isArray(block.markDefs)) {
                  const marksToRemove = block.markDefs.filter(def => def._type === type.name);
                  marksToRemove.forEach(def => {
                    slate.Editor.removeMark(editor, def._key);
                  });
                }
              });
              normalizeMarkDefs(editor, types);
            }
          });
          slate.Editor.normalize(editor);
          editor.onChange();
        }
      },
      getSelection: () => {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing) {
            return existing;
          }
          ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types);
          SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
        }
        return ptRange;
      },
      getValue: () => {
        return fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
      },
      isCollapsedSelection: () => {
        return !!editor.selection && slate.Range.isCollapsed(editor.selection);
      },
      isExpandedSelection: () => {
        return !!editor.selection && slate.Range.isExpanded(editor.selection);
      },
      insertBreak: () => {
        editor.insertBreak();
        editor.onChange();
      },
      getFragment: () => {
        return fromSlateValue(editor.getFragment(), types.block.name);
      }
    });
    return editor;
  };
}
function createWithMaxBlocks(maxBlocks) {
  return function withMaxBlocks(editor) {
    const {
      apply
    } = editor;
    editor.apply = operation => {
      const rows = maxBlocks;
      if (rows > 0 && editor.children.length >= rows) {
        if ((operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1) {
          return;
        }
      }
      apply(operation);
    };
    return editor;
  };
}
const PRESERVE_KEYS = /* @__PURE__ */new WeakMap();
function withPreserveKeys(editor, fn) {
  const prev = isPreservingKeys(editor);
  PRESERVE_KEYS.set(editor, true);
  fn();
  PRESERVE_KEYS.set(editor, prev);
}
function isPreservingKeys(editor) {
  return PRESERVE_KEYS.get(editor);
}
function createWithObjectKeys(schemaTypes, keyGenerator) {
  return function withKeys(editor) {
    PRESERVE_KEYS.set(editor, false);
    const {
      apply,
      normalizeNode
    } = editor;
    editor.apply = operation => {
      if (operation.type === "split_node") {
        operation.properties = {
          ...operation.properties,
          _key: keyGenerator()
        };
      }
      if (operation.type === "insert_node") {
        const withNewKey = !isPreservingKeys(editor) || !("_key" in operation.node);
        if (!slate.Editor.isEditor(operation.node)) {
          operation.node = {
            ...operation.node,
            ...(withNewKey ? {
              _key: keyGenerator()
            } : {})
          };
        }
      }
      apply(operation);
    };
    editor.normalizeNode = entry => {
      const [node, path] = entry;
      if (slate.Element.isElement(node) && node._type === schemaTypes.block.name) {
        if (!node._key) {
          slate.Transforms.setNodes(editor, {
            _key: keyGenerator()
          }, {
            at: path
          });
        }
        for (const [child, childPath] of slate.Node.children(editor, path)) {
          if (!child._key) {
            slate.Transforms.setNodes(editor, {
              _key: keyGenerator()
            }, {
              at: childPath
            });
            return;
          }
        }
      }
      normalizeNode(entry);
    };
    return editor;
  };
}
const BEFORE = "before";
const AFTER = "after";
function insert(array, position, index) {
  if (position !== BEFORE && position !== AFTER) {
    throw new Error('Invalid position "'.concat(position, '", must be either ').concat(BEFORE, " or ").concat(AFTER));
  }
  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }
  const items = flatten(...args);
  if (array.length === 0) {
    return items;
  }
  const len = array.length;
  const idx = Math.abs((len + index) % len) % len;
  const normalizedIdx = position === "after" ? idx + 1 : idx;
  const copy = array.slice();
  copy.splice(normalizedIdx, 0, ...flatten(items));
  return copy;
}
function flatten() {
  for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    values[_key3] = arguments[_key3];
  }
  return values.reduce((prev, item) => prev.concat(item), []);
}
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from, to) {
  const nextValue = arr.slice();
  const val = nextValue[from];
  nextValue.splice(from, 1);
  nextValue.splice(to, 0, val);
  return nextValue;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? false : index;
}
function apply$3(value, patch) {
  const nextValue = value.slice();
  if (patch.path.length === 0) {
    if (patch.type === "setIfMissing") {
      if (!Array.isArray(patch.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return value === void 0 ? patch.value : value;
    } else if (patch.type === "set") {
      if (!Array.isArray(patch.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return patch.value;
    } else if (patch.type === "unset") {
      return void 0;
    } else if (patch.type === "move") {
      if (!patch.value || !hasOwn(patch.value, "from") || !hasOwn(patch.value, "to")) {
        throw new Error('Invalid value of \'move\' patch. Expected a value with "from" and "to" indexes, instead got: '.concat(JSON.stringify(patch.value)));
      }
      return move(nextValue, patch.value.from, patch.value.to);
    }
    throw new Error("Invalid array operation: ".concat(patch.type));
  }
  const [head, ...tail] = patch.path;
  const index = findTargetIndex(value, head);
  if (index === false) {
    return nextValue;
  }
  if (tail.length === 0) {
    if (patch.type === "insert") {
      const {
        position,
        items
      } = patch;
      return insert(value, position, index, items);
    } else if (patch.type === "unset") {
      if (typeof index !== "number") {
        throw new Error('Expected array index to be a number, instead got "'.concat(index, '"'));
      }
      nextValue.splice(index, 1);
      return nextValue;
    }
  }
  nextValue[index] = _apply(nextValue[index], {
    ...patch,
    path: tail
  });
  return nextValue;
}
function apply$2(value, patch) {
  const nextValue = clone__default.default(value);
  if (patch.path.length === 0) {
    if (patch.type === "set") {
      if (!isObject__default.default(patch.value)) {
        throw new Error("Cannot set value of an object to a non-object");
      }
      return patch.value;
    } else if (patch.type === "unset") {
      return void 0;
    } else if (patch.type === "setIfMissing") {
      return value === void 0 ? patch.value : value;
    }
    throw new Error("Invalid object operation: ".concat(patch.type));
  }
  const [head, ...tail] = patch.path;
  if (typeof head !== "string") {
    throw new Error("Expected field name to be a string, instad got: ".concat(head));
  }
  if (tail.length === 0 && patch.type === "unset") {
    return omit__default.default(nextValue, head);
  }
  nextValue[head] = _apply(nextValue[head], {
    ...patch,
    path: tail
  });
  return nextValue;
}
const OPERATIONS$1 = {
  replace(_currentValue, nextValue) {
    return nextValue;
  },
  set(_currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(_currentValue, _nextValue) {
    return void 0;
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
};
const SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type)) {
    throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch.type), '" for primitives. This is most likely a bug.'));
  }
  if (patch.path.length > 0) {
    throw new Error('Cannot apply deep operations on primitive values. Received patch with type "'.concat(patch.type, '" and path "').concat(patch.path.map(path => JSON.stringify(path)).join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  return OPERATIONS$1[patch.type](value, patch.value);
}
const OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
    return void 0;
  },
  diffMatchPatch(currentValue, nextValue) {
    const [result] = apply$4(parse(nextValue), currentValue, {
      allowExceedingIndices: true
    });
    return result;
  }
};
const SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch.type)) {
    throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch.type), '" for string. This is most likely a bug.'));
  }
  if (patch.path.length > 0) {
    throw new Error('Cannot apply deep operations on string values. Received patch with type "'.concat(patch.type, '" and path "').concat(patch.path.join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
  }
  const func = OPERATIONS[patch.type];
  if (func) {
    return func(value, patch.value);
  }
  throw new Error("Unknown patch type");
}
function applyAll(value, patches) {
  return patches.reduce(_apply, value);
}
function applyPatch(value, patch) {
  if (Array.isArray(value)) {
    return apply$3(value, patch);
  }
  if (isString__default.default(value)) {
    return apply(value, patch);
  }
  if (isObject__default.default(value)) {
    return apply$2(value, patch);
  }
  return apply$1(value, patch);
}
function _apply(value, patch) {
  const res = applyPatch(value, patch);
  return res;
}
const debug$g = debugWithName("applyPatches");
const debugVerbose$3 = debug$g.enabled && true;
function createApplyPatch(schemaTypes) {
  let previousPatch;
  return function (editor, patch) {
    let changed = false;
    if (debugVerbose$3) {
      debug$g("\n\nNEW PATCH =============================================================");
      debug$g(JSON.stringify(patch, null, 2));
    }
    try {
      switch (patch.type) {
        case "insert":
          changed = insertPatch(editor, patch, schemaTypes);
          break;
        case "unset":
          changed = unsetPatch(editor, patch, previousPatch);
          break;
        case "set":
          changed = setPatch(editor, patch);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor, patch);
          break;
        default:
          debug$g("Unhandled patch", patch.type);
      }
    } catch (err) {
      console.error(err);
    }
    previousPatch = patch;
    return changed;
  };
}
function diffMatchPatch(editor, patch) {
  const {
    block,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!block) {
    debug$g("Block not found");
    return false;
  }
  if (!child || !childPath) {
    debug$g("Child not found");
    return false;
  }
  const isSpanTextDiffMatchPatch = block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === "children" && patch.path[3] === "text";
  if (!isSpanTextDiffMatchPatch || !slate.Text.isText(child)) {
    return false;
  }
  const patches = parse(patch.value);
  const [newValue] = apply$4(patches, child.text, {
    allowExceedingIndices: true
  });
  const diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);
  debugState(editor, "before");
  let offset = 0;
  for (const [op, text] of diff$1) {
    if (op === DIFF_INSERT) {
      editor.apply({
        type: "insert_text",
        path: childPath,
        offset,
        text
      });
      offset += text.length;
    } else if (op === DIFF_DELETE) {
      editor.apply({
        type: "remove_text",
        path: childPath,
        offset,
        text
      });
    } else if (op === DIFF_EQUAL) {
      offset += text.length;
    }
  }
  debugState(editor, "after");
  return true;
}
function insertPatch(editor, patch, schemaTypes) {
  const {
    block: targetBlock,
    child: targetChild,
    blockPath: targetBlockPath,
    childPath: targetChildPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!targetBlock || !targetBlockPath) {
    debug$g("Block not found");
    return false;
  }
  if (patch.path.length > 1 && patch.path[1] !== "children") {
    debug$g("Ignoring patch targeting void value");
    return false;
  }
  if (patch.path.length === 1) {
    const {
      items: items2,
      position: position2
    } = patch;
    const blocksToInsert = toSlateValue(items2, {
      schemaTypes
    }, KEY_TO_SLATE_ELEMENT.get(editor));
    const targetBlockIndex = targetBlockPath[0];
    const normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex;
    debug$g("Inserting blocks at path [".concat(normalizedIdx2, "]"));
    debugState(editor, "before");
    slate.Transforms.insertNodes(editor, blocksToInsert, {
      at: [normalizedIdx2]
    });
    debugState(editor, "after");
    return true;
  }
  const {
    items,
    position
  } = patch;
  if (!targetChild || !targetChildPath) {
    debug$g("Child not found");
    return false;
  }
  const childrenToInsert = targetBlock && toSlateValue([{
    ...targetBlock,
    children: items
  }], {
    schemaTypes
  }, KEY_TO_SLATE_ELEMENT.get(editor));
  const targetChildIndex = targetChildPath[1];
  const normalizedIdx = position === "after" ? targetChildIndex + 1 : targetChildIndex;
  const childInsertPath = [targetChildPath[0], normalizedIdx];
  debug$g("Inserting children at path ".concat(childInsertPath));
  debugState(editor, "before");
  if (childrenToInsert && slate.Element.isElement(childrenToInsert[0])) {
    slate.Transforms.insertNodes(editor, childrenToInsert[0].children, {
      at: childInsertPath
    });
  }
  debugState(editor, "after");
  return true;
}
function setPatch(editor, patch) {
  let value = patch.value;
  if (typeof patch.path[3] === "string") {
    value = {};
    value[patch.path[3]] = patch.value;
  }
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!block) {
    debug$g("Block not found");
    return false;
  }
  const isTextBlock = editor.isTextBlock(block);
  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== "children") {
    debug$g("Ignoring setting void value");
    return false;
  }
  debugState(editor, "before");
  if (isTextBlock && child && childPath) {
    if (slate.Text.isText(value) && slate.Text.isText(child)) {
      const newText = child.text;
      const oldText = value.text;
      if (oldText !== newText) {
        debug$g("Setting text property");
        editor.apply({
          type: "remove_text",
          path: childPath,
          offset: 0,
          text: newText
        });
        editor.apply({
          type: "insert_text",
          path: childPath,
          offset: 0,
          text: value.text
        });
        editor.onChange();
      }
    } else {
      debug$g("Setting non-text property");
      editor.apply({
        type: "set_node",
        path: childPath,
        properties: {},
        newProperties: value
      });
    }
    return true;
  } else if (slate.Element.isElement(block) && patch.path.length === 1 && blockPath) {
    debug$g("Setting block property");
    const {
      children,
      ...nextRest
    } = value;
    const {
      children: prevChildren,
      ...prevRest
    } = block || {
      children: void 0
    };
    editor.apply({
      type: "set_node",
      path: blockPath,
      properties: {
        ...prevRest
      },
      newProperties: nextRest
    });
    block.children.forEach((c, cIndex) => {
      editor.apply({
        type: "remove_node",
        path: blockPath.concat(cIndex),
        node: c
      });
    });
    if (Array.isArray(children)) {
      children.forEach((c, cIndex) => {
        editor.apply({
          type: "insert_node",
          path: blockPath.concat(cIndex),
          node: c
        });
      });
    }
  } else if (block && "value" in block) {
    const newVal = applyAll([block.value], [patch])[0];
    slate.Transforms.setNodes(editor, {
      ...block,
      value: newVal
    }, {
      at: blockPath
    });
    return true;
  }
  debugState(editor, "after");
  return true;
}
function unsetPatch(editor, patch, previousPatch) {
  if (patch.path.length === 0) {
    debug$g("Removing everything");
    debugState(editor, "before");
    const previousSelection = editor.selection;
    slate.Transforms.deselect(editor);
    editor.children.forEach((c, i) => {
      slate.Transforms.removeNodes(editor, {
        at: [i]
      });
    });
    slate.Transforms.insertNodes(editor, editor.createPlaceholderBlock());
    if (previousSelection) {
      slate.Transforms.select(editor, {
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        }
      });
    }
    editor.onChange();
    debugState(editor, "after");
    return true;
  }
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (patch.path.length === 1) {
    if (!block || !blockPath) {
      debug$g("Block not found");
      return false;
    }
    const blockIndex = blockPath[0];
    debug$g("Removing block at path [".concat(blockIndex, "]"));
    debugState(editor, "before");
    slate.Transforms.removeNodes(editor, {
      at: [blockIndex]
    });
    debugState(editor, "after");
    return true;
  }
  if (editor.isTextBlock(block) && patch.path[1] === "children" && patch.path.length === 3) {
    if (!child || !childPath) {
      debug$g("Child not found");
      return false;
    }
    const childIndex = childPath[1];
    debug$g("Unsetting child at path ".concat(JSON.stringify(childPath)));
    debugState(editor, "before");
    if (debugVerbose$3) {
      debug$g("Removing child at path ".concat(JSON.stringify([childPath, childIndex])));
    }
    slate.Transforms.removeNodes(editor, {
      at: childPath
    });
    debugState(editor, "after");
    return true;
  }
  return false;
}
function isKeyedSegment(segment) {
  return typeof segment === "object" && "_key" in segment;
}
function debugState(editor, stateName) {
  if (!debugVerbose$3) {
    return;
  }
  debug$g("Children ".concat(stateName, ":"), JSON.stringify(editor.children, null, 2));
  debug$g("Selection ".concat(stateName, ": "), JSON.stringify(editor.selection, null, 2));
}
function findBlockFromPath(editor, path) {
  let blockIndex = -1;
  const block = editor.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];
    if (isMatch) {
      blockIndex = index;
    }
    return isMatch;
  });
  if (!block) {
    return {};
  }
  return {
    block,
    path: [blockIndex]
  };
}
function findBlockAndChildFromPath(editor, path) {
  const {
    block,
    path: blockPath
  } = findBlockFromPath(editor, path);
  if (!(slate.Element.isElement(block) && path[1] === "children")) {
    return {
      block,
      blockPath,
      child: void 0,
      childPath: void 0
    };
  }
  let childIndex = -1;
  const child = block.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];
    if (isMatch) {
      childIndex = index;
    }
    return isMatch;
  });
  if (!child) {
    return {
      block,
      blockPath,
      child: void 0,
      childPath: void 0
    };
  }
  return {
    block,
    child,
    blockPath,
    childPath: blockPath == null ? void 0 : blockPath.concat(childIndex)
  };
}
function withRemoteChanges(editor, fn) {
  const prev = isChangingRemotely(editor) || false;
  IS_PROCESSING_REMOTE_CHANGES.set(editor, true);
  fn();
  IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);
}
function isChangingRemotely(editor) {
  return IS_PROCESSING_REMOTE_CHANGES.get(editor);
}
function isChangingLocally(editor) {
  return IS_PROCESSING_LOCAL_CHANGES.get(editor);
}
const PATCHING = /* @__PURE__ */new WeakMap();
function withoutPatching(editor, fn) {
  const prev = isPatching(editor);
  PATCHING.set(editor, false);
  fn();
  PATCHING.set(editor, prev);
}
function isPatching(editor) {
  return PATCHING.get(editor);
}
const debug$f = debugWithName("plugin:withUndoRedo");
const debugVerbose$2 = debug$f.enabled && false;
const SAVING = /* @__PURE__ */new WeakMap();
const REMOTE_PATCHES = /* @__PURE__ */new WeakMap();
const UNDO_STEP_LIMIT = 1e3;
const isSaving = editor => {
  const state = SAVING.get(editor);
  return state === void 0 ? true : state;
};
const getRemotePatches = editor => {
  if (!REMOTE_PATCHES.get(editor)) {
    REMOTE_PATCHES.set(editor, []);
  }
  return REMOTE_PATCHES.get(editor) || [];
};
function createWithUndoRedo(options) {
  const {
    readOnly,
    patches$,
    blockSchemaType
  } = options;
  return editor => {
    let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);
    const remotePatches = getRemotePatches(editor);
    if (patches$) {
      editor.subscriptions.push(() => {
        debug$f("Subscribing to patches");
        const sub = patches$.subscribe(_ref7 => {
          let {
            patches,
            snapshot
          } = _ref7;
          let reset = false;
          patches.forEach(patch => {
            if (!reset && patch.origin !== "local" && remotePatches) {
              if (patch.type === "unset" && patch.path.length === 0) {
                debug$f("Someone else cleared the content, resetting undo/redo history");
                editor.history = {
                  undos: [],
                  redos: []
                };
                remotePatches.splice(0, remotePatches.length);
                SAVING.set(editor, true);
                reset = true;
                return;
              }
              remotePatches.push({
                patch,
                time: /* @__PURE__ */new Date(),
                snapshot,
                previousSnapshot
              });
            }
          });
          previousSnapshot = snapshot;
        });
        return () => {
          debug$f("Unsubscribing to patches");
          sub.unsubscribe();
        };
      });
    }
    editor.history = {
      undos: [],
      redos: []
    };
    const {
      apply
    } = editor;
    editor.apply = op => {
      if (readOnly) {
        apply(op);
        return;
      }
      const {
        operations,
        history
      } = editor;
      const {
        undos
      } = history;
      const step = undos[undos.length - 1];
      const lastOp = step && step.operations && step.operations[step.operations.length - 1];
      const overwrite = shouldOverwrite(op, lastOp);
      const save = isSaving(editor);
      let merge = true;
      if (save) {
        if (!step) {
          merge = false;
        } else if (operations.length === 0) {
          merge = shouldMerge(op, lastOp) || overwrite;
        }
        if (step && merge) {
          step.operations.push(op);
        } else {
          const newStep = {
            operations: [...(editor.selection === null ? [] : [createSelectOperation(editor)]), op],
            timestamp: /* @__PURE__ */new Date()
          };
          undos.push(newStep);
          debug$f("Created new undo step", step);
        }
        while (undos.length > UNDO_STEP_LIMIT) {
          undos.shift();
        }
        if (shouldClear(op)) {
          history.redos = [];
        }
      }
      apply(op);
    };
    editor.undo = () => {
      if (readOnly) {
        return;
      }
      const {
        undos
      } = editor.history;
      if (undos.length > 0) {
        const step = undos[undos.length - 1];
        debug$f("Undoing", step);
        if (step.operations.length > 0) {
          const otherPatches = remotePatches.filter(item => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach(item => {
            transformedOperations = flatten__default.default(transformedOperations.map(op => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
          });
          try {
            slate.Editor.withoutNormalizing(editor, () => {
              withoutSaving(editor, () => {
                transformedOperations.map(slate.Operation.inverse).reverse().forEach(op => {
                  editor.apply(op);
                });
              });
            });
            editor.normalize();
            editor.onChange();
          } catch (err) {
            debug$f("Could not perform undo step", err);
            remotePatches.splice(0, remotePatches.length);
            slate.Transforms.deselect(editor);
            editor.history = {
              undos: [],
              redos: []
            };
            SAVING.set(editor, true);
            editor.onChange();
            return;
          }
          editor.history.redos.push(step);
          editor.history.undos.pop();
        }
      }
    };
    editor.redo = () => {
      if (readOnly) {
        return;
      }
      const {
        redos
      } = editor.history;
      if (redos.length > 0) {
        const step = redos[redos.length - 1];
        debug$f("Redoing", step);
        if (step.operations.length > 0) {
          const otherPatches = remotePatches.filter(item => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach(item => {
            transformedOperations = flatten__default.default(transformedOperations.map(op => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
          });
          try {
            slate.Editor.withoutNormalizing(editor, () => {
              withoutSaving(editor, () => {
                transformedOperations.forEach(op => {
                  editor.apply(op);
                });
              });
            });
            editor.normalize();
            editor.onChange();
          } catch (err) {
            debug$f("Could not perform redo step", err);
            remotePatches.splice(0, remotePatches.length);
            slate.Transforms.deselect(editor);
            editor.history = {
              undos: [],
              redos: []
            };
            SAVING.set(editor, true);
            editor.onChange();
            return;
          }
          editor.history.undos.push(step);
          editor.history.redos.pop();
        }
      }
    };
    return editor;
  };
}
function transformOperation(editor, patch, operation, snapshot, previousSnapshot) {
  if (debugVerbose$2) {
    debug$f("Adjusting '".concat(operation.type, "' operation paths for '").concat(patch.type, "' patch"));
    debug$f("Operation ".concat(JSON.stringify(operation)));
    debug$f("Patch ".concat(JSON.stringify(patch)));
  }
  const transformedOperation = {
    ...operation
  };
  if (patch.type === "insert" && patch.path.length === 1) {
    const insertBlockIndex = (snapshot || []).findIndex(blk => isEqual__default.default({
      _key: blk._key
    }, patch.path[0]));
    debug$f("Adjusting block path (+".concat(patch.items.length, ") for '").concat(transformedOperation.type, "' operation and patch '").concat(patch.type, "'"));
    return [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 1) {
    const unsetBlockIndex = (previousSnapshot || []).findIndex(blk => isEqual__default.default({
      _key: blk._key
    }, patch.path[0]));
    if ("path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex) {
      debug$f("Skipping transformation that targeted removed block");
      return [];
    }
    if (debugVerbose$2) {
      debug$f("Selection ".concat(JSON.stringify(editor.selection)));
      debug$f("Adjusting block path (-1) for '".concat(transformedOperation.type, "' operation and patch '").concat(patch.type, "'"));
    }
    return [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 0) {
    debug$f("Adjusting selection for unset everything patch and ".concat(operation.type, " operation"));
    return [];
  }
  if (patch.type === "diffMatchPatch") {
    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);
    if (!operationTargetBlock || !isEqual__default.default({
      _key: operationTargetBlock._key
    }, patch.path[0])) {
      return [transformedOperation];
    }
    const diffPatches = parse(patch.value);
    diffPatches.forEach(diffPatch => {
      var _a, _b, _c, _d;
      let adjustOffsetBy = 0;
      let changedOffset = diffPatch.utf8Start1;
      const {
        diffs
      } = diffPatch;
      diffs.forEach((diff, index) => {
        const [diffType, text] = diff;
        if (diffType === DIFF_INSERT) {
          adjustOffsetBy += text.length;
          changedOffset += text.length;
        } else if (diffType === DIFF_DELETE) {
          adjustOffsetBy -= text.length;
          changedOffset -= text.length;
        } else if (diffType === DIFF_EQUAL) {
          if (!diffs.slice(index).every(_ref8 => {
            let [dType] = _ref8;
            return dType === DIFF_EQUAL;
          })) {
            changedOffset += text.length;
          }
        }
      });
      if (transformedOperation.type === "insert_text") {
        if (changedOffset < transformedOperation.offset) {
          transformedOperation.offset += adjustOffsetBy;
        }
      }
      if (transformedOperation.type === "remove_text") {
        if (changedOffset <= transformedOperation.offset - transformedOperation.text.length) {
          transformedOperation.offset += adjustOffsetBy;
        }
      }
      if (transformedOperation.type === "set_selection") {
        const currentFocus = ((_a = transformedOperation.properties) == null ? void 0 : _a.focus) ? {
          ...transformedOperation.properties.focus
        } : void 0;
        const currentAnchor = ((_b = transformedOperation == null ? void 0 : transformedOperation.properties) == null ? void 0 : _b.anchor) ? {
          ...transformedOperation.properties.anchor
        } : void 0;
        const newFocus = ((_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _c.focus) ? {
          ...transformedOperation.newProperties.focus
        } : void 0;
        const newAnchor = ((_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _d.anchor) ? {
          ...transformedOperation.newProperties.anchor
        } : void 0;
        if (currentFocus && currentAnchor || newFocus && newAnchor) {
          const points = [currentFocus, currentAnchor, newFocus, newAnchor];
          points.forEach(point => {
            if (point && changedOffset < point.offset) {
              point.offset += adjustOffsetBy;
            }
          });
          if (currentFocus && currentAnchor) {
            transformedOperation.properties = {
              focus: currentFocus,
              anchor: currentAnchor
            };
          }
          if (newFocus && newAnchor) {
            transformedOperation.newProperties = {
              focus: newFocus,
              anchor: newAnchor
            };
          }
        }
      }
    });
    return [transformedOperation];
  }
  return [transformedOperation];
}
function adjustBlockPath(operation, level, blockIndex) {
  var _a, _b, _c, _d;
  const transformedOperation = {
    ...operation
  };
  if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];
    transformedOperation.path = newPath;
  }
  if (transformedOperation.type === "set_selection") {
    const currentFocus = ((_a = transformedOperation.properties) == null ? void 0 : _a.focus) ? {
      ...transformedOperation.properties.focus
    } : void 0;
    const currentAnchor = ((_b = transformedOperation == null ? void 0 : transformedOperation.properties) == null ? void 0 : _b.anchor) ? {
      ...transformedOperation.properties.anchor
    } : void 0;
    const newFocus = ((_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _c.focus) ? {
      ...transformedOperation.newProperties.focus
    } : void 0;
    const newAnchor = ((_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) == null ? void 0 : _d.anchor) ? {
      ...transformedOperation.newProperties.anchor
    } : void 0;
    if (currentFocus && currentAnchor || newFocus && newAnchor) {
      const points = [currentFocus, currentAnchor, newFocus, newAnchor];
      points.forEach(point => {
        if (point && point.path[0] >= blockIndex + level && point.path[0] + level > -1) {
          point.path = [point.path[0] + level, ...point.path.slice(1)];
        }
      });
      if (currentFocus && currentAnchor) {
        transformedOperation.properties = {
          focus: currentFocus,
          anchor: currentAnchor
        };
      }
      if (newFocus && newAnchor) {
        transformedOperation.newProperties = {
          focus: newFocus,
          anchor: newAnchor
        };
      }
    }
  }
  return transformedOperation;
}
const shouldMerge = (op, prev) => {
  if (op.type === "set_selection") {
    return true;
  }
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && slate.Path.equals(op.path, prev.path) && op.text !== " ") {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && slate.Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
const shouldOverwrite = (op, prev) => {
  if (prev && op.type === "set_selection" && prev.type === "set_selection") {
    return true;
  }
  return false;
};
const shouldClear = op => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};
function withoutSaving(editor, fn) {
  const prev = isSaving(editor);
  SAVING.set(editor, false);
  fn();
  SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
  return {
    type: "set_selection",
    properties: {
      ...editor.selection
    },
    newProperties: {
      ...editor.selection
    }
  };
}
function findOperationTargetBlock(editor, operation) {
  let block;
  if (operation.type === "set_selection" && editor.selection) {
    block = editor.children[editor.selection.focus.path[0]];
  } else if ("path" in operation) {
    block = editor.children[operation.path[0]];
  }
  return block;
}
const debug$e = debugWithName("plugin:withPatches");
function createWithPatches(_ref9) {
  let {
    change$,
    patches$,
    patchFunctions,
    readOnly,
    schemaTypes
  } = _ref9;
  let previousChildren;
  const applyPatch = createApplyPatch(schemaTypes);
  return function withPatches(editor) {
    IS_PROCESSING_REMOTE_CHANGES.set(editor, false);
    PATCHING.set(editor, true);
    previousChildren = [...editor.children];
    const {
      apply
    } = editor;
    let bufferedPatches = [];
    const handleBufferedRemotePatches = () => {
      if (bufferedPatches.length === 0) {
        return;
      }
      const patches = bufferedPatches;
      bufferedPatches = [];
      let changed = false;
      withRemoteChanges(editor, () => {
        slate.Editor.withoutNormalizing(editor, () => {
          withoutPatching(editor, () => {
            withoutSaving(editor, () => {
              withPreserveKeys(editor, () => {
                patches.forEach(patch => {
                  if (debug$e.enabled) debug$e("Handling remote patch ".concat(JSON.stringify(patch)));
                  changed = applyPatch(editor, patch);
                });
              });
            });
          });
        });
        if (changed) {
          editor.normalize();
          editor.onChange();
        }
      });
    };
    const handlePatches = _ref10 => {
      let {
        patches
      } = _ref10;
      const remotePatches = patches.filter(p => p.origin !== "local");
      if (remotePatches.length === 0) {
        return;
      }
      bufferedPatches = bufferedPatches.concat(remotePatches);
      handleBufferedRemotePatches();
    };
    if (patches$) {
      editor.subscriptions.push(() => {
        debug$e("Subscribing to patches$");
        const sub = patches$.subscribe(handlePatches);
        return () => {
          debug$e("Unsubscribing to patches$");
          sub.unsubscribe();
        };
      });
    }
    editor.apply = operation => {
      if (readOnly) {
        apply(operation);
        return editor;
      }
      let patches = [];
      previousChildren = editor.children;
      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);
      apply(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);
      if (!isPatching(editor)) {
        return editor;
      }
      if (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection") {
        patches.push(insert$1(previousChildren, "before", [0]));
      }
      switch (operation.type) {
        case "insert_text":
          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_text":
          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_node":
          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];
          break;
        case "split_node":
          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];
          break;
        case "insert_node":
          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];
          break;
        case "set_node":
          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];
          break;
        case "merge_node":
          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];
          break;
        case "move_node":
          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];
          break;
      }
      if (!editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type)) {
        patches = [...patches, unset([])];
        change$.next({
          type: "unset",
          previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))
        });
      }
      if (editorWasEmpty && patches.length > 0) {
        patches = [setIfMissing([], []), ...patches];
      }
      if (patches.length > 0) {
        patches.forEach(patch => {
          change$.next({
            type: "patch",
            patch: {
              ...patch,
              origin: "local"
            }
          });
        });
      }
      return editor;
    };
    return editor;
  };
}
const debug$d = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock(_ref11) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref11;
  return function withPlaceholderBlock(editor) {
    editor.createPlaceholderBlock = () => {
      debug$d("Creating placeholder block");
      return {
        _type: schemaTypes.block.name,
        _key: keyGenerator(),
        style: schemaTypes.styles[0].value || "normal",
        markDefs: [],
        children: [{
          _type: "span",
          _key: keyGenerator(),
          text: "",
          marks: []
        }]
      };
    };
    return editor;
  };
}
const debug$c = debugWithName("plugin:withPortableTextBlockStyle");
function createWithPortableTextBlockStyle(types) {
  const defaultStyle = types.styles[0].value;
  return function withPortableTextBlockStyle(editor) {
    const {
      normalizeNode
    } = editor;
    editor.normalizeNode = nodeEntry => {
      normalizeNode(nodeEntry);
      const [, path] = nodeEntry;
      for (const op of editor.operations) {
        if (op.type === "split_node" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate.Path.equals(path, op.path)) {
          const [child] = slate.Editor.node(editor, [op.path[0] + 1, 0]);
          if (slate.Text.isText(child) && child.text === "") {
            debug$c("Normalizing split node to ".concat(defaultStyle, " style"), op);
            slate.Transforms.setNodes(editor, {
              style: defaultStyle
            }, {
              at: [op.path[0] + 1],
              voids: false
            });
            break;
          }
        }
      }
    };
    editor.pteHasBlockStyle = style => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isTextBlock(node) && node.style === style
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    editor.pteToggleBlockStyle = blockStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isTextBlock(node)
      })];
      selectedBlocks.forEach(_ref12 => {
        let [node, path] = _ref12;
        if (editor.isTextBlock(node) && node.style === blockStyle) {
          debug$c("Unsetting block style '".concat(blockStyle, "'"));
          slate.Transforms.setNodes(editor, {
            ...node,
            style: defaultStyle
          }, {
            at: path
          });
        } else {
          if (blockStyle) {
            debug$c("Setting style '".concat(blockStyle, "'"));
          } else {
            debug$c("Setting default style", defaultStyle);
          }
          slate.Transforms.setNodes(editor, {
            ...node,
            style: blockStyle || defaultStyle
          }, {
            at: path
          });
        }
      });
      editor.onChange();
    };
    return editor;
  };
}
const debug$b = debugWithName("plugin:withPortableTextLists");
const MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(types) {
  return function withPortableTextLists(editor) {
    editor.pteToggleListItem = listItemStyle => {
      const isActive = editor.pteHasListStyle(listItemStyle);
      if (isActive) {
        debug$b("Remove list item '".concat(listItemStyle, "'"));
        editor.pteUnsetListItem(listItemStyle);
      } else {
        debug$b("Add list item '".concat(listItemStyle, "'"));
        editor.pteSetListItem(listItemStyle);
      }
    };
    editor.pteUnsetListItem = listItemStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => slate.Element.isElement(node) && node._type === types.block.name
      })];
      selectedBlocks.forEach(_ref13 => {
        let [node, path] = _ref13;
        if (editor.isListBlock(node)) {
          const {
            listItem,
            level,
            ...rest
          } = node;
          const newNode = {
            ...rest,
            listItem: void 0,
            level: void 0
          };
          debug$b("Unsetting list '".concat(listItemStyle, "'"));
          slate.Transforms.setNodes(editor, newNode, {
            at: path
          });
        }
      });
    };
    editor.pteSetListItem = listItemStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isTextBlock(node)
      })];
      selectedBlocks.forEach(_ref14 => {
        let [node, path] = _ref14;
        debug$b("Setting list '".concat(listItemStyle, "'"));
        slate.Transforms.setNodes(editor, {
          ...node,
          level: 1,
          listItem: listItemStyle || types.lists[0] && types.lists[0].value
        }, {
          at: path
        });
      });
    };
    editor.pteEndList = () => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => slate.Element.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && slate.Text.isText(node.children[0]) && node.children[0].text === ""
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach(_ref15 => {
        let [node, path] = _ref15;
        if (slate.Element.isElement(node)) {
          debug$b("Unset list");
          slate.Transforms.setNodes(editor, {
            ...node,
            level: void 0,
            listItem: void 0
          }, {
            at: path
          });
        }
      });
      return true;
    };
    editor.pteIncrementBlockLevels = reverse => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => !!editor.isListBlock(node)
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach(_ref16 => {
        let [node, path] = _ref16;
        if (editor.isListBlock(node)) {
          let level = node.level || 1;
          if (reverse) {
            level--;
            debug$b("Decrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          } else {
            level++;
            debug$b("Incrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          }
          slate.Transforms.setNodes(editor, {
            level: Math.min(MAX_LIST_LEVEL, Math.max(1, level))
          }, {
            at: path
          });
        }
      });
      return true;
    };
    editor.pteHasListStyle = listStyle => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isListBlock(node) && node.listItem === listStyle
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    return editor;
  };
}
const debug$a = debugWithName("plugin:withPortableTextSelections");
const debugVerbose$1 = debug$a.enabled && false;
function createWithPortableTextSelections(change$, types) {
  let prevSelection = null;
  return function withPortableTextSelections(editor) {
    const emitPortableTextSelection = () => {
      if (prevSelection !== editor.selection) {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing) {
            ptRange = existing;
          } else {
            const value = editor.children;
            ptRange = toPortableTextRange(value, editor.selection, types);
            SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
          }
        }
        if (debugVerbose$1) {
          debug$a("Emitting selection ".concat(JSON.stringify(ptRange || null), " (").concat(JSON.stringify(editor.selection), ")"));
        }
        if (ptRange) {
          change$.next({
            type: "selection",
            selection: ptRange
          });
        } else {
          change$.next({
            type: "selection",
            selection: null
          });
        }
      }
      prevSelection = editor.selection;
    };
    const {
      onChange
    } = editor;
    editor.onChange = () => {
      const hasChanges = editor.operations.length > 0;
      onChange();
      if (hasChanges) {
        emitPortableTextSelection();
      }
    };
    return editor;
  };
}
const debug$9 = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes(_ref17) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref17;
  return function withSchemaTypes(editor) {
    editor.isTextBlock = value => {
      return types.isPortableTextTextBlock(value) && value._type === schemaTypes.block.name;
    };
    editor.isTextSpan = value => {
      return types.isPortableTextSpan(value) && value._type == schemaTypes.span.name;
    };
    editor.isListBlock = value => {
      return types.isPortableTextListBlock(value) && value._type === schemaTypes.block.name;
    };
    editor.isVoid = element => {
      return schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map(obj => obj.name).includes(element._type) || schemaTypes.inlineObjects.map(obj => obj.name).includes(element._type));
    };
    editor.isInline = element => {
      const inlineSchemaTypes = schemaTypes.inlineObjects.map(obj => obj.name);
      return inlineSchemaTypes.includes(element._type) && "__inline" in element && element.__inline === true;
    };
    const {
      normalizeNode
    } = editor;
    editor.normalizeNode = entry => {
      const [node, path] = entry;
      if (node._type === void 0 && path.length === 2) {
        debug$9("Setting span type on text node without a type");
        const span = node;
        const key = span._key || keyGenerator();
        slate.Transforms.setNodes(editor, {
          ...span,
          _type: schemaTypes.span.name,
          _key: key
        }, {
          at: path
        });
      }
      normalizeNode(entry);
    };
    return editor;
  };
}
const debug$8 = debugWithName("plugin:withUtils");
function createWithUtils(_ref18) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref18;
  return function withUtils(editor) {
    editor.pteExpandToWord = () => {
      const {
        selection
      } = editor;
      if (selection && !slate.Range.isExpanded(selection)) {
        const [textNode] = slate.Editor.node(editor, selection.focus, {
          depth: 2
        });
        if (!textNode || !slate.Text.isText(textNode) || textNode.text.length === 0) {
          debug$8("pteExpandToWord: Can't expand to word here");
          return;
        }
        const {
          focus
        } = selection;
        const focusOffset = focus.offset;
        const charsBefore = textNode.text.slice(0, focusOffset);
        const charsAfter = textNode.text.slice(focusOffset, -1);
        const isEmpty = str => str.match(/\s/g);
        const whiteSpaceBeforeIndex = charsBefore.split("").reverse().findIndex(str => isEmpty(str));
        const newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0;
        const whiteSpaceAfterIndex = charsAfter.split("").findIndex(obj => isEmpty(obj));
        const newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
        if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
          debug$8("pteExpandToWord: Expanding to focused word");
          slate.Transforms.setSelection(editor, {
            anchor: {
              ...selection.anchor,
              offset: newStartOffset
            },
            focus: {
              ...selection.focus,
              offset: newEndOffset
            }
          });
          return;
        }
        debug$8("pteExpandToWord: Can't expand to word here");
      }
    };
    return editor;
  };
}
const debug$7 = debugWithName("plugin:withHotKeys");
const DEFAULT_HOTKEYS = {
  marks: {
    "mod+b": "strong",
    "mod+i": "em",
    "mod+u": "underline",
    "mod+'": "code"
  },
  custom: {}
};
function createWithHotkeys(types$1, keyGenerator, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"];
  const activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;
  const createEmptyBlock = () => toSlateValue([{
    _type: types$1.block.name,
    _key: keyGenerator(),
    style: "normal",
    markDefs: [],
    children: [{
      _type: "span",
      _key: keyGenerator(),
      text: "",
      marks: []
    }]
  }], portableTextEditor)[0];
  return function withHotKeys(editor) {
    editor.pteWithHotKeys = event => {
      var _a, _b;
      Object.keys(activeHotkeys).forEach(cat => {
        if (cat === "marks") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if (isHotkey__default.default(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$7("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                editor.pteToggleMark(mark);
              }
            }
          }
        }
        if (cat === "custom") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if (isHotkey__default.default(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
        }
      });
      const isEnter = isHotkey__default.default("enter", event.nativeEvent);
      const isTab = isHotkey__default.default("tab", event.nativeEvent);
      const isShiftEnter = isHotkey__default.default("shift+enter", event.nativeEvent);
      const isShiftTab = isHotkey__default.default("shift+tab", event.nativeEvent);
      const isBackspace = isHotkey__default.default("backspace", event.nativeEvent);
      const isDelete = isHotkey__default.default("delete", event.nativeEvent);
      if (isBackspace && editor.selection && editor.selection.focus.path[0] > 0 && slate.Range.isCollapsed(editor.selection)) {
        const prevPath = slate.Path.previous(editor.selection.focus.path.slice(0, 1));
        const prevBlock = slate.Node.descendant(editor, prevPath);
        const focusBlock = slate.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (prevBlock && focusBlock && slate.Editor.isVoid(editor, prevBlock) && editor.selection.focus.offset === 0) {
          debug$7("Preventing deleting void block above");
          event.preventDefault();
          event.stopPropagation();
          const isTextBlock = types.isPortableTextTextBlock(focusBlock);
          const isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_b = (_a = focusBlock.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) === "";
          if (!isTextBlock || isEmptyFocusBlock) {
            slate.Transforms.removeNodes(editor, {
              match: n => n === focusBlock
            });
            slate.Transforms.select(editor, prevPath);
            editor.onChange();
            return;
          }
          if (isTextBlock && !isEmptyFocusBlock) {
            slate.Transforms.select(editor, prevPath);
            editor.onChange();
            return;
          }
          return;
        }
      }
      if (isDelete && editor.selection && editor.selection.focus.offset === 0 && slate.Range.isCollapsed(editor.selection) && editor.children[editor.selection.focus.path[0] + 1]) {
        const nextBlock = slate.Node.descendant(editor, slate.Path.next(editor.selection.focus.path.slice(0, 1)));
        const focusBlockPath = editor.selection.focus.path.slice(0, 1);
        const focusBlock = slate.Node.descendant(editor, focusBlockPath);
        if (nextBlock && focusBlock && !slate.Editor.isVoid(editor, focusBlock) && slate.Editor.isVoid(editor, nextBlock)) {
          debug$7("Preventing deleting void block below");
          event.preventDefault();
          event.stopPropagation();
          slate.Transforms.removeNodes(editor, {
            match: n => n === focusBlock
          });
          slate.Transforms.select(editor, focusBlockPath);
          editor.onChange();
          return;
        }
      }
      if ((isTab || isShiftTab) && editor.selection) {
        const [focusChild] = slate.Editor.node(editor, editor.selection.focus, {
          depth: 2
        });
        const [focusBlock] = types.isPortableTextSpan(focusChild) ? slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        }) : [];
        const hasAnnotationFocus = focusChild && types.isPortableTextTextBlock(focusBlock) && types.isPortableTextSpan(focusChild) && (focusChild.marks || []).filter(m => (focusBlock.markDefs || []).map(def => def._key).includes(m)).length > 0;
        const [start] = slate.Range.edges(editor.selection);
        const atStartOfNode = slate.Editor.isStart(editor, start, start.path);
        if (focusChild && types.isPortableTextSpan(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab)) {
          event.preventDefault();
        }
      }
      if (isEnter && !isShiftEnter && editor.selection) {
        const focusBlockPath = editor.selection.focus.path.slice(0, 1);
        const focusBlock = slate.Node.descendant(editor, focusBlockPath);
        if (editor.isListBlock(focusBlock)) {
          if (editor.pteEndList()) {
            event.preventDefault();
          }
          return;
        }
        if (editor.isTextBlock(focusBlock) && focusBlock.style && focusBlock.style !== types$1.styles[0].value) {
          const [, end] = slate.Range.edges(editor.selection);
          const endAtEndOfNode = slate.Editor.isEnd(editor, end, end.path);
          if (endAtEndOfNode) {
            slate.Editor.insertNode(editor, createEmptyBlock());
            event.preventDefault();
            editor.onChange();
            return;
          }
        }
        if (focusBlock && slate.Editor.isVoid(editor, focusBlock)) {
          slate.Editor.insertNode(editor, createEmptyBlock());
          event.preventDefault();
          editor.onChange();
          return;
        }
        event.preventDefault();
        editor.insertBreak();
        editor.onChange();
      }
      if (isShiftEnter) {
        event.preventDefault();
        editor.insertText("\n");
        return;
      }
      if (isHotkey__default.default("mod+z", event.nativeEvent)) {
        event.preventDefault();
        editor.undo();
        return;
      }
      if (isHotkey__default.default("mod+y", event.nativeEvent) || isHotkey__default.default("mod+shift+z", event.nativeEvent)) {
        event.preventDefault();
        editor.redo();
      }
    };
    return editor;
  };
}
function validateValue(value, types$1, keyGenerator) {
  let resolution = null;
  let valid = true;
  const validChildTypes = [types$1.span.name, ...types$1.inlineObjects.map(t => t.name)];
  const validBlockTypes = [types$1.block.name, ...types$1.blockObjects.map(t => t.name)];
  if (value === void 0) {
    return {
      valid: true,
      resolution: null,
      value
    };
  }
  if (!Array.isArray(value) || value.length === 0) {
    return {
      valid: false,
      resolution: {
        patches: [unset([])],
        description: "Editor value must be an array of Portable Text blocks, or undefined.",
        action: "Unset the value",
        item: value,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-array.description",
          action: "inputs.portable-text.invalid-value.not-an-array.action"
        }
      },
      value
    };
  }
  if (value.some((blk, index) => {
    if (!isPlainObject__default.default(blk)) {
      resolution = {
        patches: [unset([index])],
        description: "Block must be an object, got ".concat(String(blk)),
        action: "Unset invalid item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-object.description",
          action: "inputs.portable-text.invalid-value.not-an-object.action",
          values: {
            index
          }
        }
      };
      return true;
    }
    if (!blk._key || typeof blk._key !== "string") {
      resolution = {
        patches: [set({
          ...blk,
          _key: keyGenerator()
        }, [index])],
        description: "Block at index ".concat(index, " is missing required _key."),
        action: "Set the block with a random _key value",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-key.description",
          action: "inputs.portable-text.invalid-value.missing-key.action",
          values: {
            index
          }
        }
      };
      return true;
    }
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types$1.block.name;
        resolution = {
          patches: [set({
            ...blk,
            _type: currentBlockTypeName
          }, [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
          action: "Use type '".concat(currentBlockTypeName, "'"),
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
            action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: currentBlockTypeName
            }
          }
        };
        return true;
      }
      if (!blk._type && types.isPortableTextTextBlock({
        ...blk,
        _type: types$1.block.name
      })) {
        resolution = {
          patches: [set({
            ...blk,
            _type: types$1.block.name
          }, [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' is missing a type name. According to the schema, the block type name is '").concat(types$1.block.name, "'"),
          action: "Use type '".concat(types$1.block.name, "'"),
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-block-type.description",
            action: "inputs.portable-text.invalid-value.missing-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: types$1.block.name
            }
          }
        };
        return true;
      }
      if (!blk._type) {
        resolution = {
          patches: [unset([{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' is missing an _type property"),
          action: "Remove the block",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-type.description",
            action: "inputs.portable-text.invalid-value.missing-type.action",
            values: {
              key: blk._key
            }
          }
        };
        return true;
      }
      resolution = {
        patches: [unset([{
          _key: blk._key
        }])],
        description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-type.action",
          values: {
            key: blk._key,
            typeName: blk._type
          }
        }
      };
      return true;
    }
    if (blk._type === types$1.block.name) {
      const textBlock = blk;
      if (!textBlock.children || !Array.isArray(textBlock.children)) {
        resolution = {
          patches: [unset([{
            _key: textBlock._key
          }])],
          description: "Text block with _key '".concat(textBlock._key, "' has a missing or invalid required property 'children'."),
          action: "Remove the block",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
            values: {
              key: textBlock._key
            }
          }
        };
        return true;
      }
      if (!blk.markDefs || !Array.isArray(blk.markDefs)) {
        resolution = {
          patches: [set({
            ...textBlock,
            markDefs: []
          }, [{
            _key: textBlock._key
          }])],
          description: "Block has a missing or invalid required property 'markDefs'.",
          action: "Add empty markDefs array",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action",
            values: {
              key: textBlock._key
            }
          }
        };
        return true;
      }
      const allUsedMarks = uniq__default.default(flatten__default.default(textBlock.children.filter(cld => cld._type === types$1.span.name).map(cld => cld.marks || [])));
      const annotationMarks = allUsedMarks.filter(mark => !types$1.decorators.map(dec => dec.value).includes(mark));
      const orphanedMarks = annotationMarks.filter(mark => textBlock.markDefs ? !textBlock.markDefs.find(def => def._key === mark) : false);
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter(cld => cld._type === types$1.span.name && Array.isArray(cld.marks) && cld.marks.some(mark => orphanedMarks.includes(mark)));
        if (spanChildren) {
          const orphaned = orphanedMarks.join(", ");
          resolution = {
            patches: spanChildren.map(child => {
              return set((child.marks || []).filter(cMrk => !orphanedMarks.includes(cMrk)), [{
                _key: blk._key
              }, "children", {
                _key: child._key
              }, "marks"]);
            }),
            description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphaned, ") not supported by the current content model."),
            action: "Remove invalid marks",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-marks.description",
              action: "inputs.portable-text.invalid-value.orphaned-marks.action",
              values: {
                key: blk._key,
                orphanedMarks
              }
            }
          };
          return true;
        }
      }
      if (textBlock.children && textBlock.children.length === 0) {
        const newSpan = {
          _type: types$1.span.name,
          _key: keyGenerator(),
          text: ""
        };
        resolution = {
          patches: [insert$1([newSpan], "after", [{
            _key: blk._key
          }, "children", 0])],
          description: "Children for text block with _key '".concat(blk._key, "' is empty."),
          action: "Insert an empty text",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.empty-children.description",
            action: "inputs.portable-text.invalid-value.empty-children.action",
            values: {
              key: blk._key
            }
          }
        };
        return true;
      }
      if (textBlock.children.some((child, cIndex) => {
        if (!isPlainObject__default.default(child)) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", cIndex])],
            description: "Child at index '".concat(cIndex, "' in block with key '").concat(blk._key, "' is not an object."),
            action: "Remove the item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.non-object-child.description",
              action: "inputs.portable-text.invalid-value.non-object-child.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          };
          return true;
        }
        if (!child._key || typeof child._key !== "string") {
          const newChild = {
            ...child,
            _key: keyGenerator()
          };
          resolution = {
            patches: [set(newChild, [{
              _key: blk._key
            }, "children", cIndex])],
            description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
            action: "Set a new random _key on the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-key.description",
              action: "inputs.portable-text.invalid-value.missing-child-key.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          };
          return true;
        }
        if (!child._type) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing '_type' property."),
            action: "Remove the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-type.description",
              action: "inputs.portable-text.invalid-value.missing-child-type.action",
              values: {
                key: blk._key,
                childKey: child._key
              }
            }
          };
          return true;
        }
        if (!validChildTypes.includes(child._type)) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
            action: "Remove the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
              action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
              values: {
                key: blk._key,
                childKey: child._key,
                childType: child._type
              }
            }
          };
          return true;
        }
        if (child._type === types$1.span.name && typeof child.text !== "string") {
          resolution = {
            patches: [set({
              ...child,
              text: ""
            }, [{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has missing or invalid text property!"),
            action: "Write an empty text property to the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.invalid-span-text.description",
              action: "inputs.portable-text.invalid-value.invalid-span-text.action",
              values: {
                key: blk._key,
                childKey: child._key
              }
            }
          };
          return true;
        }
        return false;
      })) {
        valid = false;
      }
    }
    return false;
  })) {
    valid = false;
  }
  return {
    valid,
    resolution,
    value
  };
}
const debug$6 = debugWithName("plugin:withInsertData");
function createWithInsertData(change$, schemaTypes, keyGenerator) {
  return function withInsertData(editor) {
    const blockTypeName = schemaTypes.block.name;
    const spanTypeName = schemaTypes.span.name;
    const whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode;
    const toPlainText = blocks => {
      return blocks.map(block => {
        var _a;
        if (editor.isTextBlock(block)) {
          return block.children.map(child => {
            var _a2;
            if (child._type === spanTypeName) {
              return child.text;
            }
            return "[".concat(((_a2 = schemaTypes.inlineObjects.find(t => t.name === child._type)) == null ? void 0 : _a2.title) || "Object", "]");
          }).join("");
        }
        return "[".concat(((_a = schemaTypes.blockObjects.find(t => t.name === block._type)) == null ? void 0 : _a.title) || "Object", "]");
      }).join("\n\n");
    };
    editor.setFragmentData = (data, originEvent) => {
      const {
        selection
      } = editor;
      if (!selection) {
        return;
      }
      const [start, end] = slate.Range.edges(selection);
      const startVoid = slate.Editor.void(editor, {
        at: start.path
      });
      const endVoid = slate.Editor.void(editor, {
        at: end.path
      });
      if (slate.Range.isCollapsed(selection) && !startVoid) {
        return;
      }
      const domRange = slateReact.ReactEditor.toDOMRange(editor, selection);
      let contents = domRange.cloneContents();
      if (endVoid) {
        const [voidNode] = endVoid;
        const r = domRange.cloneRange();
        const domNode = slateReact.ReactEditor.toDOMNode(editor, voidNode);
        r.setEndAfter(domNode);
        contents = r.cloneContents();
      }
      Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach(zw => {
        const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
        zw.textContent = isNewline ? "\n" : "";
      });
      Array.from(contents.querySelectorAll("*")).forEach(elm => {
        elm.removeAttribute("contentEditable");
        elm.removeAttribute("data-slate-inline");
        elm.removeAttribute("data-slate-leaf");
        elm.removeAttribute("data-slate-node");
        elm.removeAttribute("data-slate-spacer");
        elm.removeAttribute("data-slate-string");
        elm.removeAttribute("data-slate-zero-width");
        elm.removeAttribute("draggable");
        for (const key in elm.attributes) {
          if (elm.hasAttribute(key)) {
            elm.removeAttribute(key);
          }
        }
      });
      const div = contents.ownerDocument.createElement("div");
      div.appendChild(contents);
      div.setAttribute("hidden", "true");
      contents.ownerDocument.body.appendChild(div);
      const asHTML = div.innerHTML;
      contents.ownerDocument.body.removeChild(div);
      const fragment = editor.getFragment();
      const portableText = fromSlateValue(fragment, blockTypeName);
      const asJSON = JSON.stringify(portableText);
      const asPlainText = toPlainText(portableText);
      data.clearData();
      data.setData("text/plain", asPlainText);
      data.setData("text/html", asHTML);
      data.setData("application/json", asJSON);
      data.setData("application/x-portable-text", asJSON);
      debug$6("text", asPlainText);
      data.setData("application/x-portable-text-event-origin", originEvent || "external");
      debug$6("Set fragment data", asJSON, asHTML);
    };
    editor.insertPortableTextData = data => {
      var _a;
      if (!editor.selection) {
        return false;
      }
      const pText = data.getData("application/x-portable-text");
      const origin = data.getData("application/x-portable-text-event-origin");
      debug$6("Inserting portable text from ".concat(origin, " event"), pText);
      if (pText) {
        const parsed = JSON.parse(pText);
        if (Array.isArray(parsed) && parsed.length > 0) {
          const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {
            schemaTypes
          }), keyGenerator, spanTypeName);
          const validation = validateValue(parsed, schemaTypes, keyGenerator);
          if (!validation.valid) {
            const errorDescription = "".concat((_a = validation.resolution) == null ? void 0 : _a.description);
            change$.next({
              type: "error",
              level: "warning",
              name: "pasteError",
              description: errorDescription,
              data: validation
            });
            debug$6("Invalid insert result", validation);
            return false;
          }
          _insertFragment(editor, slateValue, schemaTypes);
          return true;
        }
      }
      return false;
    };
    editor.insertTextOrHTMLData = data => {
      var _a;
      if (!editor.selection) {
        debug$6("No selection, not inserting");
        return false;
      }
      change$.next({
        type: "loading",
        isLoading: true
      });
      const html = data.getData("text/html");
      const text = data.getData("text/plain");
      if (html || text) {
        debug$6("Inserting data", data);
        let portableText;
        let fragment;
        let insertedType;
        if (html) {
          portableText = blockTools.htmlToBlocks(html, schemaTypes.portableText, {
            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode
          }).map(block => blockTools.normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "HTML";
        } else {
          const blocks = escapeHtml(text).split(/\n{2,}/).map(line => line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, "<br/>"), "</p>") : "<p></p>").join("");
          const textToHtml = "<html><body>".concat(blocks, "</body></html>");
          portableText = blockTools.htmlToBlocks(textToHtml, schemaTypes.portableText).map(block => blockTools.normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "text";
        }
        const validation = validateValue(portableText, schemaTypes, keyGenerator);
        if (!validation.valid) {
          const errorDescription = "Could not validate the resulting portable text to insert.\n".concat((_a = validation.resolution) == null ? void 0 : _a.description, "\nTry to insert as plain text (shift-paste) instead.");
          change$.next({
            type: "error",
            level: "warning",
            name: "pasteError",
            description: errorDescription,
            data: validation
          });
          debug$6("Invalid insert result", validation);
          return false;
        }
        debug$6("Inserting ".concat(insertedType, " fragment at ").concat(JSON.stringify(editor.selection)));
        _insertFragment(editor, fragment, schemaTypes);
        change$.next({
          type: "loading",
          isLoading: false
        });
        return true;
      }
      change$.next({
        type: "loading",
        isLoading: false
      });
      return false;
    };
    editor.insertData = data => {
      if (!editor.insertPortableTextData(data)) {
        editor.insertTextOrHTMLData(data);
      }
    };
    editor.insertFragmentData = data => {
      const fragment = data.getData("application/x-portable-text");
      if (fragment) {
        const parsed = JSON.parse(fragment);
        editor.insertFragment(parsed);
        return true;
      }
      return false;
    };
    return editor;
  };
}
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, s => entityMap[s]);
}
function _regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
  return fragment.map(node => {
    const newNode = {
      ...node
    };
    if (editor.isTextBlock(newNode)) {
      newNode.markDefs = (newNode.markDefs || []).map(def => {
        const oldKey = def._key;
        const newKey = keyGenerator();
        newNode.children = newNode.children.map(child => child._type === spanTypeName && editor.isTextSpan(child) ? {
          ...child,
          marks: child.marks && child.marks.includes(oldKey) ?
          // eslint-disable-next-line max-nested-callbacks
          [...child.marks].filter(mark => mark !== oldKey).concat(newKey) : child.marks
        } : child);
        return {
          ...def,
          _key: newKey
        };
      });
    }
    const nodeWithNewKeys = {
      ...newNode,
      _key: keyGenerator()
    };
    if (editor.isTextBlock(nodeWithNewKeys)) {
      nodeWithNewKeys.children = nodeWithNewKeys.children.map(child => ({
        ...child,
        _key: keyGenerator()
      }));
    }
    return nodeWithNewKeys;
  });
}
function _insertFragment(editor, fragment, schemaTypes) {
  if (!editor.selection) {
    return;
  }
  const [focusBlock, focusPath] = slate.Editor.node(editor, editor.selection, {
    depth: 1
  });
  if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
    const {
      markDefs
    } = focusBlock;
    debug$6("Mixing markDefs of focusBlock and fragments[0] block", markDefs, fragment[0].markDefs);
    if (!isEqual__default.default(markDefs, fragment[0].markDefs)) {
      slate.Transforms.setNodes(editor, {
        markDefs: uniq__default.default([...(fragment[0].markDefs || []), ...(markDefs || [])])
      }, {
        at: focusPath,
        mode: "lowest",
        voids: false
      });
    }
  }
  const isPasteToEmptyEditor = isEqualToEmptyEditor(editor.children, schemaTypes);
  if (isPasteToEmptyEditor) {
    slate.Transforms.splitNodes(editor, {
      at: [0, 0]
    });
    editor.insertFragment(fragment);
    slate.Transforms.removeNodes(editor, {
      at: [0]
    });
  } else {
    editor.insertFragment(fragment);
  }
  editor.onChange();
}
const originalFnMap = /* @__PURE__ */new WeakMap();
const withPlugins = (editor, options) => {
  const e = editor;
  const {
    keyGenerator,
    portableTextEditor,
    patches$,
    readOnly,
    maxBlocks
  } = options;
  const {
    schemaTypes,
    change$
  } = portableTextEditor;
  e.subscriptions = [];
  if (e.destroy) {
    e.destroy();
  } else {
    originalFnMap.set(e, {
      apply: e.apply,
      onChange: e.onChange,
      normalizeNode: e.normalizeNode
    });
  }
  const operationToPatches = createOperationToPatches(schemaTypes);
  const withObjectKeys = createWithObjectKeys(schemaTypes, keyGenerator);
  const withSchemaTypes = createWithSchemaTypes({
    schemaTypes,
    keyGenerator
  });
  const withEditableAPI = createWithEditableAPI(portableTextEditor, schemaTypes, keyGenerator);
  const withPatches = createWithPatches({
    change$,
    keyGenerator,
    patches$,
    patchFunctions: operationToPatches,
    readOnly,
    schemaTypes
  });
  const withMaxBlocks = createWithMaxBlocks(maxBlocks || -1);
  const withPortableTextLists = createWithPortableTextLists(schemaTypes);
  const withUndoRedo = createWithUndoRedo({
    readOnly,
    patches$,
    blockSchemaType: schemaTypes.block
  });
  const withPortableTextMarkModel = createWithPortableTextMarkModel(schemaTypes, change$);
  const withPortableTextBlockStyle = createWithPortableTextBlockStyle(schemaTypes);
  const withPlaceholderBlock = createWithPlaceholderBlock({
    keyGenerator,
    schemaTypes
  });
  const withUtils = createWithUtils({
    keyGenerator,
    schemaTypes
  });
  const withPortableTextSelections = createWithPortableTextSelections(change$, schemaTypes);
  e.destroy = () => {
    const originalFunctions = originalFnMap.get(e);
    if (!originalFunctions) {
      throw new Error("Could not find pristine versions of editor functions");
    }
    e.apply = originalFunctions.apply;
    e.history = {
      undos: [],
      redos: []
    };
    e.normalizeNode = originalFunctions.normalizeNode;
    e.onChange = originalFunctions.onChange;
  };
  if (readOnly) {
    return {
      editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e))))))))),
      subscribe: () => noop__default.default
    };
  }
  return {
    editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e)))))))))))),
    subscribe: () => {
      const unsubscribes = [];
      editor.subscriptions.forEach(subscribeFn => {
        unsubscribes.push(subscribeFn());
      });
      return () => {
        unsubscribes.forEach(unsubscribeFn => {
          unsubscribeFn();
        });
      };
    }
  };
};
const debug$5 = debugWithName("component:PortableTextEditor:SlateContainer");
function SlateContainer(props) {
  const {
    patches$,
    portableTextEditor,
    readOnly,
    maxBlocks,
    keyGenerator
  } = props;
  const [slateEditor, subscribe] = react.useMemo(() => {
    debug$5("Creating new Slate editor instance");
    const {
      editor,
      subscribe: _sub
    } = withPlugins(slateReact.withReact(slate.createEditor()), {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
    KEY_TO_VALUE_ELEMENT.set(editor, {});
    KEY_TO_SLATE_ELEMENT.set(editor, {});
    return [editor, _sub];
  }, []);
  react.useEffect(() => {
    const unsubscribe = subscribe();
    return () => {
      unsubscribe();
    };
  }, [subscribe]);
  react.useEffect(() => {
    debug$5("Re-initializing plugin chain");
    withPlugins(slateEditor, {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
  }, [keyGenerator, portableTextEditor, maxBlocks, readOnly, patches$, slateEditor]);
  const initialValue = react.useMemo(() => {
    return [slateEditor.createPlaceholderBlock()];
  }, [slateEditor]);
  react.useEffect(() => {
    return () => {
      debug$5("Destroying Slate editor");
      slateEditor.destroy();
    };
  }, [slateEditor]);
  return /* @__PURE__ */jsxRuntime.jsx(slateReact.Slate, {
    editor: slateEditor,
    initialValue,
    children: props.children
  });
}
const PortableTextEditorSelectionContext = react.createContext(null);
const usePortableTextEditorSelection = () => {
  const selection = react.useContext(PortableTextEditorSelectionContext);
  if (selection === void 0) {
    throw new Error("The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return selection;
};
const PortableTextEditorValueContext = react.createContext(void 0);
const PortableTextEditorReadOnlyContext = react.createContext(false);
const usePortableTextEditorReadOnlyStatus = () => {
  const readOnly = react.useContext(PortableTextEditorReadOnlyContext);
  if (readOnly === void 0) {
    throw new Error("The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return readOnly;
};
const debug$4 = debugWithName("hook:useSyncValue");
const CURRENT_VALUE = /* @__PURE__ */new WeakMap();
function useSyncValue(props) {
  const {
    portableTextEditor,
    readOnly,
    keyGenerator
  } = props;
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const previousValue = react.useRef();
  const slateEditor = slateReact.useSlate();
  const updateValueFunctionRef = react.useRef();
  const updateFromCurrentValue = react.useCallback(() => {
    const currentValue = CURRENT_VALUE.get(portableTextEditor);
    if (previousValue.current === currentValue) {
      debug$4("Value is the same object as previous, not need to sync");
      return;
    }
    if (updateValueFunctionRef.current && currentValue) {
      debug$4("Updating the value debounced");
      updateValueFunctionRef.current(currentValue);
    }
  }, [portableTextEditor]);
  const updateValueDebounced = react.useCallback(debounce__default.default(updateFromCurrentValue, 1e3, {
    trailing: true,
    leading: false
  }), [updateFromCurrentValue]);
  return react.useMemo(() => {
    const updateFunction = value => {
      CURRENT_VALUE.set(portableTextEditor, value);
      const isProcessingLocalChanges = isChangingLocally(slateEditor);
      const isProcessingRemoteChanges = isChangingRemotely(slateEditor);
      if (!readOnly) {
        if (isProcessingLocalChanges) {
          debug$4("Has local changes, not syncing value right now");
          updateValueDebounced();
          return;
        }
        if (isProcessingRemoteChanges) {
          debug$4("Has remote changes, not syncing value right now");
          updateValueDebounced();
          return;
        }
      }
      let isChanged = false;
      let isValid = true;
      const hadSelection = !!slateEditor.selection;
      if (!value || value.length === 0) {
        debug$4("Value is empty");
        slate.Editor.withoutNormalizing(slateEditor, () => {
          withoutSaving(slateEditor, () => {
            withoutPatching(slateEditor, () => {
              if (hadSelection) {
                slate.Transforms.deselect(slateEditor);
              }
              const childrenLength = slateEditor.children.length;
              slateEditor.children.forEach((_, index) => {
                slate.Transforms.removeNodes(slateEditor, {
                  at: [childrenLength - 1 - index]
                });
              });
              slate.Transforms.insertNodes(slateEditor, slateEditor.createPlaceholderBlock(), {
                at: [0]
              });
              if (hadSelection) {
                slate.Transforms.select(slateEditor, [0, 0]);
              }
            });
          });
        });
        isChanged = true;
      }
      if (value && value.length > 0) {
        const slateValueFromProps = toSlateValue(value, {
          schemaTypes
        });
        slate.Editor.withoutNormalizing(slateEditor, () => {
          withRemoteChanges(slateEditor, () => {
            withoutSaving(slateEditor, () => {
              withoutPatching(slateEditor, () => {
                const childrenLength = slateEditor.children.length;
                if (slateValueFromProps.length < childrenLength) {
                  for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--) {
                    slate.Transforms.removeNodes(slateEditor, {
                      at: [i]
                    });
                  }
                  isChanged = true;
                }
                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {
                  const oldBlock = slateEditor.children[currentBlockIndex];
                  const hasChanges = oldBlock && !isEqual__default.default(currentBlock, oldBlock);
                  if (hasChanges && isValid) {
                    const validationValue = [value[currentBlockIndex]];
                    const validation = validateValue(validationValue, schemaTypes, keyGenerator);
                    if (validation.valid) {
                      if (oldBlock._key === currentBlock._key) {
                        if (debug$4.enabled) debug$4("Updating block", oldBlock, currentBlock);
                        _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex);
                      } else {
                        if (debug$4.enabled) debug$4("Replacing block", oldBlock, currentBlock);
                        _replaceBlock(slateEditor, currentBlock, currentBlockIndex);
                      }
                      isChanged = true;
                    } else {
                      change$.next({
                        type: "invalidValue",
                        resolution: validation.resolution,
                        value
                      });
                      isValid = false;
                    }
                  }
                  if (!oldBlock && isValid) {
                    const validationValue = [value[currentBlockIndex]];
                    const validation = validateValue(validationValue, schemaTypes, keyGenerator);
                    if (debug$4.enabled) debug$4("Validating and inserting new block in the end of the value", currentBlock);
                    if (validation.valid) {
                      withPreserveKeys(slateEditor, () => {
                        slate.Transforms.insertNodes(slateEditor, currentBlock, {
                          at: [currentBlockIndex]
                        });
                      });
                    } else {
                      debug$4("Invalid", validation);
                      change$.next({
                        type: "invalidValue",
                        resolution: validation.resolution,
                        value
                      });
                      isValid = false;
                    }
                  }
                });
              });
            });
          });
        });
      }
      if (!isValid) {
        debug$4("Invalid value, returning");
        return;
      }
      if (isChanged) {
        debug$4("Server value changed, syncing editor");
        try {
          slateEditor.onChange();
        } catch (err) {
          console.error(err);
          change$.next({
            type: "invalidValue",
            resolution: null,
            value
          });
          return;
        }
        if (hadSelection && !slateEditor.selection) {
          slate.Transforms.select(slateEditor, {
            anchor: {
              path: [0, 0],
              offset: 0
            },
            focus: {
              path: [0, 0],
              offset: 0
            }
          });
          slateEditor.onChange();
        }
        change$.next({
          type: "value",
          value
        });
      } else {
        debug$4("Server value and editor value is equal, no need to sync.");
      }
      previousValue.current = value;
    };
    updateValueFunctionRef.current = updateFunction;
    return updateFunction;
  }, [change$, keyGenerator, portableTextEditor, readOnly, schemaTypes, slateEditor, updateValueDebounced]);
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
  const currentSelection = slateEditor.selection;
  const selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
  if (selectionFocusOnBlock) {
    slate.Transforms.deselect(slateEditor);
  }
  slate.Transforms.removeNodes(slateEditor, {
    at: [currentBlockIndex]
  });
  withPreserveKeys(slateEditor, () => {
    slate.Transforms.insertNodes(slateEditor, currentBlock, {
      at: [currentBlockIndex]
    });
  });
  if (selectionFocusOnBlock) {
    slate.Transforms.select(slateEditor, currentSelection);
  }
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
  slate.Transforms.setNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  });
  if (slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
    const oldBlockChildrenLength = oldBlock.children.length;
    if (currentBlock.children.length < oldBlockChildrenLength) {
      Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {
        const childIndex = oldBlockChildrenLength - 1 - index;
        if (childIndex > 0) {
          debug$4("Removing child");
          slate.Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, childIndex]
          });
        }
      });
    }
    currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldBlock.children[currentBlockChildIndex];
      const isChildChanged = !isEqual__default.default(currentBlockChild, oldBlockChild);
      const isTextChanged = !isEqual__default.default(currentBlockChild.text, oldBlockChild == null ? void 0 : oldBlockChild.text);
      const path = [currentBlockIndex, currentBlockChildIndex];
      if (isChildChanged) {
        if (currentBlockChild._key === (oldBlockChild == null ? void 0 : oldBlockChild._key)) {
          debug$4("Updating changed child", currentBlockChild, oldBlockChild);
          slate.Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path
          });
          const isSpanNode = slate.Text.isText(currentBlockChild) && currentBlockChild._type === "span" && slate.Text.isText(oldBlockChild) && oldBlockChild._type === "span";
          if (isSpanNode && isTextChanged) {
            slate.Transforms.delete(slateEditor, {
              at: {
                focus: {
                  path,
                  offset: 0
                },
                anchor: {
                  path,
                  offset: oldBlockChild.text.length
                }
              }
            });
            slate.Transforms.insertText(slateEditor, currentBlockChild.text, {
              at: path
            });
            slateEditor.onChange();
          } else if (!isSpanNode) {
            debug$4("Updating changed inline object child", currentBlockChild);
            slate.Transforms.setNodes(slateEditor, {
              _key: VOID_CHILD_KEY
            }, {
              at: [...path, 0],
              voids: true
            });
          }
        } else if (oldBlockChild) {
          debug$4("Replacing child", currentBlockChild);
          slate.Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, currentBlockChildIndex]
          });
          withPreserveKeys(slateEditor, () => {
            slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
          });
          slateEditor.onChange();
        } else if (!oldBlockChild) {
          debug$4("Inserting new child", currentBlockChild);
          withPreserveKeys(slateEditor, () => {
            slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
            slateEditor.onChange();
          });
        }
      }
    });
  }
}
const debug$3 = debugWithName("component:PortableTextEditor:Synchronizer");
const debugVerbose = debug$3.enabled && false;
const FLUSH_PATCHES_THROTTLED_MS = process.env.NODE_ENV === "test" ? 500 : 1e3;
function Synchronizer(props) {
  const {
    change$,
    portableTextEditor,
    onChange,
    keyGenerator,
    readOnly,
    value
  } = props;
  const [selection, setSelection] = react.useState(null);
  const pendingPatches = react.useRef([]);
  const syncValue = useSyncValue({
    keyGenerator,
    onChange,
    portableTextEditor,
    readOnly
  });
  const slateEditor = slateReact.useSlate();
  react.useEffect(() => {
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, false);
  }, [slateEditor]);
  const onFlushPendingPatches = react.useCallback(() => {
    if (pendingPatches.current.length > 0) {
      debug$3("Flushing pending patches");
      if (debugVerbose) {
        debug$3("Patches:\n".concat(JSON.stringify(pendingPatches.current, null, 2)));
      }
      const snapshot = PortableTextEditor.getValue(portableTextEditor);
      change$.next({
        type: "mutation",
        patches: pendingPatches.current,
        snapshot
      });
      pendingPatches.current = [];
    }
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, false);
  }, [slateEditor, portableTextEditor, change$]);
  const onFlushPendingPatchesThrottled = react.useMemo(() => {
    return throttle__default.default(() => {
      if (slate.Editor.isNormalizing(slateEditor)) {
        onFlushPendingPatches();
        return;
      }
      onFlushPendingPatchesThrottled();
    }, FLUSH_PATCHES_THROTTLED_MS, {
      leading: false,
      trailing: true
    });
  }, [onFlushPendingPatches, slateEditor]);
  react.useEffect(() => {
    return () => {
      onFlushPendingPatches();
    };
  }, [onFlushPendingPatches]);
  react.useEffect(() => {
    debug$3("Subscribing to editor changes$");
    const sub = change$.subscribe(next => {
      switch (next.type) {
        case "patch":
          IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, true);
          pendingPatches.current.push(next.patch);
          onFlushPendingPatchesThrottled();
          onChange(next);
          break;
        case "selection":
          react.startTransition(() => {
            if (debugVerbose) debug$3("Setting selection");
            setSelection(next.selection);
          });
          onChange(next);
          break;
        default:
          onChange(next);
      }
    });
    return () => {
      debug$3("Unsubscribing to changes$");
      sub.unsubscribe();
    };
  }, [change$, onChange, onFlushPendingPatchesThrottled, slateEditor]);
  const handleOnline = react.useCallback(() => {
    debug$3("Editor is online, syncing from props.value");
    change$.next({
      type: "connection",
      value: "online"
    });
    syncValue(value);
  }, [change$, syncValue, value]);
  const handleOffline = react.useCallback(() => {
    debug$3("Editor is offline");
    change$.next({
      type: "connection",
      value: "offline"
    });
  }, [change$]);
  react.useEffect(() => {
    if (portableTextEditor.props.patches$) {
      window.addEventListener("online", handleOnline);
      window.addEventListener("offline", handleOffline);
    }
    return () => {
      if (portableTextEditor.props.patches$) {
        window.removeEventListener("online", handleOnline);
        window.removeEventListener("offline", handleOffline);
      }
    };
  });
  const isInitialValueFromProps = react.useRef(true);
  react.useEffect(() => {
    debug$3("Value from props changed, syncing new value");
    syncValue(value);
    if (isInitialValueFromProps.current) {
      change$.next({
        type: "loading",
        isLoading: false
      });
      change$.next({
        type: "ready"
      });
      isInitialValueFromProps.current = false;
    }
  }, [change$, syncValue, value]);
  return /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorKeyGeneratorContext.Provider, {
    value: keyGenerator,
    children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorContext.Provider, {
      value: portableTextEditor,
      children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorValueContext.Provider, {
        value,
        children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorReadOnlyContext.Provider, {
          value: readOnly,
          children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorSelectionContext.Provider, {
            value: selection,
            children: props.children
          })
        })
      })
    })
  });
}
const debug$2 = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends react.Component {
  constructor(props) {
    super(props);
    /**
     * An observable of all the editor changes.
     */
    this.change$ = new rxjs.Subject();
    this.setEditable = editable => {
      this.editable = {
        ...this.editable,
        ...editable
      };
    };
    if (!props.schemaType) {
      throw new Error('PortableTextEditor: missing "type" property');
    }
    if (props.incomingPatches$) {
      console.warn("The prop 'incomingPatches$' is deprecated and renamed to 'patches$'");
    }
    this.change$.next({
      type: "loading",
      isLoading: true
    });
    this.schemaTypes = getPortableTextMemberSchemaTypes(props.schemaType.hasOwnProperty("jsonType") ? props.schemaType : compileType(props.schemaType));
  }
  componentDidUpdate(prevProps) {
    if (this.props.schemaType !== prevProps.schemaType) {
      this.schemaTypes = getPortableTextMemberSchemaTypes(this.props.schemaType.hasOwnProperty("jsonType") ? this.props.schemaType : compileType(this.props.schemaType));
    }
    if (this.props.editorRef !== prevProps.editorRef && this.props.editorRef) {
      this.props.editorRef.current = this;
    }
  }
  render() {
    const {
      onChange,
      value,
      children,
      patches$,
      incomingPatches$
    } = this.props;
    const {
      change$
    } = this;
    const _patches$ = incomingPatches$ || patches$;
    const maxBlocks = typeof this.props.maxBlocks === "undefined" ? void 0 : parseInt(this.props.maxBlocks.toString(), 10) || void 0;
    const readOnly = Boolean(this.props.readOnly);
    const keyGenerator = this.props.keyGenerator || defaultKeyGenerator;
    return /* @__PURE__ */jsxRuntime.jsx(SlateContainer, {
      keyGenerator,
      maxBlocks,
      patches$: _patches$,
      portableTextEditor: this,
      readOnly,
      children: /* @__PURE__ */jsxRuntime.jsx(Synchronizer, {
        change$,
        keyGenerator,
        onChange,
        portableTextEditor: this,
        readOnly,
        value,
        children
      })
    });
  }
}
// Static API methods
PortableTextEditor.activeAnnotations = editor => {
  return editor && editor.editable ? editor.editable.activeAnnotations() : [];
};
PortableTextEditor.addAnnotation = (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.addAnnotation(type, value);
};
PortableTextEditor.blur = editor => {
  var _a;
  debug$2("Host blurred");
  (_a = editor.editable) == null ? void 0 : _a.blur();
};
PortableTextEditor.delete = (editor, selection, options) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.delete(selection, options);
};
PortableTextEditor.findDOMNode = (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.findDOMNode(element);
};
PortableTextEditor.findByPath = (editor, path) => {
  var _a;
  return ((_a = editor.editable) == null ? void 0 : _a.findByPath(path)) || [];
};
PortableTextEditor.focus = editor => {
  var _a;
  debug$2("Host requesting focus");
  (_a = editor.editable) == null ? void 0 : _a.focus();
};
PortableTextEditor.focusBlock = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusBlock();
};
PortableTextEditor.focusChild = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusChild();
};
PortableTextEditor.getSelection = editor => {
  return editor.editable ? editor.editable.getSelection() : null;
};
PortableTextEditor.getValue = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.getValue();
};
PortableTextEditor.hasBlockStyle = (editor, blockStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasBlockStyle(blockStyle);
};
PortableTextEditor.hasListStyle = (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasListStyle(listStyle);
};
PortableTextEditor.isCollapsedSelection = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isCollapsedSelection();
};
PortableTextEditor.isExpandedSelection = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isExpandedSelection();
};
PortableTextEditor.isMarkActive = (editor, mark) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isMarkActive(mark);
};
PortableTextEditor.insertChild = (editor, type, value) => {
  var _a;
  debug$2("Host inserting child");
  return (_a = editor.editable) == null ? void 0 : _a.insertChild(type, value);
};
PortableTextEditor.insertBlock = (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBlock(type, value);
};
PortableTextEditor.insertBreak = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBreak();
};
PortableTextEditor.isVoid = (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isVoid(element);
};
PortableTextEditor.isObjectPath = (editor, path) => {
  if (!path || !Array.isArray(path)) return false;
  const isChildObjectEditPath = path.length > 3 && path[1] === "children";
  const isBlockObjectEditPath = path.length > 1 && path[1] !== "children";
  return isBlockObjectEditPath || isChildObjectEditPath;
};
PortableTextEditor.marks = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.marks();
};
PortableTextEditor.select = (editor, selection) => {
  var _a;
  debug$2("Host setting selection", selection);
  (_a = editor.editable) == null ? void 0 : _a.select(selection);
};
PortableTextEditor.removeAnnotation = (editor, type) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.removeAnnotation(type);
};
PortableTextEditor.toggleBlockStyle = (editor, blockStyle) => {
  var _a;
  debug$2("Host is toggling block style");
  return (_a = editor.editable) == null ? void 0 : _a.toggleBlockStyle(blockStyle);
};
PortableTextEditor.toggleList = (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.toggleList(listStyle);
};
PortableTextEditor.toggleMark = (editor, mark) => {
  var _a;
  debug$2("Host toggling mark", mark);
  (_a = editor.editable) == null ? void 0 : _a.toggleMark(mark);
};
PortableTextEditor.getFragment = editor => {
  var _a;
  debug$2("Host getting fragment");
  return (_a = editor.editable) == null ? void 0 : _a.getFragment();
};
const debug$1 = debugWithName("components:Leaf");
const EMPTY_MARKS = [];
const Leaf = props => {
  const {
    attributes,
    children,
    leaf,
    schemaTypes,
    renderChild,
    renderDecorator,
    renderAnnotation
  } = props;
  const spanRef = react.useRef(null);
  const portableTextEditor = usePortableTextEditor();
  const blockSelected = slateReact.useSelected();
  const [focused, setFocused] = react.useState(false);
  const [selected, setSelected] = react.useState(false);
  const block = children.props.parent;
  const path = react.useMemo(() => block ? [{
    _key: block == null ? void 0 : block._key
  }, "children", {
    _key: leaf._key
  }] : [], [block, leaf._key]);
  const decoratorValues = react.useMemo(() => schemaTypes.decorators.map(dec => dec.value), [schemaTypes.decorators]);
  const marks = react.useMemo(() => uniq__default.default((leaf.marks || EMPTY_MARKS).filter(mark => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]);
  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS;
  const annotations = react.useMemo(() => annotationMarks.map(mark => {
    var _a;
    return !decoratorValues.includes(mark) && ((_a = block == null ? void 0 : block.markDefs) == null ? void 0 : _a.find(def => def._key === mark));
  }).filter(Boolean), [annotationMarks, block, decoratorValues]);
  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  react.useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(false);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    if (sel && isEqual__default.default(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
      react.startTransition(() => {
        setFocused(true);
      });
    }
  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);
  const setSelectedFromRange = react.useCallback(() => {
    if (!shouldTrackSelectionAndFocus) {
      return;
    }
    debug$1("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(false);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range = winSelection.getRangeAt(0);
      if (spanRef.current && range.intersectsNode(spanRef.current)) {
        setSelected(true);
      } else {
        setSelected(false);
      }
    } else {
      setSelected(false);
    }
  }, [shouldTrackSelectionAndFocus]);
  react.useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      return void 0;
    }
    const sub = portableTextEditor.change$.subscribe(next => {
      if (next.type === "blur") {
        setFocused(false);
        setSelected(false);
        return;
      }
      if (next.type === "focus") {
        const sel = PortableTextEditor.getSelection(portableTextEditor);
        if (sel && isEqual__default.default(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        }
        setSelectedFromRange();
        return;
      }
      if (next.type === "selection") {
        if (next.selection && isEqual__default.default(next.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        } else {
          setFocused(false);
        }
        setSelectedFromRange();
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]);
  react.useEffect(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = react.useMemo(() => {
    let returnedChildren = children;
    if (slate.Text.isText(leaf) && leaf._type === schemaTypes.span.name) {
      marks.forEach(mark => {
        const schemaType = schemaTypes.decorators.find(dec => dec.value === mark);
        if (schemaType && renderDecorator) {
          const _props = Object.defineProperty({
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType,
            value: mark
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaType;
            }
          });
          returnedChildren = renderDecorator(_props);
        }
      });
      if (block && annotations.length > 0) {
        annotations.forEach(annotation => {
          const schemaType = schemaTypes.annotations.find(t => t.name === annotation._type);
          if (schemaType) {
            if (renderAnnotation) {
              const _props = Object.defineProperty({
                block,
                children: returnedChildren,
                editorElementRef: spanRef,
                focused,
                path,
                selected,
                schemaType,
                value: annotation
              }, "type", {
                enumerable: false,
                get() {
                  console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
                  return schemaType;
                }
              });
              returnedChildren = /* @__PURE__ */jsxRuntime.jsx("span", {
                ref: spanRef,
                children: renderAnnotation(_props)
              });
            } else {
              returnedChildren = /* @__PURE__ */jsxRuntime.jsx(DefaultAnnotation, {
                annotation,
                children: /* @__PURE__ */jsxRuntime.jsx("span", {
                  ref: spanRef,
                  children: returnedChildren
                })
              });
            }
          }
        });
      }
      if (block && renderChild) {
        const child = block.children.find(_child => _child._key === leaf._key);
        if (child) {
          const defaultRendered = /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
            children: returnedChildren
          });
          const _props = Object.defineProperty({
            annotations,
            children: defaultRendered,
            editorElementRef: spanRef,
            focused,
            path,
            schemaType: schemaTypes.span,
            selected,
            value: child
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaTypes.span;
            }
          });
          returnedChildren = renderChild(_props);
        }
      }
    }
    return returnedChildren;
  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);
  return react.useMemo(() => /* @__PURE__ */jsxRuntime.jsx("span", {
    ...attributes,
    ref: spanRef,
    children: content
  }, leaf._key), [leaf, attributes, content]);
};
const useIsomorphicEffect = typeof window === "undefined" ? react.useEffect : react.useLayoutEffect;
function useForwardedRef(ref) {
  const innerRef = react.useRef(null);
  useIsomorphicEffect(() => {
    if (!ref) return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
const debug = debugWithName("component:Editable");
const PLACEHOLDER_STYLE = {
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
};
const EMPTY_DECORATORS = [];
const PortableTextEditable = react.forwardRef(function PortableTextEditable2(props, forwardedRef) {
  const {
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props;
  const portableTextEditor = usePortableTextEditor();
  const readOnly = usePortableTextEditorReadOnlyStatus();
  const keyGenerator = usePortableTextEditorKeyGenerator();
  const ref = useForwardedRef(forwardedRef);
  const [editableElement, setEditableElement] = react.useState(null);
  const [hasInvalidValue, setHasInvalidValue] = react.useState(false);
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const slateEditor = slateReact.useSlate();
  const blockTypeName = schemaTypes.block.name;
  const withInsertData = react.useMemo(() => createWithInsertData(change$, schemaTypes, keyGenerator), [change$, keyGenerator, schemaTypes]);
  const withHotKeys = react.useMemo(() => createWithHotkeys(schemaTypes, keyGenerator, portableTextEditor, hotkeys), [hotkeys, keyGenerator, portableTextEditor, schemaTypes]);
  react.useMemo(() => {
    if (readOnly) {
      debug("Editable is in read only mode");
      return withInsertData(slateEditor);
    }
    debug("Editable is in edit mode");
    return withInsertData(withHotKeys(slateEditor));
  }, [readOnly, slateEditor, withHotKeys, withInsertData]);
  const renderElement = react.useCallback(eProps => /* @__PURE__ */jsxRuntime.jsx(Element, {
    ...eProps,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem,
    renderStyle,
    schemaTypes,
    spellCheck
  }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]);
  const renderLeaf = react.useCallback(lProps => {
    const rendered = /* @__PURE__ */jsxRuntime.jsx(Leaf, {
      ...lProps,
      schemaTypes,
      renderAnnotation,
      renderChild,
      renderDecorator,
      readOnly
    });
    if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "") {
      return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/* @__PURE__ */jsxRuntime.jsx("span", {
          style: PLACEHOLDER_STYLE,
          contentEditable: false,
          children: renderPlaceholder()
        }), rendered]
      });
    }
    return rendered;
  }, [readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]);
  const restoreSelectionFromProps = react.useCallback(() => {
    if (propsSelection) {
      debug("Selection from props ".concat(JSON.stringify(propsSelection)));
      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));
      if (normalizedSelection !== null) {
        debug("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        if (slateRange) {
          slate.Transforms.select(slateEditor, slateRange);
          if (!slateEditor.operations.some(o => o.type === "set_selection")) {
            change$.next({
              type: "selection",
              selection: normalizedSelection
            });
          }
          slateEditor.onChange();
        }
      }
    }
  }, [propsSelection, slateEditor, blockTypeName, change$]);
  react.useEffect(() => {
    debug("Subscribing to editor changes$");
    const sub = change$.subscribe(next => {
      switch (next.type) {
        case "ready":
          restoreSelectionFromProps();
          break;
        case "invalidValue":
          setHasInvalidValue(true);
          break;
        case "value":
          setHasInvalidValue(false);
          break;
      }
    });
    return () => {
      debug("Unsubscribing to changes$");
      sub.unsubscribe();
    };
  }, [change$, restoreSelectionFromProps]);
  react.useEffect(() => {
    if (propsSelection && !hasInvalidValue) {
      restoreSelectionFromProps();
    }
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const handleCopy = react.useCallback(event => {
    if (onCopy) {
      const result = onCopy(event);
      if (result !== void 0) {
        event.preventDefault();
      }
    }
  }, [onCopy]);
  const handlePaste = react.useCallback(event => {
    event.preventDefault();
    if (!slateEditor.selection) {
      return;
    }
    if (!onPaste) {
      debug("Pasting normally");
      slateEditor.insertData(event.clipboardData);
      return;
    }
    new Promise(resolve => {
      const value = PortableTextEditor.getValue(portableTextEditor);
      const ptRange = toPortableTextRange(value, slateEditor.selection, schemaTypes);
      const path = (ptRange == null ? void 0 : ptRange.focus.path) || [];
      resolve(onPaste({
        event,
        value,
        path,
        schemaTypes
      }));
    }).then(result => {
      debug("Custom paste function from client resolved", result);
      change$.next({
        type: "loading",
        isLoading: true
      });
      if (!result || !result.insert) {
        debug("No result from custom paste handler, pasting normally");
        slateEditor.insertData(event.clipboardData);
        return;
      }
      if (result && result.insert) {
        slateEditor.insertFragment(toSlateValue(result.insert, {
          schemaTypes
        }));
        change$.next({
          type: "loading",
          isLoading: false
        });
        return;
      }
      console.warn("Your onPaste function returned something unexpected:", result);
    }).catch(error => {
      change$.next({
        type: "loading",
        isLoading: false
      });
      console.error(error);
      return error;
    });
  }, [change$, onPaste, portableTextEditor, schemaTypes, slateEditor]);
  const handleOnFocus = react.useCallback(event => {
    if (onFocus) {
      onFocus(event);
    }
    if (!event.isDefaultPrevented()) {
      const selection = PortableTextEditor.getSelection(portableTextEditor);
      if (selection === null) {
        slate.Transforms.select(slateEditor, slate.Editor.start(slateEditor, []));
        slateEditor.onChange();
      }
      change$.next({
        type: "focus",
        event
      });
      const newSelection = PortableTextEditor.getSelection(portableTextEditor);
      if (selection === newSelection) {
        change$.next({
          type: "selection",
          selection
        });
      }
    }
  }, [onFocus, portableTextEditor, change$, slateEditor]);
  const handleOnBlur = react.useCallback(event => {
    if (onBlur) {
      onBlur(event);
    }
    if (!event.isPropagationStopped()) {
      change$.next({
        type: "blur",
        event
      });
    }
  }, [change$, onBlur]);
  const handleOnBeforeInput = react.useCallback(event => {
    if (onBeforeInput) {
      onBeforeInput(event);
    }
  }, [onBeforeInput]);
  const validateSelection = react.useCallback(() => {
    if (!slateEditor.selection) {
      return;
    }
    const root = slateReact.ReactEditor.findDocumentOrShadowRoot(slateEditor);
    const {
      activeElement
    } = root;
    if (ref.current !== activeElement) {
      return;
    }
    const window = slateReact.ReactEditor.getWindow(slateEditor);
    const domSelection = window.getSelection();
    if (!domSelection || domSelection.rangeCount === 0) {
      return;
    }
    const existingDOMRange = domSelection.getRangeAt(0);
    try {
      const newDOMRange = slateReact.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
      if (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) {
        debug("DOM range out of sync, validating selection");
        domSelection == null ? void 0 : domSelection.removeAllRanges();
        domSelection.addRange(newDOMRange);
      }
    } catch (error) {
      debug("Could not resolve selection, selecting top document");
      slate.Transforms.deselect(slateEditor);
      if (slateEditor.children.length > 0) {
        slate.Transforms.select(slateEditor, [0, 0]);
      }
      slateEditor.onChange();
    }
  }, [ref, slateEditor]);
  react.useEffect(() => {
    if (editableElement) {
      const mutationObserver = new MutationObserver(validateSelection);
      mutationObserver.observe(editableElement, {
        attributeOldValue: false,
        attributes: false,
        characterData: false,
        childList: true,
        subtree: true
      });
      return () => {
        mutationObserver.disconnect();
      };
    }
    return void 0;
  }, [validateSelection, editableElement]);
  const handleKeyDown = react.useCallback(event => {
    if (props.onKeyDown) {
      props.onKeyDown(event);
    }
    if (!event.isDefaultPrevented()) {
      slateEditor.pteWithHotKeys(event);
    }
  }, [props, slateEditor]);
  const scrollSelectionIntoViewToSlate = react.useMemo(() => {
    if (scrollSelectionIntoView === void 0) {
      return void 0;
    }
    if (scrollSelectionIntoView === null) {
      return noop__default.default;
    }
    return (editor, domRange) => {
      scrollSelectionIntoView(portableTextEditor, domRange);
    };
  }, [portableTextEditor, scrollSelectionIntoView]);
  const decorate = react.useCallback(() => {
    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: true
      }];
    }
    return EMPTY_DECORATORS;
  }, [schemaTypes, slateEditor]);
  react.useEffect(() => {
    ref.current = slateReact.ReactEditor.toDOMNode(slateEditor, slateEditor);
    setEditableElement(ref.current);
  }, [slateEditor, ref]);
  if (!portableTextEditor) {
    return null;
  }
  return hasInvalidValue ? null : /* @__PURE__ */jsxRuntime.jsx(slateReact.Editable, {
    ...restProps,
    autoFocus: false,
    className: restProps.className || "pt-editable",
    decorate,
    onBlur: handleOnBlur,
    onCopy: handleCopy,
    onDOMBeforeInput: handleOnBeforeInput,
    onFocus: handleOnFocus,
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    readOnly,
    renderPlaceholder: void 0,
    renderElement,
    renderLeaf,
    scrollSelectionIntoView: scrollSelectionIntoViewToSlate
  });
});
function compactPatches(patches) {
  const lastPatch = patches.slice(-1)[0];
  if (lastPatch && lastPatch.type === "unset" && lastPatch.path.length === 0) {
    return [lastPatch];
  }
  let finalPatches = patches;
  finalPatches = finalPatches.filter((patch, index) => {
    if (!patch) {
      return false;
    }
    const nextPatch = finalPatches[index + 1];
    if (nextPatch && nextPatch.type === "set" && patch.type === "set" && isEqual__default.default(patch.path, nextPatch.path)) {
      return false;
    }
    return true;
  });
  if (finalPatches.length !== patches.length) {
    return finalPatches;
  }
  return patches;
}
exports.PortableTextEditable = PortableTextEditable;
exports.PortableTextEditor = PortableTextEditor;
exports.compactPatches = compactPatches;
exports.keyGenerator = defaultKeyGenerator;
exports.usePortableTextEditor = usePortableTextEditor;
exports.usePortableTextEditorSelection = usePortableTextEditorSelection;
//# sourceMappingURL=index.js.map
