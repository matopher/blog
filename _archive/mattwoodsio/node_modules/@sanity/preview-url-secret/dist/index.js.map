{"version":3,"file":"index.js","sources":["../src/validatePreviewUrl.ts","../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts"],"sourcesContent":["import { isDev } from './constants'\nimport { createClientWithConfig } from './createClientWithConfig'\nimport { parsePreviewUrl } from './parsePreviewUrl'\nimport {\n  ParsedPreviewUrl,\n  PreviewUrlValidateUrlResult,\n  SanityClientLike,\n} from './types'\nimport { validateSecret } from './validateSecret'\n\n/**\n * @public\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  /**\n   * @deprecated - this option is automatically determined based on the environment\n   */\n  // Default value based on https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent\n  disableCacheNoStore: boolean = globalThis.navigator?.userAgent ===\n    'Cloudflare-Workers',\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return { isValid: false }\n  }\n\n  const { isValid, studioUrl } = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n  let studioOrigin: string | undefined\n  if (isValid) {\n    try {\n      studioOrigin = new URL(studioUrl!).origin\n    } catch (error) {\n      if (isDev) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to parse studioUrl', error, {\n          previewUrl,\n          studioUrl,\n        })\n      }\n    }\n  }\n\n  return { isValid, redirectTo, studioOrigin }\n}\n\nexport type { PreviewUrlValidateUrlResult, SanityClientLike }\n","import { apiVersion } from './constants'\nimport { SanityClientLike } from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(\n  client: SanityClientLike,\n): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated rigth after it's created\n    useCdn: false,\n    // The documents that hold secrets are never drafts\n    perspective: 'published',\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","import {\n  urlSearchParamPreviewPathname,\n  urlSearchParamPreviewSecret,\n} from './constants'\nimport { ParsedPreviewUrl } from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  let redirectTo = undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const { pathname, search } = new URL(unsafeRedirectTo, 'http://localhost')\n    redirectTo = `${pathname}${search}`\n  }\n  return { secret, redirectTo }\n}\n","import { fetchSecretQuery, tag } from './constants'\nimport type {\n  FetchSecretQueryParams,\n  FetchSecretQueryResponse,\n  SanityClientLike,\n} from './types'\n\n/** @internal */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore: boolean,\n): Promise<{ isValid: boolean; studioUrl: string | null }> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return { isValid: false, studioUrl: null }\n  }\n  const result = await client.fetch<\n    FetchSecretQueryResponse,\n    FetchSecretQueryParams\n  >(\n    fetchSecretQuery,\n    { secret: secret },\n    {\n      tag,\n      // In CloudFlare Workers we can't pass the cache header\n      ...(!disableCacheNoStore ? { cache: 'no-store' } : undefined),\n    },\n  )\n  if (!result?._id || !result?._updatedAt || !result?.secret) {\n    return { isValid: false, studioUrl: null }\n  }\n  return { isValid: secret === result.secret, studioUrl: result.studioUrl }\n}\n"],"names":["async","validatePreviewUrl","_client","previewUrl","disableCacheNoStore","navigator","_a","userAgent","client","TypeError","config","token","withConfig","apiVersion","useCdn","perspective","resultSourceMap","stega","createClientWithConfig","parsedPreviewUrl","unsafeUrl","url","URL","secret","searchParams","get","urlSearchParamPreviewSecret","Error","redirectTo","unsafeRedirectTo","urlSearchParamPreviewPathname","pathname","search","parsePreviewUrl","error","isDev","console","isValid","studioUrl","EdgeRuntime","Promise","resolve","setTimeout","trim","result","fetch","fetchSecretQuery","tag","cache","_id","_updatedAt","validateSecret","studioOrigin","origin"],"mappings":"8EAasBA,eAAAC,EACpBC,EACAC,EAKAC,EACE,uBADF,IAA+B,oBAAWC,gBAAX,EAAAC,EAAsBC,UAArD,IAGM,MAAAC,ECfD,SACLA,GAEA,IAAKA,EACG,MAAA,IAAIC,UAAU,wBAGlB,IAACD,EAAOE,SAASC,MACb,MAAA,IAAIF,UAAU,0CAGtB,OAAOD,EAAOI,WAAW,CAEvBC,aAEAC,QAAQ,EAERC,YAAa,YAEbC,iBAAiB,EAEjBC,OAAO,GAEX,CDRiBC,CAAuBhB,GAClC,IAAAiB,EACA,IACFA,EEjBG,SAAyBC,GACxB,MAAAC,EAAM,IAAIC,IAAIF,EAAW,oBACzBG,EAASF,EAAIG,aAAaC,IAAIC,GACpC,IAAKH,EACG,MAAA,IAAII,MAAM,kBAEd,IAAAC,EACJ,MAAMC,EAAmBR,EAAIG,aAAaC,IAAIK,GAC9C,GAAID,EAAkB,CACpB,MAAME,SAAEA,EAAUC,OAAAA,GAAW,IAAIV,IAAIO,EAAkB,oBAC1CD,EAAA,GAAGG,IAAWC,GAC7B,CACO,MAAA,CAAET,SAAQK,aACnB,CFIuBK,CAAgB9B,SAC5B+B,GACP,OAAIC,GAEFC,QAAQF,MAAM,8BAA+BA,EAAO,CAClD/B,aACAK,WAGG,CAAE6B,SAAS,EACpB,CAEA,MAAMA,QAAEA,EAAAC,UAASA,SG9BGtC,eACpBQ,EACAe,EACAnB,GAOA,UAHWmC,YAAgB,WACnB,IAAIC,SAASC,GAAYC,WAAWD,EAAS,QAEhDlB,IAAWA,EAAOoB,OACrB,MAAO,CAAEN,SAAS,EAAOC,UAAW,MAEhC,MAAAM,QAAepC,EAAOqC,MAI1BC,EACA,CAAEvB,UACF,CACEwB,SAEK3C,OAA8C,EAAxB,CAAE4C,MAAO,cAGpC,aAACJ,KAAQK,WAAQL,KAAQM,YAAuB,MAARN,GAAQA,EAAArB,OAG7C,CAAEc,QAASd,IAAWqB,EAAOrB,OAAQe,UAAWM,EAAON,WAFrD,CAAED,SAAS,EAAOC,UAAW,KAGxC,CHCuCa,CACnC3C,EACAW,EAAiBI,OACjBnB,GAEIwB,EAAaS,EAAUlB,EAAiBS,gBAAa,EACvD,IAAAwB,EACA,GAAAf,EACE,IACae,EAAA,IAAI9B,IAAIgB,GAAYe,aAC5BnB,GAGLC,GAAAC,QAAQF,MAAM,4BAA6BA,EAAO,CAChD/B,aACAmC,aAGN,CAGK,MAAA,CAAED,UAAST,aAAYwB,eAChC"}