{"version":3,"file":"index.cjs","sources":["../src/validatePreviewUrl.ts","../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts"],"sourcesContent":["import { isDev } from './constants'\nimport { createClientWithConfig } from './createClientWithConfig'\nimport { parsePreviewUrl } from './parsePreviewUrl'\nimport {\n  ParsedPreviewUrl,\n  PreviewUrlValidateUrlResult,\n  SanityClientLike,\n} from './types'\nimport { validateSecret } from './validateSecret'\n\n/**\n * @public\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  /**\n   * @deprecated - this option is automatically determined based on the environment\n   */\n  // Default value based on https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent\n  disableCacheNoStore: boolean = globalThis.navigator?.userAgent ===\n    'Cloudflare-Workers',\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return { isValid: false }\n  }\n\n  const { isValid, studioUrl } = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n  let studioOrigin: string | undefined\n  if (isValid) {\n    try {\n      studioOrigin = new URL(studioUrl!).origin\n    } catch (error) {\n      if (isDev) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to parse studioUrl', error, {\n          previewUrl,\n          studioUrl,\n        })\n      }\n    }\n  }\n\n  return { isValid, redirectTo, studioOrigin }\n}\n\nexport type { PreviewUrlValidateUrlResult, SanityClientLike }\n","import { apiVersion } from './constants'\nimport { SanityClientLike } from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(\n  client: SanityClientLike,\n): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated rigth after it's created\n    useCdn: false,\n    // The documents that hold secrets are never drafts\n    perspective: 'published',\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","import {\n  urlSearchParamPreviewPathname,\n  urlSearchParamPreviewSecret,\n} from './constants'\nimport { ParsedPreviewUrl } from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  let redirectTo = undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const { pathname, search } = new URL(unsafeRedirectTo, 'http://localhost')\n    redirectTo = `${pathname}${search}`\n  }\n  return { secret, redirectTo }\n}\n","import { fetchSecretQuery, tag } from './constants'\nimport type {\n  FetchSecretQueryParams,\n  FetchSecretQueryResponse,\n  SanityClientLike,\n} from './types'\n\n/** @internal */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore: boolean,\n): Promise<{ isValid: boolean; studioUrl: string | null }> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return { isValid: false, studioUrl: null }\n  }\n  const result = await client.fetch<\n    FetchSecretQueryResponse,\n    FetchSecretQueryParams\n  >(\n    fetchSecretQuery,\n    { secret: secret },\n    {\n      tag,\n      // In CloudFlare Workers we can't pass the cache header\n      ...(!disableCacheNoStore ? { cache: 'no-store' } : undefined),\n    },\n  )\n  if (!result?._id || !result?._updatedAt || !result?.secret) {\n    return { isValid: false, studioUrl: null }\n  }\n  return { isValid: secret === result.secret, studioUrl: result.studioUrl }\n}\n"],"names":["exports","urlSearchParamPreviewPathname","constants","b","urlSearchParamPreviewSecret","u","validatePreviewUrl","async","_client","previewUrl","disableCacheNoStore","navigator","_a","userAgent","client","TypeError","config","token","withConfig","apiVersion","a","useCdn","perspective","resultSourceMap","stega","createClientWithConfig","parsedPreviewUrl","unsafeUrl","url","URL","secret","searchParams","get","Error","redirectTo","unsafeRedirectTo","pathname","search","parsePreviewUrl","error","isDev","i","console","isValid","studioUrl","EdgeRuntime","Promise","resolve","setTimeout","trim","result","fetch","fetchSecretQuery","f","tag","t","cache","_id","_updatedAt","validateSecret","studioOrigin","origin"],"mappings":"6GA4DAA,QAAAC,8BAAAC,EAAAC,EAAAH,QAAAI,4BAAAF,EAAAG,EAAAL,QAAAM,mBA/CsBC,eACpBC,EACAC,EAKAC,EACE,uBADF,IAA+B,oBAAWC,gBAAX,EAAAC,EAAsBC,UAArD,IAGM,MAAAC,ECfD,SACLA,GAEA,IAAKA,EACG,MAAA,IAAIC,UAAU,wBAGlB,IAACD,EAAOE,SAASC,MACb,MAAA,IAAIF,UAAU,0CAGtB,OAAOD,EAAOI,WAAW,CAAAC,WAEvBA,EAAAC,EAEAC,QAAQ,EAERC,YAAa,YAEbC,iBAAiB,EAEjBC,OAAO,GAEX,CDRiBC,CAAuBjB,GAClC,IAAAkB,EACA,IACFA,EEjBG,SAAyBC,GACxB,MAAAC,EAAM,IAAIC,IAAIF,EAAW,oBACzBG,EAASF,EAAIG,aAAaC,IAAI5B,EAA2BC,GAC/D,IAAKyB,EACG,MAAA,IAAIG,MAAM,kBAEd,IAAAC,EACJ,MAAMC,EAAmBP,EAAIG,aAAaC,IAAI/B,EAA6BE,GAC3E,GAAIgC,EAAkB,CACpB,MAAMC,SAAEA,EAAUC,OAAAA,GAAW,IAAIR,IAAIM,EAAkB,oBAC1CD,EAAA,GAAGE,IAAWC,GAC7B,CACO,MAAA,CAAEP,SAAQI,aACnB,CFIuBI,CAAgB7B,SAC5B8B,GACP,OAAIC,EAEFC,GAAAC,QAAQH,MAAM,8BAA+BA,EAAO,CAClD9B,aACAK,WAGG,CAAE6B,SAAS,EACpB,CAEA,MAAMA,QAAEA,EAAAC,UAASA,SG9BGrC,eACpBO,EACAgB,EACApB,GAOA,UAHWmC,YAAgB,WACnB,IAAIC,SAASC,GAAYC,WAAWD,EAAS,QAEhDjB,IAAWA,EAAOmB,OACrB,MAAO,CAAEN,SAAS,EAAOC,UAAW,MAEhC,MAAAM,QAAepC,EAAOqC,MAI1BC,EAAAC,EACA,CAAEvB,UACF,CAAAwB,IACEA,EAAAC,KAEK7C,OAA8C,EAAxB,CAAE8C,MAAO,cAGpC,aAACN,KAAQO,WAAQP,KAAQQ,YAAuB,MAARR,GAAQA,EAAApB,OAG7C,CAAEa,QAASb,IAAWoB,EAAOpB,OAAQc,UAAWM,EAAON,WAFrD,CAAED,SAAS,EAAOC,UAAW,KAGxC,CHCuCe,CACnC7C,EACAY,EAAiBI,OACjBpB,GAEIwB,EAAaS,EAAUjB,EAAiBQ,gBAAa,EACvD,IAAA0B,EACA,GAAAjB,EACE,IACaiB,EAAA,IAAI/B,IAAIe,GAAYiB,aAC5BtB,GACHC,EAAAA,GAEFE,QAAQH,MAAM,4BAA6BA,EAAO,CAChD9B,aACAmC,aAGN,CAGK,MAAA,CAAED,UAAST,aAAY0B,eAChC"}