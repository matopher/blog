{"version":3,"file":"PresentationTool.js","sources":["../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../../channels/src/constants.ts","../../../channels/src/helpers.ts","../../../channels/src/controller.ts","../../../visual-editing-helpers/dist/_chunks/urlStringToPath.js","../../../visual-editing-helpers/dist/index.js","../../src/components/ErrorCard.tsx","../../src/usePresentationTool.ts","../../src/editor/PresentationPaneRouterProvider.tsx","../../src/editor/DocumentListPane.tsx","../../src/editor/DocumentPane.tsx","../../src/editor/DocumentPanel.tsx","../../src/editor/ContentEditor.tsx","../../src/panels/PanelsContext.tsx","../../src/panels/Panel.tsx","../../src/panels/PanelResizer.tsx","../../src/panels/usePanelId.ts","../../src/lib/debounce.ts","../../src/panels/usePanelsStorage.ts","../../src/panels/util.ts","../../src/panels/Panels.tsx","../../src/PresentationNavigateProvider.tsx","../../src/PresentationNavigator.tsx","../../src/useLocalState.ts","../../src/PresentationParamsProvider.tsx","../../src/PresentationProvider.tsx","../../../../node_modules/.pnpm/valibot@0.29.0/node_modules/valibot/dist/index.js","../../src/reducers/presentationReducer.ts","../../src/preview/IFrame.tsx","../../src/preview/PreviewLocationInput.tsx","../../src/preview/ShareUrlMenuItems.tsx","../../src/preview/PreviewFrame.tsx","../../src/useDocumentsOnPage.ts","../../src/lib/parse.ts","../../src/useParams.ts","../../src/usePreviewUrl.ts","../../src/PresentationTool.tsx"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import type { ChannelMsgType } from './types'\n\nexport const RESPONSE_TIMEOUT = 1000\nexport const HEARTBEAT_INTERVAL = 1000\nexport const HANDSHAKE_INTERVAL = 500\n\nexport const INTERNAL_MSG_TYPES = [\n  'channel/disconnect',\n  'channel/response',\n  'channel/heartbeat',\n] satisfies ChannelMsgType[]\n\nexport const HANDSHAKE_MSG_TYPES = [\n  'handshake/syn',\n  'handshake/syn-ack',\n  'handshake/ack',\n] satisfies ChannelMsgType[]\n","import { HANDSHAKE_MSG_TYPES, INTERNAL_MSG_TYPES } from './constants'\nimport { ChannelMsgType, HandshakeMsgType, InternalMsgType } from './types'\n\nexport const isInternalMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is InternalMsgType => {\n  return INTERNAL_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isHandshakeMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is HandshakeMsgType => {\n  return HANDSHAKE_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isLegacyHandshakeMessage = ({\n  data = {},\n}: MessageEvent): boolean => {\n  return (\n    // Check data is a record type\n    typeof data === 'object' &&\n    data !== null &&\n    !Array.isArray(data) &&\n    // The \"domain\" key was introduced in commit 4854e7f\n    !('domain' in data) &&\n    // Check the rest of the object shape is present\n    ['id', 'type', 'from', 'to'].every((key) => key in data) &&\n    // Prior to 4854e7f only handshake events were emitted prior to an established connection\n    data.type.startsWith('handshake/')\n  )\n}\n","import { v4 as uuid } from 'uuid'\n\nimport {\n  HANDSHAKE_INTERVAL,\n  HEARTBEAT_INTERVAL,\n  RESPONSE_TIMEOUT,\n} from './constants'\nimport { isHandshakeMessage, isLegacyHandshakeMessage } from './helpers'\nimport type {\n  ChannelMsg,\n  ChannelsController,\n  ChannelsControllerChannel,\n  ChannelsControllerOptions,\n  ChannelStatus,\n  InternalMsgType,\n  ProtocolMsg,\n  ToArgs,\n} from './types'\n\nexport function createChannelsController<\n  Sends extends ChannelMsg,\n  Receives extends ChannelMsg,\n>(config: ChannelsControllerOptions<Receives>): ChannelsController {\n  const { destroy, send } = createChannelsControllerInternal<Sends, Receives>(\n    config,\n  )\n  const sources = new Set<MessageEventSource>()\n  const sendToSource = new WeakMap<\n    MessageEventSource,\n    ChannelsController['send']\n  >()\n  const destroySource = new Set<ChannelsController['destroy']>()\n\n  const sendToMany = ((id, type, data) => {\n    send(id, type, data)\n    for (const source of sources) {\n      if (\n        source &&\n        'closed' in source &&\n        !source.closed &&\n        sendToSource.has(source)\n      ) {\n        const send = sendToSource.get(source)\n        send!(id, type, data)\n      }\n    }\n  }) satisfies ChannelsController['send']\n\n  const destroyMany = (() => {\n    destroy()\n    for (const destroy of destroySource) {\n      destroy()\n    }\n  }) satisfies ChannelsController['destroy']\n\n  return {\n    destroy: destroyMany,\n    send: sendToMany,\n    addSource(source) {\n      if (sources.has(source)) {\n        return\n      }\n      if (!('closed' in source)) {\n        // eslint-disable-next-line no-console\n        console.warn('Source is unsupported', { source })\n        throw new Error('Source is unsupported')\n      }\n      if (source.closed) {\n        throw new Error('Source is closed')\n      }\n      const { send, destroy } = createChannelsControllerInternal<\n        Sends,\n        Receives\n      >({\n        ...config,\n        target: source,\n        // @TODO temporary workaround for onStatusUpdate and onEvent not differentiating\n        //       iframes from popups\n        connectTo: config.connectTo.map((prevConnectTo) => {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { onStatusUpdate, onEvent, ...connectTo } = prevConnectTo\n\n          return {\n            ...connectTo,\n            onEvent: onEvent\n              ? (((type, data) => {\n                  if (\n                    type === 'preview-kit/documents' ||\n                    type === 'overlay/navigate' ||\n                    type === 'loader/documents'\n                  ) {\n                    return\n                  }\n\n                  // @ts-expect-error -- figure out ToArgs complaining\n                  return onEvent(type, data)\n                }) satisfies typeof onEvent)\n              : undefined,\n          }\n        }),\n      })\n      destroySource.add(destroy)\n      sendToSource.set(source, send)\n      sources.add(source)\n    },\n  }\n}\n\nfunction createChannelsControllerInternal<\n  Sends extends ChannelMsg,\n  Receives extends ChannelMsg,\n>(\n  config: ChannelsControllerOptions<Receives>,\n): Omit<ChannelsController, 'addSource'> {\n  const target = config.target\n\n  const channels: ChannelsControllerChannel<Receives>[] = config.connectTo.map(\n    (config) => ({\n      buffer: [],\n      config,\n      id: '',\n      handler: handshakeHandler,\n      status: 'connecting',\n      interval: undefined,\n      heartbeat: undefined,\n    }),\n  )\n\n  function startHandshake(channel: ChannelsControllerChannel<Receives>) {\n    channel.id = uuid()\n    channel.interval = window.setInterval(() => {\n      sendHandshake(channel, 'handshake/syn', { id: channel.id })\n    }, HANDSHAKE_INTERVAL)\n  }\n\n  function stopHandshake(channel: ChannelsControllerChannel<Receives>) {\n    window.clearInterval(channel.interval)\n  }\n\n  function isValidMessageEvent(\n    e: MessageEvent,\n  ): e is MessageEvent<ProtocolMsg<Receives>> {\n    const { data, origin } = e\n    return (\n      data.domain === 'sanity/channels' &&\n      data.to == config.id &&\n      channels.map((channel) => channel.config.id).includes(data.from) &&\n      data.type !== 'channel/response' &&\n      origin === config.targetOrigin\n    )\n  }\n\n  function handshakeHandler(e: MessageEvent<ProtocolMsg<Receives>>) {\n    const { data } = e\n    if (isHandshakeMessage(data.type)) {\n      const channel = channels.find(\n        (channel) => channel.config.id === data.from,\n      )\n      if (channel && data.type === 'handshake/syn-ack') {\n        setChannelStatus(channel, 'connected')\n        sendHandshake(channel, 'handshake/ack', { id: channel.id })\n      }\n    }\n  }\n\n  const messageHandler = (e: MessageEvent<ProtocolMsg<Receives>>) => {\n    const { data } = e\n    if (\n      !isHandshakeMessage(data.type) &&\n      channels.find((channel) => channel.id === data.connectionId)\n    ) {\n      const channel = channels.find(\n        (channel) => channel.config.id === data.from,\n      )\n      if (channel) {\n        // eslint-disable-next-line no-warning-comments\n        // @todo Ugly type casting\n        const args = [data.type, data.data] as ToArgs<Receives>\n        channel.config.onEvent?.(...args)\n        config.onEvent?.(...args)\n        send(channel, 'channel/response', { responseTo: data.id }, false)\n      }\n    }\n  }\n\n  function handleEvents(e: MessageEvent<ProtocolMsg<Receives>>) {\n    if (isLegacyHandshakeMessage(e)) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Visual editing package mismatch detected! Please ensure you are using the latest version of Sanity Studio and any packages listed here:\\nhttps://github.com/sanity-io/visual-editing',\n      )\n      return\n    }\n\n    if (isValidMessageEvent(e)) {\n      const { data } = e\n      channels.find((channel) => channel.config.id === data.from)?.handler(e)\n    }\n  }\n\n  function flush(channel: ChannelsControllerChannel<Receives>) {\n    const toFlush = [...channel.buffer]\n    channel.buffer.splice(0, channel.buffer.length)\n    toFlush.forEach(({ type, data }) => {\n      send(channel, type, data)\n    })\n  }\n\n  function startHeartbeat(channel: ChannelsControllerChannel<Receives>) {\n    stopHeartbeat(channel)\n    if (channel.config.heartbeat) {\n      const heartbeatInverval =\n        typeof channel.config.heartbeat === 'number'\n          ? channel.config.heartbeat\n          : HEARTBEAT_INTERVAL\n      channel.heartbeat = window.setInterval(() => {\n        send(channel, 'channel/heartbeat')\n      }, heartbeatInverval)\n    }\n  }\n\n  function stopHeartbeat(channel: ChannelsControllerChannel<Receives>) {\n    if (channel.heartbeat) {\n      window.clearInterval(channel.heartbeat)\n    }\n  }\n\n  function setChannelStatus(\n    channel: ChannelsControllerChannel<Receives>,\n    next: ChannelStatus,\n  ) {\n    channel.status = next\n    channel.config.onStatusUpdate?.(next, channel.config.id)\n    config.onStatusUpdate?.(next, channel.config.id)\n    if (next === 'connecting' || next === 'reconnecting') {\n      channel.handler = handshakeHandler\n      stopHeartbeat(channel)\n      startHandshake(channel)\n    } else if (next === 'connected') {\n      channel.handler = messageHandler\n      stopHandshake(channel)\n      startHeartbeat(channel)\n      flush(channel)\n    } else if (next === 'disconnected') {\n      channel.id = null\n      channel.handler = handshakeHandler\n      stopHandshake(channel)\n      stopHeartbeat(channel)\n    }\n  }\n\n  function sendHandshake<T extends Sends['type']>(\n    channel: ChannelsControllerChannel<Receives>,\n    type: T,\n    data?: Extract<Sends, { type: T }>['data'],\n  ) {\n    if (!channel.id) {\n      throw new Error('No channel ID set')\n    }\n\n    const msg: ProtocolMsg<Sends> = {\n      connectionId: channel.id,\n      data,\n      domain: 'sanity/channels',\n      from: config.id,\n      id: uuid(),\n      to: channel.config.id,\n      type,\n    }\n\n    try {\n      target?.postMessage(msg, { targetOrigin: '*' })\n    } catch (e) {\n      throw new Error(`Failed to postMessage '${msg.id}' on '${config.id}'`)\n    }\n  }\n\n  function send<T extends Sends['type']>(\n    channel: ChannelsControllerChannel<Receives>,\n    type: T | InternalMsgType,\n    data?: Extract<Sends, { type: T }>['data'],\n    expectResponse = true,\n  ) {\n    const id = uuid()\n\n    // If there is no active channel, push to the buffer\n    if (\n      channel.status === 'connecting' ||\n      channel.status === 'reconnecting' ||\n      channel.status === 'disconnected'\n    ) {\n      channel.buffer.push({ type, data })\n      return\n    }\n\n    if (!channel.id) {\n      throw new Error('No channel ID set')\n    }\n\n    const msg: ProtocolMsg<Sends> = {\n      connectionId: channel.id,\n      data,\n      domain: 'sanity/channels',\n      from: config.id,\n      id,\n      to: channel.config.id,\n      type,\n    }\n\n    if (expectResponse) {\n      const maxWait = setTimeout(() => {\n        // The channel may have changed, so only reject if the IDs match\n        if (msg.connectionId === channel.id) {\n          // Cleanup the transaction listener\n          window.removeEventListener('message', transact, false)\n          // Push the message to the buffer\n          if (type !== 'channel/heartbeat') {\n            channel.buffer.push({ type, data })\n          }\n          // Try to reconnect\n          setChannelStatus(channel, 'reconnecting')\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Received no response to message '${msg.type}' on client '${config.id}' (ID: '${msg.id}').`,\n          )\n        }\n      }, RESPONSE_TIMEOUT)\n\n      const transact = (e: MessageEvent<ChannelMsg>) => {\n        const { data: eventData } = e\n        if (\n          eventData.type === 'channel/response' &&\n          eventData.data?.responseTo &&\n          eventData.data.responseTo === msg.id\n        ) {\n          window.removeEventListener('message', transact, false)\n          clearTimeout(maxWait)\n        }\n      }\n      window.addEventListener('message', transact, false)\n    }\n\n    try {\n      target?.postMessage(msg, { targetOrigin: config.targetOrigin })\n    } catch (e) {\n      throw new Error(\n        `Failed to postMessage '${msg.id}' on client '${config.id}'`,\n      )\n    }\n  }\n\n  function disconnect() {\n    channels.forEach((channel) => {\n      if (['disconnected'].includes(channel.status)) return\n      send(channel, 'channel/disconnect', { id: channel.id }, false)\n      setChannelStatus(channel, 'disconnected')\n    })\n  }\n\n  function destroy() {\n    disconnect()\n    window.removeEventListener('message', handleEvents, false)\n    channels.forEach((channel) => {\n      stopHeartbeat(channel)\n      stopHandshake(channel)\n    })\n  }\n\n  function initialise() {\n    window.addEventListener('message', handleEvents, false)\n    channels.forEach((channel) => {\n      setChannelStatus(channel, 'connecting')\n    })\n  }\n\n  initialise()\n\n  function sendPublic<T extends Sends['type']>(\n    id: string | string[] | undefined,\n    type: T,\n    data?: Extract<Sends, { type: T }>['data'],\n  ) {\n    const channelsToSend = id ? (Array.isArray(id) ? [...id] : [id]) : channels\n\n    channelsToSend.forEach((id) => {\n      const channel = channels.find((channel) => channel.config.id === id)\n      if (!channel) throw new Error('Invalid channel ID')\n      send(channel, type, data)\n    })\n  }\n\n  return {\n    destroy,\n    send: sendPublic,\n  }\n}\n","function n(n){return\"object\"==typeof n&&null!==n&&!Array.isArray(n)}function e(n){return null!==n&&Array.isArray(n)}function t(n){let t=\"\";for(const r of n)\"string\"!=typeof r?\"number\"!=typeof r?e(r)?(t&&(t+=\":\"),t+=`${r.join(\",\")}}`):r._key&&(t&&(t+=\":\"),t+=`${r._key}`):(t&&(t+=\":\"),t+=`${r}`):(t&&(t+=\".\"),t+=r);return t}const r=/^([A-Za-z]+):([0-9]+)$/,o=/^([A-Za-z]+):([0-9]+),([0-9]+)$/,u=/^([A-Za-z]+):([a-z0-9]+)$/;function s(n){const e=[];for(const t of n.split(\".\")){const n=r.exec(t);if(n){e.push(n[1],Number(n[2]));continue}const s=o.exec(t);if(s){e.push(s[1],[Number(s[2]),Number(s[3])]);continue}const c=u.exec(t);c?e.push(c[1],{_key:c[2]}):e.push(t)}return e}export{e as a,n as i,t as p,s as u};//# sourceMappingURL=urlStringToPath.js.map\n","import{p as t,u as r}from\"./_chunks/urlStringToPath.js\";function e(t,r){return`${t}-${\"string\"==typeof r?r:JSON.stringify(r)}`}const n=typeof window<\"u\"&&/Mac|iPod|iPhone|iPad/.test(window.navigator.platform),o={alt:\"altKey\",ctrl:\"ctrlKey\",mod:n?\"metaKey\":\"ctrlKey\",shift:\"shiftKey\"};function i(t,r){return t.every((t=>o[t]?r[o[t]]:r.key===t.toUpperCase()))}function a(t){return t.key===(n?\"Meta\":\"Ctrl\")}function u(t){return\"Alt\"===t.key}export{e as getQueryCacheKey,u as isAltKey,i as isHotkey,a as isModKey,t as pathToUrlString,r as urlStringToPath};//# sourceMappingURL=index.js.map\n","import {\n  Box,\n  Button,\n  Card,\n  CardProps,\n  Container,\n  Flex,\n  Inline,\n  Stack,\n  Text,\n} from '@sanity/ui'\nimport { ReactElement, ReactNode } from 'react'\n\nexport function ErrorCard(\n  props: {\n    children?: ReactNode\n    message: string\n    onRetry?: () => void\n    onContinueAnyway?: () => void\n  } & CardProps,\n): ReactElement {\n  const { children, message, onRetry, onContinueAnyway, ...restProps } = props\n\n  const retryButton = (\n    <Button fontSize={1} mode=\"ghost\" onClick={onRetry} text=\"Retry\" />\n  )\n  const continueAnywayButton = (\n    <Button\n      fontSize={1}\n      mode=\"ghost\"\n      tone=\"critical\"\n      onClick={onContinueAnyway}\n      text=\"Continue anyway\"\n    />\n  )\n\n  return (\n    <Card height=\"fill\" {...restProps}>\n      <Flex align=\"center\" height=\"fill\" justify=\"center\">\n        <Container padding={4} sizing=\"border\" width={0}>\n          <Stack space={4}>\n            <Stack space={3}>\n              <Text size={1} weight=\"semibold\">\n                An error occured\n              </Text>\n              <Text muted size={1}>\n                {message}\n              </Text>\n            </Stack>\n\n            {children}\n\n            {onRetry && onContinueAnyway ? (\n              <Inline space={2}>\n                {retryButton}\n                {continueAnywayButton}\n              </Inline>\n            ) : onRetry ? (\n              <Box>{retryButton}</Box>\n            ) : onContinueAnyway ? (\n              <Box>{continueAnywayButton}</Box>\n            ) : null}\n          </Stack>\n        </Container>\n      </Flex>\n    </Card>\n  )\n}\n","import { useContext } from 'react'\n\nimport {\n  PresentationContext,\n  PresentationContextValue,\n} from './PresentationContext'\n\nexport function usePresentationTool(): PresentationContextValue {\n  const presentation = useContext(PresentationContext)\n\n  if (!presentation) {\n    throw new Error('Presentation context is missing')\n  }\n\n  return presentation\n}\n","/* eslint-disable no-console */\n\nimport {\n  forwardRef,\n  PropsWithChildren,\n  ReactElement,\n  useCallback,\n  useMemo,\n} from 'react'\nimport { getPublishedId, useUnique } from 'sanity'\nimport { StateLink, useRouter } from 'sanity/router'\nimport {\n  BackLinkProps,\n  PaneRouterContext,\n  PaneRouterContextValue,\n  ReferenceChildLinkProps,\n} from 'sanity/structure'\n\nimport { DeskDocumentPaneParams, PresentationParams } from '../types'\nimport { usePresentationTool } from '../usePresentationTool'\n\nfunction encodeQueryString(params: Record<string, unknown> = {}): string {\n  const parts = Object.entries(params)\n    .map(([key, value]) => `${key}=${value}`)\n    .join('&')\n\n  return parts.length ? `?${parts}` : ''\n}\n\nfunction resolveQueryStringFromParams(\n  nextParams: Record<string, string | undefined>,\n) {\n  const allowed = [\n    'comment',\n    'inspect',\n    'instruction',\n    'pathKey',\n    'rev',\n    'since',\n    'template',\n    'view',\n  ] satisfies Array<keyof PresentationParams> as string[]\n\n  const safeNextParams = Object.entries(nextParams)\n    .filter(([key]) => allowed.includes(key))\n    .reduce((obj, [key, value]) => {\n      if (value == undefined) return obj\n      return { ...obj, [key]: value }\n    }, {})\n\n  return encodeQueryString(safeNextParams)\n}\n\nconst BackLink = forwardRef(function BackLink(\n  props: BackLinkProps,\n  ref: React.ForwardedRef<HTMLAnchorElement>,\n) {\n  const { deskParams, params } = usePresentationTool()\n\n  return (\n    <StateLink\n      {...props}\n      ref={ref}\n      state={{\n        type: undefined,\n        _searchParams: Object.entries({\n          ...deskParams,\n          preview: params.preview,\n        }),\n      }}\n      title={undefined}\n    />\n  )\n})\n\nconst ReferenceChildLink = forwardRef(function ReferenceChildLink(\n  props: ReferenceChildLinkProps,\n  ref: React.ForwardedRef<HTMLAnchorElement>,\n) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { documentId, documentType, parentRefPath, template, ...restProps } =\n    props\n\n  return (\n    <StateLink\n      {...restProps}\n      ref={ref}\n      state={{ id: documentId, type: documentType }}\n      title={undefined}\n    />\n  )\n})\n\nexport function PresentationPaneRouterProvider(\n  props: PropsWithChildren<{\n    onDeskParams: (params: DeskDocumentPaneParams) => void\n    params: DeskDocumentPaneParams\n    previewUrl?: string\n    refs?: { _id: string; _type: string }[]\n  }>,\n): ReactElement {\n  const { children, params, onDeskParams, previewUrl, refs } = props\n\n  const { state: routerState, resolvePathFromState } = useRouter()\n\n  const routerSearchParams = useUnique(\n    Object.fromEntries(routerState._searchParams || []),\n  )\n\n  const createPathWithParams: PaneRouterContextValue['createPathWithParams'] =\n    useCallback(\n      (nextParams) => {\n        const path = resolvePathFromState(routerState)\n        const qs = resolveQueryStringFromParams({\n          ...routerSearchParams,\n          ...nextParams,\n        })\n        return `${path}${qs}`\n      },\n      [resolvePathFromState, routerSearchParams, routerState],\n    )\n\n  const context: PaneRouterContextValue = useMemo(() => {\n    return {\n      index: 0,\n      groupIndex: 0,\n      siblingIndex: 0,\n      payload: {},\n      params: params as any,\n      hasGroupSiblings: false,\n      groupLength: 1,\n      routerPanesState: [],\n      ChildLink: (childLinkProps) => {\n        const { childId, ...restProps } = childLinkProps\n        const ref = refs?.find(\n          (r) => r._id === childId || getPublishedId(r._id) === childId,\n        )\n\n        if (ref) {\n          return (\n            <StateLink\n              {...restProps}\n              state={{\n                id: childId,\n                type: ref._type,\n                _searchParams: Object.entries({ preview: previewUrl }),\n              }}\n            />\n          )\n        }\n\n        return <div {...restProps} />\n      },\n      BackLink,\n      ReferenceChildLink,\n      ParameterizedLink: () => <>ParameterizedLink</>,\n      closeCurrentAndAfter: () => {\n        console.warn('closeCurrentAndAfter')\n      },\n      handleEditReference: (options) => {\n        console.warn('handleEditReference', options)\n      },\n      replaceCurrent: (pane) => {\n        console.warn('replaceCurrent', pane)\n      },\n      closeCurrent: () => {\n        console.warn('closeCurrent')\n      },\n      duplicateCurrent: (pane) => {\n        console.warn('duplicateCurrent', pane)\n      },\n      setView: (viewId) => {\n        console.warn('setView', viewId)\n      },\n      setParams: (nextParams) => {\n        // eslint-disable-next-line no-warning-comments\n        // @todo set inspect param to undefined manually as param is missing from object when closing inspector\n        onDeskParams({\n          ...nextParams,\n          inspect: nextParams.inspect ?? undefined,\n        } as DeskDocumentPaneParams)\n      },\n      setPayload: (payload) => {\n        console.warn('setPayload', payload)\n      },\n      navigateIntent: (intentName, intentParams, options) => {\n        console.warn('navigateIntent', intentName, intentParams, options)\n      },\n      createPathWithParams,\n    }\n  }, [createPathWithParams, onDeskParams, params, previewUrl, refs])\n\n  return (\n    <PaneRouterContext.Provider value={context}>\n      {children}\n    </PaneRouterContext.Provider>\n  )\n}\n","import { Card, Code, ErrorBoundary, Flex, Label, Stack } from '@sanity/ui'\nimport {\n  ErrorInfo,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport {\n  DocumentListPane as DeskDocumentListPane,\n  PaneLayout,\n  PaneNode,\n  StructureToolProvider,\n} from 'sanity/structure'\nimport styled from 'styled-components'\n\nimport { ErrorCard } from '../components/ErrorCard'\nimport { DeskDocumentPaneParams } from '../types'\nimport { usePresentationTool } from '../usePresentationTool'\nimport { PresentationPaneRouterProvider } from './PresentationPaneRouterProvider'\n\nconst RootLayout = styled(PaneLayout)`\n  height: 100%;\n`\n\nconst Root = styled(Flex)`\n  & > div {\n    min-width: none !important;\n    max-width: none !important;\n  }\n`\n\nconst WrappedCode = styled(Code)`\n  white-space: pre-wrap;\n`\n\nexport function DocumentListPane(props: {\n  onDeskParams: (params: DeskDocumentPaneParams) => void\n  previewUrl?: string\n  refs: { _id: string; _type: string }[]\n}): ReactElement {\n  const { onDeskParams, previewUrl, refs } = props\n  const { devMode } = usePresentationTool()\n\n  const pane: Extract<PaneNode, { type: 'documentList' }> = useMemo(\n    () => ({\n      id: '$root',\n      options: {\n        filter: '_id in $ids',\n        params: { ids: refs.map((r) => r._id) },\n        // defaultOrdering: [{ field: '_updatedAt', direction: 'desc' }],\n      },\n      schemaTypeName: '',\n      title: 'Documents on this page',\n      type: 'documentList',\n    }),\n    [refs],\n  )\n\n  const [errorParams, setErrorParams] = useState<{\n    info: ErrorInfo\n    error: Error\n  } | null>(null)\n\n  const handleRetry = useCallback(() => setErrorParams(null), [])\n\n  const [deskParams] = useState(() => ({}))\n\n  // Reset error state when `refs` value schanges\n  useEffect(() => setErrorParams(null), [refs])\n\n  if (errorParams) {\n    return (\n      <ErrorCard\n        flex={1}\n        message=\"Could not render the document list\"\n        onRetry={handleRetry}\n      >\n        {devMode && (\n          // show runtime error message in dev mode\n          <Card overflow=\"auto\" padding={3} radius={2} tone=\"critical\">\n            <Stack space={3}>\n              <Label muted size={0}>\n                Error message\n              </Label>\n              <WrappedCode size={1}>{errorParams.error.message}</WrappedCode>\n            </Stack>\n          </Card>\n        )}\n      </ErrorCard>\n    )\n  }\n\n  return (\n    <ErrorBoundary onCatch={setErrorParams}>\n      <RootLayout>\n        <StructureToolProvider>\n          <PresentationPaneRouterProvider\n            params={deskParams}\n            onDeskParams={onDeskParams}\n            previewUrl={previewUrl}\n            refs={refs}\n          >\n            <Root direction=\"column\" flex={1}>\n              <DeskDocumentListPane\n                index={0}\n                itemId=\"$root\"\n                pane={pane}\n                paneKey=\"$root\"\n              />\n            </Root>\n          </PresentationPaneRouterProvider>\n        </StructureToolProvider>\n      </RootLayout>\n    </ErrorBoundary>\n  )\n}\n","import { Card, Code, ErrorBoundary, Label, Stack } from '@sanity/ui'\nimport {\n  ErrorInfo,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport { Path } from 'sanity'\nimport { decodeJsonParams } from 'sanity/router'\nimport {\n  DocumentPane as DeskDocumentPane,\n  DocumentPaneNode,\n  PaneLayout,\n  useStructureTool,\n} from 'sanity/structure'\nimport styled from 'styled-components'\n\nimport { ErrorCard } from '../components/ErrorCard'\nimport { DeskDocumentPaneParams } from '../types'\nimport { usePresentationTool } from '../usePresentationTool'\nimport { PresentationPaneRouterProvider } from './PresentationPaneRouterProvider'\n\nconst WrappedCode = styled(Code)`\n  white-space: pre-wrap;\n`\n\nexport function DocumentPane(props: {\n  documentId: string\n  documentType: string\n  params: DeskDocumentPaneParams\n  onDeskParams: (params: DeskDocumentPaneParams) => void\n  onFocusPath: (path: Path) => void\n}): ReactElement {\n  const { documentId, documentType, params, onDeskParams, onFocusPath } = props\n  const { template, templateParams } = params\n  const { devMode } = usePresentationTool()\n\n  const paneDocumentNode: DocumentPaneNode = useMemo(\n    () => ({\n      id: documentId,\n      options: {\n        id: documentId,\n        type: documentType,\n        template,\n        templateParameters: decodeJsonParams(templateParams),\n      },\n      title: '',\n      type: 'document',\n    }),\n    [documentId, documentType, template, templateParams],\n  )\n\n  const [errorParams, setErrorParams] = useState<{\n    info: ErrorInfo\n    error: Error\n  } | null>(null)\n\n  const handleRetry = useCallback(() => setErrorParams(null), [])\n\n  // Reset error state when parameters change\n  useEffect(() => {\n    setErrorParams(null)\n  }, [documentId, documentType, params])\n\n  const { setLayoutCollapsed } = useStructureTool()\n  const handleRootCollapse = useCallback(\n    () => setLayoutCollapsed(true),\n    [setLayoutCollapsed],\n  )\n  const handleRootExpand = useCallback(\n    () => setLayoutCollapsed(false),\n    [setLayoutCollapsed],\n  )\n\n  if (errorParams) {\n    return (\n      <ErrorCard\n        flex={1}\n        message=\"Could not render the document editor\"\n        onRetry={handleRetry}\n      >\n        {devMode && (\n          // show runtime error message in dev mode\n          <Card overflow=\"auto\" padding={3} radius={2} tone=\"critical\">\n            <Stack space={3}>\n              <Label muted size={0}>\n                Error message\n              </Label>\n              <WrappedCode size={1}>{errorParams.error.message}</WrappedCode>\n            </Stack>\n          </Card>\n        )}\n      </ErrorCard>\n    )\n  }\n\n  return (\n    <ErrorBoundary onCatch={setErrorParams}>\n      <PaneLayout\n        style={{ height: '100%' }}\n        onExpand={handleRootExpand}\n        onCollapse={handleRootCollapse}\n      >\n        <PresentationPaneRouterProvider\n          onDeskParams={onDeskParams}\n          params={params}\n        >\n          <DeskDocumentPane\n            paneKey=\"document\"\n            index={1}\n            itemId=\"document\"\n            pane={paneDocumentNode}\n            onFocusPath={onFocusPath}\n          />\n        </PresentationPaneRouterProvider>\n      </PaneLayout>\n    </ErrorBoundary>\n  )\n}\n","import { type ReactElement } from 'react'\nimport { type Path } from 'sanity'\nimport { StructureToolProvider } from 'sanity/structure'\n\nimport { DeskDocumentPaneParams } from '../types'\nimport { DocumentPane } from './DocumentPane'\n\nexport function DocumentPanel(props: {\n  deskParams: DeskDocumentPaneParams\n  documentId: string\n  documentType: string\n  onDeskParams: (params: DeskDocumentPaneParams) => void\n  onFocusPath: (path: Path) => void\n}): ReactElement {\n  const { deskParams, documentId, documentType, onDeskParams, onFocusPath } =\n    props\n  return (\n    <StructureToolProvider>\n      <DocumentPane\n        documentId={documentId}\n        documentType={documentType}\n        params={deskParams}\n        onDeskParams={onDeskParams}\n        onFocusPath={onFocusPath}\n      />\n    </StructureToolProvider>\n  )\n}\n","import { type ReactElement } from 'react'\nimport { type Path } from 'sanity'\n\nimport type { DeskDocumentPaneParams } from '../types'\nimport { DocumentListPane } from './DocumentListPane'\nimport { DocumentPanel } from './DocumentPanel'\n\nexport function ContentEditor(props: {\n  deskParams: DeskDocumentPaneParams\n  documentId?: string\n  documentType?: string\n  onDeskParams: (params: DeskDocumentPaneParams) => void\n  onFocusPath: (path: Path) => void\n  previewUrl?: string\n  refs: { _id: string; _type: string }[]\n}): ReactElement {\n  const {\n    deskParams,\n    documentId,\n    documentType,\n    onDeskParams,\n    onFocusPath,\n    previewUrl,\n    refs,\n  } = props\n\n  if (documentId && documentType) {\n    return (\n      <DocumentPanel\n        deskParams={deskParams}\n        documentId={documentId}\n        documentType={documentType}\n        onDeskParams={onDeskParams}\n        onFocusPath={onFocusPath}\n      />\n    )\n  }\n\n  return (\n    <DocumentListPane\n      onDeskParams={onDeskParams}\n      previewUrl={previewUrl}\n      refs={refs}\n    />\n  )\n}\n","import { createContext, type CSSProperties } from 'react'\n\nimport { PanelElement, ResizerElement } from './types'\n\nexport const PanelsContext = createContext<{\n  activeResizer: string | null\n  drag: (id: string, event: MouseEvent) => void\n  getPanelStyle: (id: string) => CSSProperties\n  registerElement: (id: string, panel: PanelElement | ResizerElement) => void\n  startDragging: (id: string, event: MouseEvent) => void\n  stopDragging: () => void\n  unregisterElement: (id: string) => void\n} | null>(null)\n\nPanelsContext.displayName = 'PanelsContext'\n","import {\n  FunctionComponent,\n  PropsWithChildren,\n  useContext,\n  useLayoutEffect,\n} from 'react'\nimport styled from 'styled-components'\n\nimport { PanelsContext } from './PanelsContext'\n\ninterface PanelProps extends PropsWithChildren {\n  defaultSize?: number | null\n  id: string\n  minWidth?: number\n  maxWidth?: number\n  order?: number\n}\n\nconst Root = styled.div`\n  overflow: hidden;\n  flex-basis: 0;\n  flex-shrink: 1;\n`\n\nexport const Panel: FunctionComponent<PanelProps> = function ({\n  children,\n  defaultSize = null,\n  id,\n  minWidth,\n  maxWidth,\n  order = 0,\n}) {\n  const context = useContext(PanelsContext)\n\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`,\n    )\n  }\n\n  const { getPanelStyle, registerElement, unregisterElement } = context\n\n  const style = getPanelStyle(id)\n\n  useLayoutEffect(() => {\n    registerElement(id, {\n      id,\n      type: 'panel',\n      defaultSize,\n      maxWidth: maxWidth ?? null,\n      minWidth: minWidth ?? 0,\n      order,\n    })\n\n    return () => {\n      unregisterElement(id)\n    }\n  }, [\n    id,\n    defaultSize,\n    order,\n    maxWidth,\n    minWidth,\n    registerElement,\n    unregisterElement,\n  ])\n\n  return <Root style={style}>{children}</Root>\n}\n","import {\n  type FunctionComponent,\n  MouseEvent as ReactMouseEvent,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n} from 'react'\nimport styled from 'styled-components'\n\nimport { PanelsContext } from './PanelsContext'\nimport { usePanelId } from './usePanelId'\n\nconst Resizer = styled.div`\n  position: relative;\n`\nconst ResizerInner = styled.div<{\n  $disabled: boolean\n}>`\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: -5px;\n  width: 9px;\n  z-index: 10;\n  cursor: ${({ $disabled }) => ($disabled ? 'auto' : 'ew-resize')};\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n  }\n\n  ${({ $disabled }) =>\n    !$disabled &&\n    `\n    /* Hover effect */\n    & > span:nth-child(2) {\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    @media (hover: hover) {\n      &:hover > span:nth-child(2) {\n        opacity: 0.2;\n      }\n    }\n  `}\n`\n\nexport const PanelResizer: FunctionComponent<{\n  id?: string\n  order: number\n  disabled?: boolean\n}> = function ({ id: propId, order, disabled = false }) {\n  const el = useRef<HTMLDivElement>(null)\n\n  const context = useContext(PanelsContext)\n\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`,\n    )\n  }\n\n  const id = usePanelId(propId)\n\n  const {\n    activeResizer,\n    drag,\n    startDragging,\n    stopDragging,\n    registerElement,\n    unregisterElement,\n  } = context\n\n  const isDragging = activeResizer === id\n\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`,\n    )\n  }\n\n  const onMouseDown = useCallback(\n    (event: ReactMouseEvent) => {\n      startDragging(id, event.nativeEvent)\n    },\n    [id, startDragging],\n  )\n\n  const onDrag = useCallback(\n    (e: MouseEvent) => {\n      drag(id, e)\n    },\n    [id, drag],\n  )\n\n  const onDragStop = useCallback(() => {\n    el.current!.blur()\n    stopDragging()\n  }, [stopDragging])\n\n  useEffect(() => {\n    if (!isDragging || disabled) return\n\n    window.addEventListener('mousemove', onDrag)\n    window.addEventListener('mouseup', onDragStop)\n\n    return () => {\n      window.removeEventListener('mousemove', onDrag)\n      window.removeEventListener('mouseup', onDragStop)\n    }\n  }, [disabled, isDragging, onDrag, onDragStop])\n\n  useLayoutEffect(() => {\n    registerElement(id, { id, order, type: 'resizer', el })\n\n    return () => {\n      unregisterElement(id)\n    }\n  }, [id, order, registerElement, unregisterElement])\n\n  return (\n    <Resizer onMouseDown={onMouseDown} ref={el}>\n      <ResizerInner $disabled={disabled}>\n        <span />\n        <span />\n      </ResizerInner>\n    </Resizer>\n  )\n}\n","import { useRef } from 'react'\nimport { v4 as uuid } from 'uuid'\n\nexport function usePanelId(id?: string): string {\n  const idRef = useRef(id || uuid())\n  return idRef.current\n}\n","export function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(\n  fn: F,\n  timeout: number,\n): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n","import { useMemo } from 'react'\n\nimport { debounce } from '../lib/debounce'\nimport { PanelElement } from './types'\n\nconst itemKey = 'presentation/panels'\n\ntype StoredPanelsState = Record<string, number[]>\n\nconst getStoredItem = () => {\n  // @todo Validate\n  return JSON.parse(localStorage.getItem(itemKey) || '{}') as StoredPanelsState\n}\nconst setStoredItem = (data: StoredPanelsState) => {\n  localStorage.setItem(itemKey, JSON.stringify(data))\n}\n\nconst getKeyForPanels = (panels: PanelElement[]) => {\n  return panels.map((panel) => [panel.id, panel.order].join(':')).join(',')\n}\n\nexport function usePanelsStorage(): {\n  get: (panels: PanelElement[]) => number[]\n  set: (panels: PanelElement[], widths: number[]) => void\n  setDebounced: (panels: PanelElement[], widths: number[]) => void\n} {\n  return useMemo(() => {\n    const get = (panels: PanelElement[]) => {\n      const stored = getStoredItem()\n      const key = getKeyForPanels(panels)\n      return stored[key]\n    }\n\n    const set = (panels: PanelElement[], widths: number[]) => {\n      const stored = getStoredItem()\n      const key = getKeyForPanels(panels)\n      const data = {\n        ...stored,\n        [key]: widths,\n      }\n      setStoredItem(data)\n    }\n\n    const setDebounced = debounce(set, 100)\n    return {\n      get,\n      set,\n      setDebounced,\n    }\n  }, [])\n}\n","import {\n  ElementMap,\n  InitialDragState,\n  PanelElement,\n  PanelsState,\n  ResizerElement,\n} from './types'\n\nfunction getNextWidth(\n  panel: PanelElement,\n  nextWidth: number,\n  containerWidth: number,\n) {\n  const { maxWidth: maxWidthPx, minWidth: minWidthPx } = panel\n  const maxWidth =\n    maxWidthPx == null ? 100 : (maxWidthPx / containerWidth) * 100\n  const minWidth = (minWidthPx / containerWidth) * 100\n  return Math.min(maxWidth, Math.max(minWidth, nextWidth))\n}\n\nexport function getNextWidths(\n  delta: number,\n  containerWidth: number,\n  panelBefore: PanelElement,\n  panelAfter: PanelElement,\n  panelsState: PanelsState,\n  initialDragState: InitialDragState,\n): number[] {\n  const { panels, widths: prevWidths } = panelsState\n  const { widths: initialWidths } = initialDragState\n\n  const widths = initialWidths || prevWidths\n  const nextWidths = [...widths]\n\n  {\n    const pivotPanel = delta < 0 ? panelAfter : panelBefore\n    const index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n    const width = widths[index]\n    const nextWidth = getNextWidth(\n      pivotPanel,\n      width + Math.abs(delta),\n      containerWidth,\n    )\n    if (width === nextWidth) {\n      return widths\n    } else {\n      delta = delta < 0 ? width - nextWidth : nextWidth - width\n    }\n  }\n\n  let deltaApplied = 0\n  let pivotPanel = delta < 0 ? panelBefore : panelAfter\n  let index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const panel = panels[index]\n    const width = widths[index]\n\n    const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied)\n\n    const nextWidth = getNextWidth(\n      panel,\n      width - deltaRemaining,\n      containerWidth,\n    )\n\n    if (width !== nextWidth) {\n      deltaApplied += width - nextWidth\n      nextWidths[index] = nextWidth\n\n      if (\n        deltaApplied\n          .toPrecision(10)\n          .localeCompare(Math.abs(delta).toPrecision(10), undefined, {\n            numeric: true,\n          }) >= 0\n      ) {\n        break\n      }\n    }\n\n    if (delta < 0) {\n      if (--index < 0) {\n        break\n      }\n    } else {\n      if (++index >= panels.length) {\n        break\n      }\n    }\n  }\n\n  if (deltaApplied === 0) {\n    return widths\n  }\n\n  pivotPanel = delta < 0 ? panelAfter : panelBefore\n  index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n  nextWidths[index] = widths[index] + deltaApplied\n\n  return nextWidths\n}\n\nexport function getPanelWidth(\n  panels: PanelElement[],\n  id: string,\n  widths: number[],\n): string {\n  if (panels.length === 1) return '100'\n\n  const index = panels.findIndex((panel) => panel.id === id)\n  const width = widths[index]\n\n  if (width == null) return '0'\n\n  return width.toPrecision(10)\n}\n\nexport function getOffset(\n  event: MouseEvent,\n  handleElement: HTMLDivElement,\n  initialOffset: number = 0,\n  initialHandleElementRect: DOMRect | null = null,\n): number {\n  const pointerOffset = event.clientX\n\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect()\n  const elementOffset = rect.left\n\n  return pointerOffset - elementOffset - initialOffset\n}\n\nexport function isPanel(\n  element: PanelElement | ResizerElement,\n): element is PanelElement {\n  return element.type === 'panel'\n}\n\nexport function isResizer(\n  element: PanelElement | ResizerElement,\n): element is ResizerElement {\n  return element.type === 'resizer'\n}\n\nexport function getSortedElements(\n  elements: ElementMap,\n): Array<PanelElement | ResizerElement> {\n  return Array.from(elements.values()).sort(({ order: a }, { order: b }) => {\n    if (a == null && b == null) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n    return a - b\n  })\n}\n\nexport function validateWidths(\n  panels: PanelElement[],\n  widthsToValidate: number[],\n  containerWidth: number,\n): number[] {\n  // Clamp widths proportionally to total 100\n  const total = widthsToValidate.reduce((total, width) => total + width, 0)\n  const widths = [...widthsToValidate].map((width) => (width / total) * 100)\n\n  let remainingWidth = 0\n\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index]\n    const width = widths[index]\n    const nextWidth = getNextWidth(panel, width, containerWidth)\n    if (width != nextWidth) {\n      remainingWidth += width - nextWidth\n      widths[index] = nextWidth\n    }\n  }\n\n  if (remainingWidth.toFixed(3) !== '0.000') {\n    for (let index = 0; index < panels.length; index++) {\n      const panel = panels[index]\n\n      let { maxWidth, minWidth } = panel\n\n      minWidth = (minWidth / containerWidth) * 100\n      if (maxWidth != null) {\n        maxWidth = (maxWidth / containerWidth) * 100\n      }\n\n      const width = Math.min(\n        maxWidth != null ? maxWidth : 100,\n        Math.max(minWidth, widths[index] + remainingWidth),\n      )\n\n      if (width !== widths[index]) {\n        remainingWidth -= width - widths[index]\n        widths[index] = width\n\n        if (Math.abs(remainingWidth).toFixed(3) === '0.000') {\n          break\n        }\n      }\n    }\n  }\n\n  return widths\n}\n\nexport function getDefaultWidths(panels: PanelElement[]): number[] {\n  let panelsWithoutWidth = panels.length\n  let remainingWidthTotal = 100\n\n  const widthsWithNulls = panels.map((panel) => {\n    if (panel.defaultSize) {\n      remainingWidthTotal = remainingWidthTotal - panel.defaultSize\n      panelsWithoutWidth = panelsWithoutWidth - 1\n      return panel.defaultSize\n    }\n    return null\n  })\n\n  const defaultWidth = remainingWidthTotal / panelsWithoutWidth\n  const widths = widthsWithNulls.map((width) => {\n    if (width === null) return defaultWidth\n    return width\n  })\n\n  return widths\n}\n","// Slightly modified version of react-resizable-panels\n// https://github.com/bvaughn/react-resizable-panels/tree/main/packages/react-resizable-panels\n\nimport {\n  type CSSProperties,\n  type FunctionComponent,\n  PropsWithChildren,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport styled from 'styled-components'\n\nimport { PanelsContext } from './PanelsContext'\nimport {\n  ElementMap,\n  InitialDragState,\n  PanelElement,\n  PanelsState,\n  ResizerElement,\n} from './types'\nimport { usePanelsStorage } from './usePanelsStorage'\nimport {\n  getDefaultWidths,\n  getNextWidths,\n  getOffset,\n  getPanelWidth,\n  getSortedElements,\n  isPanel,\n  isResizer,\n  validateWidths,\n} from './util'\n\nconst PanelsWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  height: 100%;\n  overflow: hidden;\n  width: 100%;\n`\n\nexport const Panels: FunctionComponent<PropsWithChildren> = function ({\n  children,\n}) {\n  const panelsEl = useRef<HTMLDivElement | null>(null)\n\n  const [elements, setElements] = useState<ElementMap>(new Map())\n\n  const panels = useMemo(\n    () => getSortedElements(elements).filter(isPanel),\n    [elements],\n  )\n\n  const [widths, setWidths] = useState<number[]>([])\n  const [activeResizer, setActiveResizer] = useState<string | null>(null)\n\n  const panelsRef = useRef<PanelsState>({\n    elements,\n    panels,\n    widths,\n  })\n\n  const getPanelStyle = useCallback(\n    (id: string): CSSProperties => {\n      return {\n        flexGrow: getPanelWidth(panels, id, widths),\n        pointerEvents: activeResizer === null ? undefined : 'none',\n      }\n    },\n    [activeResizer, panels, widths],\n  )\n\n  const registerElement = useCallback(\n    (id: string, data: PanelElement | ResizerElement) => {\n      setElements((prev) => {\n        if (prev.has(id)) return prev\n        const next = new Map(prev)\n        next.set(id, data)\n        return next\n      })\n    },\n    [],\n  )\n  const unregisterElement = useCallback((id: string) => {\n    setElements((prev) => {\n      if (!prev.has(id)) return prev\n      const next = new Map(prev)\n      next.delete(id)\n      return next\n    })\n  }, [])\n\n  const dragRef = useRef<InitialDragState>({\n    containerWidth: window.innerWidth,\n    dragOffset: 0,\n    panelAfter: null,\n    panelBefore: null,\n    resizerIndex: -1,\n    resizerRect: null,\n    startX: 0,\n    widths: [],\n  })\n\n  const startDragging = useCallback(\n    (id: string, event: MouseEvent) => {\n      const elementsArr = getSortedElements(elements)\n      const index = elementsArr.findIndex((el) => el.id === id)\n\n      const resizer = elements.get(id)\n      if (!resizer || !isResizer(resizer)) return\n      const resizeElement = resizer.el.current\n      if (!resizeElement) return\n\n      dragRef.current = {\n        resizerIndex: index,\n        panelBefore: elementsArr.reduce(\n          (acc, el, i) => (isPanel(el) && i < index ? el : acc),\n          null as PanelElement | null,\n        ),\n        panelAfter: elementsArr.reduce(\n          (acc, el, i) => (acc === null && isPanel(el) && i > index ? el : acc),\n          null as PanelElement | null,\n        ),\n        containerWidth: window.innerWidth,\n        startX: event.pageX,\n        dragOffset: getOffset(event, resizeElement),\n        resizerRect: resizeElement.getBoundingClientRect(),\n        widths: panelsRef.current.widths,\n      }\n\n      setActiveResizer(id)\n    },\n    [elements],\n  )\n\n  const stopDragging = useCallback(() => {\n    setActiveResizer(null)\n  }, [])\n\n  const drag = useCallback(\n    (id: string, event: MouseEvent) => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      const {\n        containerWidth,\n        dragOffset,\n        panelBefore,\n        panelAfter,\n        resizerRect,\n      } = dragRef.current\n\n      if (panelBefore == null || panelAfter == null) {\n        return\n      }\n\n      const resizer = elements.get(id)\n      if (!resizer || !isResizer(resizer)) return\n      const resizeElement = resizer.el.current\n      if (!resizeElement) return\n\n      const offset = getOffset(event, resizeElement, dragOffset, resizerRect)\n\n      if (offset === 0) {\n        return\n      }\n\n      const { widths: prevWidths } = panelsRef.current\n      const rect = panelsEl.current!.getBoundingClientRect()\n      const delta = (offset / rect.width) * 100\n\n      const nextWidths = getNextWidths(\n        delta,\n        containerWidth,\n        panelBefore,\n        panelAfter,\n        panelsRef.current,\n        dragRef.current,\n      )\n\n      const widthsChanged = prevWidths.some(\n        (prevWidth, i) => prevWidth !== nextWidths[i],\n      )\n\n      if (widthsChanged) {\n        setWidths(nextWidths)\n      }\n    },\n    [elements],\n  )\n\n  // For setting the panels state\n  useLayoutEffect(() => {\n    panelsRef.current.elements = elements\n    panelsRef.current.panels = panels\n    panelsRef.current.widths = widths\n  }, [elements, panels, widths])\n\n  const storage = usePanelsStorage()\n\n  // For setting default sizing when panels are updated\n  useLayoutEffect(() => {\n    const { widths } = panelsRef.current\n\n    if (widths.length === panels.length) {\n      return\n    }\n\n    const storedWidths = storage.get(panels)\n\n    if (storedWidths) {\n      const validatedStoredWidths = validateWidths(\n        panels,\n        storedWidths,\n        window.innerWidth,\n      )\n      setWidths(validatedStoredWidths)\n      return\n    }\n\n    const defaultWidths = getDefaultWidths(panels)\n    setWidths(defaultWidths)\n  }, [storage, panels])\n\n  // For storing current widths in localStorage\n  useEffect(() => {\n    if (!widths.length) return\n    storage.setDebounced(panels, widths)\n  }, [storage, panels, widths])\n\n  useLayoutEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      const { panels, widths: prevWidths } = panelsRef.current\n\n      const nextWidths = validateWidths(panels, prevWidths, window.innerWidth)\n\n      const widthsChanged = prevWidths.some(\n        (prevWidth, i) => prevWidth !== nextWidths[i],\n      )\n      if (widthsChanged) {\n        setWidths(nextWidths)\n      }\n    })\n\n    resizeObserver.observe(panelsEl.current!)\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [])\n\n  const context = useMemo(\n    () => ({\n      activeResizer,\n      drag,\n      getPanelStyle,\n      registerElement,\n      startDragging,\n      stopDragging,\n      unregisterElement,\n    }),\n    [\n      activeResizer,\n      drag,\n      getPanelStyle,\n      registerElement,\n      startDragging,\n      stopDragging,\n      unregisterElement,\n    ],\n  )\n\n  return (\n    <PanelsContext.Provider value={context}>\n      <PanelsWrapper ref={panelsEl}>{children}</PanelsWrapper>\n    </PanelsContext.Provider>\n  )\n}\n","import { FunctionComponent, PropsWithChildren, useCallback } from 'react'\n\nimport {\n  PresentationNavigateContext,\n  PresentationNavigateContextValue,\n} from './PresentationNavigateContext'\nimport { PresentationNavigate } from './types'\n\nexport const PresentationNavigateProvider: FunctionComponent<\n  PropsWithChildren<{\n    navigate: PresentationNavigate\n  }>\n> = function (props) {\n  const { children, navigate: _navigate } = props\n\n  const navigate = useCallback<PresentationNavigateContextValue>(\n    (preview, document = undefined) => {\n      _navigate(document || {}, preview ? { preview } : {})\n    },\n    [_navigate],\n  )\n\n  return (\n    <PresentationNavigateContext.Provider value={navigate}>\n      {children}\n    </PresentationNavigateContext.Provider>\n  )\n}\n","import { memo, useCallback, useMemo } from 'react'\n\nimport { Panel } from './panels/Panel'\nimport { PanelResizer } from './panels/PanelResizer'\nimport type { NavigatorOptions } from './types'\nimport { useLocalState } from './useLocalState'\n\n/** @internal */\nexport interface UsePresentationNavigatorProps {\n  unstable_navigator?: NavigatorOptions\n}\n\n/** @internal */\nexport interface UsePresentationNavigatorState {\n  navigatorEnabled: boolean\n  toggleNavigator: (() => void) | undefined\n}\n\n/** @internal */\nexport function usePresentationNavigator(\n  props: UsePresentationNavigatorProps,\n): [UsePresentationNavigatorState, () => JSX.Element] {\n  const { unstable_navigator } = props\n\n  const navigatorProvided = !!unstable_navigator?.component\n  const [_navigatorEnabled, setNavigatorEnabled] = useLocalState<boolean>(\n    'presentation/navigator',\n    navigatorProvided,\n  )\n  const navigatorEnabled = navigatorProvided ? _navigatorEnabled : false\n  const toggleNavigator = useMemo(() => {\n    if (!navigatorProvided) return undefined\n\n    return () => setNavigatorEnabled((enabled) => !enabled)\n  }, [navigatorProvided, setNavigatorEnabled])\n\n  const Component = useCallback(\n    function PresentationNavigator() {\n      return <>{navigatorEnabled && <Navigator {...unstable_navigator!} />}</>\n    },\n    [navigatorEnabled, unstable_navigator],\n  )\n\n  return [{ navigatorEnabled, toggleNavigator }, Component]\n}\n\nfunction NavigatorComponent(props: NavigatorOptions) {\n  const { minWidth, maxWidth, component: NavigatorComponent } = props\n  const navigatorDisabled =\n    minWidth != null && maxWidth != null && minWidth === maxWidth\n  return (\n    <>\n      <Panel id=\"navigator\" minWidth={minWidth} maxWidth={maxWidth} order={1}>\n        <NavigatorComponent />\n      </Panel>\n      <PanelResizer order={2} disabled={navigatorDisabled} />\n    </>\n  )\n}\nconst Navigator = memo(NavigatorComponent)\n","import { Dispatch, SetStateAction, useEffect, useState } from 'react'\n\nexport function useLocalState<T>(\n  key: string,\n  defaultValue: T,\n): [T, Dispatch<SetStateAction<T>>] {\n  const [value, setValue] = useState<T>(() =>\n    JSON.parse(localStorage.getItem(key) ?? JSON.stringify(defaultValue)),\n  )\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value))\n  }, [key, value])\n\n  return [value, setValue]\n}\n","import { FunctionComponent, PropsWithChildren, useMemo } from 'react'\n\nimport { PresentationParamsContext } from './PresentationParamsContext'\nimport { PresentationParams } from './types'\n\nexport const PresentationParamsProvider: FunctionComponent<\n  PropsWithChildren<{\n    params: PresentationParams\n  }>\n> = function (props) {\n  const { children, params } = props\n\n  const context = useMemo<PresentationParams>(() => params, [params])\n\n  return (\n    <PresentationParamsContext.Provider value={context}>\n      {children}\n    </PresentationParamsContext.Provider>\n  )\n}\n","import { FunctionComponent, PropsWithChildren, useMemo } from 'react'\n\nimport {\n  PresentationContext,\n  PresentationContextValue,\n} from './PresentationContext'\nimport {\n  DeskDocumentPaneParams,\n  PresentationNavigate,\n  PresentationParams,\n} from './types'\n\nexport const PresentationProvider: FunctionComponent<\n  PropsWithChildren<{\n    deskParams: DeskDocumentPaneParams\n    devMode: boolean\n    name: string\n    navigate: PresentationNavigate\n    params: PresentationParams\n  }>\n> = function (props) {\n  const { children, deskParams, devMode, name, navigate, params } = props\n\n  const context = useMemo<PresentationContextValue>(\n    () => ({\n      deskParams,\n      devMode,\n      name,\n      navigate,\n      params,\n    }),\n    [deskParams, devMode, name, navigate, params],\n  )\n\n  return (\n    <PresentationContext.Provider value={context}>\n      {children}\n    </PresentationContext.Provider>\n  )\n}\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      return schema._parse(action(input), config);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      return schema._parse(await action(input), config);\n    }\n  };\n}\n\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(context, reference, input, label, received) {\n  return {\n    issues: [{ context, reference, input, label, received }]\n  };\n}\n\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n  return { output };\n}\n\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config) {\n  store = { ...store, ...config };\n}\nfunction getGlobalConfig(config) {\n  return {\n    lang: config?.lang ?? store?.lang,\n    message: config?.message,\n    abortEarly: config?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config?.skipPipe ?? store?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/i18n/i18n.ts\nfunction i18n(schema, context, reference, config, issue) {\n  const message = context.message ?? getSpecificMessage(reference, issue.lang) ?? (schema ? getSchemaMessage(issue.lang) : null) ?? config?.message ?? getGlobalMessage(issue.lang) ?? issue.message;\n  return typeof message === \"function\" ? message(issue) : message;\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/schemaResult/schemaResult.ts\nfunction schemaResult(typed, output, issues) {\n  return { typed, output, issues };\n}\n\n// src/utils/stringify/stringify.ts\nfunction stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = input ? Object.getPrototypeOf(input).constructor.name : \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(context, config, issue) {\n  const received = issue.received ?? stringify(issue.input);\n  const schemaIssue2 = {\n    reason: context.type,\n    context: issue.context.type,\n    expected: issue.context.expects,\n    received,\n    message: `Invalid ${issue.label}: ${issue.context.expects ? `Expected ${issue.context.expects} but r` : \"R\"}eceived ${received}`,\n    input: issue.input,\n    requirement: issue.context.requirement,\n    path: issue.path,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  schemaIssue2.message = i18n(\n    false,\n    issue.context,\n    issue.reference,\n    config,\n    schemaIssue2\n  );\n  return schemaIssue2;\n}\n\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = await action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = defaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = defaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(context, reference, input, config, other) {\n  const received = stringify(input);\n  const expected = other?.expected ?? context.expects;\n  const issue = {\n    reason: other?.reason ?? \"type\",\n    context: context.type,\n    expected,\n    received,\n    message: `Invalid type: Expected ${expected} but received ${received}`,\n    input,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  issue.message = i18n(true, context, reference, config, issue);\n  return { typed: false, output: input, issues: [issue] };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        getFallback(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        await getFallbackAsync(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n  return {\n    ...validation,\n    _parse(input) {\n      const result = validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(validation, pathList) {\n  return {\n    ...validation,\n    async _parse(input) {\n      const result = await validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default !== void 0) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default !== void 0) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback !== void 0) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback !== void 0) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input, config) {\n  return !schema._parse(input, {\n    abortEarly: true,\n    skipPipe: getGlobalConfig(config)?.skipPipe\n  }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.item._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.push(result.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, array, input, config);\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all(\n          input.map(async (value2, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.item._parse(value2, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"array\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, arrayAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, bigint, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, bigintAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, blob, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, blobAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, boolean, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, booleanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, date, input, config);\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, dateAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const values = Object.values(enum__);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: false,\n    enum: enum__,\n    message,\n    _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enum_, input, config);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message) {\n  const values = Object.values(enum_2);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enumAsync, input, config);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, instance, input, config);\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, instanceAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return { output: output1 };\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return { output: array2 };\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return { output: object2 };\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (config?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        outputs.push(result.output);\n      }\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(this, intersect, input, config);\n          }\n          output = result.output;\n        }\n        return pipeResult(this, output, config, issues);\n      }\n      return schemaResult(false, output, issues);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    type: \"lazy\",\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _parse(input, config) {\n      return this.getter(input)._parse(input, config);\n    }\n  };\n}\nvar recursive = lazy;\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    type: \"lazy\",\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _parse(input, config) {\n      return (await this.getter(input))._parse(input, config);\n    }\n  };\n}\nvar recursiveAsync = lazyAsync;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literal, input, config);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal2),\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literalAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input.entries()) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, config);\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, config);\n          if (valueResult.issues) {\n            pathItem = pathItem ?? {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!keyResult.typed || !valueResult.typed) {\n            typed = false;\n          }\n          output.set(keyResult.output, valueResult.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, map, input, config);\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        await Promise.all(\n          Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(config?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem ?? {\n                        type: \"map\",\n                        origin,\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        throw null;\n                      }\n                    }\n                    return result;\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (!keyResult?.typed || !valueResult?.typed) {\n              typed = false;\n            }\n            if (keyResult && valueResult) {\n              output.set(keyResult.output, valueResult.output);\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, mapAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nan, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: false,\n    message,\n    _parse(input, config) {\n      return schemaIssue(this, never, input, config);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      return schemaIssue(this, neverAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullable, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullableAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullish, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullishAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptional, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptionalAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, null_, input, config);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nullAsync, input, config);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, number, input, config);\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, numberAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [key, schema] of cachedEntries) {\n          const value2 = input[key];\n          const result = schema._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          if (result.output !== void 0 || key in input) {\n            output[key] = result.output;\n          }\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              const result = this.rest._parse(value2, config);\n              if (result.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (config?.abortEarly) {\n                  typed = false;\n                  break;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output[key] = result.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, object, input, config);\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all([\n          Promise.all(\n            cachedEntries.map(async ([key, schema]) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  if (result.output !== void 0 || key in input) {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          ),\n          this.rest && Promise.all(\n            Object.entries(input).map(async ([key, value2]) => {\n              if (!(config?.abortEarly && issues)) {\n                if (!(key in this.entries)) {\n                  const result = await this.rest._parse(value2, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      const pathItem = {\n                        type: \"object\",\n                        origin: \"value\",\n                        input,\n                        key,\n                        value: value2\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        typed = false;\n                        throw null;\n                      }\n                    }\n                    if (!result.typed) {\n                      typed = false;\n                    }\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, objectAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: false,\n    options,\n    message,\n    _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklist, input, config);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: true,\n    options,\n    message,\n    async _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklistAsync, input, config);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, string, input, config);\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, stringAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = defaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = defaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [inputKey, inputValue] of Object.entries(input)) {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const keyResult = this.key._parse(inputKey, config);\n            if (keyResult.issues) {\n              pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of keyResult.issues) {\n                issue.path = [pathItem];\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = keyResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            const valueResult = this.value._parse(inputValue, config);\n            if (valueResult.issues) {\n              pathItem = pathItem ?? {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of valueResult.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = valueResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!keyResult.typed || !valueResult.typed) {\n              typed = false;\n            }\n            if (keyResult.typed) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, record, input, config);\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all(\n          // Note: `Object.entries(...)` converts each key to a string\n          Object.entries(input).map(async ([inputKey, inputValue]) => {\n            if (!BLOCKED_KEYS.includes(inputKey)) {\n              let pathItem;\n              const [keyResult, valueResult] = await Promise.all(\n                [\n                  { schema: this.key, value: inputKey, origin: \"key\" },\n                  { schema: this.value, value: inputValue, origin: \"value\" }\n                ].map(async ({ schema, value: value3, origin }) => {\n                  if (!(config?.abortEarly && issues)) {\n                    const result = await schema._parse(value3, config);\n                    if (!(config?.abortEarly && issues)) {\n                      if (result.issues) {\n                        pathItem = pathItem ?? {\n                          type: \"record\",\n                          origin,\n                          input,\n                          key: inputKey,\n                          value: inputValue\n                        };\n                        for (const issue of result.issues) {\n                          if (issue.path) {\n                            issue.path.unshift(pathItem);\n                          } else {\n                            issue.path = [pathItem];\n                          }\n                          issues?.push(issue);\n                        }\n                        if (!issues) {\n                          issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                          throw null;\n                        }\n                      }\n                      return result;\n                    }\n                  }\n                })\n              ).catch(() => []);\n              if (!keyResult?.typed || !valueResult?.typed) {\n                typed = false;\n              }\n              if (keyResult?.typed && valueResult) {\n                output[keyResult.output] = valueResult.output;\n              }\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, recordAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Set) {\n        let key = 0;\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const result = this.value._parse(inputValue, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key,\n              value: inputValue\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.add(result.output);\n          key++;\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, set, input, config);\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Set) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        await Promise.all(\n          Array.from(input.values()).map(async (inputValue, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.value._parse(inputValue, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"set\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: inputValue\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output.add(result.output);\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, setAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (this.check(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, special, input, config);\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (await this.check(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, specialAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbol, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbolAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const result = this.items[key]._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output[key] = result.output;\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, config);\n            if (result.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!result.typed) {\n              typed = false;\n            }\n            output[key] = result.output;\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tuple, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all([\n          // Parse schema of each tuple item\n          Promise.all(\n            this.items.map(async (schema, key) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          ),\n          // If necessary parse schema of each rest item\n          this.rest && Promise.all(\n            input.slice(this.items.length).map(async (value2, index) => {\n              if (!(config?.abortEarly && issues)) {\n                const key = this.items.length + index;\n                const result = await this.rest._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tupleAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefined_, input, config);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefinedAsync, input, config);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/utils/subissues/subissues.ts\nfunction subissues(results) {\n  let issues;\n  if (results) {\n    for (const result of results) {\n      if (issues) {\n        for (const issue of result.issues) {\n          issues.push(issue);\n        }\n      } else {\n        issues = result.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResult(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResult(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, union, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, union, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResultAsync(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResultAsync(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, unionAsync, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, unionAsync, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResult(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variant, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variant, input, config);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = async (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = await keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = await schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                await parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          await parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResultAsync(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variantAsync, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variantAsync, input, config);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, void_, input, config);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, voidAsync, input, config);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(this, object, input, config) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(this, objectAsync, input, config) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.typed) {\n        cachedKeys = cachedKeys ?? Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.typed) {\n        cachedKeys = cachedKeys ?? Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.issues) {\n        result.typed = false;\n      } else {\n        result.output = action(result.output, { issues: result.issues });\n        if (arg1) {\n          if (Array.isArray(arg1)) {\n            return pipeResult(\n              { type: typeof result.output, pipe: arg1 },\n              result.output,\n              config\n            );\n          }\n          return arg1._parse(result.output, config);\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.issues) {\n        result.typed = false;\n      } else {\n        result.output = await action(result.output, { issues: result.issues });\n        if (arg1) {\n          if (Array.isArray(arg1)) {\n            return pipeResultAsync(\n              { type: typeof result.output, pipe: arg1 },\n              result.output,\n              config\n            );\n          }\n          return arg1._parse(result.output, config);\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        config\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return actionOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return actionOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bic/bic.ts\nfunction bic(message) {\n  return {\n    type: \"bic\",\n    expects: null,\n    async: false,\n    message,\n    requirement: BIC_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bic, input, \"BIC\");\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    type: \"bytes\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(6[27]\\d{14}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    type: \"credit_card\",\n    expects: null,\n    async: false,\n    message,\n    requirement: (input) => {\n      const sanitized = input.replace(SANITIZE_REGEX, \"\");\n      return PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, creditCard, input, \"credit card\");\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    type: \"cuid2\",\n    expects: null,\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, cuid2, input, \"Cuid2\");\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, custom, input, \"input\");\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      if (await this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, customAsync, input, \"input\");\n    }\n  };\n}\n\n// src/validations/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    type: \"decimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: DECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, decimal, input, \"decimal\");\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message) {\n  return {\n    type: \"email\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, email, input, \"email\");\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    type: \"emoji\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, emoji, input, \"emoji\");\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    type: \"ends_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.endsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        endsWith,\n        input,\n        \"end\",\n        `\"${input.slice(-this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message) {\n  return {\n    type: \"equal\",\n    expects: stringify(requirement),\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, equal, input, \"value\");\n    }\n  };\n}\n\n// src/validations/every/every.ts\nfunction every(requirement, message) {\n  return {\n    type: \"every\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.every(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, every, input, \"input\");\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = stringify(requirement);\n  return {\n    type: \"excludes\",\n    expects: `!${received}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (!input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, excludes, input, \"content\", received);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message) {\n  return {\n    type: \"finite\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, finite, input, \"finite\");\n    }\n  };\n}\n\n// src/validations/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    type: \"hash\",\n    expects: null,\n    async: false,\n    message,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hash, input, \"hash\");\n    }\n  };\n}\n\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    type: \"hexadecimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEXADECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexadecimal, input, \"hexadecimal\");\n    }\n  };\n}\n\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    type: \"hex_color\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEX_COLOR_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexColor, input, \"hex color\");\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message) {\n  return {\n    type: \"imei\",\n    expects: null,\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      if (this.requirement[0].test(input) && this.requirement[1](input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, imei, input, \"IMEI\");\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = stringify(requirement);\n  return {\n    type: \"includes\",\n    expects,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, includes, input, \"content\", `!${expects}`);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message) {\n  return {\n    type: \"integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, integer, input, \"integer\");\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message) {\n  return {\n    type: \"ip\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ip, input, \"IP\");\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    type: \"ipv4\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv4, input, \"IPv4\");\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    type: \"ipv6\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv6, input, \"IPv6\");\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    type: \"iso_date\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDate, input, \"date\");\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    type: \"iso_date_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDateTime, input, \"date-time\");\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    type: \"iso_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTime, input, \"time\");\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    type: \"iso_time_second\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimeSecond, input, \"time second\");\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    type: \"iso_timestamp\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimestamp, input, \"timestamp\");\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    type: \"iso_week\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoWeek, input, \"week\");\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message) {\n  return {\n    type: \"length\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, length, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/mac/mac.ts\nfunction mac(message) {\n  return {\n    type: \"mac\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [MAC48_REGEX, MAC64_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac, input, \"MAC\");\n    }\n  };\n}\n\n// src/validations/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    type: \"mac48\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC48_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac48, input, \"48-bit MAC\");\n    }\n  };\n}\n\n// src/validations/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    type: \"mac64\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC64_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac64, input, \"64-bit MAC\");\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    type: \"max_bytes\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    type: \"max_length\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    type: \"max_size\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    type: \"max_value\",\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        maxValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    type: \"min_bytes\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    type: \"mime_type\",\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \"),\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.includes(input.type)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mimeType, input, \"MIME type\");\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    type: \"min_length\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    type: \"min_size\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    type: \"min_value\",\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        minValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    type: \"multiple_of\",\n    expects: `%${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input % this.requirement === 0) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, multipleOf, input, \"multiple\", `${input}`);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    type: \"not_bytes\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    type: \"not_length\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    type: \"not_size\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    type: \"not_value\",\n    expects: `!${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input < this.requirement || input > this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        notValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n// src/validations/octal/octal.ts\nfunction octal(message) {\n  return {\n    type: \"octal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: OCTAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, octal, input, \"octal\");\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    type: \"regex\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, regex, input, \"format\");\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    type: \"safe_integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, safeInteger, input, \"safe integer\");\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message) {\n  return {\n    type: \"size\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, size, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/some/some.ts\nfunction some(requirement, message) {\n  return {\n    type: \"some\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.some(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, some, input, \"input\");\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    type: \"starts_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.startsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        startsWith,\n        input,\n        \"start\",\n        `\"${input.slice(0, this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    type: \"ulid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ulid, input, \"ULID\");\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message) {\n  return {\n    type: \"url\",\n    expects: null,\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, url, input, \"URL\");\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    type: \"uuid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, uuid, input, \"UUID\");\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message) {\n  return {\n    type: \"value\",\n    expects: `${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement && input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        value,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nexport {\n  BIC_REGEX,\n  BrandSymbol,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  actionIssue,\n  actionOutput,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  decimal,\n  defaultArgs,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  every,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  getDefault,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  i18n,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  literalAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  octal,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  pipeResult,\n  pipeResultAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  restAndDefaultArgs,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  schemaIssue,\n  schemaResult,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  some,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  stringify,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","import type { ClientPerspective } from '@sanity/client'\nimport type { Dispatch, Reducer } from 'react'\nimport { boolean, fallback, object, parse, picklist } from 'valibot'\n\nexport interface PresentationState {\n  iframe: {\n    status: 'loading' | 'loaded' | 'refreshing' | 'reloading'\n  }\n  /**\n   * The selected perspective that all previews should use\n   */\n  perspective: Extract<'published' | 'previewDrafts', ClientPerspective>\n  /**\n   * The viewport size of the preview iframe is currently hardcoded, using this enum to determine the size\n   */\n  viewport: 'desktop' | 'mobile'\n  visualEditing: {\n    overlaysEnabled: boolean\n  }\n}\n\nexport const ACTION_IFRAME_LOADED = 'ACTION_IFRAME_LOADED'\nexport const ACTION_IFRAME_REFRESH = 'ACTION_IFRAME_REFRESH'\nexport const ACTION_IFRAME_RELOAD = 'ACTION_IFRAME_RELOAD'\nexport const ACTION_PERSPECTIVE = 'ACTION_PERSPECTIVE'\nexport const ACTION_VIEWPORT = 'ACTION_VIEWPORT'\nexport const ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE =\n  'ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE'\n\ninterface IframeLoadedAction {\n  type: typeof ACTION_IFRAME_LOADED\n}\ninterface IframeRefreshAction {\n  type: typeof ACTION_IFRAME_REFRESH\n}\ninterface IframeReloadAction {\n  type: typeof ACTION_IFRAME_RELOAD\n}\ninterface PerspectiveAction {\n  type: typeof ACTION_PERSPECTIVE\n  perspective: PresentationState['perspective']\n}\ninterface ViewportAction {\n  type: typeof ACTION_VIEWPORT\n  viewport: PresentationState['viewport']\n}\ninterface VisualEditingOverlaysToggleAction {\n  type: typeof ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE\n  enabled: boolean\n}\n\ntype PresentationAction =\n  | IframeLoadedAction\n  | IframeRefreshAction\n  | IframeReloadAction\n  | PerspectiveAction\n  | ViewportAction\n  | VisualEditingOverlaysToggleAction\n\nexport const presentationReducer: Reducer<\n  Readonly<PresentationState>,\n  Readonly<PresentationAction>\n> = (state, action) => {\n  switch (action.type) {\n    case ACTION_IFRAME_LOADED:\n      return state.iframe.status === 'loaded'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'loaded',\n            },\n          }\n    case ACTION_IFRAME_REFRESH:\n      return state.iframe.status === 'refreshing'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'refreshing',\n            },\n          }\n    case ACTION_IFRAME_RELOAD:\n      return state.iframe.status === 'reloading'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'reloading',\n            },\n          }\n    case ACTION_PERSPECTIVE:\n      return {\n        ...state,\n        perspective: parse(perspectiveSchema, action.perspective),\n      }\n    case ACTION_VIEWPORT:\n      return {\n        ...state,\n        viewport: parse(viewportSchema, action.viewport),\n      }\n    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:\n      return toggleVisualEditingOverlays(state, action)\n    default:\n      return state\n  }\n}\n\nconst toggleVisualEditingOverlays: Reducer<\n  Readonly<PresentationState>,\n  Readonly<VisualEditingOverlaysToggleAction>\n> = (state, action) => {\n  if (state.visualEditing.overlaysEnabled === action.enabled) return state\n  return {\n    ...state,\n    visualEditing: {\n      ...state.visualEditing,\n      overlaysEnabled: action.enabled,\n    },\n  }\n}\n\nconst iframeStatusSchema = picklist([\n  'loading',\n  'loaded',\n  'refreshing',\n  'reloading',\n])\nconst perspectiveSchema = fallback(\n  picklist([\n    'published',\n    'previewDrafts',\n  ] satisfies PresentationState['perspective'][]),\n  'previewDrafts',\n)\nconst viewportSchema = fallback(\n  picklist(['desktop', 'mobile'] satisfies PresentationState['viewport'][]),\n  'desktop',\n)\nconst initStateSchema = object({\n  iframe: object({\n    status: iframeStatusSchema,\n  }),\n  perspective: perspectiveSchema,\n  viewport: viewportSchema,\n  visualEditing: object({ overlaysEnabled: boolean() }),\n})\n\nconst INITIAL_PRESENTATION_STATE = {\n  iframe: {\n    status: 'loading',\n  },\n  perspective: 'previewDrafts',\n  viewport: 'desktop',\n  visualEditing: {\n    overlaysEnabled: false,\n  },\n} as const satisfies PresentationState\nexport function presentationReducerInit(\n  state: Readonly<\n    Partial<{\n      perspective: string\n      viewport: string\n    }>\n  >,\n): Readonly<PresentationState> {\n  return parse(initStateSchema, { ...INITIAL_PRESENTATION_STATE, ...state })\n}\n\nexport type DispatchPresentationAction = Dispatch<Readonly<PresentationAction>>\n","import { motion } from 'framer-motion'\nimport styled from 'styled-components'\n\nexport const IFrame = motion(styled.iframe`\n  border: 0;\n  max-height: 100%;\n  width: 100%;\n  display: block;\n`)\n","import { ResetIcon } from '@sanity/icons'\nimport { TextInput, type TextInputClearButtonProps } from '@sanity/ui'\nimport {\n  ChangeEvent,\n  FunctionComponent,\n  KeyboardEvent,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport { useActiveWorkspace } from 'sanity'\n\nexport const PreviewLocationInput: FunctionComponent<{\n  fontSize?: number\n  onChange: (value: string) => void\n  origin: string\n  padding?: number\n  value: string\n}> = function (props) {\n  const { basePath = '/' } = useActiveWorkspace()?.activeWorkspace || {}\n  const { fontSize = 1, onChange, origin, padding = 3, value } = props\n  const inputRef = useRef<HTMLInputElement | null>(null)\n  const [sessionValue, setSessionValue] = useState<string | undefined>(\n    undefined,\n  )\n  const [customValidity, setCustomValidity] = useState<string | undefined>(\n    undefined,\n  )\n\n  const handleChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setSessionValue(event.currentTarget.value)\n  }, [])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLInputElement>) => {\n      if (event.key === 'Enter') {\n        if (sessionValue === undefined) {\n          return\n        }\n\n        const absoluteValue =\n          sessionValue.startsWith('/') || sessionValue === ''\n            ? `${origin}${sessionValue}`\n            : sessionValue\n\n        if (\n          !absoluteValue.startsWith(origin + '/') &&\n          absoluteValue !== origin\n        ) {\n          setCustomValidity(`URL must start with ${origin}`)\n          return\n        }\n        // `origin` is an empty string '' if the Studio is embedded, and that's when we need to protect against recursion\n        if (\n          !origin &&\n          (absoluteValue.startsWith(`${basePath}/`) ||\n            absoluteValue === basePath)\n        ) {\n          setCustomValidity(\n            `URL can't have the same base path as the Studio ${basePath}`,\n          )\n          return\n        }\n\n        const nextValue =\n          absoluteValue === origin ? origin + '/' : absoluteValue\n\n        setCustomValidity(undefined)\n        setSessionValue(undefined)\n\n        onChange(nextValue.slice(origin.length))\n\n        inputRef.current?.blur()\n      }\n\n      if (event.key === 'Escape') {\n        setCustomValidity(undefined)\n        setSessionValue(undefined)\n      }\n    },\n    [basePath, onChange, origin, sessionValue],\n  )\n\n  const handleBlur = useCallback(() => {\n    setCustomValidity(undefined)\n    setSessionValue(undefined)\n  }, [])\n\n  useEffect(() => {\n    setCustomValidity(undefined)\n    setSessionValue(undefined)\n  }, [origin, value])\n\n  const resetButton: TextInputClearButtonProps = useMemo(\n    () => ({ icon: ResetIcon }),\n    [],\n  )\n\n  return (\n    <>\n      <TextInput\n        clearButton={customValidity ? resetButton : undefined}\n        customValidity={customValidity}\n        fontSize={fontSize}\n        onBlur={handleBlur}\n        onClear={() => {\n          setCustomValidity(undefined)\n          setSessionValue(origin + value)\n        }}\n        onChange={handleChange}\n        onKeyDownCapture={handleKeyDown}\n        padding={padding}\n        style={{ zIndex: 1 }}\n        radius={2}\n        ref={inputRef}\n        space={padding}\n        value={sessionValue === undefined ? `${origin}${value}` : sessionValue}\n      />\n    </>\n  )\n}\n","import { CopyIcon, LaunchIcon } from '@sanity/icons'\nimport { createPreviewSecret } from '@sanity/preview-url-secret/create-secret'\nimport {\n  hasSecretSearchParams,\n  setSecretSearchParams,\n} from '@sanity/preview-url-secret/without-secret-search-params'\nimport { MenuItem, useToast } from '@sanity/ui'\nimport { useCallback, useState } from 'react'\nimport { useClient, useCurrentUser } from 'sanity'\n\nimport { API_VERSION } from '../constants'\nimport type { PreviewFrameProps } from './PreviewFrame'\n\n/** @internal */\nexport function ShareUrlMenuItems(\n  props: Pick<PreviewFrameProps, 'initialUrl' | 'openPopup'> & {\n    previewLocationOrigin: string\n    previewLocationRoute: string\n  },\n): React.ReactNode {\n  const { initialUrl, openPopup, previewLocationOrigin, previewLocationRoute } =\n    props\n\n  const handleOpenPopup = useCallback(\n    (event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {\n      event.preventDefault()\n      openPopup(event.currentTarget.href)\n    },\n    [openPopup],\n  )\n\n  return (\n    <>\n      <CopyUrlMenuButton\n        initialUrl={initialUrl}\n        previewLocationOrigin={previewLocationOrigin}\n        previewLocationRoute={previewLocationRoute}\n      />\n      <MenuItem\n        icon={LaunchIcon}\n        text=\"Open preview\"\n        as=\"a\"\n        href={`${previewLocationOrigin}${previewLocationRoute}`}\n        // @ts-expect-error the `as=\"a\"` prop isn't enough to change the type of event.target from <div> to <a>\n        onClick={handleOpenPopup}\n        rel=\"opener\"\n        target=\"_blank\"\n      />\n    </>\n  )\n}\n\nfunction CopyUrlMenuButton(\n  props: Pick<PreviewFrameProps, 'initialUrl'> & {\n    previewLocationOrigin: string\n    previewLocationRoute: string\n  },\n) {\n  const { initialUrl, previewLocationOrigin, previewLocationRoute } = props\n\n  const { push: pushToast } = useToast()\n  const client = useClient({ apiVersion: API_VERSION })\n  const currentUser = useCurrentUser()\n  const [disabled, setDisabled] = useState(false)\n\n  return (\n    <MenuItem\n      disabled={disabled}\n      onClick={() => {\n        if (!navigator?.clipboard) {\n          pushToast({\n            closable: true,\n            status: 'error',\n            title: 'Clipboard not supported',\n          })\n          return false\n        }\n        setDisabled(true)\n\n        let id: string | undefined = undefined\n        let url = `${previewLocationOrigin}${previewLocationRoute}`\n        const onFinally = () => {\n          pushToast({\n            id,\n            closable: true,\n            status: 'success',\n            title: 'The URL is copied to the clipboard',\n          })\n          setDisabled(false)\n        }\n        const onError = (error: Error) => {\n          pushToast({\n            closable: true,\n            status: 'error',\n            title: 'Copy failed',\n            description: error.message || error.toString(),\n          })\n          setDisabled(false)\n        }\n        if (\n          hasSecretSearchParams(initialUrl) &&\n          typeof ClipboardItem !== 'undefined'\n        ) {\n          const type = 'text/plain'\n          const resolvePreviewUrl = async () => {\n            id = pushToast({\n              closable: true,\n              title: 'Copying URL to clipboard',\n            })\n            const previewUrlSecret = await createPreviewSecret(\n              client,\n              '@sanity/presentation',\n              typeof window === 'undefined' ? '' : location.href,\n              currentUser?.id,\n            )\n\n            const newUrl = setSecretSearchParams(\n              initialUrl,\n              previewUrlSecret.secret,\n              previewLocationRoute,\n            )\n            url = newUrl.toString()\n            return new Blob([url], { type })\n          }\n\n          // Try to save to clipboard then save it in the state if worked\n          const item = new ClipboardItem({\n            [type]: resolvePreviewUrl(),\n          })\n          navigator.clipboard.write([item]).then(onFinally).catch(onError)\n        } else {\n          navigator.clipboard.writeText(url).then(onFinally).catch(onError)\n        }\n      }}\n      text=\"Copy link\"\n      icon={CopyIcon}\n    />\n  )\n}\n","import type { ChannelStatus } from '@sanity/channels'\nimport {\n  CheckmarkIcon,\n  ChevronDownIcon,\n  DesktopIcon,\n  EditIcon,\n  MobileDeviceIcon,\n  PanelLeftIcon,\n  PublishIcon,\n  RefreshIcon,\n  ShareIcon,\n} from '@sanity/icons'\nimport { withoutSecretSearchParams } from '@sanity/preview-url-secret/without-secret-search-params'\nimport {\n  Box,\n  Button,\n  ButtonTone,\n  Card,\n  Code,\n  Flex,\n  Label,\n  Menu,\n  MenuButton,\n  MenuItem,\n  Spinner,\n  Stack,\n  Switch,\n  Text,\n  Tooltip,\n  TooltipDelayGroupProvider,\n  usePrefersReducedMotion,\n} from '@sanity/ui'\nimport { AnimatePresence, motion, MotionConfig } from 'framer-motion'\nimport {\n  ComponentType,\n  createElement,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport { Hotkeys } from 'sanity'\nimport styled from 'styled-components'\n\nimport { ErrorCard } from '../components/ErrorCard'\nimport { MAX_TIME_TO_OVERLAYS_CONNECTION } from '../constants'\nimport {\n  ACTION_IFRAME_LOADED,\n  ACTION_IFRAME_RELOAD,\n  ACTION_PERSPECTIVE,\n  ACTION_VIEWPORT,\n  type DispatchPresentationAction,\n  type PresentationState,\n} from '../reducers/presentationReducer'\nimport { PresentationParams } from '../types'\nimport { usePresentationTool } from '../usePresentationTool'\nimport { IFrame } from './IFrame'\nimport { PreviewLocationInput } from './PreviewLocationInput'\nimport { ShareUrlMenuItems } from './ShareUrlMenuItems'\n\nconst MotionFlex = motion(Flex)\n\nconst StyledSwitch = styled(Switch)`\n  & > span {\n    width: 21px;\n    height: 13px;\n    overflow: hidden;\n\n    & > span:nth-child(1) {\n      width: 21px;\n      height: 13px;\n    }\n\n    & > span:nth-child(2) {\n      width: 9px;\n      height: 9px;\n      top: 2px;\n      left: 2px;\n    }\n  }\n\n  & input:checked + span {\n    & > span:nth-child(2) {\n      transform: translate3d(8px, 0, 0) !important;\n    }\n  }\n`\n\nconst PERSPECTIVE_TITLES: Record<PresentationState['perspective'], string> = {\n  previewDrafts: 'Drafts',\n  published: 'Published',\n}\n\nconst PERSPECTIVE_TONES: Record<PresentationState['perspective'], ButtonTone> =\n  {\n    previewDrafts: 'caution',\n    published: 'positive',\n  }\n\nconst PERSPECTIVE_ICONS: Record<\n  PresentationState['perspective'],\n  ComponentType\n> = {\n  previewDrafts: EditIcon,\n  published: PublishIcon,\n}\n\nexport interface PreviewFrameProps\n  extends Pick<\n    PresentationState,\n    'iframe' | 'perspective' | 'viewport' | 'visualEditing'\n  > {\n  dispatch: DispatchPresentationAction\n  initialUrl: URL\n  loadersConnection: ChannelStatus\n  navigatorEnabled: boolean\n  onPathChange: (nextPath: string) => void\n  onRefresh: (fallback: () => void) => void\n  openPopup: (url: string) => void\n  overlaysConnection: ChannelStatus\n  params: PresentationParams\n  targetOrigin: string\n  toggleNavigator?: () => void\n  toggleOverlay: () => void\n}\n\nexport const PreviewFrame = forwardRef<HTMLIFrameElement, PreviewFrameProps>(\n  function PreviewFrame(props, ref) {\n    const {\n      dispatch,\n      iframe,\n      initialUrl,\n      loadersConnection,\n      navigatorEnabled,\n      onPathChange,\n      onRefresh,\n      openPopup,\n      overlaysConnection,\n      params,\n      perspective,\n      targetOrigin,\n      toggleNavigator,\n      toggleOverlay,\n      viewport,\n      visualEditing: { overlaysEnabled },\n    } = props\n\n    const { devMode } = usePresentationTool()\n\n    const prefersReducedMotion = usePrefersReducedMotion()\n\n    const setDesktopMode = useCallback(\n      () => dispatch({ type: ACTION_VIEWPORT, viewport: 'desktop' }),\n      [dispatch],\n    )\n    const setMobileMode = useCallback(\n      () => dispatch({ type: ACTION_VIEWPORT, viewport: 'mobile' }),\n      [dispatch],\n    )\n    const loading = iframe.status === 'loading' || iframe.status === 'reloading'\n    const [timedOut, setTimedOut] = useState(false)\n    const refreshing = iframe.status === 'refreshing'\n    const [somethingIsWrong, setSomethingIsWrong] = useState(false)\n    const iframeIsBusy =\n      loading || refreshing || overlaysConnection === 'connecting'\n\n    const previewLocationOrigin = useMemo(() => {\n      return targetOrigin === location.origin ? '' : targetOrigin\n    }, [targetOrigin])\n\n    const handleRefresh = useCallback(() => {\n      onRefresh(() => {\n        if (typeof ref === 'function' || !ref?.current) {\n          return\n        }\n        dispatch({ type: ACTION_IFRAME_RELOAD })\n        // Funky way to reload an iframe without CORS issues\n        // eslint-disable-next-line no-self-assign\n        // ref.current.src = ref.current.src\n        ref.current.src = `${targetOrigin}${params.preview || '/'}`\n      })\n    }, [dispatch, onRefresh, params.preview, targetOrigin, ref])\n    const handleRetry = useCallback(() => {\n      if (typeof ref === 'function' || !ref?.current) {\n        return\n      }\n\n      ref.current.src = initialUrl.toString()\n\n      dispatch({ type: ACTION_IFRAME_RELOAD })\n    }, [dispatch, ref, initialUrl])\n    const handleContinueAnyway = useCallback(() => {\n      setContinueAnyway(true)\n    }, [])\n\n    const [continueAnyway, setContinueAnyway] = useState(false)\n    const [showOverlaysConnectionStatus, setShowOverlaysConnectionState] =\n      useState(false)\n    useEffect(() => {\n      if (loading || refreshing) {\n        return\n      }\n\n      if (\n        overlaysConnection === 'connecting' ||\n        overlaysConnection === 'reconnecting'\n      ) {\n        const timeout = setTimeout(() => {\n          setShowOverlaysConnectionState(true)\n        }, 1000)\n        return () => clearTimeout(timeout)\n      }\n      return\n    }, [overlaysConnection, loading, refreshing])\n\n    useEffect(() => {\n      if (loading || refreshing || !showOverlaysConnectionStatus) {\n        return\n      }\n      if (overlaysConnection === 'connected') {\n        setSomethingIsWrong(false)\n        setShowOverlaysConnectionState(false)\n        setTimedOut(false)\n        setContinueAnyway(false)\n      }\n      if (overlaysConnection === 'connecting') {\n        const timeout = setTimeout(() => {\n          setTimedOut(true)\n          // eslint-disable-next-line no-console\n          console.error(\n            `Unable to connect to visual editing. Make sure you've setup '@sanity/visual-editing' correctly`,\n          )\n        }, MAX_TIME_TO_OVERLAYS_CONNECTION)\n        return () => clearTimeout(timeout)\n      }\n      if (overlaysConnection === 'reconnecting') {\n        const timeout = setTimeout(() => {\n          setTimedOut(true)\n          setSomethingIsWrong(true)\n        }, MAX_TIME_TO_OVERLAYS_CONNECTION)\n        return () => clearTimeout(timeout)\n      }\n      if (overlaysConnection === 'disconnected') {\n        setSomethingIsWrong(true)\n      }\n      return\n    }, [loading, overlaysConnection, refreshing, showOverlaysConnectionStatus])\n\n    const previewLocationRoute = useMemo(() => {\n      const previewUrl = new URL(params.preview || '/', targetOrigin)\n      const { pathname, search } = withoutSecretSearchParams(previewUrl)\n\n      return `${pathname}${search}`\n    }, [params.preview, targetOrigin])\n\n    const onIFrameLoad = useCallback(() => {\n      dispatch({ type: ACTION_IFRAME_LOADED })\n    }, [dispatch])\n\n    return (\n      <MotionConfig\n        transition={prefersReducedMotion ? { duration: 0 } : undefined}\n      >\n        <TooltipDelayGroupProvider delay={1000}>\n          <Card\n            flex=\"none\"\n            padding={2}\n            shadow={1}\n            style={{ position: 'relative' }}\n          >\n            <Flex align=\"center\" gap={2} style={{ minHeight: 0 }}>\n              {toggleNavigator && (\n                <Tooltip\n                  animate\n                  content={<Text size={1}>Toggle navigator</Text>}\n                  fallbackPlacements={['bottom-start']}\n                  padding={2}\n                  placement=\"bottom\"\n                  portal\n                >\n                  <Button\n                    aria-label=\"Toggle navigator\"\n                    fontSize={1}\n                    icon={PanelLeftIcon}\n                    mode=\"bleed\"\n                    onClick={toggleNavigator}\n                    padding={3}\n                    selected={navigatorEnabled}\n                  />\n                </Tooltip>\n              )}\n\n              <Tooltip\n                animate\n                content={\n                  <Flex align=\"center\" style={{ whiteSpace: 'nowrap' }}>\n                    <Box padding={1}>\n                      <Text size={1}>\n                        {overlaysEnabled\n                          ? 'Disable edit overlay'\n                          : 'Enable edit overlay'}\n                      </Text>\n                    </Box>\n                    <Box paddingY={1}>\n                      <Hotkeys\n                        keys={['Alt']}\n                        style={{ marginTop: -4, marginBottom: -4 }}\n                      />\n                    </Box>\n                  </Flex>\n                }\n                fallbackPlacements={['bottom-start']}\n                padding={1}\n                placement=\"bottom\"\n                portal\n              >\n                <Card\n                  as=\"label\"\n                  flex=\"none\"\n                  padding={3}\n                  style={{\n                    lineHeight: 0,\n                    borderRadius: 999,\n                    userSelect: 'none',\n                  }}\n                  tone={overlaysEnabled ? 'positive' : undefined}\n                >\n                  <Flex align=\"center\" gap={2}>\n                    <div style={{ margin: -2 }}>\n                      <StyledSwitch\n                        checked={overlaysEnabled}\n                        onChange={toggleOverlay}\n                        disabled={\n                          iframe.status === 'loading' ||\n                          overlaysConnection !== 'connected'\n                        }\n                      />\n                    </div>\n                    <Box>\n                      <Text muted size={1} weight=\"medium\">\n                        Edit\n                      </Text>\n                    </Box>\n                  </Flex>\n                </Card>\n              </Tooltip>\n              <Tooltip\n                animate\n                content={\n                  <Text size={1}>\n                    {iframe.status === 'loading'\n                      ? 'Loading'\n                      : iframe.status === 'reloading'\n                        ? 'Refreshing'\n                        : iframe.status === 'refreshing'\n                          ? 'Refreshing'\n                          : 'Refresh preview'}\n                  </Text>\n                }\n                fallbackPlacements={['bottom-start']}\n                padding={2}\n                placement=\"bottom\"\n                portal\n              >\n                <Button\n                  aria-label=\"Refresh preview\"\n                  fontSize={1}\n                  icon={RefreshIcon}\n                  mode=\"bleed\"\n                  loading={\n                    iframe.status === 'reloading' ||\n                    iframe.status === 'refreshing'\n                  }\n                  onClick={handleRefresh}\n                  padding={3}\n                />\n              </Tooltip>\n\n              <Box flex={1}>\n                <PreviewLocationInput\n                  onChange={onPathChange}\n                  origin={previewLocationOrigin}\n                  value={previewLocationRoute}\n                />\n              </Box>\n\n              <Flex align=\"center\" flex=\"none\" gap={1}>\n                <MenuButton\n                  button={\n                    <Button\n                      fontSize={1}\n                      iconRight={ShareIcon}\n                      mode=\"bleed\"\n                      padding={3}\n                      space={2}\n                    />\n                  }\n                  id=\"location-menu\"\n                  menu={\n                    <Menu>\n                      <ShareUrlMenuItems\n                        initialUrl={initialUrl}\n                        openPopup={openPopup}\n                        previewLocationOrigin={previewLocationOrigin}\n                        previewLocationRoute={previewLocationRoute}\n                      />\n                    </Menu>\n                  }\n                  popover={{\n                    animate: true,\n                    constrainSize: true,\n                    placement: 'bottom',\n                    portal: true,\n                  }}\n                />\n              </Flex>\n\n              <Flex align=\"center\" flex=\"none\" gap={1}>\n                <MenuButton\n                  button={\n                    <Button\n                      fontSize={1}\n                      iconRight={ChevronDownIcon}\n                      mode=\"bleed\"\n                      padding={3}\n                      space={2}\n                      text={\n                        PERSPECTIVE_TITLES[\n                          loadersConnection === 'connected'\n                            ? perspective\n                            : 'previewDrafts'\n                        ]\n                      }\n                      loading={\n                        loadersConnection === 'reconnecting' &&\n                        iframe.status !== 'loaded'\n                      }\n                      disabled={loadersConnection !== 'connected'}\n                    />\n                  }\n                  id=\"perspective-menu\"\n                  menu={\n                    <Menu style={{ maxWidth: 240 }}>\n                      <MenuItem\n                        fontSize={1}\n                        onClick={() =>\n                          dispatch({\n                            type: ACTION_PERSPECTIVE,\n                            perspective: 'previewDrafts',\n                          })\n                        }\n                        padding={3}\n                        pressed={perspective === 'previewDrafts'}\n                        tone={PERSPECTIVE_TONES.previewDrafts}\n                      >\n                        <Flex align=\"flex-start\" gap={3}>\n                          <Box flex=\"none\">\n                            <Text size={1}>\n                              {createElement(PERSPECTIVE_ICONS.previewDrafts)}\n                            </Text>\n                          </Box>\n                          <Stack flex={1} space={2}>\n                            <Text size={1} weight=\"medium\">\n                              {PERSPECTIVE_TITLES.previewDrafts}\n                            </Text>\n                            <Text muted size={1}>\n                              View this page with latest draft content\n                            </Text>\n                          </Stack>\n                          <Box flex=\"none\">\n                            <Text\n                              muted\n                              size={1}\n                              style={{\n                                opacity:\n                                  perspective === 'previewDrafts' ? 1 : 0,\n                              }}\n                            >\n                              <CheckmarkIcon />\n                            </Text>\n                          </Box>\n                        </Flex>\n                      </MenuItem>\n                      <MenuItem\n                        fontSize={1}\n                        onClick={() =>\n                          dispatch({\n                            type: ACTION_PERSPECTIVE,\n                            perspective: 'published',\n                          })\n                        }\n                        padding={3}\n                        pressed={perspective === 'published'}\n                        tone={PERSPECTIVE_TONES.published}\n                      >\n                        <Flex align=\"flex-start\" gap={3}>\n                          <Box flex=\"none\">\n                            <Text size={1}>\n                              {createElement(PERSPECTIVE_ICONS.published)}\n                            </Text>\n                          </Box>\n                          <Stack flex={1} space={2}>\n                            <Text size={1} weight=\"medium\">\n                              {PERSPECTIVE_TITLES.published}\n                            </Text>\n                            <Text muted size={1}>\n                              View this page with published content\n                            </Text>\n                          </Stack>\n                          <Box flex=\"none\">\n                            <Text\n                              muted\n                              size={1}\n                              style={{\n                                opacity: perspective === 'published' ? 1 : 0,\n                              }}\n                            >\n                              <CheckmarkIcon />\n                            </Text>\n                          </Box>\n                        </Flex>\n                      </MenuItem>\n                    </Menu>\n                  }\n                  popover={{\n                    animate: true,\n                    constrainSize: true,\n                    placement: 'bottom',\n                    portal: true,\n                  }}\n                />\n              </Flex>\n\n              <Flex align=\"center\" flex=\"none\" gap={1}>\n                <Tooltip\n                  animate\n                  content={<Text size={1}>Full viewport</Text>}\n                  fallbackPlacements={['bottom-start']}\n                  padding={2}\n                  placement=\"bottom\"\n                  portal\n                >\n                  <Button\n                    aria-label=\"Full viewport\"\n                    fontSize={1}\n                    icon={DesktopIcon}\n                    mode=\"bleed\"\n                    onClick={setDesktopMode}\n                    padding={3}\n                    selected={viewport === 'desktop'}\n                  />\n                </Tooltip>\n                <Tooltip\n                  animate\n                  content={<Text size={1}>Narrow viewport</Text>}\n                  padding={2}\n                  placement=\"bottom\"\n                  portal\n                >\n                  <Button\n                    aria-label=\"Narrow viewport\"\n                    fontSize={1}\n                    icon={MobileDeviceIcon}\n                    mode=\"bleed\"\n                    onClick={setMobileMode}\n                    padding={3}\n                    selected={viewport === 'mobile'}\n                  />\n                </Tooltip>\n              </Flex>\n            </Flex>\n          </Card>\n\n          <Card flex={1} tone=\"transparent\">\n            <Flex\n              align=\"center\"\n              height=\"fill\"\n              justify=\"center\"\n              padding={viewport === 'desktop' ? 0 : 2}\n              sizing=\"border\"\n              style={{\n                position: 'relative',\n                cursor: iframeIsBusy ? 'wait' : undefined,\n              }}\n            >\n              <AnimatePresence>\n                {!somethingIsWrong &&\n                !loading &&\n                !refreshing &&\n                showOverlaysConnectionStatus &&\n                !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={spinnerVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      inset: '0',\n                      position: 'absolute',\n                      backdropFilter: timedOut\n                        ? 'blur(16px) saturate(0.5) grayscale(0.5)'\n                        : 'blur(2px)',\n                      ['transition' as string]:\n                        'backdrop-filter 0.2s ease-in-out',\n                      // @TODO Because of Safari we have to do this\n                      WebkitBackdropFilter: timedOut\n                        ? 'blur(16px) saturate(0.5) grayscale(0.5)'\n                        : 'blur(2px)',\n                      WebkitTransition:\n                        '-webkit-backdrop-filter 0.2s ease-in-out',\n                      zIndex: 1,\n                    }}\n                  >\n                    <Flex\n                      style={{ ...sizes[viewport] }}\n                      justify=\"center\"\n                      align=\"center\"\n                      direction=\"column\"\n                      gap={4}\n                    >\n                      {timedOut && (\n                        <Button\n                          disabled\n                          fontSize={1}\n                          mode=\"ghost\"\n                          text=\"Continue anyway\"\n                          style={{ opacity: 0 }}\n                        />\n                      )}\n                      <Card\n                        radius={2}\n                        tone={timedOut ? 'caution' : 'inherit'}\n                        padding={4}\n                        shadow={1}\n                      >\n                        <Flex\n                          justify=\"center\"\n                          align=\"center\"\n                          direction=\"column\"\n                          gap={4}\n                        >\n                          <Spinner muted />\n                          <Text muted size={1}>\n                            {timedOut ? (\n                              <>\n                                Unable to connect, check the browser console for\n                                more information.\n                              </>\n                            ) : (\n                              'Connecting'\n                            )}\n                          </Text>\n                        </Flex>\n                      </Card>\n                      {timedOut && (\n                        <Button\n                          fontSize={1}\n                          // mode=\"ghost\"\n                          tone=\"critical\"\n                          onClick={handleContinueAnyway}\n                          text=\"Continue anyway\"\n                        />\n                      )}\n                    </Flex>\n                  </MotionFlex>\n                ) : (loading ||\n                    (overlaysConnection === 'connecting' &&\n                      iframe.status !== 'refreshing')) &&\n                  !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={spinnerVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      inset: '0',\n                      position: 'absolute',\n                      // boxShadow: '0 0 0 1px var(--card-shadow-outline-color)',\n                    }}\n                  >\n                    <Flex\n                      style={{ ...sizes[viewport] }}\n                      justify=\"center\"\n                      align=\"center\"\n                      direction=\"column\"\n                      gap={4}\n                    >\n                      <Spinner muted />\n                      <Text muted size={1}>\n                        Loading\n                      </Text>\n                    </Flex>\n                  </MotionFlex>\n                ) : somethingIsWrong && !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={errorVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      background: 'var(--card-bg-color)',\n                      inset: '0',\n                      position: 'absolute',\n                      borderTop: '1px solid transparent',\n                      boxShadow: '0 0 0 1px var(--card-border-color)',\n                    }}\n                  >\n                    <ErrorCard\n                      flex={1}\n                      message=\"Could not connect to the preview\"\n                      onRetry={handleRetry}\n                      onContinueAnyway={handleContinueAnyway}\n                    >\n                      {devMode && (\n                        <>\n                          {overlaysConnection !== 'connected' && (\n                            <Card padding={3} radius={2} tone=\"critical\">\n                              <Stack space={3}>\n                                <Label muted size={0}>\n                                  Overlay connection status\n                                </Label>\n                                <Code size={1}>{overlaysConnection}</Code>\n                              </Stack>\n                            </Card>\n                          )}\n\n                          {loadersConnection !== 'connected' && (\n                            <Card padding={3} radius={2} tone=\"critical\">\n                              <Stack space={3}>\n                                <Label muted size={0}>\n                                  Loader connection status\n                                </Label>\n                                <Code size={1}>{loadersConnection}</Code>\n                              </Stack>\n                            </Card>\n                          )}\n                        </>\n                      )}\n                    </ErrorCard>\n                  </MotionFlex>\n                ) : null}\n              </AnimatePresence>\n              <IFrame\n                ref={ref}\n                style={{\n                  pointerEvents:\n                    (loading ||\n                      (overlaysConnection === 'connecting' &&\n                        iframe.status !== 'refreshing')) &&\n                    !continueAnyway\n                      ? 'none'\n                      : 'auto',\n                  boxShadow: '0 0 0 1px var(--card-border-color)',\n                  borderTop: '1px solid transparent',\n                }}\n                src={initialUrl.toString()}\n                initial={['background']}\n                variants={iframeVariants}\n                animate={[\n                  (loading ||\n                    (overlaysConnection === 'connecting' &&\n                      iframe.status !== 'refreshing')) &&\n                  !continueAnyway\n                    ? 'background'\n                    : 'active',\n                  loading ? 'reloading' : 'idle',\n                  viewport,\n                  showOverlaysConnectionStatus && !continueAnyway\n                    ? 'timedOut'\n                    : '',\n                ]}\n                onLoad={onIFrameLoad}\n              />\n            </Flex>\n          </Card>\n        </TooltipDelayGroupProvider>\n      </MotionConfig>\n    )\n  },\n)\n\nconst sizes = {\n  desktop: {\n    width: '100%',\n    height: '100%',\n  },\n  mobile: {\n    width: 375,\n    height: 650,\n  },\n}\n\nconst spinnerVariants = {\n  initial: { opacity: 1 },\n  animate: { opacity: [0, 0, 1] },\n  exit: { opacity: [1, 0, 0] },\n}\n\nconst errorVariants = {\n  initial: { opacity: 1 },\n  animate: { opacity: [0, 0, 1] },\n  exit: { opacity: [1, 0, 0] },\n}\n\nconst iframeVariants = {\n  desktop: {\n    ...sizes.desktop,\n    boxShadow: '0 0 0 0px var(--card-border-color)',\n  },\n  mobile: {\n    ...sizes.mobile,\n    boxShadow: '0 0 0 1px var(--card-border-color)',\n  },\n  background: {\n    opacity: 0,\n    scale: 1,\n  },\n  idle: {\n    scale: 1,\n  },\n  reloading: {\n    scale: [1, 1, 1, 0.98],\n  },\n  active: {\n    opacity: [0, 0, 1],\n    scale: 1,\n  },\n  timedOut: {\n    opacity: [0, 0, 1],\n  },\n}\n","import type { ClientPerspective } from '@sanity/client'\nimport isEqual from 'fast-deep-equal'\nimport { MutableRefObject, useCallback, useMemo, useRef, useState } from 'react'\n\nimport type { PresentationState } from './reducers/presentationReducer'\nimport type { FrameState } from './types'\n\nexport type DocumentOnPage = {\n  _id: string\n  _type: string\n}\n\ntype DocumentCache = Record<string, DocumentOnPage>\ntype KeyedDocumentCache = Record<string, DocumentCache>\n\nlet warnedAboutCrossDatasetReference = false\n\nexport function useDocumentsOnPage(\n  perspective: PresentationState['perspective'],\n  frameStateRef: MutableRefObject<FrameState>,\n): [\n  DocumentOnPage[],\n  (\n    key: string,\n    perspective: PresentationState['perspective'],\n    state: DocumentOnPage[],\n  ) => void,\n] {\n  if (perspective !== 'published' && perspective !== 'previewDrafts') {\n    throw new Error(`Invalid perspective: ${perspective}`)\n  }\n\n  const [published, setPublished] = useState<KeyedDocumentCache>({})\n  const [previewDrafts, setPreviewDrafts] = useState<KeyedDocumentCache>({})\n\n  // Used to compare the frame url with its value when the cache was last updated\n  // If the url has changed, the entire cache is replaced\n  const urlRef = useRef<string | undefined>('')\n\n  const setDocumentsOnPage = useCallback(\n    (\n      key: string,\n      perspective: ClientPerspective,\n      sourceDocuments: DocumentOnPage[] = [],\n    ) => {\n      const documents = sourceDocuments.filter((sourceDocument) => {\n        if ('_projectId' in sourceDocument && sourceDocument._projectId) {\n          // @TODO Handle cross dataset references\n          if (!warnedAboutCrossDatasetReference) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              'Cross dataset references are not supported yet, ignoring source document',\n              sourceDocument,\n            )\n            warnedAboutCrossDatasetReference = true\n          }\n          return false\n        }\n        return sourceDocument\n      })\n\n      const setCache =\n        perspective === 'published' ? setPublished : setPreviewDrafts\n\n      setCache((cache) => {\n        // Create the `next` documents, dedupe by `_id`\n        const next: Record<string, DocumentOnPage> = {}\n        for (const document of documents) {\n          next[document._id] = document\n        }\n\n        // If the frame url has changed, replace the entire cache with the next documents\n        if (urlRef.current !== frameStateRef.current.url) {\n          urlRef.current = frameStateRef.current.url\n          return { [key]: next }\n        }\n\n        // If the keyed cache has changed, return the entire cache and replace the keyed part\n        const prev = cache[key]\n        if (!isEqual(prev, next)) {\n          return { ...cache, [key]: next }\n        }\n\n        // Otherwise return the entire cache as is\n        return cache\n      })\n    },\n    [frameStateRef],\n  )\n\n  const documentsOnPage = useMemo(() => {\n    const keyedCache = perspective === 'published' ? published : previewDrafts\n    const uniqueDocuments = Object.values(keyedCache).reduce((acc, cache) => {\n      Object.values(cache).forEach((doc) => {\n        acc[doc._id] = doc\n      })\n      return acc\n    }, {})\n\n    return Object.values(uniqueDocuments)\n  }, [perspective, previewDrafts, published])\n\n  return [documentsOnPage, setDocumentsOnPage]\n}\n","import { studioPath } from '@sanity/client/csm'\nimport { urlStringToPath } from '@sanity/visual-editing-helpers'\n\nimport type { PresentationStateParams } from '../types'\n\nexport function parseId(rawId: string | undefined): string | undefined {\n  if (rawId === undefined) {\n    return undefined\n  }\n\n  const segments = decodeURIComponent(rawId)?.split('.')\n\n  if (segments[0] === 'drafts') {\n    segments.shift()\n  }\n\n  return segments.join('.')\n}\n\nexport function parsePath(rawPath: string | undefined): string | undefined {\n  if (rawPath === undefined) {\n    return undefined\n  }\n\n  return studioPath.toString(urlStringToPath(decodeURIComponent(rawPath)))\n}\n\nexport function parseRouterState(\n  state: PresentationStateParams,\n): PresentationStateParams {\n  return {\n    id: parseId(state.id),\n    path: parsePath(state.path),\n    type: state.type,\n  }\n}\n","import { MutableRefObject, useEffect, useMemo, useRef } from 'react'\nimport { getPublishedId } from 'sanity'\nimport { RouterContextValue, RouterState, SearchParam } from 'sanity/router'\n\nimport { debounce } from './lib/debounce'\nimport { parseRouterState } from './lib/parse'\nimport {\n  DeskDocumentPaneParams,\n  FrameState,\n  PresentationNavigate,\n  PresentationParams,\n  PresentationSearchParams,\n  PresentationStateParams,\n} from './types'\n\nfunction pruneObject<T extends RouterState | PresentationParams>(obj: T): T {\n  return Object.fromEntries(\n    Object.entries(obj).filter(\n      ([, value]) => value !== undefined && value !== '' && value !== null,\n    ),\n  ) as T\n}\n\nexport function useParams({\n  initialPreviewUrl,\n  routerNavigate,\n  routerState,\n  routerSearchParams,\n  frameStateRef,\n}: {\n  initialPreviewUrl: URL\n  routerNavigate: RouterContextValue['navigate']\n  routerState: RouterState & PresentationStateParams\n  routerSearchParams: {\n    [k: string]: string\n  }\n  frameStateRef: MutableRefObject<FrameState>\n}): {\n  deskParams: DeskDocumentPaneParams\n  navigate: PresentationNavigate\n  params: PresentationParams\n} {\n  const params = useMemo<PresentationParams>(() => {\n    const { id, path, type } = parseRouterState(routerState)\n\n    return {\n      id,\n      type,\n      path,\n      preview:\n        routerSearchParams.preview ||\n        `${initialPreviewUrl.pathname}${initialPreviewUrl.search}`,\n      perspective: routerSearchParams.perspective,\n      viewport: routerSearchParams.viewport,\n      inspect: routerSearchParams.inspect,\n      rev: routerSearchParams.rev,\n      since: routerSearchParams.since,\n      template: routerSearchParams.template,\n      templateParams: routerSearchParams.templateParams,\n      view: routerSearchParams.view,\n      // assist\n      pathKey: routerSearchParams.pathKey,\n      instruction: routerSearchParams.instruction,\n      // comments\n      comment: routerSearchParams.comment,\n    }\n  }, [routerState, routerSearchParams, initialPreviewUrl])\n\n  const deskParams = useMemo<DeskDocumentPaneParams>(() => {\n    const pruned = pruneObject({\n      inspect: params.inspect,\n      path: params.path,\n      rev: params.rev,\n      since: params.since,\n      template: params.template,\n      templateParams: params.templateParams,\n      view: params.view,\n      // assist\n      pathKey: params.pathKey,\n      instruction: params.instruction,\n      // comments\n      comment: params.comment,\n    })\n    return pruned\n  }, [\n    params.comment,\n    params.inspect,\n    params.instruction,\n    params.path,\n    params.pathKey,\n    params.rev,\n    params.since,\n    params.template,\n    params.templateParams,\n    params.view,\n  ])\n\n  const routerStateRef = useRef(routerState)\n\n  useEffect(() => {\n    routerStateRef.current = routerState\n  }, [routerState])\n\n  const navigate = useMemo(\n    () =>\n      debounce<PresentationNavigate>(\n        (nextState, nextSearchState = {}, forceReplace) => {\n          // Force navigation to use published IDs only\n          if (nextState.id) nextState.id = getPublishedId(nextState.id)\n\n          // Extract type, id and path as 'routerState'\n          const { _searchParams: routerSearchParams, ...routerState } =\n            routerStateRef.current\n\n          // Convert array of search params to an object\n          const routerSearchState = (routerSearchParams || []).reduce(\n            (acc, [key, value]) => (\n              (acc[key as keyof PresentationSearchParams] = value), acc\n            ),\n            {} as PresentationSearchParams,\n          )\n\n          // Merge routerState and incoming state\n          const state: RouterState = pruneObject({\n            ...routerState,\n            ...nextState,\n          })\n\n          // Merge routerSearchState and incoming searchState\n          const searchState = pruneObject({\n            ...routerSearchState,\n            ...nextSearchState,\n          })\n\n          // If the document has changed, clear the template and templateParams\n          if (routerState.id !== state.id) {\n            delete searchState.template\n            delete searchState.templateParams\n          }\n\n          state._searchParams = Object.entries(searchState).reduce(\n            (acc, [key, value]) => [...acc, [key, value]],\n            [] as SearchParam[],\n          )\n\n          const replace =\n            forceReplace ?? searchState.preview === frameStateRef.current.url\n\n          routerNavigate(state, { replace })\n        },\n        50,\n      ),\n    [routerNavigate, frameStateRef],\n  )\n\n  return {\n    deskParams,\n    navigate,\n    params,\n  }\n}\n","import { createPreviewSecret } from '@sanity/preview-url-secret/create-secret'\nimport { definePreviewUrl } from '@sanity/preview-url-secret/define-preview-url'\nimport { startTransition, useEffect, useMemo, useState } from 'react'\nimport {\n  type SanityClient,\n  useActiveWorkspace,\n  useClient,\n  useCurrentUser,\n} from 'sanity'\nimport { suspend } from 'suspend-react'\n\nimport { API_VERSION } from './constants'\nimport { PreviewUrlOption } from './types'\n\nexport function usePreviewUrl(\n  previewUrl: PreviewUrlOption,\n  toolName: string,\n  previewSearchParam: string | null,\n): URL {\n  const client = useClient({ apiVersion: API_VERSION })\n  const workspace = useActiveWorkspace()\n  const basePath = workspace?.activeWorkspace?.basePath || '/'\n  const workspaceName = workspace?.activeWorkspace?.name || 'default'\n  const deps = useSuspendCacheKeys(toolName, basePath, workspaceName)\n  const previewUrlSecret = usePreviewUrlSecret(\n    typeof previewUrl === 'object' || typeof previewUrl === 'function',\n    deps,\n  )\n  return suspend(async () => {\n    if (typeof previewUrl === 'string') {\n      const resolvedUrl = new URL(previewUrl, location.origin)\n      let resultUrl = resolvedUrl\n      try {\n        if (previewSearchParam) {\n          const restoredUrl = new URL(previewSearchParam, resolvedUrl)\n          if (restoredUrl.origin === resolvedUrl.origin) {\n            resultUrl = restoredUrl\n          }\n        } else if (document.referrer) {\n          const referrerUrl = new URL(document.referrer)\n          if (referrerUrl.origin === resolvedUrl.origin) {\n            resultUrl = referrerUrl\n          }\n        }\n      } catch {\n        // ignore\n      }\n      // Prevent infinite recursion\n      if (\n        location.origin === resultUrl.origin &&\n        (resultUrl.pathname.startsWith(`${basePath}/`) ||\n          resultUrl.pathname === basePath)\n      ) {\n        return resolvedUrl\n      }\n      return resultUrl\n    }\n    const resolvePreviewUrl =\n      typeof previewUrl === 'object'\n        ? definePreviewUrl<SanityClient>(previewUrl)\n        : previewUrl\n    const resolvedUrl = await resolvePreviewUrl({\n      client,\n      previewUrlSecret: previewUrlSecret!,\n      previewSearchParam,\n      referrer: typeof document === 'undefined' ? null : document.referrer,\n      studioBasePath: basePath,\n    })\n    return new URL(resolvedUrl, location.origin)\n  }, [...deps, previewUrlSecret]) satisfies URL\n}\n\n// https://github.com/pmndrs/suspend-react?tab=readme-ov-file#making-cache-keys-unique\nconst resolveUUID = Symbol()\n\nfunction useSuspendCacheKeys(\n  toolName: string,\n  basePath: string,\n  workspaceName: string,\n) {\n  const currentUser = useCurrentUser()\n  return useMemo(\n    () => [\n      // Cache based on a few specific conditions\n      '@sanity/presentation',\n      basePath,\n      workspaceName,\n      toolName,\n      currentUser?.id,\n      resolveUUID,\n    ],\n    [basePath, currentUser?.id, toolName, workspaceName],\n  )\n}\n\nfunction usePreviewUrlSecret(\n  enabled: boolean,\n  deps: (string | symbol | undefined)[],\n) {\n  const client = useClient({ apiVersion: API_VERSION })\n  const currentUser = useCurrentUser()\n  const [secretLastExpiredAt, setSecretLastExpiredAt] = useState<string>('')\n\n  const previewUrlSecret = enabled\n    ? suspend(async () => {\n        return await createPreviewSecret(\n          client,\n          '@sanity/presentation',\n          typeof window === 'undefined' ? '' : location.href,\n          currentUser?.id,\n        )\n      }, [...deps, secretLastExpiredAt])\n    : null\n\n  useEffect(() => {\n    if (!previewUrlSecret) return\n    const timeout = setTimeout(() => {\n      startTransition(() =>\n        setSecretLastExpiredAt(previewUrlSecret.expiresAt.toString()),\n      )\n    }, previewUrlSecret.expiresAt.getTime() - Date.now())\n    return () => clearTimeout(timeout)\n  }, [previewUrlSecret])\n\n  return previewUrlSecret?.secret || null\n}\n","import {\n  type ChannelsController,\n  type ChannelStatus,\n  createChannelsController,\n} from '@sanity/channels'\nimport { studioPath } from '@sanity/client/csm'\nimport { BoundaryElementProvider, Flex } from '@sanity/ui'\nimport {\n  getQueryCacheKey,\n  isAltKey,\n  isHotkey,\n  type LoaderMsg,\n  type OverlayMsg,\n  type PresentationMsg,\n  type PreviewKitMsg,\n  type VisualEditingConnectionIds,\n  type VisualEditingMsg,\n} from '@sanity/visual-editing-helpers'\nimport {\n  lazy,\n  type ReactElement,\n  startTransition,\n  Suspense,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from 'react'\nimport { useUnique, useWorkspace } from 'sanity'\nimport {\n  type Path,\n  type SanityDocument,\n  type Tool,\n  useDataset,\n  useProjectId,\n} from 'sanity'\nimport { RouterContextValue, useRouter } from 'sanity/router'\nimport {\n  type CommentIntentGetter,\n  CommentsIntentProvider,\n} from 'sanity/structure'\nimport styled from 'styled-components'\n\nimport {\n  COMMENTS_INSPECTOR_NAME,\n  DEFAULT_TOOL_NAME,\n  EDIT_INTENT_MODE,\n  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,\n} from './constants'\nimport { ContentEditor } from './editor/ContentEditor'\nimport { DisplayedDocumentBroadcasterProvider } from './loader/DisplayedDocumentBroadcaster'\nimport { Panel } from './panels/Panel'\nimport { PanelResizer } from './panels/PanelResizer'\nimport { Panels } from './panels/Panels'\nimport { PresentationNavigateProvider } from './PresentationNavigateProvider'\nimport { usePresentationNavigator } from './PresentationNavigator'\nimport { PresentationParamsProvider } from './PresentationParamsProvider'\nimport { PresentationProvider } from './PresentationProvider'\nimport { PreviewFrame } from './preview/PreviewFrame'\nimport {\n  ACTION_IFRAME_LOADED,\n  ACTION_IFRAME_REFRESH,\n  ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,\n  presentationReducer,\n  presentationReducerInit,\n} from './reducers/presentationReducer'\nimport type {\n  DeskDocumentPaneParams,\n  FrameState,\n  LiveQueriesState,\n  LiveQueriesStateValue,\n  PresentationPluginOptions,\n  PresentationStateParams,\n} from './types'\nimport { useDocumentsOnPage } from './useDocumentsOnPage'\nimport { useParams } from './useParams'\nimport { usePreviewUrl } from './usePreviewUrl'\n\nconst LoaderQueries = lazy(() => import('./loader/LoaderQueries'))\nconst PostMessageRefreshMutations = lazy(\n  () => import('./editor/PostMessageRefreshMutations'),\n)\n\nconst Container = styled(Flex)`\n  overflow-x: auto;\n`\n\nexport default function PresentationTool(props: {\n  tool: Tool<PresentationPluginOptions>\n}): ReactElement {\n  const { previewUrl: _previewUrl, components } = props.tool.options ?? {}\n  const name = props.tool.name || DEFAULT_TOOL_NAME\n  const { unstable_navigator } = components || {}\n\n  const { navigate: routerNavigate, state: routerState } =\n    useRouter() as RouterContextValue & { state: PresentationStateParams }\n  const routerSearchParams = useUnique(\n    Object.fromEntries(routerState._searchParams || []),\n  )\n\n  const initialPreviewUrl = usePreviewUrl(\n    _previewUrl || '/',\n    name,\n    routerSearchParams.preview || null,\n  )\n\n  const [devMode] = useState(() => {\n    const option = props.tool.options?.devMode\n\n    if (typeof option === 'function') return option()\n    if (typeof option === 'boolean') return option\n\n    return (\n      typeof window !== 'undefined' && window.location.hostname === 'localhost'\n    )\n  })\n\n  const targetOrigin = useMemo(() => {\n    return initialPreviewUrl.origin\n  }, [initialPreviewUrl.origin])\n\n  const iframeRef = useRef<HTMLIFrameElement>(null)\n\n  const [channel, setChannel] =\n    useState<ChannelsController<LoaderMsg | PresentationMsg>>()\n\n  const [liveQueries, setLiveQueries] = useState<LiveQueriesState>({})\n\n  const frameStateRef = useRef<FrameState>({\n    title: undefined,\n    url: undefined,\n  })\n\n  const { params, deskParams, navigate } = useParams({\n    initialPreviewUrl,\n    routerNavigate,\n    routerState,\n    routerSearchParams,\n    frameStateRef,\n  })\n\n  const [state, dispatch] = useReducer(\n    presentationReducer,\n    { perspective: params.perspective, viewport: params.viewport },\n    presentationReducerInit,\n  )\n\n  const [documentsOnPage, setDocumentsOnPage] = useDocumentsOnPage(\n    state.perspective,\n    frameStateRef,\n  )\n\n  const projectId = useProjectId()\n  const dataset = useDataset()\n\n  // Update the perspective and viewport when the param changes\n  useEffect(() => {\n    if (\n      state.perspective !== params.perspective ||\n      state.viewport !== params.viewport\n    ) {\n      navigate(\n        {},\n        {\n          perspective:\n            state.perspective === 'previewDrafts'\n              ? undefined\n              : state.perspective,\n          viewport: state.viewport === 'desktop' ? undefined : state.viewport,\n        },\n      )\n    }\n  }, [\n    params.perspective,\n    state.perspective,\n    navigate,\n    state.viewport,\n    params.viewport,\n  ])\n\n  const [overlaysConnection, setOverlaysConnection] =\n    useState<ChannelStatus>('connecting')\n  const [loadersConnection, setLoadersConnection] =\n    useState<ChannelStatus>('connecting')\n  const [previewKitConnection, setPreviewKitConnection] =\n    useState<ChannelStatus>('connecting')\n\n  const [popups] = useState<Set<Window>>(() => new Set())\n  const handleOpenPopup = useCallback(\n    (url: string) => {\n      const source = window.open(url, '_blank')\n      if (source) {\n        popups.add(source)\n      }\n    },\n    [popups],\n  )\n\n  useEffect(() => {\n    if (popups.size && channel) {\n      // loop popups and call channel.addSource\n      for (const source of popups) {\n        if (source && 'closed' in source && !source.closed) {\n          channel.addSource(source)\n        }\n      }\n    }\n  }, [channel, popups, popups.size])\n\n  useEffect(() => {\n    const target = iframeRef.current?.contentWindow\n\n    if (!target) return\n\n    const nextChannel = createChannelsController<\n      PresentationMsg,\n      LoaderMsg | OverlayMsg | VisualEditingMsg | PreviewKitMsg\n    >({\n      id: 'presentation' satisfies VisualEditingConnectionIds,\n      target,\n      targetOrigin,\n      connectTo: [\n        {\n          id: 'overlays' satisfies VisualEditingConnectionIds,\n          heartbeat: true,\n          onStatusUpdate: setOverlaysConnection,\n          onEvent(type, data) {\n            if (\n              (type === 'visual-editing/focus' || type === 'overlay/focus') &&\n              'id' in data\n            ) {\n              navigate({\n                type: data.type,\n                id: data.id,\n                path: data.path,\n              })\n            } else if (\n              type === 'visual-editing/navigate' ||\n              type === 'overlay/navigate'\n            ) {\n              const { title, url } = data\n              if (frameStateRef.current.url !== url) {\n                navigate({}, { preview: url })\n              }\n              frameStateRef.current = { title, url }\n            } else if (type === 'visual-editing/meta') {\n              frameStateRef.current.title = data.title\n            } else if (\n              type === 'visual-editing/toggle' ||\n              type === 'overlay/toggle'\n            ) {\n              dispatch({\n                type: ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,\n                enabled: data.enabled,\n              })\n            } else if (type === 'visual-editing/documents') {\n              setDocumentsOnPage(\n                'visual-editing',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            } else if (\n              type === 'visual-editing/refreshing' &&\n              data.source === 'manual'\n            ) {\n              clearTimeout(refreshRef.current)\n            } else if (\n              type === 'visual-editing/refreshing' &&\n              data.source === 'mutation'\n            ) {\n              dispatch({ type: ACTION_IFRAME_REFRESH })\n            } else if (type === 'visual-editing/refreshed') {\n              dispatch({ type: ACTION_IFRAME_LOADED })\n            }\n          },\n        },\n        {\n          id: 'loaders' satisfies VisualEditingConnectionIds,\n          heartbeat: true,\n          onStatusUpdate: setLoadersConnection,\n          onEvent(type, data) {\n            if (\n              type === 'loader/documents' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              setDocumentsOnPage(\n                'loaders',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            } else if (\n              type === 'loader/query-listen' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              if (\n                typeof data.heartbeat === 'number' &&\n                data.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL\n              ) {\n                throw new Error(\n                  `Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`,\n                )\n              }\n              setLiveQueries((prev) => ({\n                ...prev,\n                [getQueryCacheKey(data.query, data.params)]: {\n                  perspective: data.perspective,\n                  query: data.query,\n                  params: data.params,\n                  receivedAt: Date.now(),\n                  heartbeat: data.heartbeat ?? false,\n                } satisfies LiveQueriesStateValue,\n              }))\n            }\n          },\n        },\n        {\n          id: 'preview-kit' satisfies VisualEditingConnectionIds,\n          heartbeat: true,\n          onStatusUpdate: setPreviewKitConnection,\n          onEvent(type, data) {\n            if (\n              type === 'preview-kit/documents' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              setDocumentsOnPage(\n                'preview-kit',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            }\n          },\n        },\n      ],\n    })\n    setChannel(nextChannel)\n\n    return () => {\n      nextChannel.destroy()\n      setChannel(undefined)\n    }\n  }, [dataset, projectId, setDocumentsOnPage, navigate, targetOrigin])\n\n  useEffect(() => {\n    const interval = setInterval(\n      () =>\n        startTransition(() =>\n          setLiveQueries((liveQueries) => {\n            if (Object.keys(liveQueries).length < 1) {\n              return liveQueries\n            }\n\n            const now = Date.now()\n            const hasAnyExpired = Object.values(liveQueries).some(\n              (liveQuery) =>\n                liveQuery.heartbeat !== false &&\n                now > liveQuery.receivedAt + liveQuery.heartbeat,\n            )\n            if (!hasAnyExpired) {\n              return liveQueries\n            }\n            const next = {} as LiveQueriesState\n            for (const [key, value] of Object.entries(liveQueries)) {\n              if (\n                value.heartbeat !== false &&\n                now > value.receivedAt + value.heartbeat\n              ) {\n                continue\n              }\n              next[key] = value\n            }\n            return next\n          }),\n        ),\n      MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,\n    )\n    return () => clearInterval(interval)\n  }, [])\n\n  const handleFocusPath = useCallback(\n    (nextPath: Path) => {\n      // Dont need to explicitly set the id here because it was either already set via postMessage or is the same if navigating in the document pane\n      navigate({ path: studioPath.toString(nextPath) }, {}, true)\n    },\n    [navigate],\n  )\n\n  const handlePreviewPath = useCallback(\n    (nextPath: string) => {\n      const url = new URL(nextPath, initialPreviewUrl.origin)\n      const preview = url.pathname + url.search\n      if (\n        url.origin === initialPreviewUrl.origin &&\n        preview !== params.preview\n      ) {\n        navigate({}, { preview })\n      }\n    },\n    [initialPreviewUrl, params, navigate],\n  )\n\n  const handleDeskParams = useCallback(\n    (deskParams: DeskDocumentPaneParams) => {\n      navigate({}, deskParams)\n    },\n    [navigate],\n  )\n\n  // Dispatch a perspective message when the perspective changes\n  useEffect(() => {\n    channel?.send('overlays', 'presentation/perspective', {\n      perspective: state.perspective,\n    })\n  }, [channel, state.perspective])\n\n  // Dispatch a focus or blur message when the id or path change\n  useEffect(() => {\n    if (params.id && params.path) {\n      channel?.send('overlays', 'presentation/focus', {\n        id: params.id,\n        path: params.path,\n      })\n    } else {\n      channel?.send('overlays', 'presentation/blur', undefined)\n    }\n  }, [channel, params.id, params.path])\n\n  // Dispatch a navigation message when the preview param changes\n  useEffect(() => {\n    if (\n      frameStateRef.current.url &&\n      params.preview &&\n      frameStateRef.current.url !== params.preview\n    ) {\n      frameStateRef.current.url = params.preview\n      if (overlaysConnection !== 'connected' && iframeRef.current) {\n        iframeRef.current.src = `${targetOrigin}${params.preview}`\n      } else {\n        channel?.send('overlays', 'presentation/navigate', {\n          url: params.preview,\n          type: 'replace',\n        })\n      }\n    }\n  }, [channel, overlaysConnection, targetOrigin, params.preview])\n\n  const toggleOverlay = useCallback(\n    () => channel?.send('overlays', 'presentation/toggleOverlay', undefined),\n    [channel],\n  )\n\n  const [displayedDocument, setDisplayedDocument] = useState<\n    Partial<SanityDocument> | null | undefined\n  >(null)\n\n  useEffect(() => {\n    const handleKeyUp = (e: KeyboardEvent) => {\n      if (isAltKey(e)) {\n        toggleOverlay()\n      }\n    }\n    const handleKeydown = (e: KeyboardEvent) => {\n      if (isAltKey(e)) {\n        toggleOverlay()\n      }\n\n      if (isHotkey(['mod', '\\\\'], e)) {\n        toggleOverlay()\n      }\n    }\n    window.addEventListener('keydown', handleKeydown)\n    window.addEventListener('keyup', handleKeyUp)\n    return () => {\n      window.removeEventListener('keydown', handleKeydown)\n      window.removeEventListener('keyup', handleKeyUp)\n    }\n  }, [toggleOverlay])\n\n  const [boundaryElement, setBoundaryElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n\n  const [{ navigatorEnabled, toggleNavigator }, PresentationNavigator] =\n    usePresentationNavigator({ unstable_navigator })\n\n  // Handle edge case where the `&rev=` parameter gets \"stuck\"\n  const idRef = useRef<string | undefined>(params.id)\n  useEffect(() => {\n    if (params.rev && idRef.current && params.id !== idRef.current) {\n      navigate({}, { rev: undefined })\n    }\n    idRef.current = params.id\n  })\n\n  const refreshRef = useRef<number>()\n  const handleRefresh = useCallback(\n    (fallback: () => void) => {\n      dispatch({ type: ACTION_IFRAME_REFRESH })\n      if (channel) {\n        // We only wait 300ms for the iframe to ack the refresh request before running the fallback logic\n        refreshRef.current = window.setTimeout(fallback, 300)\n        channel.send('overlays', 'presentation/refresh', {\n          source: 'manual',\n          livePreviewEnabled:\n            previewKitConnection === 'connected' ||\n            loadersConnection === 'connected',\n        })\n        return\n      }\n      fallback()\n    },\n    [channel, loadersConnection, previewKitConnection],\n  )\n\n  const workspace = useWorkspace()\n\n  const getCommentIntent = useCallback<CommentIntentGetter>(\n    ({ id, type, path }) => {\n      if (frameStateRef.current.url) {\n        return {\n          title: frameStateRef.current.title || frameStateRef.current.url,\n          name: 'edit',\n          params: {\n            id,\n            path,\n            type,\n            inspect: COMMENTS_INSPECTOR_NAME,\n            workspace: workspace.name,\n            mode: EDIT_INTENT_MODE,\n            preview: params.preview,\n          },\n        }\n      }\n      return undefined\n    },\n    [params.preview, workspace.name],\n  )\n\n  return (\n    <>\n      <PresentationProvider\n        deskParams={deskParams}\n        devMode={devMode}\n        name={name}\n        params={params}\n        navigate={navigate}\n      >\n        <PresentationNavigateProvider navigate={navigate}>\n          <PresentationParamsProvider params={params}>\n            <Container height=\"fill\">\n              <Panels>\n                <PresentationNavigator />\n                <Panel\n                  id=\"preview\"\n                  minWidth={325}\n                  defaultSize={navigatorEnabled ? 50 : 75}\n                  order={3}\n                >\n                  <Flex\n                    direction=\"column\"\n                    flex={1}\n                    height=\"fill\"\n                    ref={setBoundaryElement}\n                  >\n                    <BoundaryElementProvider element={boundaryElement}>\n                      <PreviewFrame\n                        dispatch={dispatch}\n                        iframe={state.iframe}\n                        initialUrl={initialPreviewUrl}\n                        loadersConnection={loadersConnection}\n                        navigatorEnabled={navigatorEnabled}\n                        onPathChange={handlePreviewPath}\n                        onRefresh={handleRefresh}\n                        openPopup={handleOpenPopup}\n                        overlaysConnection={overlaysConnection}\n                        params={params}\n                        perspective={state.perspective}\n                        ref={iframeRef}\n                        targetOrigin={targetOrigin}\n                        toggleNavigator={toggleNavigator}\n                        toggleOverlay={toggleOverlay}\n                        viewport={state.viewport}\n                        visualEditing={state.visualEditing}\n                      />\n                    </BoundaryElementProvider>\n                  </Flex>\n                </Panel>\n                <PanelResizer order={4} />\n                <Panel id=\"content\" minWidth={325} order={5}>\n                  <DisplayedDocumentBroadcasterProvider\n                    documentId={params.id}\n                    setDisplayedDocument={setDisplayedDocument}\n                  >\n                    <CommentsIntentProvider getIntent={getCommentIntent}>\n                      <ContentEditor\n                        refs={documentsOnPage}\n                        deskParams={deskParams}\n                        documentId={params.id}\n                        documentType={params.type}\n                        onDeskParams={handleDeskParams}\n                        onFocusPath={handleFocusPath}\n                        previewUrl={params.preview}\n                      />\n                    </CommentsIntentProvider>\n                  </DisplayedDocumentBroadcasterProvider>\n                </Panel>\n              </Panels>\n            </Container>\n          </PresentationParamsProvider>\n        </PresentationNavigateProvider>\n      </PresentationProvider>\n      {channel && (\n        <Suspense>\n          <LoaderQueries\n            channel={channel}\n            liveQueries={liveQueries}\n            perspective={state.perspective}\n            liveDocument={displayedDocument}\n            documentsOnPage={documentsOnPage}\n          />\n        </Suspense>\n      )}\n      {channel && params.id && params.type && (\n        <Suspense>\n          <PostMessageRefreshMutations\n            channel={channel}\n            id={params.id}\n            type={params.type}\n            loadersConnection={loadersConnection}\n            previewKitConnection={previewKitConnection}\n          />\n        </Suspense>\n      )}\n    </>\n  )\n}\n"],"names":["jsx","jsxs","Fragment","studioPath","Card","Flex","Container$1","Stack","Text","Inline","Box","Button","Code","Label","ErrorBoundary","TextInput","MenuItem","useToast","Switch","usePrefersReducedMotion","TooltipDelayGroupProvider","Tooltip","MenuButton","Menu","Spinner","BoundaryElementProvider","useContext","forwardRef","useCallback","useMemo","useState","useEffect","createContext","useLayoutEffect","useRef","memo","createElement","startTransition","useReducer","Suspense","lazy","useUnique","getPublishedId","useActiveWorkspace","useClient","useCurrentUser","Hotkeys","useProjectId","useDataset","useWorkspace","StateLink","useRouter","decodeJsonParams","PaneRouterContext","PaneLayout","StructureToolProvider","DocumentListPane$1","useStructureTool","DocumentPane$1","CommentsIntentProvider","styled","PresentationContext","PresentationNavigateContext","PresentationParamsContext","API_VERSION","MAX_TIME_TO_OVERLAYS_CONNECTION","MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL","COMMENTS_INSPECTOR_NAME","EDIT_INTENT_MODE","DEFAULT_TOOL_NAME","DisplayedDocumentBroadcasterProvider","ResetIcon","LaunchIcon","CopyIcon","PanelLeftIcon","RefreshIcon","ShareIcon","ChevronDownIcon","CheckmarkIcon","DesktopIcon","MobileDeviceIcon","EditIcon","PublishIcon","hasSecretSearchParams","setSecretSearchParams","withoutSecretSearchParams","motion","MotionConfig","AnimatePresence","createPreviewSecret","isEqual","definePreviewUrl","suspend","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","RESPONSE_TIMEOUT","HEARTBEAT_INTERVAL","HANDSHAKE_INTERVAL","HANDSHAKE_MSG_TYPES","isHandshakeMessage","type","some","t","isLegacyHandshakeMessage","data","Array","isArray","every","key","startsWith","createChannelsControllerInternal","config","target","channels","connectTo","map","buffer","id","handler","handshakeHandler","status","interval","heartbeat","stopHandshake","channel","window","clearInterval","e","find","from","setChannelStatus","sendHandshake","messageHandler","_a","_b","_c","connectionId","args","onEvent","call","send","responseTo","handleEvents","console","error","origin","domain","to","includes","targetOrigin","isValidMessageEvent","stopHeartbeat","next","onStatusUpdate","uuid","setInterval","startHandshake","heartbeatInverval","startHeartbeat","toFlush","splice","length","forEach","flush","msg","postMessage","expectResponse","maxWait","setTimeout","removeEventListener","transact","warn","eventData","clearTimeout","addEventListener","destroy","r","o","u","alt","ctrl","mod","test","navigator","platform","shift","ErrorCard","props","children","message","onRetry","onContinueAnyway","restProps","retryButton","fontSize","mode","onClick","text","continueAnywayButton","tone","height","align","justify","Container","padding","sizing","width","space","size","weight","muted","usePresentationTool","presentation","resolveQueryStringFromParams","nextParams","allowed","params","parts","Object","entries","value","join","encodeQueryString","filter","reduce","obj","BackLink","ref","deskParams","state","_searchParams","preview","title","ReferenceChildLink","documentId","documentType","parentRefPath","template","PresentationPaneRouterProvider","onDeskParams","previewUrl","refs","routerState","resolvePathFromState","routerSearchParams","fromEntries","createPathWithParams","context","index","groupIndex","siblingIndex","payload","hasGroupSiblings","groupLength","routerPanesState","ChildLink","childLinkProps","childId","_id","_type","ParameterizedLink","closeCurrentAndAfter","handleEditReference","replaceCurrent","pane","closeCurrent","duplicateCurrent","setView","viewId","setParams","inspect","setPayload","navigateIntent","intentName","intentParams","Provider","RootLayout","Root","WrappedCode","DocumentListPane","devMode","ids","schemaTypeName","errorParams","setErrorParams","handleRetry","flex","overflow","radius","onCatch","direction","DeskDocumentListPane","itemId","paneKey","DocumentPane","onFocusPath","templateParams","paneDocumentNode","templateParameters","setLayoutCollapsed","handleRootCollapse","handleRootExpand","style","onExpand","onCollapse","DeskDocumentPane","DocumentPanel","ContentEditor","PanelsContext","displayName","div","Panel","defaultSize","minWidth","maxWidth","order","getPanelStyle","registerElement","unregisterElement","Resizer","ResizerInner","$disabled","PanelResizer","propId","disabled","el","current","usePanelId","activeResizer","drag","startDragging","stopDragging","isDragging","onMouseDown","event","nativeEvent","onDrag","onDragStop","blur","debounce","fn","timeout","timer","apply","itemKey","getStoredItem","JSON","parse","localStorage","getItem","getKeyForPanels","panels","panel","usePanelsStorage","set","widths","setItem","stringify","setStoredItem","get","setDebounced","getNextWidth","nextWidth","containerWidth","maxWidthPx","minWidthPx","Math","min","max","getPanelWidth","findIndex","toPrecision","getOffset","handleElement","initialOffset","initialHandleElementRect","clientX","getBoundingClientRect","left","isPanel","element","isResizer","getSortedElements","elements","values","sort","a","b","validateWidths","widthsToValidate","total","remainingWidth","toFixed","abs","PanelsWrapper","Panels","panelsEl","setElements","Map","setWidths","setActiveResizer","panelsRef","flexGrow","pointerEvents","prev","has","delete","dragRef","innerWidth","dragOffset","panelAfter","panelBefore","resizerIndex","resizerRect","startX","elementsArr","resizer","resizeElement","acc","pageX","preventDefault","stopPropagation","prevWidths","nextWidths","delta","panelsState","initialDragState","initialWidths","pivotPanel","deltaApplied","localeCompare","numeric","getNextWidths","prevWidth","storage","storedWidths","validatedStoredWidths","defaultWidths","panelsWithoutWidth","remainingWidthTotal","widthsWithNulls","defaultWidth","getDefaultWidths","resizeObserver","ResizeObserver","observe","disconnect","PresentationNavigateProvider","navigate","_navigate","document","usePresentationNavigator","unstable_navigator","navigatorProvided","component","_navigatorEnabled","setNavigatorEnabled","defaultValue","setValue","useLocalState","navigatorEnabled","toggleNavigator","enabled","Component","Navigator","NavigatorComponent","navigatorDisabled","PresentationParamsProvider","PresentationProvider","name","store","store2","store3","store4","ValiError","constructor","issues","super","__publicField","this","defaultArgs","arg1","arg2","i18n","schema","reference","issue","_d","_e","lang","getSpecificMessage","getGlobalMessage","schemaResult","typed","output","input","getPrototypeOf","pipeIssue","received","schemaIssue2","reason","expected","expects","label","requirement","path","abortEarly","abortPipeEarly","skipPipe","pipeResult","pipe","action","result","_parse","actionIssue2","schemaIssue","other","fallback","fallback2","info","getFallback","object","arg3","arg4","rest","error2","pipe2","restAndDefaultArgs","cachedEntries","async","value2","pathItem","unshift","picklist","getGlobalConfig","ACTION_IFRAME_LOADED","ACTION_IFRAME_REFRESH","ACTION_IFRAME_RELOAD","ACTION_PERSPECTIVE","ACTION_VIEWPORT","ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE","presentationReducer","iframe","perspective","perspectiveSchema","viewport","viewportSchema","toggleVisualEditingOverlays","visualEditing","overlaysEnabled","iframeStatusSchema","initStateSchema","boolean","INITIAL_PRESENTATION_STATE","presentationReducerInit","IFrame","PreviewLocationInput","basePath","activeWorkspace","onChange","inputRef","sessionValue","setSessionValue","customValidity","setCustomValidity","handleChange","currentTarget","handleKeyDown","absoluteValue","nextValue","handleBlur","resetButton","icon","clearButton","onBlur","onClear","onKeyDownCapture","zIndex","ShareUrlMenuItems","initialUrl","openPopup","previewLocationOrigin","previewLocationRoute","handleOpenPopup","href","CopyUrlMenuButton","as","rel","pushToast","client","apiVersion","currentUser","setDisabled","clipboard","closable","url","onFinally","onError","description","ClipboardItem","item","previewUrlSecret","location","secret","Blob","resolvePreviewUrl","write","then","catch","writeText","MotionFlex","StyledSwitch","PERSPECTIVE_TITLES","previewDrafts","published","PERSPECTIVE_TONES","PERSPECTIVE_ICONS","PreviewFrame","dispatch","loadersConnection","onPathChange","onRefresh","overlaysConnection","toggleOverlay","prefersReducedMotion","setDesktopMode","setMobileMode","loading","timedOut","setTimedOut","refreshing","somethingIsWrong","setSomethingIsWrong","iframeIsBusy","handleRefresh","src","handleContinueAnyway","setContinueAnyway","continueAnyway","showOverlaysConnectionStatus","setShowOverlaysConnectionState","URL","pathname","search","onIFrameLoad","transition","duration","delay","shadow","position","gap","minHeight","animate","content","fallbackPlacements","placement","portal","selected","whiteSpace","paddingY","keys","marginTop","marginBottom","lineHeight","borderRadius","userSelect","margin","checked","button","iconRight","menu","popover","constrainSize","pressed","opacity","cursor","initial","exit","variants","spinnerVariants","inset","sizes","errorVariants","background","borderTop","boxShadow","backdropFilter","WebkitBackdropFilter","WebkitTransition","iframeVariants","onLoad","desktop","mobile","scale","idle","reloading","active","warnedAboutCrossDatasetReference","parseId","rawId","segments","decodeURIComponent","split","parsePath","rawPath","n","exec","e2","Number","s","c","_key","urlStringToPath","pruneObject","useParams","initialPreviewUrl","routerNavigate","frameStateRef","rev","since","view","pathKey","instruction","comment","routerStateRef","nextState","nextSearchState","forceReplace","routerSearchState","searchState","replace","usePreviewUrl","toolName","previewSearchParam","workspace","workspaceName","deps","resolveUUID","useSuspendCacheKeys","secretLastExpiredAt","setSecretLastExpiredAt","expiresAt","getTime","Date","now","usePreviewUrlSecret","resolvedUrl","resultUrl","restoredUrl","referrer","referrerUrl","studioBasePath","Symbol","LoaderQueries","import","PostMessageRefreshMutations","PresentationTool","_previewUrl","components","tool","option","hostname","iframeRef","setChannel","liveQueries","setLiveQueries","documentsOnPage","setDocumentsOnPage","setPublished","setPreviewDrafts","urlRef","sourceDocuments","documents","sourceDocument","_projectId","cache","uniqueDocuments","doc","useDocumentsOnPage","projectId","dataset","setOverlaysConnection","setLoadersConnection","previewKitConnection","setPreviewKitConnection","popups","Set","source","open","add","closed","addSource","contentWindow","nextChannel","sources","sendToSource","WeakMap","destroySource","prevConnectTo","createChannelsController","refreshRef","query","receivedAt","liveQuery","handleFocusPath","nextPath","handlePreviewPath","handleDeskParams","displayedDocument","setDisplayedDocument","handleKeyUp","handleKeydown","toUpperCase","boundaryElement","setBoundaryElement","PresentationNavigator","idRef","livePreviewEnabled","getCommentIntent","getIntent","liveDocument"],"mappings":"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","x_google_ignoreList":[0,1,2,3,29]}