{"version":3,"file":"LoaderQueries.js","sources":["../../../visual-editing-helpers/dist/hooks.js","../../src/loader/LoaderQueries.tsx"],"sourcesContent":["import{useMemo as e,useState as n,useCallback as t,useEffect as i,useSyncExternalStore as r}from\"react\";function o(n){const t=e((()=>JSON.stringify(n||{})),[n]);return e((()=>JSON.parse(t)),[t])}function s(e){const{refreshInterval:o}=e,s=function(){const[e,t]=n(!1);i((()=>{t(navigator.onLine);const e=()=>t(!0),n=()=>t(!1);return window.addEventListener(\"online\",e),window.addEventListener(\"offline\",n),()=>{window.removeEventListener(\"online\",e),window.removeEventListener(\"offline\",n)}}),[]);const o=r(d,(()=>document.visibilityState),(()=>\"hidden\"));return!e||\"hidden\"===o}(),[c,u]=n(\"hit\"),a=t((()=>(u(\"inflight\"),()=>u(\"hit\"))),[]);return i((()=>{if(!o||\"hit\"!==c)return;const e=setTimeout((()=>u(\"stale\")),o);return()=>clearTimeout(e)}),[o,c]),i((()=>{if(\"hit\"!==c)return;const e=()=>u(\"stale\");return window.addEventListener(\"focus\",e),()=>window.removeEventListener(\"focus\",e)}),[o,c]),i((()=>{s&&\"hit\"===c&&u(\"stale\"),!s&&\"stale\"===c&&u(\"refresh\")}),[s,c]),[c,a]}function d(e){return document.addEventListener(\"visibilitychange\",e),()=>document.removeEventListener(\"visibilitychange\",e)}export{o as useQueryParams,s as useRevalidate};//# sourceMappingURL=hooks.js.map\n","import type { ChannelsController } from '@sanity/channels'\nimport type {\n  ClientConfig,\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport { applySourceDocuments, getPublishedId } from '@sanity/client/csm'\nimport type { LoaderMsg, LoaderPayloads } from '@sanity/visual-editing-helpers'\nimport {\n  useQueryParams,\n  useRevalidate,\n} from '@sanity/visual-editing-helpers/hooks'\nimport { applyPatch } from 'mendoza'\nimport LRUCache from 'mnemonist/lru-cache-with-delete'\nimport { memo, useEffect, useMemo, useState } from 'react'\nimport { type SanityClient, type SanityDocument, useClient } from 'sanity'\n\nimport {\n  LIVE_QUERY_CACHE_BATCH_SIZE,\n  LIVE_QUERY_CACHE_SIZE,\n} from '../constants'\nimport type { LiveQueriesState } from '../types'\n\nexport interface LoaderQueriesProps {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  channel: ChannelsController<LoaderMsg> | undefined\n  perspective: ClientPerspective\n  liveQueries: LiveQueriesState\n  documentsOnPage: { _id: string; _type: string }[]\n}\n\nexport default function LoaderQueries(props: LoaderQueriesProps): JSX.Element {\n  const {\n    liveDocument,\n    channel,\n    perspective: activePerspective,\n    liveQueries,\n    documentsOnPage,\n  } = props\n  const [cache] = useState(\n    () => new LRUCache<string, SanityDocument>(LIVE_QUERY_CACHE_SIZE),\n  )\n  const studioClient = useClient({ apiVersion: '2023-10-16' })\n  const clientConfig = useMemo(() => studioClient.config(), [studioClient])\n  const client = useMemo(\n    () =>\n      studioClient.withConfig({\n        resultSourceMap: 'withKeyArraySelector',\n      }),\n    [studioClient],\n  )\n  useEffect(() => {\n    if (channel) {\n      const { projectId, dataset } = clientConfig\n      // @todo - Can this be migrated/deprecated in favour of emitting\n      // `presentation/perspective` at a higher level?\n      channel.send('loaders', 'loader/perspective', {\n        projectId: projectId!,\n        dataset: dataset!,\n        perspective: activePerspective,\n      } satisfies LoaderPayloads['perspective'])\n    }\n  }, [channel, clientConfig, activePerspective])\n\n  const turboIds = useMemo(() => {\n    const documentsActuallyInUse = documentsOnPage.map(({ _id }) => _id)\n    const set = new Set(documentsActuallyInUse)\n    const ids = [...set]\n    const max = cache.capacity\n    if (ids.length >= max) {\n      ids.length = max\n    }\n    return ids\n  }, [cache.capacity, documentsOnPage])\n\n  const [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0)\n\n  return (\n    <>\n      <Turbo\n        cache={cache}\n        client={client}\n        turboIds={turboIds}\n        setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n      />\n      {Object.entries(liveQueries).map(\n        ([key, { query, params, perspective }]) => (\n          <QuerySubscription\n            key={`${key}${perspective}`}\n            cache={cache}\n            projectId={clientConfig.projectId!}\n            dataset={clientConfig.dataset!}\n            perspective={perspective}\n            query={query}\n            params={params}\n            channel={channel}\n            client={client}\n            refreshInterval={activePerspective ? 2000 : 0}\n            liveDocument={liveDocument}\n            documentsCacheLastUpdated={documentsCacheLastUpdated}\n          />\n        ),\n      )}\n    </>\n  )\n}\n\ninterface SharedProps {\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * The documents cache to use for turbo-charging queries.\n   */\n  cache: LRUCache<string, SanityDocument>\n}\n\ninterface TurboProps extends Pick<SharedProps, 'client' | 'cache'> {\n  turboIds: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const { cache, client, turboIds, setDocumentsCacheLastUpdated } = props\n  // Figure out which documents are missing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (!batchSet.has(turboId) && !cache.has(turboId)) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE)\n    if (nextBatchSlice.length === 0) return\n    setBatch((prevBatch) => [\n      ...prevBatch.slice(-LIVE_QUERY_CACHE_BATCH_SIZE),\n      nextBatchSlice,\n    ])\n  }, [batch, cache, turboIds])\n\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        '*',\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'presentation-loader',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type === 'mutation' && update.transition === 'disappear') {\n          if (cache.delete(update.documentId)) {\n            setDocumentsCacheLastUpdated(Date.now())\n          }\n        }\n\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const cachedDocument = cache.peek(update.documentId)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = { ...cachedDocument } as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          cache.set(update.documentId, patchedDocument)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      })\n    return () => subscription.unsubscribe()\n  }, [cache, client, setDocumentsCacheLastUpdated])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          cache={cache}\n          client={client}\n          ids={ids}\n          setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n})\n\ninterface GetDocumentsProps extends Pick<SharedProps, 'client' | 'cache'> {\n  ids: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const { client, cache, ids, setDocumentsCacheLastUpdated } = props\n\n  useEffect(() => {\n    const missingIds = ids.filter((id) => !cache.has(id))\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          cache.set(doc._id, doc)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [cache, client, ids, setDocumentsCacheLastUpdated])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\ninterface QuerySubscriptionProps\n  extends Pick<\n    UseQuerySubscriptionProps,\n    | 'client'\n    | 'cache'\n    | 'refreshInterval'\n    | 'liveDocument'\n    | 'documentsCacheLastUpdated'\n  > {\n  projectId: string\n  dataset: string\n  perspective: ClientPerspective\n  query: string\n  params: QueryParams\n  channel: ChannelsController<LoaderMsg> | undefined\n}\nfunction QuerySubscription(props: QuerySubscriptionProps) {\n  const {\n    cache,\n    projectId,\n    dataset,\n    perspective,\n    query,\n    client,\n    refreshInterval,\n    liveDocument,\n    channel,\n    documentsCacheLastUpdated,\n  } = props\n\n  const params = useQueryParams(props.params)\n  const data = useQuerySubscription({\n    cache,\n    client,\n    liveDocument,\n    params,\n    perspective,\n    query,\n    refreshInterval,\n    documentsCacheLastUpdated,\n  })\n  const result = data?.result\n  const resultSourceMap = data?.resultSourceMap\n\n  useEffect(() => {\n    if (resultSourceMap) {\n      channel!.send('loaders', 'loader/query-change', {\n        projectId,\n        dataset,\n        perspective,\n        query,\n        params,\n        result,\n        resultSourceMap,\n      } satisfies LoaderPayloads['query-change'])\n    }\n  }, [\n    channel,\n    dataset,\n    params,\n    perspective,\n    projectId,\n    query,\n    result,\n    resultSourceMap,\n  ])\n\n  return null\n}\n\ninterface UseQuerySubscriptionProps\n  extends Required<Pick<SharedProps, 'client' | 'refreshInterval' | 'cache'>> {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  query: string\n  params: QueryParams\n  perspective: ClientPerspective\n  documentsCacheLastUpdated: number\n}\nfunction useQuerySubscription(props: UseQuerySubscriptionProps) {\n  const {\n    cache,\n    liveDocument,\n    client,\n    refreshInterval,\n    query,\n    params,\n    perspective,\n    documentsCacheLastUpdated,\n  } = props\n  const [snapshot, setSnapshot] = useState<{\n    result: unknown\n    resultSourceMap?: ContentSourceMap\n  } | null>(null)\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({ refreshInterval })\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    let fetching = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const { signal } = controller\n      fetching = true\n      const { result, resultSourceMap } = await client.fetch(query, params, {\n        tag: 'presentation-loader',\n        signal,\n        perspective,\n        filterResponse: false,\n      })\n      fetching = false\n\n      if (!signal.aborted) {\n        setSnapshot({ result, resultSourceMap })\n\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        fetching = false\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled && !fetching) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    liveDocument,\n    params,\n    perspective,\n    projectId,\n    query,\n    shouldRefetch,\n    startRefresh,\n  ])\n\n  return useMemo(() => {\n    if (documentsCacheLastUpdated && snapshot?.resultSourceMap) {\n      return {\n        result: turboChargeResultIfSourceMap(\n          cache,\n          liveDocument,\n          snapshot.result,\n          perspective,\n          snapshot.resultSourceMap,\n        ),\n        resultSourceMap: snapshot.resultSourceMap,\n      }\n    }\n    return snapshot\n  }, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot])\n}\n\nlet warnedAboutCrossDatasetReference = false\nexport function turboChargeResultIfSourceMap<T = unknown>(\n  cache: SharedProps['cache'],\n  liveDocument: Partial<SanityDocument> | null | undefined,\n  result: T,\n  perspective: ClientPerspective,\n  resultSourceMap?: ContentSourceMap,\n): T {\n  if (perspective === 'raw') {\n    throw new Error(\n      'turboChargeResultIfSourceMap does not support raw perspective',\n    )\n  }\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      // If there's a displayed document, always prefer it\n      if (\n        liveDocument?._id &&\n        getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)\n      ) {\n        return liveDocument\n      }\n      // Fallback to general documents cache\n      return cache.get(sourceDocument._id)\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, { previousValue }) => {\n      if (\n        typeof changedValue === 'number' &&\n        typeof previousValue === 'string'\n      ) {\n        // If the string() function was used in the query, we need to convert the source value to a string as well\n        return `${changedValue}`\n      }\n      return changedValue\n    },\n    perspective,\n  )\n}\n"],"names":["d","e","document","addEventListener","removeEventListener","LoaderQueries","props","liveDocument","channel","perspective","activePerspective","liveQueries","documentsOnPage","cache","useState","LRUCache","LIVE_QUERY_CACHE_SIZE","studioClient","useClient","apiVersion","clientConfig","useMemo","config","client","withConfig","resultSourceMap","useEffect","projectId","dataset","send","turboIds","documentsActuallyInUse","map","_id","ids","Set","max","capacity","length","documentsCacheLastUpdated","setDocumentsCacheLastUpdated","jsxs","Fragment","children","jsx","Turbo","Object","entries","key","query","params","QuerySubscription","refreshInterval","memo","batch","setBatch","batchSet","flat","nextBatch","turboId","has","add","nextBatchSlice","slice","LIVE_QUERY_CACHE_BATCH_SIZE","prevBatch","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","subscribe","update","_a","_b","type","transition","delete","documentId","Date","now","effects","apply","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","set","unsubscribe","GetDocuments","JSON","stringify","missingIds","filter","id","getDocuments","then","documents","doc","console","error","n","t","parse","useQueryParams","data","snapshot","setSnapshot","setError","revalidate","startRefresh","o","s","i","navigator","onLine","window","r","visibilityState","c","u","a","setTimeout","clearTimeout","s2","useRevalidate","shouldRefetch","fulfilled","fetching","controller","AbortController","async","effect","signal","result","fetch","filterResponse","aborted","onFinally","catch","name","finally","abort","turboChargeResultIfSourceMap","useQuerySubscription","displayName","warnedAboutCrossDatasetReference","Error","applySourceDocuments","sourceDocument","_projectId","getPublishedId","get","warn","changedValue","previousValue"],"mappings":"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"}