{"version":3,"file":"index.cjs","sources":["../src/utils/surrogatePairs.ts","../src/diff/clone.ts","../src/diff/commonOverlap.ts","../src/diff/commonPrefix.ts","../src/diff/commonSuffix.ts","../src/diff/cleanup.ts","../src/diff/bisect.ts","../src/diff/halfMatch.ts","../src/diff/charsToLines.ts","../src/diff/linesToChars.ts","../src/diff/lineMode.ts","../src/diff/compute.ts","../src/diff/diff.ts","../src/match/bitap.ts","../src/match/match.ts","../src/patch/createPatchObject.ts","../src/diff/diffText.ts","../src/utils/utf8Indices.ts","../src/patch/constants.ts","../src/patch/make.ts","../src/diff/levenshtein.ts","../src/diff/xIndex.ts","../src/patch/addPadding.ts","../src/patch/splitMax.ts","../src/patch/apply.ts","../src/patch/stringify.ts","../src/patch/parse.ts"],"sourcesContent":["/**\n * Checks if the character is a high surrogate\n *\n * @param char - Character to check\n * @returns True if high surrogate, false otherwise\n */\nexport function isHighSurrogate(char: string): boolean {\n  const charCode = char.charCodeAt(0)\n  return charCode >= 0xd800 && charCode <= 0xdbff\n}\n\n/**\n * Checks if the character is a low surrogate\n *\n * @param char - Character to check\n * @returns True if low surrogate, false otherwise\n */\nexport function isLowSurrogate(char: string): boolean {\n  const charCode = char.charCodeAt(0)\n  return charCode >= 0xdc00 && charCode <= 0xdfff\n}\n","import type {Diff} from './diff.js'\n\n/**\n * Clones a diff tuple.\n *\n * @param diff - Tuple to clone.\n * @returns New, cloned tuple.\n * @internal\n */\nexport function cloneDiff(diff: Diff): Diff {\n  const [type, patch] = diff\n  return [type, patch]\n}\n","/**\n * Determine if the suffix of one string is the prefix of another.\n *\n * @param textA - First string.\n * @param textB - Second string.\n * @returns Number of characters common to the end of the first string\n *   and the start of the second string.\n * @internal\n */\nexport function getCommonOverlap(textA: string, textB: string): number {\n  let text1 = textA\n  let text2 = textB\n\n  // Cache the text lengths to prevent multiple calls.\n  const text1Length = text1.length\n  const text2Length = text2.length\n\n  // Eliminate the null case.\n  if (text1Length === 0 || text2Length === 0) {\n    return 0\n  }\n\n  // Truncate the longer string.\n  if (text1Length > text2Length) {\n    text1 = text1.substring(text1Length - text2Length)\n  } else if (text1Length < text2Length) {\n    text2 = text2.substring(0, text1Length)\n  }\n  const textLength = Math.min(text1Length, text2Length)\n\n  // Quick check for the worst case.\n  if (text1 === text2) {\n    return textLength\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  let best = 0\n  let length = 1\n\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length)\n    found = text2.indexOf(pattern)\n    if (found === -1) {\n      return best\n    }\n    length += found\n    if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n      best = length\n      length++\n    }\n  }\n\n  // Only for typescript, never reached\n  return best\n}\n","/**\n * Determine the common prefix of two strings.\n *\n * @param text1 - First string.\n * @param text2 - Second string.\n * @returns The number of characters common to the start of each string.\n * @internal\n */\nexport function getCommonPrefix(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1[0] !== text2[0]) {\n    return 0\n  }\n\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  let pointerMin = 0\n  let pointerMax = Math.min(text1.length, text2.length)\n  let pointerMid = pointerMax\n  let pointerStart = 0\n  while (pointerMin < pointerMid) {\n    if (text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid)) {\n      pointerMin = pointerMid\n      pointerStart = pointerMin\n    } else {\n      pointerMax = pointerMid\n    }\n    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin)\n  }\n  return pointerMid\n}\n","/**\n * Determine the common suffix of two strings.\n *\n * @param text1 - First string.\n * @param text2 - Second string.\n * @returns The number of characters common to the end of each string.\n * @internal\n */\nexport function getCommonSuffix(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) {\n    return 0\n  }\n\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  let pointerMin = 0\n  let pointerMax = Math.min(text1.length, text2.length)\n  let pointerMid = pointerMax\n  let pointerEnd = 0\n  while (pointerMin < pointerMid) {\n    if (\n      text1.substring(text1.length - pointerMid, text1.length - pointerEnd) ===\n      text2.substring(text2.length - pointerMid, text2.length - pointerEnd)\n    ) {\n      pointerMin = pointerMid\n      pointerEnd = pointerMin\n    } else {\n      pointerMax = pointerMid\n    }\n    pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin)\n  }\n\n  return pointerMid\n}\n","import {cloneDiff} from './clone.js'\nimport {getCommonOverlap} from './commonOverlap.js'\nimport {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, type Diff} from './diff.js'\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupSemantic(rawDiffs: Diff[]): Diff[] {\n  let diffs: Diff[] = rawDiffs.map((diff) => cloneDiff(diff))\n\n  let hasChanges = false\n  const equalities: number[] = [] // Stack of indices where equalities are found.\n  let equalitiesLength = 0 // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  let lastEquality = null\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  let pointer = 0 // Index of current position.\n  // Number of characters that changed prior to the equality.\n  let lengthInsertions1 = 0\n  let lengthDeletions1 = 0\n  // Number of characters that changed after the equality.\n  let lengthInsertions2 = 0\n  let lengthDeletions2 = 0\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer\n      lengthInsertions1 = lengthInsertions2\n      lengthDeletions1 = lengthDeletions2\n      lengthInsertions2 = 0\n      lengthDeletions2 = 0\n      lastEquality = diffs[pointer][1]\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] === DIFF_INSERT) {\n        lengthInsertions2 += diffs[pointer][1].length\n      } else {\n        lengthDeletions2 += diffs[pointer][1].length\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (\n        lastEquality &&\n        lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) &&\n        lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality])\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT\n        // Throw away the equality we just deleted.\n        equalitiesLength--\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1\n        lengthInsertions1 = 0 // Reset the counters.\n        lengthDeletions1 = 0\n        lengthInsertions2 = 0\n        lengthDeletions2 = 0\n        lastEquality = null\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n\n  // Normalize the diff.\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n  diffs = cleanupSemanticLossless(diffs)\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abczzz</del><ins>zzzdef</ins>\n  //   -> <del>abc</del>zzz<ins>def</ins>\n  // e.g: <del>zzzabc</del><ins>defzzz</ins>\n  //   -> <ins>def</ins>zzz<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1]\n      const insertion = diffs[pointer][1]\n      const overlapLength1 = getCommonOverlap(deletion, insertion)\n      const overlapLength2 = getCommonOverlap(insertion, deletion)\n      if (overlapLength1 >= overlapLength2) {\n        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)])\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1)\n          diffs[pointer + 1][1] = insertion.substring(overlapLength1)\n          pointer++\n        }\n      } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n        // Reverse overlap found.\n        // Insert an equality and swap and trim the surrounding edits.\n        diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)])\n        diffs[pointer - 1][0] = DIFF_INSERT\n        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2)\n        diffs[pointer + 1][0] = DIFF_DELETE\n        diffs[pointer + 1][1] = deletion.substring(overlapLength2)\n        pointer++\n      }\n      pointer++\n    }\n    pointer++\n  }\n  return diffs\n}\n\n// Define some regex patterns for matching boundaries.\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/\nconst whitespaceRegex = /\\s/\nconst linebreakRegex = /[\\r\\n]/\nconst blanklineEndRegex = /\\n\\r?\\n$/\nconst blanklineStartRegex = /^\\r?\\n\\r?\\n/\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupSemanticLossless(rawDiffs: Diff[]): Diff[] {\n  const diffs = rawDiffs.map((diff) => cloneDiff(diff))\n\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   *\n   * @param one - First string.\n   * @param two - Second string.\n   * @returns The score.\n   * @internal\n   */\n  function diffCleanupSemanticScore(one: string, two: string) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    const char1 = one.charAt(one.length - 1)\n    const char2 = two.charAt(0)\n    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex)\n    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex)\n    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex)\n    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex)\n    const lineBreak1 = whitespace1 && char1.match(linebreakRegex)\n    const lineBreak2 = whitespace2 && char2.match(linebreakRegex)\n    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex)\n    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex)\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1\n    }\n    return 0\n  }\n\n  let pointer = 1\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      let equality1 = diffs[pointer - 1][1]\n      let edit = diffs[pointer][1]\n      let equality2 = diffs[pointer + 1][1]\n\n      // First, shift the edit as far left as possible.\n      const commonOffset = getCommonSuffix(equality1, edit)\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset)\n        equality1 = equality1.substring(0, equality1.length - commonOffset)\n        edit = commonString + edit.substring(0, edit.length - commonOffset)\n        equality2 = commonString + equality2\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      let bestEquality1 = equality1\n      let bestEdit = edit\n      let bestEquality2 = equality2\n      let bestScore =\n        diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2)\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0)\n        edit = edit.substring(1) + equality2.charAt(0)\n        equality2 = equality2.substring(1)\n        const score =\n          diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2)\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score\n          bestEquality1 = equality1\n          bestEdit = edit\n          bestEquality2 = equality2\n        }\n      }\n\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1\n        } else {\n          diffs.splice(pointer - 1, 1)\n          pointer--\n        }\n        diffs[pointer][1] = bestEdit\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2\n        } else {\n          diffs.splice(pointer + 1, 1)\n          pointer--\n        }\n      }\n    }\n    pointer++\n  }\n\n  return diffs\n}\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n *\n * @param rawDiffs - Array of diff tuples.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupMerge(rawDiffs: Diff[]): Diff[] {\n  let diffs = rawDiffs.map((diff) => cloneDiff(diff))\n\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, ''])\n  let pointer = 0\n  let countDelete = 0\n  let countInsert = 0\n  let textDelete = ''\n  let textInsert = ''\n  let commonlength\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++\n        textInsert += diffs[pointer][1]\n        pointer++\n        break\n      case DIFF_DELETE:\n        countDelete++\n        textDelete += diffs[pointer][1]\n        pointer++\n        break\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (countDelete + countInsert > 1) {\n          if (countDelete !== 0 && countInsert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = getCommonPrefix(textInsert, textDelete)\n            if (commonlength !== 0) {\n              if (\n                pointer - countDelete - countInsert > 0 &&\n                diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL\n              ) {\n                diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n                  0,\n                  commonlength\n                )\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)])\n                pointer++\n              }\n              textInsert = textInsert.substring(commonlength)\n              textDelete = textDelete.substring(commonlength)\n            }\n            // Factor out any common suffixies.\n            commonlength = getCommonSuffix(textInsert, textDelete)\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1]\n              textInsert = textInsert.substring(0, textInsert.length - commonlength)\n              textDelete = textDelete.substring(0, textDelete.length - commonlength)\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= countDelete + countInsert\n          diffs.splice(pointer, countDelete + countInsert)\n          if (textDelete.length) {\n            diffs.splice(pointer, 0, [DIFF_DELETE, textDelete])\n            pointer++\n          }\n          if (textInsert.length) {\n            diffs.splice(pointer, 0, [DIFF_INSERT, textInsert])\n            pointer++\n          }\n          pointer++\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1]\n          diffs.splice(pointer, 1)\n        } else {\n          pointer++\n        }\n        countInsert = 0\n        countDelete = 0\n        textDelete = ''\n        textInsert = ''\n        break\n      default:\n        throw new Error('Unknown diff operation')\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop() // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  let hasChanges = false\n  pointer = 1\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) ===\n        diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length)\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1]\n        diffs.splice(pointer - 1, 1)\n        hasChanges = true\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1]\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1]\n        diffs.splice(pointer + 1, 1)\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n\n  return diffs\n}\n\nfunction trueCount(...args: boolean[]) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0)\n}\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n *\n * @param rawDiffs - Array of diff tuples.\n * @param editCost - Cost of an empty edit operation in terms of edit characters.\n * @returns Array of diff tuples.\n * @public\n */\nexport function cleanupEfficiency(rawDiffs: Diff[], editCost: number = 4): Diff[] {\n  let diffs = rawDiffs.map((diff) => cloneDiff(diff))\n  let hasChanges = false\n  const equalities: number[] = [] // Stack of indices where equalities are found.\n  let equalitiesLength = 0 // Keeping our own length var is faster in JS.\n  let lastEquality: string | null = null\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  let pointer = 0 // Index of current position.\n  // Is there an insertion operation before the last equality.\n  let preIns = false\n  // Is there a deletion operation before the last equality.\n  let preDel = false\n  // Is there an insertion operation after the last equality.\n  let postIns = false\n  // Is there a deletion operation after the last equality.\n  let postDel = false\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      // Equality found.\n      if (diffs[pointer][1].length < editCost && (postIns || postDel)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer\n        preIns = postIns\n        preDel = postDel\n        lastEquality = diffs[pointer][1]\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0\n        lastEquality = null\n      }\n      postIns = false\n      postDel = false\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] === DIFF_DELETE) {\n        postDel = true\n      } else {\n        postIns = true\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (\n        lastEquality &&\n        ((preIns && preDel && postIns && postDel) ||\n          (lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3))\n      ) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality])\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT\n        equalitiesLength-- // Throw away the equality we just deleted;\n        lastEquality = null\n        if (preIns && preDel) {\n          // No hasChanges made which could affect previous entry, keep going.\n          postIns = true\n          postDel = true\n          equalitiesLength = 0\n        } else {\n          equalitiesLength-- // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1\n          postIns = false\n          postDel = false\n        }\n        hasChanges = true\n      }\n    }\n    pointer++\n  }\n\n  if (hasChanges) {\n    diffs = cleanupMerge(diffs)\n  }\n\n  return diffs\n}\n","import {doDiff, DIFF_DELETE, DIFF_INSERT, type Diff} from './diff.js'\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function bisect(text1: string, text2: string, deadline: number): Diff[] {\n  // Cache the text lengths to prevent multiple calls.\n  const text1Length = text1.length\n  const text2Length = text2.length\n  const maxD = Math.ceil((text1Length + text2Length) / 2)\n  const vOffset = maxD\n  const vLength = 2 * maxD\n  const v1 = new Array(vLength)\n  const v2 = new Array(vLength)\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (let x = 0; x < vLength; x++) {\n    v1[x] = -1\n    v2[x] = -1\n  }\n  v1[vOffset + 1] = 0\n  v2[vOffset + 1] = 0\n  const delta = text1Length - text2Length\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  const front = delta % 2 !== 0\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  let k1start = 0\n  let k1end = 0\n  let k2start = 0\n  let k2end = 0\n  for (let d = 0; d < maxD; d++) {\n    // Bail out if deadline is reached.\n    if (Date.now() > deadline) {\n      break\n    }\n    // Walk the front path one step.\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1\n      let x1\n      if (k1 === -d || (k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1])) {\n        x1 = v1[k1Offset + 1]\n      } else {\n        x1 = v1[k1Offset - 1] + 1\n      }\n      let y1 = x1 - k1\n      while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n        x1++\n        y1++\n      }\n      v1[k1Offset] = x1\n      if (x1 > text1Length) {\n        // Ran off the right of the graph.\n        k1end += 2\n      } else if (y1 > text2Length) {\n        // Ran off the bottom of the graph.\n        k1start += 2\n      } else if (front) {\n        const k2Offset = vOffset + delta - k1\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          const x2 = text1Length - v2[k2Offset]\n          if (x1 >= x2) {\n            // Overlap detected.\n            return bisectSplit(text1, text2, x1, y1, deadline)\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2\n      let x2\n      if (k2 === -d || (k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1])) {\n        x2 = v2[k2Offset + 1]\n      } else {\n        x2 = v2[k2Offset - 1] + 1\n      }\n      let y2 = x2 - k2\n      while (\n        x2 < text1Length &&\n        y2 < text2Length &&\n        text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)\n      ) {\n        x2++\n        y2++\n      }\n      v2[k2Offset] = x2\n      if (x2 > text1Length) {\n        // Ran off the left of the graph.\n        k2end += 2\n      } else if (y2 > text2Length) {\n        // Ran off the top of the graph.\n        k2start += 2\n      } else if (!front) {\n        const k1Offset = vOffset + delta - k2\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset]\n          const y1 = vOffset + x1 - k1Offset\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1Length - x2\n          if (x1 >= x2) {\n            // Overlap detected.\n            return bisectSplit(text1, text2, x1, y1, deadline)\n          }\n        }\n      }\n    }\n  }\n  // Number of diffs equals number of characters, no commonality at all.\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2],\n  ]\n}\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @param x - Index of split point in text1.\n * @param y - Index of split point in text2.\n * @param deadline - Time at which to bail if not yet complete.\n * @returns Array of diff tuples.\n * @internal\n */\nfunction bisectSplit(text1: string, text2: string, x: number, y: number, deadline: number): Diff[] {\n  const text1a = text1.substring(0, x)\n  const text2a = text2.substring(0, y)\n  const text1b = text1.substring(x)\n  const text2b = text2.substring(y)\n\n  // Compute both diffs serially.\n  const diffs = doDiff(text1a, text2a, {checkLines: false, deadline})\n  const diffsb = doDiff(text1b, text2b, {checkLines: false, deadline})\n\n  return diffs.concat(diffsb)\n}\n","import {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\n\ntype HalfMatch = [string, string, string, string, string]\n\n/**\n * Does a slice of shorttext exist within longtext such that the slice\n * is at least half the length of longtext?\n *\n * @param longtext - Longer string.\n * @param shorttext - Shorter string.\n * @param i - Start index of quarter length slice within longtext.\n * @returns Five element Array, containing the prefix of\n *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n *     of shorttext and the common middle.  Or null if there was no match.\n * @internal\n */\nexport function findHalfMatch(text1: string, text2: string, timeout = 1): null | HalfMatch {\n  if (timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null\n  }\n\n  const longText = text1.length > text2.length ? text1 : text2\n  const shortText = text1.length > text2.length ? text2 : text1\n  if (longText.length < 4 || shortText.length * 2 < longText.length) {\n    return null // Pointless.\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4))\n  // Check again based on the third quarter.\n  const halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2))\n\n  let halfMatch\n  if (halfMatch1 && halfMatch2) {\n    // Both matched.  Select the longest.\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2\n  } else if (!halfMatch1 && !halfMatch2) {\n    return null\n  } else if (!halfMatch2) {\n    halfMatch = halfMatch1\n  } else if (!halfMatch1) {\n    halfMatch = halfMatch2\n  }\n\n  if (!halfMatch) {\n    throw new Error('Unable to find a half match.')\n  }\n\n  // A half-match was found, sort out the return data.\n  let text1A: string\n  let text1B: string\n  let text2A: string\n  let text2B: string\n\n  if (text1.length > text2.length) {\n    text1A = halfMatch[0]\n    text1B = halfMatch[1]\n    text2A = halfMatch[2]\n    text2B = halfMatch[3]\n  } else {\n    text2A = halfMatch[0]\n    text2B = halfMatch[1]\n    text1A = halfMatch[2]\n    text1B = halfMatch[3]\n  }\n  const midCommon = halfMatch[4]\n  return [text1A, text1B, text2A, text2B, midCommon]\n}\n\n/**\n * Do the two texts share a slice which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n *\n * @param longText - First string.\n * @param shortText - Second string.\n * @returns Five element array, containing the prefix of longText,\n *     the suffix of longText, the prefix of shortText, the suffix of\n *     shortText and the common middle.  Or null if there was no match.\n * @internal\n */\nfunction halfMatchI(longText: string, shortText: string, i: number): null | HalfMatch {\n  // Start with a 1/4 length slice at position i as a seed.\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4))\n  let j = -1\n  let bestCommon = ''\n  let bestLongTextA\n  let bestLongTextB\n  let bestShortTextA\n  let bestShortTextB\n\n  while ((j = shortText.indexOf(seed, j + 1)) !== -1) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j))\n    const suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j))\n    if (bestCommon.length < suffixLength + prefixLength) {\n      bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength)\n      bestLongTextA = longText.slice(0, i - suffixLength)\n      bestLongTextB = longText.slice(i + prefixLength)\n      bestShortTextA = shortText.slice(0, j - suffixLength)\n      bestShortTextB = shortText.slice(j + prefixLength)\n    }\n  }\n  if (bestCommon.length * 2 >= longText.length) {\n    return [\n      bestLongTextA || '',\n      bestLongTextB || '',\n      bestShortTextA || '',\n      bestShortTextB || '',\n      bestCommon || '',\n    ]\n  }\n\n  return null\n}\n","import type {Diff} from './diff.js'\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of text.\n *\n * @param diffs - Array of diff tuples.\n * @param lineArray - Array of unique strings.\n * @internal\n */\nexport function charsToLines(diffs: Diff[], lineArray: string[]): void {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1]\n    const text: string[] = []\n    for (let y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)]\n    }\n    diffs[x][1] = text.join('')\n  }\n}\n","/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n *\n * @param textA - First string.\n * @param textB - Second string.\n * @returns An object containing the encoded textA, the encoded textB and\n *   the array of unique strings. The zeroth element of the array of unique\n *   strings is intentionally blank.\n * @internal\n */\nexport function linesToChars(\n  textA: string,\n  textB: string\n): {\n  chars1: string\n  chars2: string\n  lineArray: string[]\n} {\n  const lineArray: string[] = [] // e.g. lineArray[4] === 'Hello\\n'\n  const lineHash: {[key: string]: number} = {} // e.g. lineHash['Hello\\n'] === 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = ''\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   *\n   * @param text - String to encode.\n   * @returns Encoded string.\n   * @internal\n   */\n  function diffLinesToMunge(text: string) {\n    let chars = ''\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    let lineStart = 0\n    let lineEnd = -1\n    // Keeping our own length variable is faster than looking it up.\n    let lineArrayLength = lineArray.length\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart)\n      if (lineEnd === -1) {\n        lineEnd = text.length - 1\n      }\n      let line = text.slice(lineStart, lineEnd + 1)\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n        chars += String.fromCharCode(lineHash[line])\n      } else {\n        if (lineArrayLength === maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.slice(lineStart)\n          lineEnd = text.length\n        }\n        chars += String.fromCharCode(lineArrayLength)\n        lineHash[line] = lineArrayLength\n        lineArray[lineArrayLength++] = line\n      }\n      lineStart = lineEnd + 1\n    }\n    return chars\n  }\n  // Allocate 2/3rds of the space for textA, the rest for textB.\n  let maxLines = 40000\n  const chars1 = diffLinesToMunge(textA)\n  maxLines = 65535\n  const chars2 = diffLinesToMunge(textB)\n  return {chars1, chars2, lineArray}\n}\n","import {charsToLines} from './charsToLines.js'\nimport {cleanupSemantic} from './cleanup.js'\nimport {linesToChars} from './linesToChars.js'\nimport {\n  doDiff,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  type Diff,\n  type InternalDiffOptions,\n} from './diff.js'\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n *\n * @param textA - Old string to be diffed.\n * @param textB - New string to be diffed.\n * @param options - Options for the differ.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function doLineModeDiff(textA: string, textB: string, opts: InternalDiffOptions): Diff[] {\n  // Don't reassign fn params\n  let text1 = textA\n  let text2 = textB\n\n  // Scan the text on a line-by-line basis first.\n  const a = linesToChars(text1, text2)\n  text1 = a.chars1\n  text2 = a.chars2\n  const linearray = a.lineArray\n\n  let diffs = doDiff(text1, text2, {\n    checkLines: false,\n    deadline: opts.deadline,\n  })\n\n  // Convert the diff back to original text.\n  charsToLines(diffs, linearray)\n  // Eliminate freak matches (e.g. blank lines)\n  diffs = cleanupSemantic(diffs)\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, ''])\n  let pointer = 0\n  let countDelete = 0\n  let countInsert = 0\n  let textDelete = ''\n  let textInsert = ''\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++\n        textInsert += diffs[pointer][1]\n        break\n      case DIFF_DELETE:\n        countDelete++\n        textDelete += diffs[pointer][1]\n        break\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (countDelete >= 1 && countInsert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert)\n          pointer = pointer - countDelete - countInsert\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: false,\n            deadline: opts.deadline,\n          })\n          for (let j = aa.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, aa[j])\n          }\n          pointer += aa.length\n        }\n        countInsert = 0\n        countDelete = 0\n        textDelete = ''\n        textInsert = ''\n        break\n      default:\n        throw new Error('Unknown diff operation.')\n    }\n    pointer++\n  }\n  diffs.pop() // Remove the dummy entry at the end.\n\n  return diffs\n}\n","import {\n  doDiff,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  type Diff,\n  type InternalDiffOptions,\n} from './diff.js'\nimport {bisect} from './bisect.js'\nimport {findHalfMatch} from './halfMatch.js'\nimport {doLineModeDiff} from './lineMode.js'\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n *\n * @param text1 - Old string to be diffed.\n * @param text2 - New string to be diffed.\n * @param checklines - Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param deadline - Time when the diff should be complete by.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function computeDiff(text1: string, text2: string, opts: InternalDiffOptions): Diff[] {\n  let diffs: Diff[]\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]]\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]]\n  }\n\n  const longtext = text1.length > text2.length ? text1 : text2\n  const shorttext = text1.length > text2.length ? text2 : text1\n  const i = longtext.indexOf(shorttext)\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)],\n    ]\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = DIFF_DELETE\n      diffs[2][0] = DIFF_DELETE\n    }\n    return diffs\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2],\n    ]\n  }\n\n  // Check to see if the problem can be split in two.\n  const halfMatch = findHalfMatch(text1, text2)\n  if (halfMatch) {\n    // A half-match was found, sort out the return data.\n    const text1A = halfMatch[0]\n    const text1B = halfMatch[1]\n    const text2A = halfMatch[2]\n    const text2B = halfMatch[3]\n    const midCommon = halfMatch[4]\n    // Send both pairs off for separate processing.\n    const diffsA = doDiff(text1A, text2A, opts)\n    const diffsB = doDiff(text1B, text2B, opts)\n    // Merge the results.\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB)\n  }\n\n  if (opts.checkLines && text1.length > 100 && text2.length > 100) {\n    return doLineModeDiff(text1, text2, opts)\n  }\n\n  return bisect(text1, text2, opts.deadline)\n}\n","import {isHighSurrogate, isLowSurrogate} from '../utils/surrogatePairs.js'\nimport {cleanupMerge} from './cleanup.js'\nimport {getCommonPrefix} from './commonPrefix.js'\nimport {getCommonSuffix} from './commonSuffix.js'\nimport {computeDiff} from './compute.js'\n\n/**\n * Diff type for deleted text.\n *\n * @public\n */\nexport const DIFF_DELETE = -1\n\n/**\n * Diff type for inserted text.\n *\n * @public\n */\nexport const DIFF_INSERT = 1\n\n/**\n * Diff type for text that is equal.\n *\n * @public\n */\nexport const DIFF_EQUAL = 0\n\n/**\n * The three different types of changes possible in a diff:\n * - `DIFF_DELETE`: a deletion of text\n * - `DIFF_INSERT`: an insertion of text\n * - `DIFF_EQUAL` : an equal text\n *\n * @public\n */\nexport type DiffType = typeof DIFF_DELETE | typeof DIFF_INSERT | typeof DIFF_EQUAL\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n *\n * @public\n */\nexport type Diff = [DiffType, string]\n\n/**\n * Options for generating a diff.\n *\n * @public\n */\nexport interface DiffOptions {\n  checkLines: boolean\n  timeout: number\n}\n\n/**\n * @internal\n */\nexport interface InternalDiffOptions {\n  checkLines: boolean\n\n  /**\n   * Time when the diff should be complete by.\n   */\n  deadline: number\n}\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n *\n * @param textA - Old string to be diffed.\n * @param textA - New string to be diffed.\n * @returns Array of diff tuples.\n * @public\n */\nexport function diff(\n  textA: null | string,\n  textB: null | string,\n  opts?: Partial<DiffOptions>\n): Diff[] {\n  // Check for null inputs.\n  if (textA === null || textB === null) {\n    throw new Error('Null input. (diff)')\n  }\n\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}))\n  adjustDiffForSurrogatePairs(diffs)\n  return diffs\n}\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n *\n * @param textA - Old string to be diffed.\n * @param textB - New string to be diffed.\n * @returns Array of diff tuples.\n * @internal\n */\nexport function doDiff(textA: string, textB: string, options: InternalDiffOptions): Diff[] {\n  // Don't reassign fn params\n  let text1 = textA\n  let text2 = textB\n\n  // Check for equality (speedup).\n  if (text1 === text2) {\n    return text1 ? [[DIFF_EQUAL, text1]] : []\n  }\n\n  // Trim off common prefix (speedup).\n  let commonlength = getCommonPrefix(text1, text2)\n  const commonprefix = text1.substring(0, commonlength)\n  text1 = text1.substring(commonlength)\n  text2 = text2.substring(commonlength)\n\n  // Trim off common suffix (speedup).\n  commonlength = getCommonSuffix(text1, text2)\n  const commonsuffix = text1.substring(text1.length - commonlength)\n  text1 = text1.substring(0, text1.length - commonlength)\n  text2 = text2.substring(0, text2.length - commonlength)\n\n  // Compute the diff on the middle block.\n  let diffs = computeDiff(text1, text2, options)\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix])\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix])\n  }\n  diffs = cleanupMerge(diffs)\n  return diffs\n}\n\nfunction createDeadLine(timeout: undefined | number): number {\n  let t = 1\n  if (typeof timeout !== 'undefined') {\n    t = timeout <= 0 ? Number.MAX_VALUE : timeout\n  }\n  return Date.now() + t * 1000\n}\n\nfunction createInternalOpts(opts: Partial<DiffOptions>): InternalDiffOptions {\n  return {\n    checkLines: true,\n    deadline: createDeadLine(opts.timeout || 1.0),\n    ...opts,\n  }\n}\n\nfunction combineChar(data: string, char: string, dir: 1 | -1) {\n  return dir === 1 ? data + char : char + data\n}\n\n/**\n * Splits out a character in a given direction.\n */\nfunction splitChar(data: string, dir: 1 | -1): [string, string] {\n  return dir === 1\n    ? [data.substring(0, data.length - 1), data[data.length - 1]]\n    : [data.substring(1), data[0]]\n}\n\n/**\n * Checks if two entries of the diff has the same character in the same \"direction\".\n */\nfunction hasSharedChar(diffs: Diff[], i: number, j: number, dir: 1 | -1): boolean {\n  return dir === 1\n    ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1]\n    : diffs[i][1][0] === diffs[j][1][0]\n}\n\n/**\n * Takes in a position of an EQUAL diff-type and attempts to \"deisolate\" the character for a given direction.\n * By this we mean that we attempt to either \"shift\" it to the later diffs, or bring another character next into this one.\n *\n * It's easier to understand with an example:\n *   [INSERT a, DELETE b, EQUAL cde, INSERT f, DELETE g]\n * shifting this forward will produce\n *   [INSERT a, DELETE b, EQUAL cd, INSERT ef, DELETE eg]\n *\n * This behavior is useful when `e` is actually a high surrogate character.\n *\n * Shifting it backwards produces\n *   [INSERT ac, DELETE bc, EQUAL cde, INSERT f, DELETE g]\n * which is useful when `c` is a low surrogate character.\n *\n * Note that these diffs are 100% semantically equal.\n *\n * If there's not a matching INSERT/DELETE then it's forced to insert an additional entry:\n *   [EQUAL abc, INSERT d, EQUAL e]\n * shifted forward becomes:\n *   [EQUAL ab, INSERT cd, DELETE c, EQUAL e]\n *\n * If the INSERT and DELETE ends with the same character it will instead deisolate it by\n * bring that charcter into _this_ equal:\n *   [EQUAL abc, INSERT de, DELETE df]\n * shifted forward actually becomes\n *   [EQUAL abcd, INSERT e, DELETE f]\n *\n * The original diff here is typically never produced by the diff algorithm directly,\n * but they occur when we isolate characters in other places.\n */\nfunction deisolateChar(diffs: Diff[], i: number, dir: 1 | -1) {\n  const inv = dir === 1 ? -1 : 1\n  let insertIdx: null | number = null\n  let deleteIdx: null | number = null\n\n  let j = i + dir\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text] = diffs[j]\n    if (text.length === 0) {\n      continue\n    }\n\n    if (op === DIFF_INSERT) {\n      if (insertIdx === null) {\n        insertIdx = j\n      }\n      continue\n    } else if (op === DIFF_DELETE) {\n      if (deleteIdx === null) {\n        deleteIdx = j\n      }\n      continue\n    } else if (op === DIFF_EQUAL) {\n      if (insertIdx === null && deleteIdx === null) {\n        // This means that there was two consecutive EQUAL. Kinda weird, but easy to handle.\n        const [rest, char] = splitChar(diffs[i][1], dir)\n        diffs[i][1] = rest\n        diffs[j][1] = combineChar(diffs[j][1], char, inv)\n        return\n      }\n      break\n    }\n  }\n\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    // Special case.\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv)\n    const [deleteText] = splitChar(diffs[deleteIdx][1], inv)\n    diffs[insertIdx][1] = insertText\n    diffs[deleteIdx][1] = deleteText\n    diffs[i][1] = combineChar(diffs[i][1], insertChar, dir)\n    return\n  }\n\n  const [text, char] = splitChar(diffs[i][1], dir)\n  diffs[i][1] = text\n\n  if (insertIdx === null) {\n    diffs.splice(j, 0, [DIFF_INSERT, char])\n\n    // We need to adjust deleteIdx here since it's been shifted\n    if (deleteIdx !== null && deleteIdx >= j) deleteIdx++\n  } else {\n    diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv)\n  }\n\n  if (deleteIdx === null) {\n    diffs.splice(j, 0, [DIFF_DELETE, char])\n  } else {\n    diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv)\n  }\n}\n\nfunction adjustDiffForSurrogatePairs(diffs: Diff[]) {\n  // Go over each pair of diffs and see if there was a split at a surrogate pair\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i]\n\n    if (diffText.length === 0) continue\n\n    const firstChar = diffText[0]\n    const lastChar = diffText[diffText.length - 1]\n\n    if (isHighSurrogate(lastChar) && diffType === DIFF_EQUAL) {\n      deisolateChar(diffs, i, 1)\n    }\n\n    if (isLowSurrogate(firstChar) && diffType === DIFF_EQUAL) {\n      deisolateChar(diffs, i, -1)\n    }\n  }\n\n  for (let i = 0; i < diffs.length; i++) {\n    // Remove any empty diffs\n    if (diffs[i][1].length === 0) {\n      diffs.splice(i, 1)\n    }\n  }\n}\n","/* eslint-disable no-bitwise */\ninterface BitapOptions {\n  threshold: number\n  distance: number\n}\n\ninterface Alphabet {\n  [char: string]: number\n}\n\nconst DEFAULT_OPTIONS: BitapOptions = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1000,\n}\n\nfunction applyDefaults(options: Partial<BitapOptions>): BitapOptions {\n  return {...DEFAULT_OPTIONS, ...options}\n}\n\n// The number of bits in an int.\nconst MAX_BITS = 32\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n *\n * @param text - The text to search.\n * @param pattern - The pattern to search for.\n * @param loc - The location to search around.\n * @returns Best match index or -1.\n * @internal\n */\nexport function bitap(\n  text: string,\n  pattern: string,\n  loc: number,\n  opts: Partial<BitapOptions> = {}\n): number {\n  if (pattern.length > MAX_BITS) {\n    throw new Error('Pattern too long for this browser.')\n  }\n\n  const options = applyDefaults(opts)\n\n  // Initialise the alphabet.\n  const s = getAlphabetFromPattern(pattern)\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   *\n   * @param e - Number of errors in match.\n   * @param x - Location of match.\n   * @returns Overall - score for match (0.0 = good, 1.0 = bad).\n   * @internal\n   */\n  function getBitapScore(e: number, x: number) {\n    const accuracy = e / pattern.length\n    const proximity = Math.abs(loc - x)\n    if (!options.distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy\n    }\n    return accuracy + proximity / options.distance\n  }\n\n  // Highest score beyond which we give up.\n  let scoreThreshold = options.threshold\n  // Is there a nearby exact match? (speedup)\n  let bestLoc = text.indexOf(pattern, loc)\n  if (bestLoc !== -1) {\n    scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)\n    // What about in the other direction? (speedup)\n    bestLoc = text.lastIndexOf(pattern, loc + pattern.length)\n    if (bestLoc !== -1) {\n      scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)\n    }\n  }\n\n  // Initialise the bit arrays.\n  const matchmask = 1 << (pattern.length - 1)\n  bestLoc = -1\n\n  let binMin\n  let binMid\n  let binMax = pattern.length + text.length\n  let lastRd: number[] = []\n  for (let d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    binMin = 0\n    binMid = binMax\n    while (binMin < binMid) {\n      if (getBitapScore(d, loc + binMid) <= scoreThreshold) {\n        binMin = binMid\n      } else {\n        binMax = binMid\n      }\n      binMid = Math.floor((binMax - binMin) / 2 + binMin)\n    }\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid\n    let start = Math.max(1, loc - binMid + 1)\n    const finish = Math.min(loc + binMid, text.length) + pattern.length\n\n    const rd: number[] = new Array(finish + 2)\n    rd[finish + 1] = (1 << d) - 1\n    for (let j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      const charMatch = s[text.charAt(j - 1)]\n      if (d === 0) {\n        // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch\n      } else {\n        // Subsequent passes: fuzzy match.\n        rd[j] =\n          (((rd[j + 1] << 1) | 1) & charMatch) |\n          (((lastRd[j + 1] | lastRd[j]) << 1) | 1) |\n          lastRd[j + 1]\n      }\n      if (rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1)\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= scoreThreshold) {\n          // Told you so.\n          scoreThreshold = score\n          bestLoc = j - 1\n          if (bestLoc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - bestLoc)\n          } else {\n            // Already passed loc, downhill from here on in.\n            break\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (getBitapScore(d + 1, loc) > scoreThreshold) {\n      break\n    }\n    lastRd = rd\n  }\n  return bestLoc\n}\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n *\n * @param pattern - The text to encode.\n * @returns Hash of character locations.\n * @internal\n */\nfunction getAlphabetFromPattern(pattern: string): Alphabet {\n  const s: Alphabet = {}\n  for (let i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0\n  }\n  for (let i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1)\n  }\n  return s\n}\n","import {bitap} from './bitap.js'\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n *\n * @param text - The text to search.\n * @param pattern - The pattern to search for.\n * @param searchLocation - The location to search around.\n * @returns Best match index or -1.\n * @public\n */\nexport function match(text: string, pattern: string, searchLocation: number): number {\n  // Check for null inputs.\n  if (text === null || pattern === null || searchLocation === null) {\n    throw new Error('Null input. (match())')\n  }\n\n  const loc = Math.max(0, Math.min(searchLocation, text.length))\n  if (text === pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1\n  } else if (text.substring(loc, loc + pattern.length) === pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc\n  }\n\n  // Do a fuzzy compare.\n  return bitap(text, pattern, loc)\n}\n","import type {Diff} from '../diff/diff.js'\n\n/**\n * Object representing one patch operation.\n *\n * @public\n */\nexport interface Patch {\n  diffs: Diff[]\n\n  start1: number\n  start2: number\n  utf8Start1: number\n  utf8Start2: number\n\n  length1: number\n  length2: number\n  utf8Length1: number\n  utf8Length2: number\n}\n\n/**\n * Clones a patch object.\n *\n * @param patch - The patch to clone\n * @returns Cloned object\n * @private\n */\nexport function clone(patch: Patch): Patch {\n  return {...patch, diffs: patch.diffs.map((diff) => ({...diff}))}\n}\n\n/**\n * Performs a deep copy of a patch array.\n *\n * @param patches - Patches to clone\n * @returns Cloned array\n * @internal\n */\nexport function deepCopy(patches: Patch[]): Patch[] {\n  return patches.map(clone)\n}\n\n/**\n * Create a new, empty, patch object.\n *\n * @param start1 - The index to start the \"from\" at\n * @param start2 - The index to start the \"to\" at\n * @returns New patch object\n * @internal\n */\nexport function createPatchObject(start1: number, start2: number): Patch {\n  return {\n    diffs: [],\n\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0,\n  }\n}\n","import {DIFF_DELETE, DIFF_INSERT, type Diff} from './diff.js'\n\n/**\n * Compute and return the source text (all equalities and deletions).\n *\n * @param diffs - Array of diff tuples.\n * @returns Source text.\n * @private\n */\nexport function diffText1(diffs: Diff[]): string {\n  const text: string[] = []\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1]\n    }\n  }\n  return text.join('')\n}\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n *\n * @param diffs - Array of diff tuples.\n * @returns Destination text.\n * @private\n */\nexport function diffText2(diffs: Diff[]): string {\n  const text: string[] = []\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1]\n    }\n  }\n  return text.join('')\n}\n","import {cloneDiff} from '../diff/clone.js'\nimport type {Patch} from '../index.js'\n\n/**\n * Counts the number of bytes in a string.\n * Note that while this approach may seem heavy-handed, it is actually\n * significantly faster than both `new Blob([str]).size` and `TextEncoder`.\n *\n * @param str - String to count\n * @returns Number of bytes\n */\nexport function countUtf8Bytes(str: string): number {\n  let bytes = 0\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i)\n    if (typeof codePoint === 'undefined') {\n      throw new Error('Failed to get codepoint')\n    }\n    bytes += utf8len(codePoint)\n  }\n  return bytes\n}\n\n/**\n * Options for the index adjustment operations.\n *\n * @public\n */\nexport interface AdjustmentOptions {\n  /**\n   * When converting indices between UTF-8 and UCS-2, certain scenarios can occur\n   * where we go beyond the target offset. This can happen in particular with\n   * surrogate pairs/high codepoints, when the base string we are applying the\n   * patch to does not fully match the one that was used to generate the patch.\n   * Defaults to `false`.\n   */\n  allowExceedingIndices?: boolean\n}\n\n/**\n * Takes a `patches` array as produced by diff-match-patch and adjusts the\n * `start1` and `start2` properties so that they refer to UCS-2 index instead\n * of a UTF-8 index.\n *\n * @param patches - The patches to adjust\n * @param base - The base string to use for counting bytes\n * @param options - Options for the adjustment of indices\n * @returns A new array of patches with adjusted indicies\n * @beta\n */\nexport function adjustIndiciesToUcs2(\n  patches: Patch[],\n  base: string,\n  options: AdjustmentOptions = {}\n): Patch[] {\n  let byteOffset = 0\n  let idx = 0 // index into the input.\n\n  function advanceTo(target: number) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx)\n      if (typeof codePoint === 'undefined') {\n        // Reached the end of the base string - the indicies won't be correct,\n        // but we also cannot advance any further to find a closer index.\n        return idx\n      }\n\n      byteOffset += utf8len(codePoint)\n\n      // This is encoded as a surrogate pair.\n      if (codePoint > 0xffff) {\n        idx += 2\n      } else {\n        idx += 1\n      }\n    }\n\n    if (!options.allowExceedingIndices && byteOffset !== target) {\n      throw new Error('Failed to determine byte offset')\n    }\n\n    return idx\n  }\n\n  const adjusted: Patch[] = []\n  for (const patch of patches) {\n    adjusted.push({\n      diffs: patch.diffs.map((diff) => cloneDiff(diff)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2,\n    })\n  }\n\n  return adjusted\n}\n\nfunction utf8len(codePoint: number): 1 | 2 | 3 | 4 {\n  // See table at https://en.wikipedia.org/wiki/UTF-8\n  if (codePoint <= 0x007f) return 1\n  if (codePoint <= 0x07ff) return 2\n  if (codePoint <= 0xffff) return 3\n  return 4\n}\n","// The number of bits in an int.\nexport const MAX_BITS = 32\n\nexport const DEFAULT_MARGIN = 4\n","import {cleanupSemantic, cleanupEfficiency} from '../diff/cleanup.js'\nimport {diff, type Diff, DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {diffText1} from '../diff/diffText.js'\nimport {isLowSurrogate} from '../utils/surrogatePairs.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {MAX_BITS} from './constants.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\n/**\n * Options for patch generation.\n *\n * @public\n */\nexport interface MakePatchOptions {\n  // Chunk size for context length.\n  margin: number\n}\n\nconst DEFAULT_OPTS: MakePatchOptions = {\n  margin: 4,\n}\n\nfunction getDefaultOpts(opts: Partial<MakePatchOptions> = {}): MakePatchOptions {\n  return {\n    ...DEFAULT_OPTS,\n    ...opts,\n  }\n}\n\n/**\n * Compute a list of patches to turn based on passed diffs.\n *\n * @param diffs - Array of diff tuples.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(diffs: Diff[], options?: Partial<MakePatchOptions>): Patch[]\n\n/**\n * Compute a list of patches to turn textA into textB.\n *\n * @param textA - Original text.\n * @param textB - New text.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(textA: string, textB: string, options?: Partial<MakePatchOptions>): Patch[]\n\n/**\n * Compute a list of patches to turn textA into textB using provided diff tuples.\n *\n * @param textA - Original text.\n * @param diffs - Diff tuples to use as base.\n * @param options - Options for the patch generation.\n * @returns Array of Patch objects.\n * @public\n */\nexport function make(textA: string, diffs: Diff[], options?: Partial<MakePatchOptions>): Patch[]\n\nexport function make(\n  a: Diff[] | string,\n  b?: Partial<MakePatchOptions> | string | Diff[],\n  options?: Partial<MakePatchOptions>\n): Patch[] {\n  if (typeof a === 'string' && typeof b === 'string') {\n    // Method 1: textA, textB\n    // Compute diffs from textA and textB.\n    let diffs = diff(a, b, {checkLines: true})\n    if (diffs.length > 2) {\n      diffs = cleanupSemantic(diffs)\n      diffs = cleanupEfficiency(diffs)\n    }\n    return _make(a, diffs, getDefaultOpts(options))\n  }\n\n  if (a && Array.isArray(a) && typeof b === 'undefined') {\n    // Method 2: diffs\n    // Compute textA from diffs.\n    return _make(diffText1(a), a, getDefaultOpts(options))\n  }\n\n  if (typeof a === 'string' && b && Array.isArray(b)) {\n    // Method 3: textA, diffs\n    return _make(a, b, getDefaultOpts(options))\n  }\n\n  throw new Error('Unknown call format to make()')\n}\n\nfunction _make(textA: string, diffs: Diff[], options: MakePatchOptions): Patch[] {\n  if (diffs.length === 0) {\n    return [] // Get rid of the null case.\n  }\n  const patches: Patch[] = []\n\n  let patch = createPatchObject(0, 0)\n  let patchDiffLength = 0 // Keeping our own length var is faster in JS.\n  let charCount1 = 0 // Number of characters into the textA string.\n  let charCount2 = 0 // Number of characters into the textB string.\n  let utf8Count1 = 0 // Number of utf-8 bytes into the textA string.\n  let utf8Count2 = 0 // Number of utf-8 bytes into the textB string.\n\n  // Start with textA (prepatchText) and apply the diffs until we arrive at\n  // textB (postpatchText).  We recreate the patches one by one to determine\n  // context info.\n  let prepatchText = textA\n  let postpatchText = textA\n\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x]\n    const [diffType, diffText] = currentDiff\n    const diffTextLength = diffText.length\n    const diffByteLength = countUtf8Bytes(diffText)\n\n    if (!patchDiffLength && diffType !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = charCount1\n      patch.start2 = charCount2\n      patch.utf8Start1 = utf8Count1\n      patch.utf8Start2 = utf8Count2\n    }\n\n    switch (diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff\n        patch.length2 += diffTextLength\n        patch.utf8Length2 += diffByteLength\n        postpatchText =\n          postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2)\n        break\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength\n        patch.utf8Length1 += diffByteLength\n        patch.diffs[patchDiffLength++] = currentDiff\n        postpatchText =\n          postpatchText.substring(0, charCount2) +\n          postpatchText.substring(charCount2 + diffTextLength)\n        break\n      case DIFF_EQUAL:\n        if (diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = currentDiff\n          patch.length1 += diffTextLength\n          patch.length2 += diffTextLength\n          patch.utf8Length1 += diffByteLength\n          patch.utf8Length2 += diffByteLength\n        } else if (diffTextLength >= 2 * options.margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            addContext(patch, prepatchText, options)\n            patches.push(patch)\n            patch = createPatchObject(-1, -1)\n            patchDiffLength = 0\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatchText = postpatchText\n            charCount1 = charCount2\n            utf8Count1 = utf8Count2\n          }\n        }\n        break\n      default:\n        throw new Error('Unknown diff type')\n    }\n\n    // Update the current character count.\n    if (diffType !== DIFF_INSERT) {\n      charCount1 += diffTextLength\n      utf8Count1 += diffByteLength\n    }\n    if (diffType !== DIFF_DELETE) {\n      charCount2 += diffTextLength\n      utf8Count2 += diffByteLength\n    }\n  }\n\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    addContext(patch, prepatchText, options)\n    patches.push(patch)\n  }\n\n  return patches\n}\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond MAX_BITS.\n *\n * @param patch - The patch to grow.\n * @param text - Source text.\n * @param opts\n * @internal\n */\nexport function addContext(patch: Patch, text: string, opts: MakePatchOptions): void {\n  if (text.length === 0) {\n    return\n  }\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1)\n  let padding = 0\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (\n    text.indexOf(pattern) !== text.lastIndexOf(pattern) &&\n    pattern.length < MAX_BITS - opts.margin - opts.margin\n  ) {\n    padding += opts.margin\n    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding)\n  }\n  // Add one chunk for good luck.\n  padding += opts.margin\n\n  // Add the prefix.\n\n  // Avoid splitting inside a surrogate.\n  let prefixStart = patch.start2 - padding\n  if (prefixStart >= 1 && isLowSurrogate(text[prefixStart])) {\n    prefixStart--\n  }\n\n  const prefix = text.substring(prefixStart, patch.start2)\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix])\n  }\n\n  const prefixLength = prefix.length\n  const prefixUtf8Length = countUtf8Bytes(prefix)\n\n  // Add the suffix.\n\n  // Avoid splitting inside a surrogate.\n  let suffixEnd = patch.start2 + patch.length1 + padding\n  if (suffixEnd < text.length && isLowSurrogate(text[suffixEnd])) {\n    suffixEnd++\n  }\n\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd)\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix])\n  }\n\n  const suffixLength = suffix.length\n  const suffixUtf8Length = countUtf8Bytes(suffix)\n\n  // Roll back the start points.\n  patch.start1 -= prefixLength\n  patch.start2 -= prefixLength\n  patch.utf8Start1 -= prefixUtf8Length\n  patch.utf8Start2 -= prefixUtf8Length\n\n  // Extend the lengths.\n  patch.length1 += prefixLength + suffixLength\n  patch.length2 += prefixLength + suffixLength\n  patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length\n  patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, type Diff} from './diff.js'\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n *\n * @param diffs - Array of diff tuples.\n * @returns Number of changes.\n * @internal\n */\nexport function levenshtein(diffs: Diff[]): number {\n  let leven = 0\n  let insertions = 0\n  let deletions = 0\n\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0]\n    const data = diffs[x][1]\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length\n        break\n      case DIFF_DELETE:\n        deletions += data.length\n        break\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        leven += Math.max(insertions, deletions)\n        insertions = 0\n        deletions = 0\n        break\n      default:\n        throw new Error('Unknown diff operation.')\n    }\n  }\n  leven += Math.max(insertions, deletions)\n  return leven\n}\n","import {DIFF_DELETE, DIFF_INSERT, type Diff} from './diff.js'\n\n/**\n * loc is a location in textA, compute and return the equivalent location in\n * textB.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n *\n * @param diffs - Array of diff tuples.\n * @param loc - Location within textA.\n * @returns Location within textB.\n */\nexport function xIndex(diffs: Diff[], loc: number): number {\n  let chars1 = 0\n  let chars2 = 0\n  let lastChars1 = 0\n  let lastChars2 = 0\n  let x\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      // Equality or deletion.\n      chars1 += diffs[x][1].length\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {\n      // Equality or insertion.\n      chars2 += diffs[x][1].length\n    }\n    if (chars1 > loc) {\n      // Overshot the location.\n      break\n    }\n    lastChars1 = chars1\n    lastChars2 = chars2\n  }\n  // Was the location was deleted?\n  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE) {\n    return lastChars2\n  }\n  // Add the remaining character length.\n  return lastChars2 + (loc - lastChars1)\n}\n","import {DIFF_EQUAL} from '../diff/diff.js'\nimport {DEFAULT_MARGIN} from './constants.js'\nimport type {Patch} from './createPatchObject.js'\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n *\n * @param patches - Array of Patch objects.\n * @param margin - The margin length to add.\n * @returns The string, padded on each side.\n * @internal\n */\nexport function addPadding(patches: Patch[], margin: number = DEFAULT_MARGIN): string {\n  const paddingLength = margin\n  let nullPadding = ''\n  for (let x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x)\n  }\n\n  // Bump all the patches forward.\n  for (const p of patches) {\n    p.start1 += paddingLength\n    p.start2 += paddingLength\n    p.utf8Start1 += paddingLength\n    p.utf8Start2 += paddingLength\n  }\n\n  // Add some padding on start of first diff.\n  let patch = patches[0]\n  let diffs = patch.diffs\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding])\n    patch.start1 -= paddingLength // Should be 0.\n    patch.start2 -= paddingLength // Should be 0.\n    patch.utf8Start1 -= paddingLength // Should be 0.\n    patch.utf8Start2 -= paddingLength // Should be 0.\n    patch.length1 += paddingLength\n    patch.length2 += paddingLength\n    patch.utf8Length1 += paddingLength\n    patch.utf8Length2 += paddingLength\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    const firstDiffLength = diffs[0][1].length\n    const extraLength = paddingLength - firstDiffLength\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1]\n    patch.start1 -= extraLength\n    patch.start2 -= extraLength\n    patch.utf8Start1 -= extraLength\n    patch.utf8Start2 -= extraLength\n    patch.length1 += extraLength\n    patch.length2 += extraLength\n    patch.utf8Length1 += extraLength\n    patch.utf8Length2 += extraLength\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1]\n  diffs = patch.diffs\n  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding])\n    patch.length1 += paddingLength\n    patch.length2 += paddingLength\n    patch.utf8Length1 += paddingLength\n    patch.utf8Length2 += paddingLength\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength)\n    patch.length1 += extraLength\n    patch.length2 += extraLength\n    patch.utf8Length1 += extraLength\n    patch.utf8Length2 += extraLength\n  }\n\n  return nullPadding\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {diffText1, diffText2} from '../diff/diffText.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {DEFAULT_MARGIN, MAX_BITS} from './constants.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n *\n * @param patches - Array of Patch objects.\n * @internal\n */\nexport function splitMax(patches: Patch[], margin: number = DEFAULT_MARGIN): void {\n  const patchSize = MAX_BITS\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) {\n      continue\n    }\n    const bigpatch = patches[x]\n    // Remove the big old patch.\n    patches.splice(x--, 1)\n    let start1 = bigpatch.start1\n    let start2 = bigpatch.start2\n    let preContext = ''\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length)\n      let empty = true\n\n      if (preContext !== '') {\n        const precontextByteCount = countUtf8Bytes(preContext)\n        patch.length1 = preContext.length\n        patch.utf8Length1 = precontextByteCount\n        patch.length2 = preContext.length\n        patch.utf8Length2 = precontextByteCount\n        patch.diffs.push([DIFF_EQUAL, preContext])\n      }\n      while (bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin) {\n        const diffType = bigpatch.diffs[0][0]\n        let diffText = bigpatch.diffs[0][1]\n        let diffTextByteCount = countUtf8Bytes(diffText)\n        if (diffType === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diffText.length\n          patch.utf8Length2 += diffTextByteCount\n          start2 += diffText.length\n          const diff = bigpatch.diffs.shift()\n          if (diff) {\n            patch.diffs.push(diff)\n          }\n          empty = false\n        } else if (\n          diffType === DIFF_DELETE &&\n          patch.diffs.length === 1 &&\n          patch.diffs[0][0] === DIFF_EQUAL &&\n          diffText.length > 2 * patchSize\n        ) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diffText.length\n          patch.utf8Length1 += diffTextByteCount\n          start1 += diffText.length\n          empty = false\n          patch.diffs.push([diffType, diffText])\n          bigpatch.diffs.shift()\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diffText = diffText.substring(0, patchSize - patch.length1 - margin)\n          diffTextByteCount = countUtf8Bytes(diffText)\n          patch.length1 += diffText.length\n          patch.utf8Length1 += diffTextByteCount\n          start1 += diffText.length\n          if (diffType === DIFF_EQUAL) {\n            patch.length2 += diffText.length\n            patch.utf8Length2 += diffTextByteCount\n            start2 += diffText.length\n          } else {\n            empty = false\n          }\n          patch.diffs.push([diffType, diffText])\n          if (diffText === bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift()\n          } else {\n            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length)\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      preContext = diffText2(patch.diffs)\n      preContext = preContext.substring(preContext.length - margin)\n      // Append the end context for this patch.\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin)\n      const postContextByteCount = countUtf8Bytes(postContext)\n      if (postContext !== '') {\n        patch.length1 += postContext.length\n        patch.length2 += postContext.length\n        patch.utf8Length1 += postContextByteCount\n        patch.utf8Length2 += postContextByteCount\n        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postContext\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postContext])\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch)\n      }\n    }\n  }\n}\n","/* eslint-disable max-depth */\n/* eslint-disable max-statements */\nimport {cleanupSemanticLossless} from '../diff/cleanup.js'\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, diff} from '../diff/diff.js'\nimport {diffText1, diffText2} from '../diff/diffText.js'\nimport {levenshtein} from '../diff/levenshtein.js'\nimport {xIndex} from '../diff/xIndex.js'\nimport {match} from '../match/match.js'\nimport {adjustIndiciesToUcs2} from '../utils/utf8Indices.js'\nimport {addPadding} from './addPadding.js'\nimport {DEFAULT_MARGIN, MAX_BITS} from './constants.js'\nimport {splitMax} from './splitMax.js'\nimport type {Patch} from './createPatchObject.js'\n\n/**\n * Options for applying a patch.\n *\n * @public\n */\nexport interface ApplyPatchOptions {\n  /**\n   * Chunk size for context length\n   */\n  margin: number\n\n  /**\n   * When deleting a large block of text (over ~64 characters),\n   * how close do the contents have to be to match the expected contents.\n   * (0.0 = perfection, 1.0 = very loose).\n   */\n  deleteThreshold: number\n\n  /**\n   * When converting indices between UTF-8 and UCS-2, certain scenarios can occur\n   * where we go beyond the target offset. This can happen in particular with\n   * surrogate pairs/high codepoints, when the base string we are applying the\n   * patch to does not fully match the one that was used to generate the patch.\n   * Defaults to `false`.\n   */\n  allowExceedingIndices: boolean\n}\n\n/**\n * Result of a patch application operation.\n * Index 0 contains the new text\n * Index 1 contains an array of booleans indicating which patches were applied\n *\n * @public\n */\nexport type PatchResult = [string, boolean[]]\n\n/**\n * Merge a set of patches onto the text. Returns patched text, as well as a\n * list of true/false values indicating which patches were applied.\n *\n * @param patches - Array of Patch objects.\n * @param text - Old text.\n * @param opts - Optional settings for the patch application.\n * @returns Two element Array, containing the new text and an array of boolean values.\n * @public\n */\nexport function apply(\n  patches: Patch[],\n  originalText: string,\n  opts: Partial<ApplyPatchOptions> = {}\n): PatchResult {\n  if (typeof patches === 'string') {\n    throw new Error('Patches must be an array - pass the patch to `parsePatch()` first')\n  }\n\n  let text = originalText\n  if (patches.length === 0) {\n    return [text, []]\n  }\n\n  // Note: adjustment also deep-copies patches so that no changes are made to the originals.\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices,\n  })\n\n  const margin = opts.margin || DEFAULT_MARGIN\n  const deleteThreshold = opts.deleteThreshold || 0.4\n\n  const nullPadding = addPadding(parsed, margin)\n  text = nullPadding + text + nullPadding\n\n  splitMax(parsed, margin)\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  let delta = 0\n  const results: boolean[] = []\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta\n    const text1 = diffText1(parsed[x].diffs)\n    let startLoc\n    let endLoc = -1\n    if (text1.length > MAX_BITS) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc)\n      if (startLoc !== -1) {\n        endLoc = match(\n          text,\n          text1.substring(text1.length - MAX_BITS),\n          expectedLoc + text1.length - MAX_BITS\n        )\n        if (endLoc === -1 || startLoc >= endLoc) {\n          // Can't find valid trailing context.  Drop this patch.\n          startLoc = -1\n        }\n      }\n    } else {\n      startLoc = match(text, text1, expectedLoc)\n    }\n    if (startLoc === -1) {\n      // No match found.  :(\n      results[x] = false\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= parsed[x].length2 - parsed[x].length1\n    } else {\n      // Found a match.  :)\n      results[x] = true\n      delta = startLoc - expectedLoc\n      let text2\n      if (endLoc === -1) {\n        text2 = text.substring(startLoc, startLoc + text1.length)\n      } else {\n        text2 = text.substring(startLoc, endLoc + MAX_BITS)\n      }\n      if (text1 === text2) {\n        // Perfect match, just shove the replacement text in.\n        text =\n          text.substring(0, startLoc) +\n          diffText2(parsed[x].diffs) +\n          text.substring(startLoc + text1.length)\n      } else {\n        // Imperfect match. Run a diff to get a framework of equivalent indices.\n        let diffs = diff(text1, text2, {checkLines: false})\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false\n        } else {\n          diffs = cleanupSemanticLossless(diffs)\n          let index1 = 0\n          let index2 = 0\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y]\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = xIndex(diffs, index1)\n            }\n            if (mod[0] === DIFF_INSERT) {\n              // Insertion\n              text =\n                text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2)\n            } else if (mod[0] === DIFF_DELETE) {\n              // Deletion\n              text =\n                text.substring(0, startLoc + index2) +\n                text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length)\n  return [text, results]\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport type {Patch} from './createPatchObject.js'\n\n/**\n * Create a textual representation of a patch list.\n *\n * @param patches - Patches to stringify\n * @returns Text representation of patches\n * @public\n */\nexport function stringify(patches: Patch[]): string {\n  return patches.map(stringifyPatch).join('')\n}\n\n/**\n * Create a textual representation of a patch.\n *\n * @param patch - Patch to stringify\n * @returns Text representation of patch\n * @public\n */\nexport function stringifyPatch(patch: Patch): string {\n  const {utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs} = patch\n\n  let coords1: string\n  if (utf8Length1 === 0) {\n    coords1 = `${utf8Start1},0`\n  } else if (utf8Length1 === 1) {\n    coords1 = `${utf8Start1 + 1}`\n  } else {\n    coords1 = `${utf8Start1 + 1},${utf8Length1}`\n  }\n\n  let coords2: string\n  if (utf8Length2 === 0) {\n    coords2 = `${utf8Start2},0`\n  } else if (utf8Length2 === 1) {\n    coords2 = `${utf8Start2 + 1}`\n  } else {\n    coords2 = `${utf8Start2 + 1},${utf8Length2}`\n  }\n\n  const text = [`@@ -${coords1} +${coords2} @@\\n`]\n  let op\n\n  // Escape the body of the patch with %xx notation.\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+'\n        break\n      case DIFF_DELETE:\n        op = '-'\n        break\n      case DIFF_EQUAL:\n        op = ' '\n        break\n      default:\n        throw new Error('Unknown patch operation.')\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\\n`\n  }\n\n  return text.join('').replace(/%20/g, ' ')\n}\n","import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT} from '../diff/diff.js'\nimport {countUtf8Bytes} from '../utils/utf8Indices.js'\nimport {createPatchObject, type Patch} from './createPatchObject.js'\n\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n *\n * @param textline - Text representation of patches.\n * @returns Array of Patch objects.\n * @public\n */\nexport function parse(textline: string): Patch[] {\n  if (!textline) {\n    return []\n  }\n\n  const patches: Patch[] = []\n  const lines = textline.split('\\n')\n\n  let textPointer = 0\n  while (textPointer < lines.length) {\n    const m = lines[textPointer].match(patchHeader)\n    if (!m) {\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`)\n    }\n\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]))\n    patches.push(patch)\n    if (m[2] === '') {\n      patch.start1--\n      patch.utf8Start1--\n      patch.length1 = 1\n      patch.utf8Length1 = 1\n    } else if (m[2] === '0') {\n      patch.length1 = 0\n      patch.utf8Length1 = 0\n    } else {\n      patch.start1--\n      patch.utf8Start1--\n      // The patch itself will contain the UTF-8 length\n      patch.utf8Length1 = toInt(m[2])\n      // We start with UCS-2 length set to the same, but we adjust for it later\n      patch.length1 = patch.utf8Length1\n    }\n\n    if (m[4] === '') {\n      patch.start2--\n      patch.utf8Start2--\n      patch.length2 = 1\n      patch.utf8Length2 = 1\n    } else if (m[4] === '0') {\n      patch.length2 = 0\n      patch.utf8Length2 = 0\n    } else {\n      patch.start2--\n      patch.utf8Start2--\n      // The patch itself will contain the UTF-8 length\n      patch.utf8Length2 = toInt(m[4])\n      // We start with UCS-2 length set to the same, but we adjust for it later\n      patch.length2 = patch.utf8Length2\n    }\n    textPointer++\n\n    while (textPointer < lines.length) {\n      const currentLine = lines[textPointer]\n      const sign = currentLine.charAt(0)\n\n      if (sign === '@') {\n        // Start of next patch\n        break\n      }\n\n      if (sign === '') {\n        // Blank line? Ignore.\n        textPointer++\n        continue\n      }\n\n      let line: string\n      try {\n        line = decodeURI(currentLine.slice(1))\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error(`Illegal escape in parse: ${currentLine}`)\n      }\n\n      // The number of bytes in a line does not equate to the number of \"characters\"\n      // returned by `string.length` - we have to subtract the diff here in order to\n      // make slicing/calculations work correctly\n      const utf8Diff = countUtf8Bytes(line) - line.length\n      if (sign === '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line])\n        patch.length1 -= utf8Diff\n      } else if (sign === '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line])\n        patch.length2 -= utf8Diff\n      } else if (sign === ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line])\n        patch.length1 -= utf8Diff\n        patch.length2 -= utf8Diff\n      } else {\n        // WTF?\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`)\n      }\n      textPointer++\n    }\n  }\n  return patches\n}\n\nfunction toInt(num: string): number {\n  return parseInt(num, 10)\n}\n"],"names":["isHighSurrogate","char","charCode","charCodeAt","isLowSurrogate","cloneDiff","diff","type","patch","getCommonOverlap","textA","textB","text1","text2","text1Length","length","text2Length","substring","textLength","Math","min","best","found","pattern","indexOf","getCommonPrefix","pointerMin","pointerMax","pointerMid","pointerStart","floor","getCommonSuffix","pointerEnd","cleanupSemantic","rawDiffs","diffs","map","hasChanges","equalities","equalitiesLength","lastEquality","pointer","lengthInsertions1","lengthDeletions1","lengthInsertions2","lengthDeletions2","DIFF_EQUAL","DIFF_INSERT","max","splice","DIFF_DELETE","cleanupMerge","cleanupSemanticLossless","deletion","insertion","overlapLength1","overlapLength2","nonAlphaNumericRegex","whitespaceRegex","linebreakRegex","blanklineEndRegex","blanklineStartRegex","diffCleanupSemanticScore","one","two","char1","charAt","char2","nonAlphaNumeric1","match","nonAlphaNumeric2","whitespace1","whitespace2","lineBreak1","lineBreak2","blankLine1","blankLine2","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","push","countDelete","countInsert","textDelete","textInsert","commonlength","Error","pop","trueCount","_len","arguments","args","Array","_key","reduce","n","bool","cleanupEfficiency","editCost","undefined","preIns","preDel","postIns","postDel","bisect","deadline","maxD","ceil","vOffset","vLength","v1","v2","x","delta","front","k1start","k1end","k2start","k2end","d","Date","now","k1","k1Offset","x1","y1","k2Offset","x2","bisectSplit","k2","y2","y","text1a","text2a","text1b","text2b","doDiff","checkLines","diffsb","concat","findHalfMatch","timeout","longText","shortText","halfMatch1","halfMatchI","halfMatch2","halfMatch","text1A","text1B","text2A","text2B","midCommon","i","seed","slice","j","bestCommon","bestLongTextA","bestLongTextB","bestShortTextA","bestShortTextB","prefixLength","suffixLength","charsToLines","lineArray","chars","text","join","linesToChars","lineHash","diffLinesToMunge","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","String","fromCharCode","maxLines","chars1","chars2","doLineModeDiff","opts","a","linearray","aa","computeDiff","longtext","shorttext","diffsA","diffsB","createInternalOpts","adjustDiffForSurrogatePairs","options","commonprefix","commonsuffix","unshift","createDeadLine","t","Number","MAX_VALUE","combineChar","data","dir","splitChar","hasSharedChar","deisolateChar","inv","insertIdx","deleteIdx","op","rest","insertText","insertChar","deleteText","diffType","diffText","firstChar","lastChar","DEFAULT_OPTIONS","threshold","distance","applyDefaults","MAX_BITS","bitap","loc","s","getAlphabetFromPattern","getBitapScore","e","accuracy","proximity","abs","scoreThreshold","bestLoc","lastIndexOf","matchmask","binMin","binMid","binMax","lastRd","start","finish","rd","charMatch","searchLocation","createPatchObject","start1","start2","utf8Start1","utf8Start2","length1","length2","utf8Length1","utf8Length2","diffText1","diffText2","countUtf8Bytes","str","bytes","codePoint","codePointAt","utf8len","adjustIndiciesToUcs2","patches","base","byteOffset","idx","advanceTo","target","allowExceedingIndices","adjusted","DEFAULT_MARGIN","DEFAULT_OPTS","margin","getDefaultOpts","make","b","_make","isArray","patchDiffLength","charCount1","charCount2","utf8Count1","utf8Count2","prepatchText","postpatchText","currentDiff","diffTextLength","diffByteLength","addContext","padding","prefixStart","prefix","prefixUtf8Length","suffixEnd","suffix","suffixUtf8Length","levenshtein","leven","insertions","deletions","xIndex","lastChars1","lastChars2","addPadding","paddingLength","nullPadding","p","firstDiffLength","extraLength","splitMax","patchSize","bigpatch","preContext","empty","precontextByteCount","diffTextByteCount","shift","postContext","postContextByteCount","apply","originalText","parsed","deleteThreshold","results","expectedLoc","startLoc","endLoc","index1","index2","mod","stringify","stringifyPatch","coords1","coords2","encodeURI","replace","patchHeader","parse","textline","lines","split","textPointer","m","toInt","currentLine","sign","decodeURI","ex","utf8Diff","num","parseInt"],"mappings":"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"}