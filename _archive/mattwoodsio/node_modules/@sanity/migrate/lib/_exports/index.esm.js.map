{"version":3,"file":"index.esm.js","sources":["../../src/defineMigration.ts","../../src/it-utils/decodeText.ts","../../src/it-utils/delay.ts","../../src/it-utils/filter.ts","../../src/it-utils/json.ts","../../src/it-utils/map.ts","../../src/it-utils/split.ts","../../src/it-utils/ndjson.ts","../../src/it-utils/take.ts","../../src/it-utils/toArray.ts","../../src/mutations/creators.ts","../../src/mutations/operations/creators.ts","../../src/mutations/transaction.ts","../../src/mutations/asserters.ts","../../src/runner/utils/getValueType.ts","../../src/runner/utils/flatMapDeep.ts","../../src/runner/normalizeMigrateDefinition.ts","../../src/runner/collectMigrationMutations.ts","../../src/runner/constants.ts","../../src/debug.ts","../../src/fs-webstream/bufferThroughFile.ts","../../src/uint8arrays/index.ts","../../src/fs-webstream/peekInto.ts","../../src/fs-webstream/maybeDecompress.ts","../../src/fs-webstream/readFileAsWebStream.ts","../../src/tar-webstream/drain.ts","../../src/tar-webstream/BufferList.ts","../../src/tar-webstream/headers.ts","../../src/tar-webstream/untar.ts","../../src/utils/streamToAsyncIterator.ts","../../src/sources/fromExportArchive.ts","../../src/fetch-utils/endpoints.ts","../../src/fetch-utils/fetchStream.ts","../../src/fetch-utils/sanityRequestOptions.ts","../../src/sources/fromExportEndpoint.ts","../../src/utils/asyncIterableToStream.ts","../../src/runner/utils/applyFilters.ts","../../src/runner/utils/limitClientConcurrency.ts","../../src/runner/utils/createContextClient.ts","../../src/runner/utils/createFilteredDocumentsClient.ts","../../src/runner/utils/getBufferFile.ts","../../src/runner/dryRun.ts","../../src/it-utils/concatStr.ts","../../src/it-utils/lastValueFrom.ts","../../src/it-utils/mapAsync.ts","../../src/it-utils/tap.ts","../../src/runner/utils/batchMutations.ts","../../src/runner/utils/toSanityMutations.ts","../../src/runner/run.ts","../../src/sources/fromDocuments.ts"],"sourcesContent":["import {type Migration} from './types'\n\n/**\n * @public\n *\n * Helper function for defining a Sanity content migration. This function does not do anything on its own;\n * it exists to check that your schema definition is correct, and help autocompletion in your IDE.\n *\n * {@link https://www.sanity.io/docs/schema-and-content-migrations#af2be129ccd6}\n\n * @example Basic usage\n *\n * ```ts\n * export default defineMigration({\n *  title: 'Make sure all strings with ‚Äúacme‚Äù is uppercased to ‚ÄúACME‚Äù',\n *  migrate: {\n *    string(node, path, context) {\n *      if (node === \"acme\") {\n *        return set(node.toUpperCase())\n *      }\n *    },\n *  },\n * })\n * ```\n * @param migration - The migration definition\n *\n * See {@link Migration}\n */\nexport function defineMigration<T extends Migration>(migration: T): T {\n  return migration\n}\n","export async function* decodeText(it: AsyncIterableIterator<Uint8Array>) {\n  const decoder = new TextDecoder()\n  for await (const chunk of it) {\n    yield decoder.decode(chunk)\n  }\n}\n","function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nexport async function* delay<T>(it: AsyncIterableIterator<T>, ms: number) {\n  for await (const chunk of it) {\n    await sleep(ms)\n    yield chunk\n  }\n}\n","export async function* filter<T>(\n  it: AsyncIterableIterator<T>,\n  predicate: (value: T) => boolean | Promise<boolean>,\n) {\n  for await (const chunk of it) {\n    if (await predicate(chunk)) {\n      yield chunk\n    }\n  }\n}\n","export type JSONParser<Type> = (line: string) => Type\n\nexport interface JSONOptions<Type> {\n  parse?: JSONParser<Type>\n}\n\nexport async function* parseJSON<Type>(\n  it: AsyncIterableIterator<string>,\n  {parse = JSON.parse}: JSONOptions<Type> = {},\n): AsyncIterableIterator<Type> {\n  for await (const chunk of it) {\n    yield parse(chunk)\n  }\n}\n\nexport async function* stringifyJSON(it: AsyncIterableIterator<unknown>) {\n  for await (const chunk of it) {\n    yield JSON.stringify(chunk)\n  }\n}\n","export async function* map<T, U>(\n  it: AsyncIterableIterator<T>,\n  project: (value: T) => U,\n): AsyncIterableIterator<U> {\n  for await (const chunk of it) {\n    yield project(chunk)\n  }\n}\n","export async function* split(\n  it: AsyncIterableIterator<string>,\n  delimiter: string,\n): AsyncIterableIterator<string> {\n  let buf = ''\n  for await (const chunk of it) {\n    buf += chunk\n    if (buf.includes(delimiter)) {\n      const lastIndex = buf.lastIndexOf(delimiter)\n      const parts = buf.substring(0, lastIndex).split(delimiter)\n\n      for (const part of parts) {\n        yield part\n      }\n      buf = buf.substring(lastIndex + delimiter.length)\n    }\n  }\n  yield buf\n}\n","import {filter} from './filter'\nimport {type JSONOptions, parseJSON} from './json'\nimport {split} from './split'\n\nexport function parse<Type>(\n  it: AsyncIterableIterator<string>,\n  options?: JSONOptions<Type>,\n): AsyncIterableIterator<Type> {\n  return parseJSON(\n    filter(split(it, '\\n'), (line) => Boolean(line && line.trim())),\n    options,\n  )\n}\n\nexport async function* stringify(iterable: AsyncIterableIterator<unknown>) {\n  for await (const doc of iterable) {\n    yield `${JSON.stringify(doc)}\\n`\n  }\n}\n","export async function* take<T>(it: AsyncIterableIterator<T>, count: number) {\n  let i = 0\n  for await (const chunk of it) {\n    if (i++ >= count) return\n    yield chunk\n  }\n}\n","export async function toArray<T>(it: AsyncIterableIterator<T>): Promise<T[]> {\n  const result: T[] = []\n  for await (const chunk of it) {\n    result.push(chunk)\n  }\n  return result\n}\n","import {type Path} from '@sanity/types'\nimport {fromString} from '@sanity/util/paths'\nimport arrify from 'arrify'\n\nimport {type Operation} from './operations/types'\nimport {\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type NodePatch,\n  type NodePatchList,\n  type PatchMutation,\n  type PatchOptions,\n  type SanityDocument,\n} from './types'\nimport {type NormalizeReadOnlyArray, type Optional, type Tuplify} from './typeUtils'\n\n/**\n * Creates a new document.\n * @param document - The document to be created.\n * @returns The mutation to create the document.\n * @beta\n */\nexport function create<Doc extends Optional<SanityDocument, '_id'>>(\n  document: Doc,\n): CreateMutation<Doc> {\n  return {type: 'create', document}\n}\n\n/**\n * Applies a patch to a document.\n * @param id - The ID of the document to be patched.\n * @param patches - The patches to be applied.\n * @param options - Optional patch options.\n * @returns The mutation to patch the document.\n * @beta\n */\nexport function patch<P extends NodePatchList | NodePatch>(\n  id: string,\n  patches: P,\n  options?: PatchOptions,\n): PatchMutation<NormalizeReadOnlyArray<Tuplify<P>>> {\n  return {\n    type: 'patch',\n    id,\n    patches: arrify(patches) as any,\n    ...(options ? {options} : {}),\n  }\n}\n\n/**\n * Creates a {@link NodePatch} at a specific path.\n * @param path - The path where the operation should be applied.\n * @param operation - The operation to be applied.\n * @returns The node patch.\n * @beta\n */\nexport function at<O extends Operation>(path: Path | string, operation: O): NodePatch<Path, O> {\n  return {\n    path: typeof path === 'string' ? fromString(path) : path,\n    op: operation,\n  }\n}\n\n/**\n * Creates a document if it does not exist.\n * @param document - The document to be created.\n * @returns The mutation operation to create the document if it does not exist.\n * @beta\n */\nexport function createIfNotExists<Doc extends SanityDocument>(\n  document: Doc,\n): CreateIfNotExistsMutation<Doc> {\n  return {type: 'createIfNotExists', document}\n}\n\n/**\n * Creates or replaces a document.\n * @param document - The document to be created or replaced.\n * @returns The mutation operation to create or replace the document.\n * @beta\n */\nexport function createOrReplace<Doc extends SanityDocument>(\n  document: Doc,\n): CreateOrReplaceMutation<Doc> {\n  return {type: 'createOrReplace', document}\n}\n\n/**\n * Deletes a document.\n * @param id - The id of the document to be deleted.\n * @returns The mutation operation to delete the document.\n * @beta\n */\nexport function delete_(id: string): DeleteMutation {\n  return {type: 'delete', id}\n}\n\n/**\n * Alias for delete\n */\nexport const del = delete_\n","import arrify from 'arrify'\n\nimport {type AnyArray, type ArrayElement, type NormalizeReadOnlyArray} from '../typeUtils'\nimport {\n  type DecOp,\n  type DiffMatchPatchOp,\n  type IncOp,\n  type IndexedSegment,\n  type InsertOp,\n  type KeyedSegment,\n  type RelativePosition,\n  type ReplaceOp,\n  type SetIfMissingOp,\n  type SetOp,\n  type TruncateOp,\n  type UnsetOp,\n} from './types'\n\n/**\n * Creates a `set` operation with the provided value.\n * @param value - The value to set.\n * @returns A `set` operation.\n * {@link https://www.sanity.io/docs/http-patches#6TPENSW3}\n * @beta\n *\n * @example\n * ```ts\n * const setFoo = set('foo')\n * const setEmptyArray = set([])\n * ```\n */\nexport const set = <const T>(value: T): SetOp<T> => ({type: 'set', value})\n\n/**\n * Creates a `setIfMissing` operation with the provided value.\n * @param value - The value to set if missing.\n * @returns A `setIfMissing` operation.\n * {@link https://www.sanity.io/docs/http-patches#A80781bT}\n * @beta\n * @example\n * ```ts\n * const setFooIfMissing = setIfMissing('foo')\n * const setEmptyArrayIfMissing = setIfMissing([])\n * ```\n */\nexport const setIfMissing = <const T>(value: T): SetIfMissingOp<T> => ({\n  type: 'setIfMissing',\n  value,\n})\n\n/**\n * Creates an `unset` operation.\n * @returns An `unset` operation.\n * {@link https://www.sanity.io/docs/http-patches#xRtBjp8o}\n * @beta\n *\n * @example\n * ```ts\n * const unsetAnyValue = unset()\n * ```\n */\nexport const unset = (): UnsetOp => ({type: 'unset'})\n\n/**\n * Creates an `inc` (increment) operation with the provided amount.\n * @param amount - The amount to increment by.\n * @returns An incrementation operation for numeric values\n * {@link https://www.sanity.io/docs/http-patches#vIT8WWQo}\n * @beta\n *\n * @example\n * ```ts\n * const incBy1 = inc()\n * const incBy5 = inc(5)\n * ```\n */\nexport const inc = <const N extends number = 1>(amount: N = 1 as N): IncOp<N> => ({\n  type: 'inc',\n  amount,\n})\n\n/**\n * Creates a `dec` (decrement) operation with the provided amount.\n * @param amount - The amount to decrement by.\n * @returns A `dec` operation.\n * {@link https://www.sanity.io/docs/http-patches#vIT8WWQo}\n * @beta\n *\n * @example\n * ```ts\n * const decBy1 = dec()\n * const decBy10 = dec(10)\n * ```\n */\nexport const dec = <const N extends number = 1>(amount: N = 1 as N): DecOp<N> => ({\n  type: 'dec',\n  amount,\n})\n\n/**\n * Creates a `diffMatchPatch` operation with the provided value.\n * @param value - The value for the diff match patch operation.\n * @returns A `diffMatchPatch` operation.\n * {@link https://www.sanity.io/docs/http-patches#aTbJhlAJ}\n * @public\n */\nexport const diffMatchPatch = (value: string): DiffMatchPatchOp => ({\n  type: 'diffMatchPatch',\n  value,\n})\n\n/**\n * Creates an `insert` operation with the provided items, position, and reference item.\n * @param items - The items to insert.\n * @param position - The position to insert at.\n * @param indexOrReferenceItem - The index or reference item to insert before or after.\n * @returns An `insert` operation for adding values to arrays\n * {@link https://www.sanity.io/docs/http-patches#febxf6Fk}\n * @beta\n *\n * @example\n * ```ts\n * const prependFoo = insert(['foo'], 'before')\n * const appendFooAndBar = insert(['foo', 'bar'], 'after')\n * const insertObjAfterXYZ = insert({name: 'foo'}, 'after', {_key: 'xyz'}])\n * ```\n */\nexport function insert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  indexOrReferenceItem: ReferenceItem,\n): InsertOp<NormalizeReadOnlyArray<Items>, Pos, ReferenceItem> {\n  return {\n    type: 'insert',\n    referenceItem: indexOrReferenceItem,\n    position,\n    items: arrify(items) as any,\n  }\n}\n\n/**\n * Creates an `insert` operation that appends the provided items.\n * @param items - The items to append.\n * @returns An `insert` operation for adding a value to the end of an array.\n * {@link https://www.sanity.io/docs/http-patches#Cw4vhD88}\n * @beta\n *\n * @example\n * ```ts\n * const appendFoo = append('foo')\n * const appendObject = append({name: 'foo'})\n * const appendObjects = append([{name: 'foo'}, [{name: 'bar'}]])\n * ```\n */\nexport function append<const Items extends AnyArray<unknown>>(items: Items | ArrayElement<Items>) {\n  return insert(items, 'after', -1)\n}\n\n/**\n * Creates an `insert` operation that prepends the provided items.\n * @param items - The items to prepend.\n * @returns An `insert` operation for adding a value to the start of an array.\n * {@link https://www.sanity.io/docs/http-patches#refAUsf0}\n * @beta\n *\n * @example\n * ```ts\n * const prependFoo = prepend('foo')\n * const prependObject = prepend({name: 'foo'})\n * const prependObjects = prepend([{name: 'foo'}, [{name: 'bar'}]])\n * ```\n */\nexport function prepend<const Items extends AnyArray<unknown>>(items: Items | ArrayElement<Items>) {\n  return insert(items, 'before', 0)\n}\n\n/**\n * Creates an `insert` operation that inserts the provided items before the provided index or reference item.\n * @param items - The items to insert.\n * @param indexOrReferenceItem - The index or reference item to insert before.\n * @returns An `insert` operation before the provided index or reference item.\n * {@link https://www.sanity.io/docs/http-patches#0SQmPlb6}\n * @public\n *\n * @example\n * ```ts\n * const insertFooBeforeIndex3 = insertBefore('foo', 3)\n * const insertObjectBeforeKey = insertBefore({name: 'foo'}, {_key: 'xyz'}]\n * ```\n */\nexport function insertBefore<\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(items: Items | ArrayElement<Items>, indexOrReferenceItem: ReferenceItem) {\n  return insert(items, 'before', indexOrReferenceItem)\n}\n\n/**\n * Creates an `insert` operation that inserts the provided items after the provided index or reference item.\n * @param items - The items to insert.\n * @param indexOrReferenceItem - The index or reference item to insert after.\n * @returns An `insert` operation after the provided index or reference item.\n * {@link https://www.sanity.io/docs/http-patches#0SQmPlb6}\n * @beta\n *\n * @example\n * ```ts\n * const insertFooAfterIndex3 = insertAfter('foo', 3)\n * const insertObjectAfterKey = insertAfter({name: 'foo'}, {_key: 'xyz'}]\n * ```\n */\nexport const insertAfter = <\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(\n  items: Items | ArrayElement<Items>,\n  indexOrReferenceItem: ReferenceItem,\n) => {\n  return insert(items, 'after', indexOrReferenceItem)\n}\n\n/**\n * Creates a `truncate` operation that will remove all items after `startIndex` until the end of the array or the provided `endIndex`.\n * @param startIndex - The start index for the truncate operation.\n * @param endIndex - The end index for the truncate operation.\n * @returns A `truncate` operation.\n * @remarks - This will be converted to an `unset` patch when submitted to the API\n * {@link https://www.sanity.io/docs/http-patches#xRtBjp8o}\n * @beta\n *\n * @example\n * ```ts\n * const clearArray = truncate(0)\n * const removeItems = truncate(3, 5) // Removes items at index 3, 4, and 5\n * const truncate200 = truncate(200) // Removes all items after index 200\n * ```\n */\nexport function truncate(startIndex: number, endIndex?: number): TruncateOp {\n  return {\n    type: 'truncate',\n    startIndex,\n    endIndex,\n  }\n}\n\n/**\n * Creates a `replace` operation with the provided items and reference item.\n * @param items - The items to replace.\n * @param referenceItem - The reference item to replace.\n * @returns A ReplaceOp operation.\n * @remarks This will be converted to an `insert`/`replace` patch when submitted to the API\n * {@link https://www.sanity.io/docs/http-patches#GnVSwcPa}\n * @beta\n *\n * @example\n * ```ts\n * const replaceItem3WithFoo = replace('foo', 3)\n * const replaceItem3WithFooAndBar = replace(['foo', 'bar'], 3)\n * const replaceObject = replace({name: 'bar'}, {_key: 'xyz'})\n * ```\n */\nexport function replace<Items extends any[], ReferenceItem extends IndexedSegment | KeyedSegment>(\n  items: Items | ArrayElement<Items>,\n  referenceItem: ReferenceItem,\n): ReplaceOp<Items, ReferenceItem> {\n  return {\n    type: 'replace',\n    referenceItem,\n    items: arrify(items) as Items,\n  }\n}\n","import {type Mutation} from './types'\n\nexport interface Transaction {\n  type: 'transaction'\n  id?: string\n  mutations: Mutation[]\n}\n\n/**\n * @public\n *\n * Wraps a set of mutations in a transaction.\n * Note: use with caution. Transactions cannot be optimized and will be submitted one-by-one, which means they will make\n * your migration run slower and produce more API requests.\n * @param transactionId - The transaction ID. This is optional and should usually be omitted, as it will be auto-generated by the server if not provided.\n * @param mutations - The mutations to include in the transaction.\n *\n * {@link https://www.sanity.io/docs/http-mutations#afccc1b9ef78}\n */\nexport function transaction(transactionId: string, mutations: Mutation[]): Transaction\nexport function transaction(mutations: Mutation[]): Transaction\nexport function transaction(\n  idOrMutations: string | Mutation[],\n  _mutations?: Mutation[],\n): Transaction {\n  const [id, mutations] =\n    typeof idOrMutations === 'string'\n      ? [idOrMutations, _mutations as Mutation[]]\n      : [undefined, idOrMutations as Mutation[]]\n  return {type: 'transaction', id, mutations}\n}\n","import {type Operation} from './operations/types'\nimport {type Transaction} from './transaction'\nimport {type Mutation, type NodePatch} from './types'\n\nexport function isMutation(mutation: unknown): mutation is Mutation {\n  return (\n    mutation !== null &&\n    typeof mutation === 'object' &&\n    'type' in mutation &&\n    (mutation.type === 'create' ||\n      mutation.type === 'createIfNotExists' ||\n      mutation.type === 'createOrReplace' ||\n      mutation.type === 'patch' ||\n      mutation.type === 'delete')\n  )\n}\n\nexport function isTransaction(mutation: unknown): mutation is Transaction {\n  return (\n    mutation !== null &&\n    typeof mutation === 'object' &&\n    'type' in mutation &&\n    mutation.type === 'transaction'\n  )\n}\n\nexport function isOperation(value: unknown): value is Operation {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    (value.type === 'set' ||\n      value.type === 'unset' ||\n      value.type === 'insert' ||\n      value.type === 'diffMatchPatch' ||\n      value.type === 'dec' ||\n      value.type === 'inc' ||\n      value.type === 'upsert' ||\n      value.type === 'unassign' ||\n      value.type === 'truncate' ||\n      value.type === 'setIfMissing')\n  )\n}\n\nexport function isNodePatch(change: unknown): change is NodePatch {\n  return (\n    change !== null &&\n    typeof change === 'object' &&\n    'path' in change &&\n    Array.isArray(change.path) &&\n    'op' in change &&\n    isOperation(change.op)\n  )\n}\n","export function getValueType(value: unknown) {\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return value === null ? 'null' : typeof value\n}\n","import {type Path, type PathSegment} from '@sanity/types'\n\nimport {type JsonArray, type JsonObject, type JsonValue} from '../../json'\nimport {getValueType} from './getValueType'\n\ntype SkipMarker = {_: 'SKIP_MARKER'}\nexport const SKIP_MARKER: SkipMarker = {_: 'SKIP_MARKER'}\n\nfunction callMap<T>(mapFn: MapFn<T>, value: JsonValue, path: Path): T[] {\n  const res = mapFn(value, path)\n  return Array.isArray(res) ? res : [res]\n}\n\nfunction getPathWithKey(\n  item: unknown,\n  index: number | string,\n  container: JsonArray | JsonObject,\n): PathSegment {\n  if (\n    item &&\n    Array.isArray(container) &&\n    typeof item === 'object' &&\n    '_key' in item &&\n    typeof item._key === 'string'\n  ) {\n    return {_key: item._key}\n  }\n  return index\n}\n\ntype MapFn<T> = (value: JsonValue, path: Path) => T | T[]\n\n// Reduce depth first\nfunction mapObject<T>(reducerFn: MapFn<T>, object: JsonObject, path: Path): T[] {\n  return [\n    ...callMap(reducerFn, object, path),\n    ...Object.keys(object).flatMap((key) =>\n      flatMapAny(reducerFn, object[key], path.concat(getPathWithKey(object[key], key, object))),\n    ),\n  ]\n}\n\n// Reduce depth first\nfunction mapArray<T>(mapFn: MapFn<T>, array: JsonArray, path: Path): T[] {\n  return [\n    ...callMap(mapFn, array, path),\n    ...array.flatMap((item: JsonValue, index) =>\n      flatMapAny(mapFn, item, path.concat(getPathWithKey(item, index, array))),\n    ),\n  ]\n}\n\nfunction flatMapAny<T>(mapFn: MapFn<T>, val: JsonValue, path: Path) {\n  const type = getValueType(val)\n  if (type === 'object') {\n    return mapObject(mapFn, val as JsonObject, path)\n  }\n  if (type === 'array') {\n    return mapArray(mapFn, val as JsonArray, path)\n  }\n  return callMap(mapFn, val, path)\n}\n\n/**\n * Iterating depth first over the JSON tree, calling the mapFn for parents before children\n * @param value - the value to map deeply over\n * @param mapFn - the mapFn to call for each value\n */\nexport function flatMapDeep<T>(value: JsonValue, mapFn: MapFn<T>): T[] {\n  return flatMapAny(mapFn, value, [])\n}\n","import {SanityEncoder} from '@bjoerge/mutiny'\nimport {type Mutation as RawMutation} from '@sanity/client'\nimport {type Path, type SanityDocument} from '@sanity/types'\nimport arrify from 'arrify'\n\nimport {type JsonArray, type JsonObject, type JsonValue} from '../json'\nimport {\n  at,\n  type Mutation,\n  type NodePatch,\n  type Operation,\n  patch,\n  type Transaction,\n} from '../mutations'\nimport {isMutation, isNodePatch, isOperation, isTransaction} from '../mutations/asserters'\nimport {\n  type AsyncIterableMigration,\n  type Migration,\n  type MigrationContext,\n  type NodeMigration,\n  type NodeMigrationReturnValue,\n} from '../types'\nimport {flatMapDeep} from './utils/flatMapDeep'\nimport {getValueType} from './utils/getValueType'\n\nexport function normalizeMigrateDefinition(migration: Migration): AsyncIterableMigration {\n  if (typeof migration.migrate == 'function') {\n    // assume AsyncIterableMigration\n    return normalizeIteratorValues(migration.migrate)\n  }\n  return createAsyncIterableMutation(migration.migrate, {\n    filter: migration.filter,\n    documentTypes: migration.documentTypes,\n  })\n}\n\nfunction normalizeIteratorValues(asyncIterable: AsyncIterableMigration): AsyncIterableMigration {\n  return async function* run(docs, context) {\n    for await (const documentMutations of asyncIterable(docs, context)) {\n      yield normalizeMutation(documentMutations)\n    }\n  }\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param documentId - The document id\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeMutation(\n  change: Transaction | Mutation | RawMutation | (Mutation | Transaction | RawMutation)[],\n): (Mutation | Transaction)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeMutation(ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any) as Mutation[]\n  }\n  return [change]\n}\n\nfunction isRawMutation(\n  mutation: Transaction | Mutation | NodePatch | Operation | RawMutation,\n): mutation is RawMutation {\n  return (\n    'createIfNotExists' in mutation ||\n    'createOrReplace' in mutation ||\n    'create' in mutation ||\n    'patch' in mutation ||\n    'delete' in mutation\n  )\n}\nexport function createAsyncIterableMutation(\n  migration: NodeMigration,\n  opts: {filter?: string; documentTypes?: string[]},\n): AsyncIterableMigration {\n  const documentTypesSet = new Set(opts.documentTypes)\n\n  return async function* run(docs, context) {\n    for await (const doc of docs()) {\n      if (opts.documentTypes && !documentTypesSet.has(doc._type)) continue\n\n      const documentMutations = await collectDocumentMutations(migration, doc, context)\n      if (documentMutations.length > 0) {\n        yield documentMutations\n      }\n    }\n  }\n}\n\nasync function collectDocumentMutations(\n  migration: NodeMigration,\n  doc: SanityDocument,\n  context: MigrationContext,\n): Promise<(Mutation | Transaction)[]> {\n  const documentMutations = Promise.resolve(migration.document?.(doc, context))\n  const nodeMigrations = flatMapDeep(doc as JsonValue, async (value, path) => {\n    const [nodeReturnValues, nodeTypeReturnValues] = await Promise.all([\n      Promise.resolve(migration.node?.(value, path, context)),\n      Promise.resolve(migrateNodeType(migration, value, path, context)),\n    ])\n\n    return [...arrify(nodeReturnValues), ...arrify(nodeTypeReturnValues)].map(\n      (change) => change && normalizeNodeMutation(path, change),\n    )\n  })\n\n  return (await Promise.all([...arrify(await documentMutations), ...nodeMigrations]))\n    .flat()\n    .flatMap((change) => (change ? normalizeDocumentMutation(doc._id, change) : []))\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param documentId - The document id\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeDocumentMutation(\n  documentId: string,\n  change:\n    | Transaction\n    | Mutation\n    | NodePatch\n    | RawMutation\n    | (Mutation | NodePatch | Transaction | RawMutation)[],\n): Mutation | Transaction | (Mutation | Transaction)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeDocumentMutation(documentId, ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any)[0] as Mutation\n  }\n  if (isTransaction(change)) {\n    return change\n  }\n  return isMutation(change) ? change : patch(documentId, change)\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param path - The path the operation should be applied at\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeNodeMutation(\n  path: Path,\n  change: Mutation | NodePatch | Operation | RawMutation | RawMutation[],\n): Mutation | NodePatch | (Mutation | NodePatch)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeNodeMutation(path, ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any)[0] as Mutation\n  }\n\n  if (isNodePatch(change)) {\n    return at(path.concat(change.path), change.op)\n  }\n  return isOperation(change) ? at(path, change) : change\n}\n\nfunction migrateNodeType(\n  migration: NodeMigration,\n  value: JsonValue,\n  path: Path,\n  context: MigrationContext,\n): void | NodeMigrationReturnValue | Promise<void | NodeMigrationReturnValue> {\n  switch (getValueType(value)) {\n    case 'string':\n      return migration.string?.(value as string, path, context)\n    case 'number':\n      return migration.number?.(value as number, path, context)\n    case 'boolean':\n      return migration.boolean?.(value as boolean, path, context)\n    case 'object':\n      return migration.object?.(value as JsonObject, path, context)\n    case 'array':\n      return migration.array?.(value as JsonArray, path, context)\n    case 'null':\n      return migration.null?.(value as null, path, context)\n    default:\n      throw new Error('Unknown value type')\n  }\n}\n","import {type SanityDocument} from '@sanity/types'\n\nimport {type Migration, type MigrationContext} from '../types'\nimport {normalizeMigrateDefinition} from './normalizeMigrateDefinition'\n\nasync function* empty() {}\n\nfunction wrapDocumentsIteratorProducer(factory: () => AsyncIterableIterator<SanityDocument>) {\n  function documents() {\n    return factory()\n  }\n\n  ;(documents as any)[Symbol.asyncIterator] = () => {\n    throw new Error(\n      `The migration is attempting to iterate over the \"documents\" function, please call the function instead:\n\n      // BAD:\n      for await (const document of documents) {\n        // ...\n      }\n\n      // GOOD:                        üëá This is a function and has to be called\n      for await (const document of documents()) {\n        // ...\n      }\n      `,\n    )\n  }\n  return documents\n}\n\nexport function collectMigrationMutations(\n  migration: Migration,\n  documents: () => AsyncIterableIterator<SanityDocument>,\n  context: MigrationContext,\n) {\n  const migrate = normalizeMigrateDefinition(migration)\n  return migrate(wrapDocumentsIteratorProducer(documents), context)\n}\n","export const MUTATION_ENDPOINT_MAX_BODY_SIZE = 1024 * 256 // 256KB\nexport const DEFAULT_MUTATION_CONCURRENCY = 6\nexport const MAX_MUTATION_CONCURRENCY = 10\n","import createDebug from 'debug'\n\nexport default createDebug('sanity:migrate')\n","import {type FileHandle, open, unlink} from 'node:fs/promises'\n\nimport baseDebug from '../debug'\n\nconst debug = baseDebug.extend('bufferThroughFile')\n\nconst CHUNK_SIZE = 1024\n\n/**\n * Takes a source stream that will be drained and written to the provided file name as fast as possible.\n * and returns a function that can be called to create multiple readable stream on top of the buffer file.\n * It will start pulling data from the source stream once the first readableStream is created, writing to the buffer file in the background.\n * The readable streams and can be read at any rate (but will not receive data faster than the buffer file is written to).\n * Note: by default, buffering will run to completion, and this may prevent the process from exiting after done reading from the\n * buffered streams. To stop writing to the buffer file, an AbortSignal can be provided and once it's controller aborts, the buffer file will\n * stop. After the signal is aborted, no new buffered readers can be created.\n *\n * @param source - The source readable stream. Will be drained as fast as possible.\n * @param filename - The filename to write to.\n * @param options - Optional AbortSignal to stop writing to the buffer file.\n * @returns A function that can be called multiple times to create a readable stream on top of the buffer file.\n */\nexport function bufferThroughFile(\n  source: ReadableStream<Uint8Array>,\n  filename: string,\n  options?: {signal: AbortSignal; keepFile?: boolean},\n) {\n  const signal = options?.signal\n\n  let writeHandle: FileHandle\n  let readHandle: Promise<FileHandle> | null\n\n  // Whether the all data has been written to the buffer file.\n  let bufferDone = false\n\n  signal?.addEventListener('abort', async () => {\n    debug('Aborting bufferThroughFile')\n    await Promise.all([\n      writeHandle && writeHandle.close(),\n      readHandle && (await readHandle).close(),\n    ])\n  })\n\n  // Number of active readers. When this reaches 0, the read handle will be closed.\n  let readerCount = 0\n  let ready: Promise<void>\n\n  async function pump(reader: ReadableStreamDefaultReader<Uint8Array>) {\n    try {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const {done, value} = await reader.read()\n        if (done || signal?.aborted) {\n          // if we're done reading, or the primary reader has been cancelled, stop writing to the buffer file\n          return\n        }\n        await writeHandle.write(value)\n      }\n    } finally {\n      await writeHandle.close()\n      bufferDone = true\n      reader.releaseLock()\n    }\n  }\n\n  function createBufferedReader() {\n    let totalBytesRead = 0\n\n    return async function tryReadFromBuffer(handle: FileHandle) {\n      const {bytesRead, buffer} = await handle.read(\n        new Uint8Array(CHUNK_SIZE),\n        0,\n        CHUNK_SIZE,\n        totalBytesRead,\n      )\n      if (bytesRead === 0 && !bufferDone && !signal?.aborted) {\n        debug('Not enough data in buffer file, waiting for more data to be written')\n        // we're waiting for more data to be written to the buffer file, try again\n        return tryReadFromBuffer(handle)\n      }\n      totalBytesRead += bytesRead\n      return {bytesRead, buffer}\n    }\n  }\n\n  function init(): Promise<void> {\n    if (!ready) {\n      ready = (async () => {\n        debug('Initializing bufferThroughFile')\n        writeHandle = await open(filename, 'w')\n        // start pumping data from the source stream to the buffer file\n        // note, don't await this, as it will block the ReadableStream.start() method\n        debug('Start buffering source stream to file')\n        pump(source.getReader()).then(() => {\n          debug('Buffering source stream to buffer file')\n        })\n      })()\n    }\n    return ready\n  }\n\n  function getReadHandle(): Promise<FileHandle> {\n    if (!readHandle) {\n      debug('Opening read handle on %s', filename)\n      readHandle = open(filename, 'r')\n    }\n    return readHandle\n  }\n\n  function onReaderStart() {\n    readerCount++\n  }\n  async function onReaderEnd() {\n    readerCount--\n    if (readerCount === 0 && readHandle) {\n      const handle = readHandle\n      readHandle = null\n      debug('Closing read handle on %s', filename)\n      await (await handle).close()\n      if (options?.keepFile !== true) {\n        debug('Removing buffer file', filename)\n        await unlink(filename)\n      }\n    }\n  }\n\n  return () => {\n    const readChunk = createBufferedReader()\n\n    let didEnd = false\n    function onEnd() {\n      if (didEnd) {\n        return\n      }\n      didEnd = true\n      onReaderEnd()\n    }\n    return new ReadableStream<Uint8Array>({\n      async start() {\n        if (signal?.aborted) {\n          throw new Error('Cannot create new buffered readers on aborted stream')\n        }\n        debug('Reader started reading from file handle')\n        onReaderStart()\n        await init()\n        await getReadHandle()\n      },\n      async pull(controller) {\n        if (!readHandle) {\n          throw new Error('Cannot read from closed handle')\n        }\n        const {bytesRead, buffer} = await readChunk(await readHandle)\n        if (bytesRead === 0 && bufferDone) {\n          debug('Reader done reading from file handle')\n          await onEnd()\n          controller.close()\n        } else {\n          controller.enqueue(buffer.subarray(0, bytesRead))\n        }\n      },\n      cancel() {\n        onEnd()\n      },\n    })\n  }\n}\n","/**\n * Copied over from uint8array-extras to sort out ESM build issues. Should be replaced with imports from that module eventually\n */\nconst objectToString = Object.prototype.toString\nconst uint8ArrayStringified = '[object Uint8Array]'\n\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  if (!value) {\n    return false\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true\n  }\n\n  return objectToString.call(value) === uint8ArrayStringified\n}\n\nexport function assertUint8Array(value: unknown): asserts value is Uint8Array {\n  if (!isUint8Array(value)) {\n    throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``)\n  }\n}\n\nexport function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  totalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0)\n\n  const returnValue = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const array of arrays) {\n    assertUint8Array(array)\n    returnValue.set(array, offset)\n    offset += array.length\n  }\n\n  return returnValue\n}\n\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array) {\n  assertUint8Array(a)\n  assertUint8Array(b)\n\n  if (a === b) {\n    return true\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false\n    }\n  }\n\n  return true\n}\n","import {concatUint8Arrays} from '../uint8arrays'\n\nexport function peekInto(readable: ReadableStream, options: {size: number}) {\n  const {size} = options\n  return new Promise<[head: Uint8Array, ReadableStream]>((resolve, reject) => {\n    let totalBytesRead = 0\n    let streamCompleted = false\n    const chunks: Array<Uint8Array> = []\n    const reader = readable.getReader()\n\n    function settled() {\n      const head = concatUint8Arrays(chunks)\n      resolve([\n        head,\n        new ReadableStream<Uint8Array>({\n          start(controller) {\n            controller.enqueue(head)\n            if (streamCompleted) {\n              controller.close()\n            }\n          },\n          async pull(controller) {\n            const {done, value} = await reader.read()\n            if (done) {\n              controller.close()\n            } else {\n              controller.enqueue(value)\n            }\n          },\n        }),\n      ])\n    }\n    ;(async () => {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const {done, value: chunk} = await reader.read()\n        if (done) {\n          streamCompleted = true\n          break\n        } else {\n          totalBytesRead += chunk.byteLength\n          chunks.push(chunk)\n          if (totalBytesRead >= size) {\n            break\n          }\n        }\n      }\n    })().then(settled, reject)\n  })\n}\n","import {peekInto} from './peekInto'\n\nfunction isGzip(buffer: Uint8Array) {\n  return buffer.length > 3 && buffer[0] === 0x1f && buffer[1] === 0x8b && buffer[2] === 0x08\n}\n\nfunction isDeflate(buf: Uint8Array) {\n  return buf.length > 2 && buf[0] === 0x78 && (buf[1] === 1 || buf[1] === 0x9c || buf[1] === 0xda)\n}\n\nexport async function maybeDecompress(readable: ReadableStream<Uint8Array>) {\n  const [head, stream] = await peekInto(readable, {size: 10})\n  if (isGzip(head)) {\n    return stream.pipeThrough(new DecompressionStream('gzip'))\n  }\n  if (isDeflate(head)) {\n    return stream.pipeThrough(new DecompressionStream('deflate-raw'))\n  }\n  return stream\n}\n","import {type FileHandle, open} from 'node:fs/promises'\n\nimport baseDebug from '../debug'\n\nconst debug = baseDebug.extend('readFileAsWebStream')\n\nconst CHUNK_SIZE = 1024 * 16\n\nexport function readFileAsWebStream(filename: string): ReadableStream<Uint8Array> {\n  let fileHandle: FileHandle\n  let position = 0\n\n  return new ReadableStream({\n    async start() {\n      debug('Starting readable stream from', filename)\n      fileHandle = await open(filename, 'r')\n    },\n    async pull(controller) {\n      const {bytesRead, buffer} = await fileHandle.read(\n        new Uint8Array(CHUNK_SIZE),\n        0,\n        CHUNK_SIZE,\n        position,\n      )\n      if (bytesRead === 0) {\n        await fileHandle.close()\n        debug('Closing readable stream from', filename)\n        controller.close()\n      } else {\n        position += bytesRead\n        controller.enqueue(buffer.subarray(0, bytesRead))\n      }\n    },\n\n    cancel() {\n      debug('Cancelling readable stream from', filename)\n      return fileHandle.close()\n    },\n  })\n}\n","/* eslint-disable no-constant-condition */\n/**\n * Helper to drain a stream, useful in cases where you want to keep reading a stream but disregard the received chunks.\n * @param stream - the readable stream to drain\n */\nexport async function drain(stream: ReadableStream) {\n  const reader = stream.getReader()\n  while (true) {\n    const {done} = await reader.read()\n    if (done) {\n      return\n    }\n  }\n}\n","import FIFO from 'fast-fifo'\n\nimport {concatUint8Arrays} from '../uint8arrays'\n\nconst EMPTY = new Uint8Array()\n\n// Extracted from https://github.com/mafintosh/tar-stream/blob/master/extract.js#L8 and converted to ts\nexport class BufferList {\n  public buffered: number\n  public shifted: number\n  private queue: FIFO<Uint8Array>\n  private _offset: number\n\n  constructor() {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push(buffer: Uint8Array) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst(size: number) {\n    return this.buffered === 0 ? null : this._next(size)\n  }\n\n  shift(size: number) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return concatUint8Arrays(chunks)\n  }\n\n  private _next(size: number) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n","/* eslint-disable no-bitwise */\n// Extracted from https://github.com/mafintosh/tar-stream/blob/master/headers.js\n// Converted to TypeScript and removed reliance on Node Buffers\n\nimport {areUint8ArraysEqual} from '../uint8arrays'\n\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = new Uint8Array([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst GNU_MAGIC = new Uint8Array([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = new Uint8Array([0x20, 0x00])\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexport type TarEntryType =\n  | 'file'\n  | 'link'\n  | 'symlink'\n  | 'directory'\n  | 'block-device'\n  | 'character-device'\n  | 'fifo'\n  | 'contiguous-file'\n\nexport interface TarHeader {\n  // type of entry. defaults to file. can be:\n  // file | link | symlink | directory | block-device\n  // character-device | fifo | contiguous-file\n  type: TarEntryType | null\n  // entry name\n  name: string\n  // entry size. defaults to 0\n  size: number | null\n  // entry mode. defaults to 0o755 for dirs and 0o644 otherwise\n  mode: number | null\n  // uid of entry owner. defaults to 0\n  uid: number | null\n  // gid of entry owner. defaults to 0\n  gid: number | null\n  // last modified date for entry. defaults to now.\n  mtime: Date | null\n  // linked file name. only valid for type 'link' and 'symlink' entries\n  linkname: string | null\n  // uname of entry owner. defaults to null\n  uname: string\n  // gname of entry owner. defaults to null\n  gname: string\n  // device major version. defaults to 0\n  devmajor: number | null\n  // device minor version. defaults to 0\n  devminor: number | null\n}\n\nexport function decode(\n  buf: Uint8Array,\n  filenameEncoding: BufferEncoding,\n  allowUnknownFormat: boolean,\n): TarHeader | null {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) {\n    throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n  }\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = `${decodeStr(buf, 345, 155, filenameEncoding)}/${name}`\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else if (!allowUnknownFormat) {\n    throw new Error('Invalid tar header: unknown format.')\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    type: type as TarEntryType,\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: mtime ? new Date(1000 * mtime) : null,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n  }\n}\n\nfunction isUSTAR(buf: Uint8Array) {\n  return areUint8ArraysEqual(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU(buf: Uint8Array) {\n  return (\n    areUint8ArraysEqual(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    areUint8ArraysEqual(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n  )\n}\n\nfunction clamp(index: number, len: number, defaultValue: number) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\nfunction toType(flag: number) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n    default:\n      return null\n  }\n}\n\nfunction indexOf(block: Uint8Array, num: number, offset: number, end: number) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum(block: Uint8Array) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256(buf: Uint8Array) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xff) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xff - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nconst decoders: {[encoding: string]: TextDecoder} = {}\nconst getCachedDecoder = (encoding: string) => {\n  if (!(encoding in decoders)) {\n    decoders[encoding] = new TextDecoder(encoding)\n  }\n  return decoders[encoding]\n}\n\nfunction toString(uint8: Uint8Array, encoding = 'utf-8') {\n  return getCachedDecoder(encoding).decode(uint8)\n}\n\nfunction decodeOct(val: Uint8Array, offset: number, length: number) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  }\n  // Older versions of tar can prefix with spaces\n  while (offset < val.length && val[offset] === 32) offset++\n  const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n  while (offset < end && val[offset] === 0) offset++\n  if (end === offset) return 0\n  return parseInt(toString(val.subarray(offset, end)), 8)\n}\n\nfunction decodeStr(val: Uint8Array, offset: number, length: number, encoding?: string) {\n  return toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n","/* eslint-disable no-bitwise,callback-return */\nimport {BufferList} from './BufferList'\nimport * as headers from './headers'\nimport {type TarHeader} from './headers'\n\n// Inspired by\n// - https://github.com/alanshaw/it-tar/blob/master/src/extract.ts\n// - https://github.com/mafintosh/tar-stream/blob/master/extract.js\n\nconst emptyReadableStream = () =>\n  new ReadableStream({\n    pull(controller) {\n      controller.close()\n    },\n  })\n\nexport function untar(\n  stream: ReadableStream<Uint8Array>,\n  options: {\n    filenameEncoding?: BufferEncoding\n    allowUnknownFormat?: boolean\n  } = {},\n): ReadableStream<[header: TarHeader, entry: ReadableStream<Uint8Array>]> {\n  const buffer = new BufferList()\n\n  const reader = stream.getReader()\n\n  let readingChunk = false\n  return new ReadableStream({\n    async pull(controller) {\n      if (readingChunk) {\n        return\n      }\n      const {done, value} = await reader.read()\n\n      if (!done) {\n        buffer.push(value)\n      }\n\n      const headerChunk = buffer.shift(512)\n      if (!headerChunk) {\n        throw new Error('Unexpected end of tar file. Expected 512 bytes of headers.')\n      }\n\n      const header = headers.decode(\n        headerChunk,\n        options.filenameEncoding ?? 'utf-8',\n        options.allowUnknownFormat ?? false,\n      )\n      if (header) {\n        if (header.size === null || header.size === 0 || header.type === 'directory') {\n          controller.enqueue([header, emptyReadableStream()])\n        } else {\n          readingChunk = true\n          controller.enqueue([\n            header,\n            entryStream(reader, header.size!, buffer, () => {\n              readingChunk = false\n            }),\n          ])\n        }\n      } else if (done) {\n        // note - there might be more data in the buffer, after the input stream is done\n        // so only complete if we couldn't find a header\n        controller.close()\n      }\n    },\n  })\n}\n\nfunction entryStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  expectedBytes: number,\n  buffer: BufferList,\n  next: () => void,\n) {\n  let totalBytesRead = 0\n  // let pulling = false\n  return new ReadableStream({\n    async pull(controller) {\n      const {done, value} = await reader.read()\n      const remaining = expectedBytes - totalBytesRead\n\n      if (!done) {\n        buffer.push(value)\n      }\n\n      const chunk = buffer.shiftFirst(remaining)\n      if (!chunk) {\n        throw new Error('Premature end of tar stream')\n      }\n      controller.enqueue(chunk)\n      totalBytesRead += chunk!.byteLength\n      if (chunk?.byteLength === remaining) {\n        // We've reached the end of the entry, discard any padding at the end (\n        discardPadding(buffer, expectedBytes)\n        controller.close()\n        next()\n      }\n    },\n  })\n}\n\nfunction getPadding(size: number) {\n  size &= 511\n  return size === 0 ? 0 : 512 - size\n}\n\nfunction discardPadding(bl: BufferList, size: number) {\n  const overflow = getPadding(size)\n  if (overflow > 0) {\n    bl.shift(overflow)\n  }\n}\n","export async function* streamToAsyncIterator<T>(stream: ReadableStream<T>) {\n  // Get a lock on the stream\n  const reader = stream.getReader()\n  try {\n    while (true) {\n      // Read from the stream\n      const {done, value} = await reader.read()\n\n      // Exit if we're done\n      if (done) return\n      // Else yield the chunk\n      yield value\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n","import {maybeDecompress} from '../fs-webstream/maybeDecompress'\nimport {readFileAsWebStream} from '../fs-webstream/readFileAsWebStream'\nimport {drain} from '../tar-webstream/drain'\nimport {untar} from '../tar-webstream/untar'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\n\nexport async function* fromExportArchive(path: string) {\n  for await (const [header, entry] of streamToAsyncIterator(\n    untar(await maybeDecompress(readFileAsWebStream(path))),\n  )) {\n    if (header.type === 'file' && header.name.endsWith('.ndjson')) {\n      for await (const chunk of streamToAsyncIterator(entry)) {\n        yield chunk\n      }\n    } else {\n      // It's not ndjson, so drain the entry stream, so we can move on with the next entry\n      await drain(entry)\n    }\n  }\n}\n","type SupportedMethod = 'GET' | 'POST'\nexport type Endpoint = {\n  global: boolean\n  path: `/${string}`\n  searchParams: [param: string, value: string][]\n  method: SupportedMethod\n}\n\nexport const endpoints = {\n  users: {\n    me: (): Endpoint => ({\n      global: true,\n      path: `/users/me`,\n      method: 'GET',\n      searchParams: [],\n    }),\n  },\n  data: {\n    query: (dataset: string): Endpoint => ({\n      global: false,\n      method: 'GET',\n      path: `/query/${dataset}`,\n      searchParams: [],\n    }),\n    export: (dataset: string, documentTypes?: string[]): Endpoint => ({\n      global: false,\n      method: 'GET',\n      path: `/data/export/${dataset}`,\n      searchParams:\n        documentTypes && documentTypes?.length > 0 ? [['types', documentTypes.join(',')]] : [],\n    }),\n    mutate: (\n      dataset: string,\n      options?: {\n        returnIds?: boolean\n        returnDocuments?: boolean\n        autoGenerateArrayKeys?: boolean\n        visibility?: 'async' | 'sync' | 'deferred'\n        dryRun?: boolean\n        tag?: string\n      },\n    ): Endpoint => {\n      const params = [\n        options?.tag && ['tag', options.tag],\n        options?.returnIds && ['returnIds', 'true'],\n        options?.returnDocuments && ['returnDocuments', 'true'],\n        options?.autoGenerateArrayKeys && ['autoGenerateArrayKeys', 'true'],\n        options?.visibility && ['visibility', options.visibility],\n        options?.dryRun && ['dryRun', 'true'],\n      ].filter(Boolean) as [string, string][]\n\n      return {\n        global: false,\n        method: 'POST',\n        path: `/data/mutate/${dataset}`,\n        searchParams: params,\n      }\n    },\n  },\n}\n","import {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\n\nexport interface FetchOptions {\n  url: string | URL\n  init: RequestInit\n}\nexport interface HTTPError extends Error {\n  statusCode: number\n}\n\nexport async function assert2xx(res: Response): Promise<void> {\n  if (res.status < 200 || res.status > 299) {\n    const response = await res.json().catch(() => {\n      throw new Error(`Error parsing JSON ${res.status}: ${res.statusText}`)\n    })\n\n    const message = response.error\n      ? response.error.description\n      : `HTTP Error ${res.status}: ${res.statusText}`\n\n    const err = new Error(message) as HTTPError\n    err.statusCode = res.status\n    throw err\n  }\n}\n\nexport async function fetchStream({url, init}: FetchOptions) {\n  const response = await fetch(url, init)\n  await assert2xx(response)\n  if (response.body === null) throw new Error('No response received')\n  return response.body\n}\n\nexport async function fetchAsyncIterator(options: FetchOptions) {\n  return streamToAsyncIterator(await fetchStream(options))\n}\n","import {type Endpoint} from './endpoints'\nimport {type FetchOptions} from './fetchStream'\n\nfunction getUserAgent() {\n  if (typeof window === 'undefined') {\n    // only set UA if we're in a non-browser environment\n    try {\n      const pkg = require('../../package.json')\n      return `${pkg.name}@${pkg.version}`\n      // eslint-disable-next-line no-empty\n    } catch (err) {}\n  }\n  return null\n}\n\ninterface SanityRequestOptions {\n  endpoint: Endpoint\n  apiVersion: `vX` | `v${number}-${number}-${number}`\n  apiHost: string\n  projectId: string\n  token?: string\n  body?: string\n  tag?: string\n}\n\nfunction normalizeApiHost(apiHost: string) {\n  return apiHost.replace(/^https?:\\/\\//, '')\n}\n\nexport function toFetchOptions(req: SanityRequestOptions): FetchOptions {\n  const {endpoint, apiVersion, tag, projectId, apiHost, token, body} = req\n  const requestInit: RequestInit = {\n    method: endpoint.method || 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body,\n  }\n  const ua = getUserAgent()\n  if (ua) {\n    requestInit.headers = {\n      ...requestInit.headers,\n      'User-Agent': ua,\n    }\n  }\n  if (token) {\n    requestInit.headers = {\n      ...requestInit.headers,\n      Authorization: `bearer ${token}`,\n    }\n  }\n  const normalizedApiHost = normalizeApiHost(apiHost)\n  const path = `/${apiVersion}${endpoint.path}`\n  const host = endpoint.global ? normalizedApiHost : `${projectId}.${normalizedApiHost}`\n  const searchParams = new URLSearchParams([\n    ...endpoint.searchParams,\n    ...(tag ? [['tag', tag]] : []),\n  ]).toString()\n\n  return {\n    url: `https://${host}/${path}${searchParams ? `?${searchParams}` : ''}`,\n    init: requestInit,\n  }\n}\n","import {type SanityDocument} from '@sanity/types'\nimport {createSafeJsonParser} from '@sanity/util/createSafeJsonParser'\n\nimport {endpoints} from '../fetch-utils/endpoints'\nimport {fetchStream} from '../fetch-utils/fetchStream'\nimport {toFetchOptions} from '../fetch-utils/sanityRequestOptions'\nimport {type ExportAPIConfig} from '../types'\n\nexport function fromExportEndpoint(options: ExportAPIConfig) {\n  return fetchStream(\n    toFetchOptions({\n      projectId: options.projectId,\n      apiVersion: options.apiVersion,\n      token: options.token,\n      apiHost: options.apiHost ?? 'api.sanity.io',\n      tag: 'sanity.migration.export',\n      endpoint: endpoints.data.export(options.dataset, options.documentTypes),\n    }),\n  )\n}\n\n/**\n * Safe JSON parser that is able to handle lines interrupted by an error object.\n *\n * This may occur when streaming NDJSON from the Export HTTP API.\n *\n * @internal\n * @see {@link https://github.com/sanity-io/sanity/pull/1787 | Initial pull request}\n */\nexport const safeJsonParser = createSafeJsonParser<SanityDocument>({\n  errorLabel: 'Error streaming dataset',\n})\n","export function asyncIterableToStream<T>(it: AsyncIterableIterator<T>) {\n  return new ReadableStream({\n    async pull(controller) {\n      const {value, done} = await it.next()\n      if (done) {\n        controller.close()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n","import {type SanityDocument} from '@sanity/types'\nimport groq, {type ExprNode} from 'groq-js'\n\nimport {type Migration} from '../../types'\n\nfunction isSystemDocumentId(id: string) {\n  return id.startsWith('_.')\n}\n\nasync function* filterDocumentTypes(\n  documents: AsyncIterableIterator<SanityDocument>,\n  types: string[],\n) {\n  for await (const doc of documents) {\n    if (types.includes(doc._type)) {\n      yield doc\n    }\n  }\n}\n\nfunction parseGroqFilter(filter: string) {\n  try {\n    return groq.parse(`*[${filter}]`)\n  } catch (err) {\n    err.message = `Failed to parse GROQ filter \"${filter}\": ${err.message}`\n    throw err\n  }\n}\n\nexport async function matchesFilter(parsedFilter: ExprNode, document: SanityDocument) {\n  const result = await (await groq.evaluate(parsedFilter, {dataset: [document]})).get()\n  return result.length === 1\n}\n\nexport async function* applyFilters(\n  migration: Migration,\n  documents: AsyncIterableIterator<SanityDocument>,\n) {\n  const documentTypes = migration.documentTypes\n  const parsedFilter = migration.filter ? parseGroqFilter(migration.filter) : undefined\n\n  for await (const doc of documents) {\n    if (isSystemDocumentId(doc._id)) {\n      continue\n    }\n    if (documentTypes && documentTypes.length > 0 && !documentTypes.includes(doc._type)) {\n      continue\n    }\n    if (parsedFilter && !(await matchesFilter(parsedFilter, doc))) {\n      continue\n    }\n    yield doc\n  }\n}\n","// this is the number of requests allowed inflight at once. this is done to prevent\n// the validation library from overwhelming our backend\nimport {createClientConcurrencyLimiter} from '@sanity/util/client'\n\nconst MAX_FETCH_CONCURRENCY = 10\n\nexport const limitClientConcurrency = createClientConcurrencyLimiter(MAX_FETCH_CONCURRENCY)\n","import {createClient, type SanityClient} from '@sanity/client'\n\nimport {limitClientConcurrency} from './limitClientConcurrency'\n\nexport function createContextClient(config: Parameters<typeof createClient>[0]): RestrictedClient {\n  return restrictClient(\n    limitClientConcurrency(\n      createClient({...config, useCdn: false, requestTagPrefix: 'sanity.migration'}),\n    ),\n  )\n}\n\nconst ALLOWED_PROPERTIES = [\n  'fetch',\n  'clone',\n  'config',\n  'withConfig',\n  'getDocument',\n  'getDocuments',\n  'users',\n  'projects',\n] as const\n\ntype AllowedMethods = (typeof ALLOWED_PROPERTIES)[number]\n\nexport type RestrictedClient = Pick<SanityClient, AllowedMethods>\n\nfunction restrictClient(client: SanityClient): RestrictedClient {\n  return new Proxy(client, {\n    get: (target, property) => {\n      switch (property) {\n        case 'clone': {\n          return (...args: Parameters<SanityClient['clone']>) => {\n            return restrictClient(target.clone(...args))\n          }\n        }\n        case 'config': {\n          return (...args: Parameters<SanityClient['config']>) => {\n            const result = target.config(...args)\n\n            // if there is a config, it returns a client so we need to wrap again\n            if (args[0]) return restrictClient(result)\n            return result\n          }\n        }\n        case 'withConfig': {\n          return (...args: Parameters<SanityClient['withConfig']>) => {\n            return restrictClient(target.withConfig(...args))\n          }\n        }\n        default: {\n          if (ALLOWED_PROPERTIES.includes(property as any)) {\n            return target[property as keyof SanityClient]\n          }\n          throw new Error(\n            `Client method \"${String(\n              property,\n            )}\" can not be called during a migration. Only ${ALLOWED_PROPERTIES.join(\n              ', ',\n            )} are allowed.`,\n          )\n        }\n      }\n    },\n  })\n}\n","import {type SanityDocument} from '@sanity/types'\n\nimport {decodeText, type JSONParser, parse} from '../../it-utils'\nimport {safeJsonParser} from '../../sources/fromExportEndpoint'\nimport {type MigrationContext} from '../../types'\nimport {streamToAsyncIterator} from '../../utils/streamToAsyncIterator'\n\nexport function createFilteredDocumentsClient(\n  getFilteredDocumentsReadableStream: () => ReadableStream<Uint8Array>,\n): MigrationContext['filtered'] {\n  function getAllDocumentsFromBuffer<T extends SanityDocument>() {\n    return parse<T>(decodeText(streamToAsyncIterator(getFilteredDocumentsReadableStream())), {\n      parse: safeJsonParser as JSONParser<T>,\n    })\n  }\n\n  async function getDocumentsFromBuffer<T extends SanityDocument>(ids: string[]): Promise<T[]> {\n    const found: {[id: string]: T} = {}\n    let remaining = ids.length\n    for await (const doc of getAllDocumentsFromBuffer<T>()) {\n      if (ids.includes(doc._id)) {\n        remaining--\n        found[doc._id] = doc\n      }\n      if (remaining === 0) break\n    }\n    return ids.map((id) => found[id])\n  }\n\n  async function getDocumentFromBuffer<T extends SanityDocument>(\n    id: string,\n  ): Promise<T | undefined> {\n    return (await getDocumentsFromBuffer<T>([id]))[0]\n  }\n\n  return {\n    getDocument: getDocumentFromBuffer,\n    getDocuments: getDocumentsFromBuffer,\n  }\n}\n","import {mkdir} from 'node:fs/promises'\nimport {tmpdir} from 'node:os'\nimport path from 'node:path'\n\nexport async function createBufferFile() {\n  const bufferDir = path.join(\n    tmpdir(),\n    'sanity-migrate',\n    `${Date.now()}-${Math.random().toString(36).slice(2)}`,\n  )\n\n  await mkdir(bufferDir, {recursive: true})\n  return path.join(bufferDir, `snapshot.ndjson`)\n}\n","import {type SanityDocument} from '@sanity/types'\n\nimport {bufferThroughFile} from '../fs-webstream/bufferThroughFile'\nimport {decodeText} from '../it-utils'\nimport {parse, stringify} from '../it-utils/ndjson'\nimport {fromExportArchive} from '../sources/fromExportArchive'\nimport {fromExportEndpoint, safeJsonParser} from '../sources/fromExportEndpoint'\nimport {type APIConfig, type Migration} from '../types'\nimport {asyncIterableToStream} from '../utils/asyncIterableToStream'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {collectMigrationMutations} from './collectMigrationMutations'\nimport {applyFilters} from './utils/applyFilters'\nimport {createContextClient} from './utils/createContextClient'\nimport {createFilteredDocumentsClient} from './utils/createFilteredDocumentsClient'\nimport {createBufferFile} from './utils/getBufferFile'\n\ninterface MigrationRunnerOptions {\n  api: APIConfig\n  exportPath?: string\n}\n\nexport async function* dryRun(config: MigrationRunnerOptions, migration: Migration) {\n  const source = config.exportPath\n    ? fromExportArchive(config.exportPath)\n    : streamToAsyncIterator(\n        await fromExportEndpoint({...config.api, documentTypes: migration.documentTypes}),\n      )\n\n  const filteredDocuments = applyFilters(\n    migration,\n    parse<SanityDocument>(decodeText(source), {parse: safeJsonParser}),\n  )\n\n  const abortController = new AbortController()\n\n  const createReader = bufferThroughFile(\n    asyncIterableToStream(stringify(filteredDocuments)),\n    await createBufferFile(),\n    {signal: abortController.signal},\n  )\n\n  // Create a client exposed to the migration script. This will have a max concurrency of 10\n  const client = createContextClient({...config.api, useCdn: false})\n\n  const filteredDocumentsClient = createFilteredDocumentsClient(createReader)\n  const context = {\n    client,\n    filtered: filteredDocumentsClient,\n  }\n\n  yield* collectMigrationMutations(\n    migration,\n    () => parse(decodeText(streamToAsyncIterator(createReader())), {parse: safeJsonParser}),\n    context,\n  )\n\n  // stop buffering the export once we're done collecting all mutations\n  abortController.abort()\n}\n","/**\n * Concatenates each chunk of a string iterator to a buffer and yields the buffer when the input iterator is done\n * @param it - The input iterator\n */\nexport async function* concatStr(it: AsyncIterableIterator<string>): AsyncIterableIterator<string> {\n  let buf = ''\n  for await (const chunk of it) {\n    buf += chunk\n  }\n  yield buf\n}\n","interface Options<T> {\n  defaultValue?: T\n}\nexport async function lastValueFrom<T>(\n  it: AsyncIterableIterator<T>,\n  options?: Options<T>,\n): Promise<T> {\n  const defaultGiven = 'defaultValue' in (options ?? {})\n  let latestValue: T | undefined\n  let didYield = false\n\n  for await (const value of it) {\n    didYield = true\n    latestValue = value\n  }\n  if (!didYield) {\n    if (defaultGiven) {\n      return options!.defaultValue!\n    }\n    throw new Error(\n      'No value yielded from async iterable. If this iterable is empty, provide a default value.',\n    )\n  }\n  return latestValue!\n}\n","export async function mapAsync<T, U>(\n  it: AsyncIterableIterator<T>,\n  project: (value: T) => Promise<U>,\n  concurrency: number,\n): Promise<AsyncIterable<U>> {\n  // todo: convert to top level import when we can\n  const {pMapIterable} = await import('p-map')\n\n  return pMapIterable(it, (v) => project(v), {\n    concurrency: concurrency,\n  })\n}\n","export async function* tap<T>(it: AsyncIterableIterator<T>, interceptor: (value: T) => void) {\n  for await (const chunk of it) {\n    interceptor(chunk)\n    yield chunk\n  }\n}\n","import {type Mutation as SanityMutation} from '@sanity/client'\nimport arrify from 'arrify'\n\nimport {type TransactionPayload} from './toSanityMutations'\n\n// We're working on \"raw\" mutations, e.g what will be put into the mutations array in the request body\nconst PADDING_SIZE = '{\"mutations\":[]}'.length\n\nfunction isTransactionPayload(payload: any): payload is TransactionPayload {\n  return payload && payload.mutations && Array.isArray(payload.mutations)\n}\n\n/**\n *\n * @param mutations - Async iterable of either single values or arrays of values\n * @param maxBatchSize - Max batch size in bytes\n * @public\n *\n */\nexport async function* batchMutations(\n  mutations: AsyncIterableIterator<TransactionPayload | SanityMutation | SanityMutation[]>,\n  maxBatchSize: number,\n): AsyncIterableIterator<TransactionPayload> {\n  let currentBatch: SanityMutation[] = []\n  let currentBatchSize = 0\n\n  for await (const mutation of mutations) {\n    if (isTransactionPayload(mutation)) {\n      yield {mutations: currentBatch}\n      yield mutation\n      currentBatch = []\n      currentBatchSize = 0\n      continue\n    }\n\n    // the mutation itself may exceed the payload size, need to handle that\n    const mutationSize = JSON.stringify(mutation).length\n\n    if (mutationSize >= maxBatchSize + PADDING_SIZE) {\n      // the mutation size itself is bigger than max batch size, yield it as a single batch and hope for the best (the server has a bigger limit)\n      if (currentBatch.length) {\n        yield {mutations: currentBatch}\n      }\n      yield {mutations: [...arrify(mutation)]}\n      currentBatch = []\n      currentBatchSize = 0\n      continue\n    }\n    currentBatchSize += mutationSize\n    if (currentBatchSize >= maxBatchSize + PADDING_SIZE) {\n      yield {mutations: currentBatch}\n      currentBatch = []\n      currentBatchSize = 0\n    }\n    currentBatch.push(...arrify(mutation))\n  }\n\n  if (currentBatch.length > 0) {\n    yield {mutations: currentBatch}\n  }\n}\n","import {SanityEncoder} from '@bjoerge/mutiny'\nimport {type Mutation as SanityMutation} from '@sanity/client'\nimport arrify from 'arrify'\n\nimport {type Mutation, type Transaction} from '../../mutations'\nimport {isTransaction} from '../../mutations/asserters'\n\nexport interface TransactionPayload {\n  transactionId?: string\n  mutations: SanityMutation[]\n}\n\nexport async function* toSanityMutations(\n  it: AsyncIterableIterator<Mutation | Transaction | (Mutation | Transaction)[]>,\n): AsyncIterableIterator<SanityMutation[] | TransactionPayload> {\n  for await (const mutation of it) {\n    for (const mut of arrify(mutation)) {\n      if (isTransaction(mut)) {\n        yield {\n          transactionId: mut.id,\n          mutations: SanityEncoder.encode(mut.mutations as any) as SanityMutation[],\n        }\n        continue\n      }\n\n      yield SanityEncoder.encode(arrify(mut) as any[]) as SanityMutation[]\n    }\n  }\n}\n","import {type MultipleMutationResult} from '@sanity/client'\nimport {type SanityDocument} from '@sanity/types'\nimport arrify from 'arrify'\n\nimport {endpoints} from '../fetch-utils/endpoints'\nimport {fetchAsyncIterator, type FetchOptions} from '../fetch-utils/fetchStream'\nimport {toFetchOptions} from '../fetch-utils/sanityRequestOptions'\nimport {bufferThroughFile} from '../fs-webstream/bufferThroughFile'\nimport {decodeText, parseJSON} from '../it-utils'\nimport {concatStr} from '../it-utils/concatStr'\nimport {lastValueFrom} from '../it-utils/lastValueFrom'\nimport {mapAsync} from '../it-utils/mapAsync'\nimport {parse, stringify} from '../it-utils/ndjson'\nimport {tap} from '../it-utils/tap'\nimport {fromExportEndpoint, safeJsonParser} from '../sources/fromExportEndpoint'\nimport {type APIConfig, type Migration, type MigrationProgress} from '../types'\nimport {asyncIterableToStream} from '../utils/asyncIterableToStream'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {collectMigrationMutations} from './collectMigrationMutations'\nimport {\n  DEFAULT_MUTATION_CONCURRENCY,\n  MAX_MUTATION_CONCURRENCY,\n  MUTATION_ENDPOINT_MAX_BODY_SIZE,\n} from './constants'\nimport {applyFilters} from './utils/applyFilters'\nimport {batchMutations} from './utils/batchMutations'\nimport {createContextClient} from './utils/createContextClient'\nimport {createFilteredDocumentsClient} from './utils/createFilteredDocumentsClient'\nimport {createBufferFile} from './utils/getBufferFile'\nimport {toSanityMutations, type TransactionPayload} from './utils/toSanityMutations'\n\nexport interface MigrationRunnerConfig {\n  api: APIConfig\n  concurrency?: number\n  onProgress?: (event: MigrationProgress) => void\n}\n\nexport async function* toFetchOptionsIterable(\n  apiConfig: APIConfig,\n  mutations: AsyncIterableIterator<TransactionPayload>,\n) {\n  for await (const transaction of mutations) {\n    yield toFetchOptions({\n      projectId: apiConfig.projectId,\n      apiVersion: apiConfig.apiVersion,\n      token: apiConfig.token,\n      tag: 'sanity.migration.mutate',\n      apiHost: apiConfig.apiHost ?? 'api.sanity.io',\n      endpoint: endpoints.data.mutate(apiConfig.dataset, {\n        returnIds: true,\n        visibility: 'async',\n        autoGenerateArrayKeys: true,\n      }),\n      body: JSON.stringify(transaction),\n    })\n  }\n}\n\nexport async function run(config: MigrationRunnerConfig, migration: Migration) {\n  const stats: MigrationProgress = {\n    documents: 0,\n    mutations: 0,\n    pending: 0,\n    queuedBatches: 0,\n    completedTransactions: [],\n    currentTransactions: [],\n  }\n\n  const filteredDocuments = applyFilters(\n    migration,\n    parse<SanityDocument>(\n      decodeText(\n        streamToAsyncIterator(\n          await fromExportEndpoint({...config.api, documentTypes: migration.documentTypes}),\n        ),\n      ),\n      {parse: safeJsonParser},\n    ),\n  )\n  const abortController = new AbortController()\n\n  const createReader = bufferThroughFile(\n    asyncIterableToStream(stringify(filteredDocuments)),\n    await createBufferFile(),\n    {signal: abortController.signal},\n  )\n\n  const client = createContextClient({\n    ...config.api,\n    useCdn: false,\n    requestTagPrefix: 'sanity.migration',\n  })\n\n  const filteredDocumentsClient = createFilteredDocumentsClient(createReader)\n  const context = {\n    client,\n    filtered: filteredDocumentsClient,\n  }\n\n  const documents = () =>\n    tap(\n      parse<SanityDocument>(decodeText(streamToAsyncIterator(createReader())), {\n        parse: safeJsonParser,\n      }),\n      () => {\n        config.onProgress?.({...stats, documents: ++stats.documents})\n      },\n    )\n\n  const mutations = tap(collectMigrationMutations(migration, documents, context), (muts) => {\n    stats.currentTransactions = arrify(muts)\n    config.onProgress?.({\n      ...stats,\n      mutations: ++stats.mutations,\n    })\n  })\n\n  const concurrency = config?.concurrency ?? DEFAULT_MUTATION_CONCURRENCY\n\n  if (concurrency > MAX_MUTATION_CONCURRENCY) {\n    throw new Error(`Concurrency exceeds maximum allowed value (${MAX_MUTATION_CONCURRENCY})`)\n  }\n\n  const batches = tap(\n    batchMutations(toSanityMutations(mutations), MUTATION_ENDPOINT_MAX_BODY_SIZE),\n    () => {\n      config.onProgress?.({...stats, queuedBatches: ++stats.queuedBatches})\n    },\n  )\n\n  const submit = async (opts: FetchOptions): Promise<MultipleMutationResult> =>\n    lastValueFrom(parseJSON(concatStr(decodeText(await fetchAsyncIterator(opts)))))\n\n  const commits = await mapAsync(\n    toFetchOptionsIterable(config.api, batches),\n    (opts) => {\n      config.onProgress?.({...stats, pending: ++stats.pending})\n      return submit(opts)\n    },\n    concurrency,\n  )\n\n  for await (const result of commits) {\n    stats.completedTransactions.push(result)\n    config.onProgress?.({\n      ...stats,\n    })\n  }\n  config.onProgress?.({\n    ...stats,\n    done: true,\n  })\n\n  // Cancel export/buffer stream, it's not needed anymore\n  abortController.abort()\n}\n","import {type SanityDocument} from '@sanity/types'\n\nexport function* fromDocuments(documents: SanityDocument[]) {\n  for (const document of documents) {\n    yield document\n  }\n}\n"],"names":["defineMigration","migration","decodeText","it","decoder","TextDecoder","chunk","decode","sleep","ms","Promise","resolve","setTimeout","delay","filter","predicate","parseJSON","parse","JSON","arguments","length","undefined","e","reject","stringifyJSON","stringify","map","project","split","delimiter","buf","includes","lastIndex","lastIndexOf","parts","substring","part","options","line","Boolean","trim","iterable","doc","concat","take","count","i","toArray","result","push","create","document","type","patch","id","patches","arrify","at","path","operation","fromString","op","createIfNotExists","createOrReplace","delete_","del","set","value","setIfMissing","unset","inc","amount","dec","diffMatchPatch","insert","items","position","indexOrReferenceItem","referenceItem","append","prepend","insertBefore","insertAfter","truncate","startIndex","endIndex","replace","transaction","idOrMutations","_mutations","mutations","isMutation","mutation","isTransaction","isOperation","isNodePatch","change","Array","isArray","getValueType","callMap","mapFn","res","getPathWithKey","item","index","container","_key","mapObject","reducerFn","object","Object","keys","flatMap","key","flatMapAny","mapArray","array","val","flatMapDeep","normalizeMigrateDefinition","migrate","normalizeIteratorValues","createAsyncIterableMutation","documentTypes","asyncIterable","run","docs","context","documentMutations","normalizeMutation","ch","isRawMutation","SanityEncoder","opts","documentTypesSet","Set","has","_type","collectDocumentMutations","_a","call","nodeMigrations","nodeReturnValues","nodeTypeReturnValues","all","node","migrateNodeType","normalizeNodeMutation","flat","normalizeDocumentMutation","_id","documentId","_b","_c","_d","_e","_f","string","number","boolean","null","Error","wrapDocumentsIteratorProducer","factory","documents","Symbol","asyncIterator","collectMigrationMutations","MUTATION_ENDPOINT_MAX_BODY_SIZE","DEFAULT_MUTATION_CONCURRENCY","MAX_MUTATION_CONCURRENCY","baseDebug","createDebug","debug","extend","CHUNK_SIZE","bufferThroughFile","source","filename","signal","writeHandle","readHandle","bufferDone","addEventListener","close","readerCount","ready","pump","reader","done","read","aborted","write","releaseLock","createBufferedReader","totalBytesRead","tryReadFromBuffer","handle","bytesRead","buffer","Uint8Array","init","open","getReader","then","getReadHandle","onReaderStart","onReaderEnd","keepFile","unlink","readChunk","didEnd","onEnd","ReadableStream","start","pull","controller","enqueue","subarray","cancel","objectToString","prototype","toString","uint8ArrayStringified","isUint8Array","constructor","assertUint8Array","TypeError","concatUint8Arrays","arrays","totalLength","reduce","accumulator","currentValue","returnValue","offset","areUint8ArraysEqual","a","b","peekInto","readable","size","streamCompleted","chunks","settled","head","byteLength","isGzip","isDeflate","maybeDecompress","stream","pipeThrough","DecompressionStream","readFileAsWebStream","fileHandle","drain","EMPTY","BufferList","buffered","shifted","queue","FIFO","_offset","shiftFirst","_next","shift","peek","rem","sub","ZERO_OFFSET","charCodeAt","USTAR_MAGIC","GNU_MAGIC","GNU_VER","MAGIC_OFFSET","VERSION_OFFSET","filenameEncoding","allowUnknownFormat","typeflag","name","decodeStr","mode","decodeOct","uid","gid","mtime","toType","linkname","uname","gname","devmajor","devminor","c","cksum","isUSTAR","isGNU","Date","clamp","len","defaultValue","flag","indexOf","block","num","end","sum","j","parse256","positive","tuple","byte","l","Math","pow","decoders","getCachedDecoder","encoding","uint8","parseInt","emptyReadableStream","untar","readingChunk","headerChunk","header","headers.decode","entryStream","expectedBytes","next","remaining","discardPadding","getPadding","bl","overflow","streamToAsyncIterator","fromExportArchive","entry","endsWith","endpoints","users","me","global","method","searchParams","data","query","dataset","export","join","mutate","params","tag","returnIds","returnDocuments","autoGenerateArrayKeys","visibility","dryRun","assert2xx","status","response","json","catch","statusText","message","error","description","err","statusCode","fetchStream","_ref","url","fetch","body","fetchAsyncIterator","getUserAgent","window","pkg","require","version","normalizeApiHost","apiHost","toFetchOptions","req","endpoint","apiVersion","projectId","token","requestInit","headers","ua","Authorization","normalizedApiHost","host","URLSearchParams","fromExportEndpoint","safeJsonParser","createSafeJsonParser","errorLabel","asyncIterableToStream","isSystemDocumentId","startsWith","parseGroqFilter","groq","matchesFilter","parsedFilter","evaluate","get","applyFilters","MAX_FETCH_CONCURRENCY","limitClientConcurrency","createClientConcurrencyLimiter","createContextClient","config","restrictClient","createClient","useCdn","requestTagPrefix","ALLOWED_PROPERTIES","client","Proxy","target","property","clone","withConfig","String","createFilteredDocumentsClient","getFilteredDocumentsReadableStream","getAllDocumentsFromBuffer","getDocumentsFromBuffer","ids","found","getDocumentFromBuffer","getDocument","getDocuments","createBufferFile","bufferDir","tmpdir","now","random","slice","mkdir","recursive","exportPath","api","filteredDocuments","abortController","AbortController","createReader","filteredDocumentsClient","filtered","abort","concatStr","lastValueFrom","defaultGiven","latestValue","didYield","mapAsync","concurrency","pMapIterable","v","tap","interceptor","PADDING_SIZE","isTransactionPayload","payload","batchMutations","maxBatchSize","currentBatch","currentBatchSize","mutationSize","toSanityMutations","mut","transactionId","encode","toFetchOptionsIterable","apiConfig","stats","pending","queuedBatches","completedTransactions","currentTransactions","onProgress","muts","batches","submit","commits","fromDocuments"],"mappings":"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"}