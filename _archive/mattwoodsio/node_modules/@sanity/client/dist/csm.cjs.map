{"version":3,"file":"csm.cjs","sources":["../src/csm/applySourceDocuments.ts","../src/csm/resolvedKeyedSourcePath.ts","../src/csm/resolveEditUrl.ts"],"sourcesContent":["import {DRAFTS_PREFIX, getPublishedId} from './getPublishedId'\nimport {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport * as paths from './studioPath'\nimport type {\n  Any,\n  ApplySourceDocumentsUpdateFunction,\n  ClientPerspective,\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  Path,\n  SanityDocument,\n} from './types'\nimport {walkMap} from './walkMap'\n\nconst defaultUpdateFunction = <T = unknown>(changed: T): T => changed\n\n/**\n * Optimistically applies source documents to a result, using the content source map to trace fields.\n * Can be used to apply mutations to documents being edited in a Studio, or any mutation on Content Lake, to a result with extremely low latency.\n * @alpha\n */\nexport function applySourceDocuments<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  getCachedDocument: (\n    sourceDocument: ContentSourceMapDocuments[number],\n  ) => Partial<SanityDocument> | null | undefined,\n  updateFn: ApplySourceDocumentsUpdateFunction = defaultUpdateFunction,\n  perspective: ClientPerspective = 'raw',\n): Result {\n  if (!resultSourceMap) return result\n\n  if (perspective !== 'published' && perspective !== 'raw' && perspective !== 'previewDrafts') {\n    throw new Error(`Unknown perspective \"${perspective}\"`)\n  }\n\n  return walkMap(JSON.parse(JSON.stringify(result)), (value, path) => {\n    const resolveMappingResult = resolveMapping(path, resultSourceMap)\n    if (!resolveMappingResult) {\n      // console.warn('no mapping for path', path)\n      return value\n    }\n\n    const {mapping, pathSuffix} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = resultSourceMap.documents[mapping.source.document]\n    const sourcePath = resultSourceMap.paths[mapping.source.path]\n\n    if (sourceDocument) {\n      const parsedPath = parseJsonPath(sourcePath + pathSuffix)\n      const stringifiedPath = paths.toString(parsedPath as Path)\n\n      // The _id is sometimes used used as `key` in lists, and should not be changed optimistically\n      if (stringifiedPath === '_id') {\n        return value\n      }\n\n      let cachedDocument: Partial<SanityDocument> | null | undefined\n      if (perspective === 'previewDrafts') {\n        cachedDocument = getCachedDocument(\n          sourceDocument._id.startsWith(DRAFTS_PREFIX)\n            ? sourceDocument\n            : {...sourceDocument, _id: `${DRAFTS_PREFIX}${sourceDocument._id}}`},\n        )\n        if (!cachedDocument) {\n          cachedDocument = getCachedDocument(\n            sourceDocument._id.startsWith(DRAFTS_PREFIX)\n              ? {...sourceDocument, _id: getPublishedId(sourceDocument._id)}\n              : sourceDocument,\n          )\n        }\n        if (cachedDocument) {\n          cachedDocument = {\n            ...cachedDocument,\n            _id: getPublishedId(sourceDocument._id),\n            _originalId: sourceDocument._id,\n          }\n        }\n      } else {\n        cachedDocument = getCachedDocument(sourceDocument)\n      }\n\n      if (!cachedDocument) {\n        return value\n      }\n\n      const changedValue = cachedDocument\n        ? paths.get<Result[keyof Result]>(cachedDocument, stringifiedPath, value)\n        : value\n      return value === changedValue\n        ? value\n        : updateFn<Result[keyof Result]>(changedValue as Any, {\n            cachedDocument,\n            previousValue: value as Result[keyof Result],\n            sourceDocument,\n            sourcePath: parsedPath,\n          })\n    }\n\n    return value\n  }) as Result\n}\n","import {jsonPath, parseJsonPath} from './jsonPath'\nimport type {ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolvedKeyedSourcePath(options: {\n  keyedResultPath: ContentSourceMapParsedPath\n  pathSuffix?: string\n  sourceBasePath: string\n}): ContentSourceMapParsedPath {\n  const {keyedResultPath, pathSuffix, sourceBasePath} = options\n\n  const inferredResultPath = pathSuffix === undefined ? [] : parseJsonPath(pathSuffix)\n\n  const inferredPath = keyedResultPath.slice(keyedResultPath.length - inferredResultPath.length)\n\n  const inferredPathSuffix = inferredPath.length ? jsonPath(inferredPath).slice(1) : ''\n\n  return parseJsonPath(sourceBasePath + inferredPathSuffix)\n}\n","import {createEditUrl} from './createEditUrl'\nimport {studioPathToJsonPath} from './jsonPath'\nimport {resolveEditInfo} from './resolveEditInfo'\nimport type {ResolveEditUrlOptions} from './types'\n\n/** @alpha */\nexport function resolveEditUrl(\n  options: ResolveEditUrlOptions,\n): ReturnType<typeof createEditUrl> | undefined {\n  const {resultSourceMap, studioUrl} = options\n  const resultPath = studioPathToJsonPath(options.resultPath)\n\n  const editInfo = resolveEditInfo({\n    resultPath,\n    resultSourceMap,\n    studioUrl,\n  })\n  if (!editInfo) {\n    return undefined\n  }\n\n  return createEditUrl(editInfo)\n}\n"],"names":["walkMap","resolveMapping","parseJsonPath","paths.toString","DRAFTS_PREFIX","getPublishedId","paths.get","jsonPath","studioPathToJsonPath","resolveEditInfo","createEditUrl"],"mappings":";;;AAeA,MAAM,wBAAwB,CAAc,YAAkB;AAOvD,SAAS,qBACd,QACA,iBACA,mBAGA,WAA+C,uBAC/C,cAAiC,OACzB;AACR,MAAI,CAAC;AAAwB,WAAA;AAE7B,MAAI,gBAAgB,eAAe,gBAAgB,SAAS,gBAAgB;AAC1E,UAAM,IAAI,MAAM,wBAAwB,WAAW,GAAG;AAGjD,SAAAA,gBAAA,QAAQ,KAAK,MAAM,KAAK,UAAU,MAAM,CAAC,GAAG,CAAC,OAAO,SAAS;AAC5D,UAAA,uBAAuBC,gBAAAA,eAAe,MAAM,eAAe;AACjE,QAAI,CAAC;AAEI,aAAA;AAGH,UAAA,EAAC,SAAS,WAAc,IAAA;AAK9B,QAJI,QAAQ,SAAS,WAIjB,QAAQ,OAAO,SAAS;AACnB,aAAA;AAGT,UAAM,iBAAiB,gBAAgB,UAAU,QAAQ,OAAO,QAAQ,GAClE,aAAa,gBAAgB,MAAM,QAAQ,OAAO,IAAI;AAE5D,QAAI,gBAAgB;AACZ,YAAA,aAAaC,8BAAc,aAAa,UAAU,GAClD,kBAAkBC,gBAAAA,SAAe,UAAkB;AAGzD,UAAI,oBAAoB;AACf,eAAA;AAGL,UAAA;AACA,UAAA,gBAAgB,mBAClB,iBAAiB;AAAA,QACf,eAAe,IAAI,WAAWC,gBAAa,aAAA,IACvC,iBACA,EAAC,GAAG,gBAAgB,KAAK,GAAGA,gBAAAA,aAAa,GAAG,eAAe,GAAG,IAAG;AAAA,MAAA,GAElE,mBACH,iBAAiB;AAAA,QACf,eAAe,IAAI,WAAWA,gBAAAA,aAAa,IACvC,EAAC,GAAG,gBAAgB,KAAKC,gBAAAA,eAAe,eAAe,GAAG,EAC1D,IAAA;AAAA,MAAA,IAGJ,mBACF,iBAAiB;AAAA,QACf,GAAG;AAAA,QACH,KAAKA,gBAAAA,eAAe,eAAe,GAAG;AAAA,QACtC,aAAa,eAAe;AAAA,MAIhC,MAAA,iBAAiB,kBAAkB,cAAc,GAG/C,CAAC;AACI,eAAA;AAGT,YAAM,eAAe,iBACjBC,oBAAgC,gBAAgB,iBAAiB,KAAK,IACtE;AACJ,aAAO,UAAU,eACb,QACA,SAA+B,cAAqB;AAAA,QAClD;AAAA,QACA,eAAe;AAAA,QACf;AAAA,QACA,YAAY;AAAA,MAAA,CACb;AAAA,IACP;AAEO,WAAA;AAAA,EAAA,CACR;AACH;ACvGO,SAAS,wBAAwB,SAIT;AAC7B,QAAM,EAAC,iBAAiB,YAAY,eAAkB,IAAA,SAEhD,qBAAqB,eAAe,SAAY,CAAK,IAAAJ,gBAAA,cAAc,UAAU,GAE7E,eAAe,gBAAgB,MAAM,gBAAgB,SAAS,mBAAmB,MAAM,GAEvF,qBAAqB,aAAa,SAASK,gBAAAA,SAAS,YAAY,EAAE,MAAM,CAAC,IAAI;AAE5E,SAAAL,gBAAA,cAAc,iBAAiB,kBAAkB;AAC1D;ACdO,SAAS,eACd,SAC8C;AACxC,QAAA,EAAC,iBAAiB,UAAa,IAAA,SAC/B,aAAaM,gBAAA,qBAAqB,QAAQ,UAAU,GAEpD,WAAWC,gBAAAA,gBAAgB;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,EAAA,CACD;AACI,MAAA;AAIL,WAAOC,gBAAAA,cAAc,QAAQ;AAC/B;;;;;;;;;;;;;;"}