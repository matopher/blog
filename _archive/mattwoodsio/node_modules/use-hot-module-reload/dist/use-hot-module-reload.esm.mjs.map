{"version":3,"sources":["../src/use-hot-module-reload.esm.ts"],"sourcesContent":["import {useEffect} from 'react'\n\n// Even accessing `import` for a `typeof` check will throw in non-ESM mode,\n// thus the try/catch\nconst isModule = (() => {\n  try {\n    return typeof import.meta !== 'undefined'\n  } catch (err) {\n    return false\n  }\n})()\n\n// Allow us to short-circuit in production/non-HMR environments\nconst hasHMR = () => {\n  try {\n    return Boolean(isModule && (import.meta.hot || import.meta.webpackHot))\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Trigger a callback after hot-module reloads (any, not only the module using the hook).\n * Use it to force recomputation of stale values and state that do not automatically update.\n * This should be an escape hatch - ideally you shouldn't need this.\n *\n * @param callback - The callback to be triggered after hot-module reloads.\n */\nexport function useHotModuleReload(callback: () => void): void {\n  if (!hasHMR) {\n    return undefined\n  }\n\n  return typeof import.meta.webpackHot === 'undefined'\n    ? // eslint-disable-next-line react-hooks/rules-of-hooks -- Vite vs Webpack won't change at runtime\n      useViteHotModuleReload(callback)\n    : // eslint-disable-next-line react-hooks/rules-of-hooks -- Vite vs Webpack won't change at runtime\n      useWebpackHotModuleReload(callback)\n}\n\nfunction useWebpackHotModuleReload(callback: () => void): void {\n  useEffect(() => {\n    if (import.meta.webpackHot) {\n      // Webpack in CommonJS mode\n      const statusHandler = (status: string): void => (status === 'idle' ? callback() : undefined)\n      import.meta.webpackHot.addStatusHandler(statusHandler)\n\n      return () => import.meta.webpackHot?.removeStatusHandler(statusHandler)\n    }\n\n    return undefined\n  }, [callback])\n}\n\nfunction useViteHotModuleReload(callback: () => void): void {\n  useEffect(() => {\n    // Note: not using early return here in order to optimize tree-shaking\n    if (import.meta.hot) {\n      /**\n       * Unfortunately, there is currently no `vite:afterUpdate` event\n       * (see https://github.com/vitejs/vite/pull/9810), and `react-refresh`\n       * does not expose a way to listen for flushed updates (the vite HMR only\n       * _schedules_ an update - the update is then done asynchronously).\n       *\n       * Many attempts were done to find a way to know that React actually updated\n       * with the new code, but because of layers of timeouts, debouncing, partially\n       * updated trees and whatnot; this is complicated.\n       *\n       * What this actually does is to wait for a `beforeUpdate` event, and then\n       * probe for the `__vite_plugin_react_timeout` window global to become non-zero.\n       * When it is, it means an update is _scheduled_, which has a 30ms timeout and\n       * a 16 ms debounce - so in essence it should be non-zero for about 46ms.\n       *\n       * Once it goes back to 0, it means the update is done, and we can trigger the\n       * callback. Since this is a bit best-effort and not 100% reliable, we also add\n       * a 1000ms timeout to make sure we don't wait forever should the update already\n       * have been applied before we observed the change, or if vite changes the\n       * implementation details (I have requested a callback/event from the vite crew).\n       */\n      const disposers = new Set<() => void>()\n      import.meta.hot.on('vite:beforeUpdate', () => {\n        let flushTimeout: number | ReturnType<typeof setTimeout>\n        let hasSeenScheduledUpdate = window.__vite_plugin_react_timeout > 0\n\n        const refreshProber = setInterval(() => {\n          const now = window.__vite_plugin_react_timeout\n          if (hasSeenScheduledUpdate && now === 0) {\n            complete()\n          } else if (!hasSeenScheduledUpdate && now > 0) {\n            hasSeenScheduledUpdate = true\n          }\n        }, 10)\n\n        const fallbackTimeout = setTimeout(complete, 1000, 'fallback')\n\n        function clear() {\n          clearInterval(refreshProber)\n          clearTimeout(fallbackTimeout)\n          clearTimeout(flushTimeout)\n        }\n\n        function complete() {\n          clear()\n\n          // While the react refresh has been _triggered_ by this point, it may\n          // not be flushed yet. Wait for an additional 50ms to make sure it is.\n          flushTimeout = setTimeout(callback, 50)\n        }\n\n        disposers.add(clear)\n      })\n\n      return () => {\n        disposers.forEach((disposer) => disposer())\n        disposers.clear()\n      }\n    }\n\n    return undefined\n  }, [callback])\n}\n"],"mappings":";AAAA,SAAQ,iBAAgB;AAIxB,IAAM,YAAY,MAAM;AACtB,MAAI;AACF,WAAO,OAAO,gBAAgB;AAAA,EAChC,SAAS,KAAP;AACA,WAAO;AAAA,EACT;AACF,GAAG;AAGH,IAAM,SAAS,MAAM;AACnB,MAAI;AACF,WAAO,QAAQ,aAAa,YAAY,OAAO,YAAY,WAAW;AAAA,EACxE,SAAS,KAAP;AACA,WAAO;AAAA,EACT;AACF;AASO,SAAS,mBAAmB,UAA4B;AAC7D,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA,SAAO,OAAO,YAAY,eAAe,cAErC,uBAAuB,QAAQ,IAE/B,0BAA0B,QAAQ;AACxC;AAEA,SAAS,0BAA0B,UAA4B;AAC7D,YAAU,MAAM;AACd,QAAI,YAAY,YAAY;AAE1B,YAAM,gBAAgB,CAAC,WAA0B,WAAW,SAAS,SAAS,IAAI;AAClF,kBAAY,WAAW,iBAAiB,aAAa;AAErD,aAAO,MAAG;AA/ChB;AA+CmB,iCAAY,eAAZ,mBAAwB,oBAAoB;AAAA;AAAA,IAC3D;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,CAAC;AACf;AAEA,SAAS,uBAAuB,UAA4B;AAC1D,YAAU,MAAM;AAEd,QAAI,YAAY,KAAK;AAsBnB,YAAM,YAAY,oBAAI,IAAgB;AACtC,kBAAY,IAAI,GAAG,qBAAqB,MAAM;AAC5C,YAAI;AACJ,YAAI,yBAAyB,OAAO,8BAA8B;AAElE,cAAM,gBAAgB,YAAY,MAAM;AACtC,gBAAM,MAAM,OAAO;AACnB,cAAI,0BAA0B,QAAQ,GAAG;AACvC,qBAAS;AAAA,UACX,WAAW,CAAC,0BAA0B,MAAM,GAAG;AAC7C,qCAAyB;AAAA,UAC3B;AAAA,QACF,GAAG,EAAE;AAEL,cAAM,kBAAkB,WAAW,UAAU,KAAM,UAAU;AAE7D,iBAAS,QAAQ;AACf,wBAAc,aAAa;AAC3B,uBAAa,eAAe;AAC5B,uBAAa,YAAY;AAAA,QAC3B;AAEA,iBAAS,WAAW;AAClB,gBAAM;AAIN,yBAAe,WAAW,UAAU,EAAE;AAAA,QACxC;AAEA,kBAAU,IAAI,KAAK;AAAA,MACrB,CAAC;AAED,aAAO,MAAM;AACX,kBAAU,QAAQ,CAAC,aAAa,SAAS,CAAC;AAC1C,kBAAU,MAAM;AAAA,MAClB;AAAA,IACF;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,CAAC;AACf;","names":[]}