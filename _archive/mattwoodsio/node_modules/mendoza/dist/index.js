const OPS = [
  "Value",
  "Copy",
  "Blank",
  "ReturnIntoArray",
  "ReturnIntoObject",
  "ReturnIntoObjectSameKey",
  "PushField",
  "PushElement",
  "PushParent",
  "Pop",
  "PushFieldCopy",
  "PushFieldBlank",
  "PushElementCopy",
  "PushElementBlank",
  "ReturnIntoObjectPop",
  "ReturnIntoObjectSameKeyPop",
  "ReturnIntoArrayPop",
  "ObjectSetFieldValue",
  "ObjectCopyField",
  "ObjectDeleteField",
  "ArrayAppendValue",
  "ArrayAppendSlice",
  "StringAppendString",
  "StringAppendSlice"
];
class Patcher {
  constructor(model, root, patch) {
    this.model = model, this.root = root, this.patch = patch, this.i = 0, this.inputStack = [], this.outputStack = [];
  }
  read() {
    return this.patch[this.i++];
  }
  process() {
    for (this.inputStack.push({ value: this.root }), this.outputStack.push({ value: this.root }); this.i < this.patch.length; ) {
      let opcode = this.read(), op = OPS[opcode];
      if (!op)
        throw new Error(`Unknown opcode: ${opcode}`);
      let processor = `process${op}`;
      this[processor].apply(this);
    }
    let entry = this.outputStack.pop();
    return this.finalizeOutput(entry);
  }
  inputEntry() {
    return this.inputStack[this.inputStack.length - 1];
  }
  inputKey(entry, idx) {
    return entry.keys || (entry.keys = this.model.objectGetKeys(entry.value).sort()), entry.keys[idx];
  }
  outputEntry() {
    return this.outputStack[this.outputStack.length - 1];
  }
  outputArray() {
    let entry = this.outputEntry();
    return entry.writeValue || (entry.writeValue = this.model.copyArray(entry.value)), entry.writeValue;
  }
  outputObject() {
    let entry = this.outputEntry();
    return entry.writeValue || (entry.writeValue = this.model.copyObject(entry.value)), entry.writeValue;
  }
  outputString() {
    let entry = this.outputEntry();
    return entry.writeValue || (entry.writeValue = this.model.copyString(entry.value)), entry.writeValue;
  }
  finalizeOutput(entry) {
    return entry.writeValue ? this.model.finalize(entry.writeValue) : entry.value;
  }
  // Processors:
  processValue() {
    let value = this.model.wrap(this.read());
    this.outputStack.push({ value });
  }
  processCopy() {
    let input = this.inputEntry();
    this.outputStack.push({ value: input.value });
  }
  processBlank() {
    this.outputStack.push({ value: null });
  }
  processReturnIntoArray() {
    let entry = this.outputStack.pop(), result = this.finalizeOutput(entry), arr = this.outputArray();
    this.model.arrayAppendValue(arr, result);
  }
  processReturnIntoObject() {
    let key = this.read(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry);
    result = this.model.markChanged(result);
    let obj = this.outputObject();
    this.model.objectSetField(obj, key, result);
  }
  processReturnIntoObjectSameKey() {
    let input = this.inputEntry(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry), obj = this.outputObject();
    this.model.objectSetField(obj, input.key, result);
  }
  processPushField() {
    let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), value = this.model.objectGetField(entry.value, key);
    this.inputStack.push({ value, key });
  }
  processPushElement() {
    let idx = this.read(), entry = this.inputEntry(), value = this.model.arrayGetElement(entry.value, idx);
    this.inputStack.push({ value });
  }
  processPop() {
    this.inputStack.pop();
  }
  processPushFieldCopy() {
    this.processPushField(), this.processCopy();
  }
  processPushFieldBlank() {
    this.processPushField(), this.processBlank();
  }
  processPushElementCopy() {
    this.processPushElement(), this.processCopy();
  }
  processPushElementBlank() {
    this.processPushElement(), this.processBlank();
  }
  processReturnIntoObjectPop() {
    this.processReturnIntoObject(), this.processPop();
  }
  processReturnIntoObjectSameKeyPop() {
    this.processReturnIntoObjectSameKey(), this.processPop();
  }
  processReturnIntoArrayPop() {
    this.processReturnIntoArray(), this.processPop();
  }
  processObjectSetFieldValue() {
    this.processValue(), this.processReturnIntoObject();
  }
  processObjectCopyField() {
    this.processPushField(), this.processCopy(), this.processReturnIntoObjectSameKey(), this.processPop();
  }
  processObjectDeleteField() {
    let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), obj = this.outputObject();
    this.model.objectDeleteField(obj, key);
  }
  processArrayAppendValue() {
    let value = this.model.wrap(this.read()), arr = this.outputArray();
    this.model.arrayAppendValue(arr, value);
  }
  processArrayAppendSlice() {
    let left = this.read(), right = this.read(), str = this.outputArray(), val = this.inputEntry().value;
    this.model.arrayAppendSlice(str, val, left, right);
  }
  processStringAppendString() {
    let value = this.model.wrap(this.read()), str = this.outputString();
    this.model.stringAppendValue(str, value);
  }
  processStringAppendSlice() {
    let left = this.read(), right = this.read(), str = this.outputString(), val = this.inputEntry().value;
    this.model.stringAppendSlice(str, val, left, right);
  }
}
function utf8charSize(code) {
  return code >> 16 ? 4 : code >> 11 ? 3 : code >> 7 ? 2 : 1;
}
function utf8stringSize(str) {
  let b = 0;
  for (let i = 0; i < str.length; i++) {
    let code = str.codePointAt(i), size = utf8charSize(code);
    size == 4 && i++, b += size;
  }
  return b;
}
function utf8resolveIndex(str, idx, start = 0) {
  let byteCount = start, ucsIdx = 0;
  for (ucsIdx = start; byteCount < idx; ucsIdx++) {
    let code = str.codePointAt(ucsIdx), size = utf8charSize(code);
    size === 4 && ucsIdx++, byteCount += size;
  }
  return ucsIdx;
}
function commonPrefix(str, str2) {
  let len = Math.min(str.length, str2.length), b = 0;
  for (let i = 0; i < len; ) {
    let aPoint = str.codePointAt(i), bPoint = str2.codePointAt(i);
    if (aPoint !== bPoint)
      return b;
    let size = utf8charSize(aPoint);
    b += size, i += size === 4 ? 2 : 1;
  }
  return b;
}
function commonSuffix(str, str2, prefix = 0) {
  let len = Math.min(str.length, str2.length) - prefix, b = 0;
  for (let i = 0; i < len; ) {
    let aPoint = str.codePointAt(str.length - 1 - i), bPoint = str2.codePointAt(str2.length - 1 - i);
    if (aPoint !== bPoint)
      return b;
    let size = utf8charSize(aPoint);
    b += size, i += size === 4 ? 2 : 1;
  }
  return b;
}
class IncrementalModel {
  constructor(meta) {
    this.meta = meta;
  }
  wrap(data) {
    return this.wrapWithMeta(data, this.meta, this.meta);
  }
  wrapWithMeta(data, startMeta, endMeta = this.meta) {
    return { data, startMeta, endMeta };
  }
  asObject(value) {
    if (!value.content) {
      let fields = {};
      for (let [key, val] of Object.entries(value.data))
        fields[key] = this.wrapWithMeta(val, value.startMeta);
      value.content = { type: "object", fields };
    }
    return value.content;
  }
  asArray(value) {
    if (!value.content) {
      let elements = value.data.map(
        (item) => this.wrapWithMeta(item, value.startMeta)
      ), metas = elements.map(() => this.meta);
      value.content = { type: "array", elements, metas };
    }
    return value.content;
  }
  asString(value) {
    if (!value.content) {
      let str = value.data, part = {
        value: str,
        utf8size: utf8stringSize(str),
        uses: [],
        startMeta: value.startMeta,
        endMeta: value.endMeta
      };
      value.content = this.stringFromParts([part]);
    }
    return value.content;
  }
  stringFromParts(parts) {
    let str = {
      type: "string",
      parts
    };
    for (let part of parts)
      part.uses.push(str);
    return str;
  }
  objectGetKeys(value) {
    return value.content ? Object.keys(value.content.fields) : Object.keys(value.data);
  }
  objectGetField(value, key) {
    return this.asObject(value).fields[key];
  }
  arrayGetElement(value, idx) {
    return this.asArray(value).elements[idx];
  }
  finalize(content) {
    return this.updateEndMeta(content), { content, startMeta: this.meta, endMeta: this.meta };
  }
  markChanged(value) {
    return this.wrap(unwrap(value));
  }
  updateEndMeta(content) {
    if (content.type == "string")
      for (let part of content.parts)
        part.endMeta = this.meta;
    else if (content.type === "array")
      for (let val of content.elements)
        val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
    else
      for (let val of Object.values(content.fields))
        val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
  }
  copyString(value) {
    if (value) {
      let other = this.asString(value);
      return this.stringFromParts(other.parts.slice());
    } else
      return {
        type: "string",
        parts: []
      };
  }
  copyObject(value) {
    let obj = {
      type: "object",
      fields: {}
    };
    if (value) {
      let other = this.asObject(value);
      Object.assign(obj.fields, other.fields);
    }
    return obj;
  }
  copyArray(value) {
    let arr = value ? this.asArray(value) : null, elements = arr ? arr.elements : [], metas = arr ? arr.metas : [];
    return {
      type: "array",
      elements,
      metas
    };
  }
  objectSetField(target, key, value) {
    target.fields[key] = value;
  }
  objectDeleteField(target, key) {
    delete target.fields[key];
  }
  arrayAppendValue(target, value) {
    target.elements.push(value), target.metas.push(this.meta);
  }
  arrayAppendSlice(target, source, left, right) {
    let arr = this.asArray(source), samePosition = arr.elements.length === left;
    if (target.elements.push(...arr.elements.slice(left, right)), samePosition)
      target.metas.push(...arr.metas.slice(left, right));
    else
      for (let i = left; i < right; i++)
        target.metas.push(this.meta);
  }
  stringAppendValue(target, value) {
    let str = this.asString(value);
    for (let part of str.parts)
      this.stringAppendPart(target, part);
  }
  stringAppendPart(target, part) {
    target.parts.push(part), part.uses.push(target);
  }
  resolveStringPart(str, from, len) {
    if (len === 0)
      return from;
    for (let i = from; i < str.parts.length; i++) {
      let part = str.parts[i];
      if (len === part.utf8size)
        return i + 1;
      if (len < part.utf8size)
        return this.splitString(part, len), i + 1;
      len -= part.utf8size;
    }
    throw new Error("splitting string out of bounds");
  }
  splitString(part, idx) {
    let leftValue, rightValue, leftSize = idx, rightSize = part.utf8size - leftSize;
    if (part.utf8size !== part.value.length) {
      let byteCount = 0;
      for (idx = 0; byteCount < leftSize; idx++) {
        let code = part.value.codePointAt(idx), size = utf8charSize(code);
        size === 4 && idx++, byteCount += size;
      }
    }
    leftValue = part.value.slice(0, idx), rightValue = part.value.slice(idx);
    let newPart = {
      value: rightValue,
      utf8size: rightSize,
      uses: part.uses.slice(),
      startMeta: part.startMeta,
      endMeta: part.endMeta
    };
    part.value = leftValue, part.utf8size = leftSize;
    for (let use of part.uses) {
      let ndx = use.parts.indexOf(part);
      if (ndx === -1)
        throw new Error("bug: mismatch between string parts and use.");
      use.parts.splice(ndx + 1, 0, newPart);
    }
  }
  stringAppendSlice(target, source, left, right) {
    let str = this.asString(source), firstPart = this.resolveStringPart(str, 0, left), lastPart = this.resolveStringPart(str, firstPart, right - left);
    for (let i = firstPart; i < lastPart; i++) {
      let part = str.parts[i];
      this.stringAppendPart(target, part);
    }
  }
}
function wrap(data, meta) {
  return { data, startMeta: meta, endMeta: meta };
}
function unwrap(value) {
  if (typeof value.data < "u")
    return value.data;
  let result, content = value.content;
  switch (content.type) {
    case "string":
      result = content.parts.map((part) => part.value).join("");
      break;
    case "array":
      result = content.elements.map((val) => unwrap(val));
      break;
    case "object": {
      result = {};
      for (let [key, val] of Object.entries(content.fields))
        result[key] = unwrap(val);
    }
  }
  return value.data = result, result;
}
function getType(value) {
  return value.content ? value.content.type : Array.isArray(value.data) ? "array" : value.data === null ? "null" : typeof value.data;
}
function rebaseValue(left, right) {
  let leftType = getType(left), rightType = getType(right);
  if (leftType !== rightType)
    return right;
  let leftModel = new IncrementalModel(left.endMeta), rightModel = new IncrementalModel(right.endMeta);
  switch (leftType) {
    case "object": {
      let leftObj = leftModel.asObject(left), rightObj = rightModel.asObject(right), identicalFieldCount = 0, leftFieldCount = Object.keys(leftObj.fields).length, rightFieldCount = Object.keys(rightObj.fields).length;
      for (let [key, rightVal] of Object.entries(rightObj.fields)) {
        let leftVal = leftObj.fields[key];
        leftVal && (rightObj.fields[key] = rebaseValue(leftVal, rightVal), rightObj.fields[key] === leftVal && identicalFieldCount++);
      }
      return leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount ? left : right;
    }
    case "array": {
      let leftArr = leftModel.asArray(left), rightArr = rightModel.asArray(right);
      if (leftArr.elements.length !== rightArr.elements.length)
        break;
      let numRebased = 0;
      for (let i = 0; i < rightArr.elements.length; i++)
        rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]), rightArr.elements[i] !== leftArr.elements[i] && numRebased++;
      return numRebased === 0 ? left : right;
    }
    case "null":
    case "boolean":
    case "number": {
      if (unwrap(left) === unwrap(right))
        return left;
      break;
    }
    case "string": {
      let leftRaw = unwrap(left), rightRaw = unwrap(right);
      if (leftRaw === rightRaw)
        return left;
      let result = rightModel.copyString(null), prefix = commonPrefix(leftRaw, rightRaw), suffix = commonSuffix(leftRaw, rightRaw, prefix), rightLen = utf8stringSize(rightRaw), leftLen = utf8stringSize(leftRaw);
      0 < prefix && rightModel.stringAppendSlice(result, left, 0, prefix), prefix < rightLen - suffix && rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix), leftLen - suffix < leftLen && rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
      let value = rightModel.finalize(result);
      if (unwrap(value) !== rightRaw)
        throw new Error("incorrect string rebase");
      return value;
    }
  }
  return right;
}
function applyPatch$1(left, patch, startMeta) {
  let model = new IncrementalModel(startMeta);
  return new Patcher(model, left, patch).process();
}
var incrementalPatcher = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  applyPatch: applyPatch$1,
  getType,
  rebaseValue,
  unwrap,
  wrap
});
class SimpleModel {
  wrap(data) {
    return data;
  }
  finalize(b) {
    return Array.isArray(b) ? b : b.data;
  }
  markChanged(value) {
    return value;
  }
  objectGetKeys(value) {
    return Object.keys(value);
  }
  objectGetField(value, key) {
    return value[key];
  }
  arrayGetElement(value, idx) {
    return value[idx];
  }
  copyObject(value) {
    let res = {
      type: "object",
      data: {}
    };
    if (value !== null)
      for (let [key, val] of Object.entries(value))
        res.data[key] = val;
    return res;
  }
  copyArray(value) {
    return value === null ? [] : value.slice();
  }
  copyString(value) {
    return {
      type: "string",
      data: value === null ? "" : value
    };
  }
  objectSetField(target, key, value) {
    target.data[key] = value;
  }
  objectDeleteField(target, key) {
    delete target.data[key];
  }
  arrayAppendValue(target, value) {
    target.push(value);
  }
  arrayAppendSlice(target, source, left, right) {
    target.push(...source.slice(left, right));
  }
  stringAppendSlice(target, source, left, right) {
    const sourceString = source, leftPos = utf8resolveIndex(sourceString, left), rightPos = utf8resolveIndex(sourceString, right, leftPos);
    target.data += sourceString.slice(leftPos, rightPos);
  }
  stringAppendValue(target, value) {
    target.data += value;
  }
}
function applyPatch(left, patch) {
  let root = left;
  return new Patcher(new SimpleModel(), root, patch).process();
}
export {
  applyPatch,
  incrementalPatcher as incremental
};
//# sourceMappingURL=index.js.map
