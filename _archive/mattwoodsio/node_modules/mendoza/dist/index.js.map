{"version":3,"file":"index.js","sources":["../src/internal-patcher.ts","../src/utf8.ts","../src/incremental-patcher.ts","../src/simple-patcher.ts"],"sourcesContent":["import {ObjectModel} from './object-model'\nimport {RawPatch} from './patch'\n\nconst OPS = [\n  'Value',\n  'Copy',\n  'Blank',\n  'ReturnIntoArray',\n  'ReturnIntoObject',\n  'ReturnIntoObjectSameKey',\n  'PushField',\n  'PushElement',\n  'PushParent',\n  'Pop',\n  'PushFieldCopy',\n  'PushFieldBlank',\n  'PushElementCopy',\n  'PushElementBlank',\n  'ReturnIntoObjectPop',\n  'ReturnIntoObjectSameKeyPop',\n  'ReturnIntoArrayPop',\n  'ObjectSetFieldValue',\n  'ObjectCopyField',\n  'ObjectDeleteField',\n  'ArrayAppendValue',\n  'ArrayAppendSlice',\n  'StringAppendString',\n  'StringAppendSlice',\n]\n\ntype InputEntry<V> = {\n  value: V\n  key?: string\n  keys?: string[]\n}\n\ntype OutputEntry<V, S, O, A> = {\n  value: V | null\n  writeValue?: S | O | A\n}\n\nexport class Patcher<V, S, O, A> {\n  model: ObjectModel<V, S, O, A>\n  root: V\n  patch: RawPatch\n  i: number\n  inputStack: InputEntry<V>[]\n  outputStack: OutputEntry<V, S, O, A>[]\n\n  constructor(model: ObjectModel<V, S, O, A>, root: V, patch: RawPatch) {\n    this.model = model\n    this.root = root\n    this.patch = patch\n    this.i = 0\n    this.inputStack = []\n    this.outputStack = []\n  }\n\n  read(): unknown {\n    return this.patch[this.i++]\n  }\n\n  process() {\n    this.inputStack.push({value: this.root})\n    this.outputStack.push({value: this.root})\n\n    for (; this.i < this.patch.length; ) {\n      let opcode = this.read() as number\n      let op = OPS[opcode]\n      if (!op) throw new Error(`Unknown opcode: ${opcode}`)\n      let processor = `process${op}`\n      ;(this as any)[processor].apply(this)\n    }\n\n    let entry = this.outputStack.pop()!\n    return this.finalizeOutput(entry)\n  }\n\n  inputEntry(): InputEntry<V> {\n    return this.inputStack[this.inputStack.length - 1]\n  }\n\n  inputKey(entry: InputEntry<V>, idx: number): string {\n    if (!entry.keys) {\n      entry.keys = this.model.objectGetKeys(entry.value).sort()\n    }\n\n    return entry.keys[idx]\n  }\n\n  outputEntry(): OutputEntry<V, S, O, A> {\n    return this.outputStack[this.outputStack.length - 1]\n  }\n\n  outputArray(): A {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyArray(entry.value)\n    }\n\n    return entry.writeValue as A\n  }\n\n  outputObject(): O {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyObject(entry.value)\n    }\n\n    return entry.writeValue as O\n  }\n\n  outputString(): S {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyString(entry.value)\n    }\n\n    return entry.writeValue as S\n  }\n\n  finalizeOutput(entry: OutputEntry<V, S, O, A>): V {\n    if (entry.writeValue) {\n      return this.model.finalize(entry.writeValue)\n    } else {\n      return entry.value!\n    }\n  }\n\n  // Processors:\n\n  processValue() {\n    let value = this.model.wrap(this.read())\n    this.outputStack.push({value})\n  }\n\n  processCopy() {\n    let input = this.inputEntry()\n    this.outputStack.push({value: input.value})\n  }\n\n  processBlank() {\n    this.outputStack.push({value: null})\n  }\n\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    let arr = this.outputArray()\n    this.model.arrayAppendValue(arr, result)\n  }\n\n  processReturnIntoObject() {\n    let key = this.read() as string\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    result = this.model.markChanged(result)\n    let obj = this.outputObject()\n    this.model.objectSetField(obj, key, result)\n  }\n\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry()\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    let obj = this.outputObject()\n    this.model.objectSetField(obj, input.key!, result)\n  }\n\n  processPushField() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let key = this.inputKey(entry, idx)\n    let value = this.model.objectGetField(entry.value, key)\n    this.inputStack.push({value, key})\n  }\n\n  processPushElement() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let value = this.model.arrayGetElement(entry.value, idx)\n    this.inputStack.push({value})\n  }\n\n  processPop() {\n    this.inputStack.pop()\n  }\n\n  processPushFieldCopy() {\n    this.processPushField()\n    this.processCopy()\n  }\n\n  processPushFieldBlank() {\n    this.processPushField()\n    this.processBlank()\n  }\n\n  processPushElementCopy() {\n    this.processPushElement()\n    this.processCopy()\n  }\n\n  processPushElementBlank() {\n    this.processPushElement()\n    this.processBlank()\n  }\n\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject()\n    this.processPop()\n  }\n\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey()\n    this.processPop()\n  }\n\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray()\n    this.processPop()\n  }\n\n  processObjectSetFieldValue() {\n    this.processValue()\n    this.processReturnIntoObject()\n  }\n\n  processObjectCopyField() {\n    this.processPushField()\n    this.processCopy()\n    this.processReturnIntoObjectSameKey()\n    this.processPop()\n  }\n\n  processObjectDeleteField() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let key = this.inputKey(entry, idx)\n    let obj = this.outputObject()\n    this.model.objectDeleteField(obj, key)\n  }\n\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read())\n    let arr = this.outputArray()\n    this.model.arrayAppendValue(arr, value)\n  }\n\n  processArrayAppendSlice() {\n    let left = this.read() as number\n    let right = this.read() as number\n    let str = this.outputArray()\n    let val = this.inputEntry().value\n    this.model.arrayAppendSlice(str, val, left, right)\n  }\n\n  processStringAppendString() {\n    let value = this.model.wrap(this.read())\n    let str = this.outputString()\n    this.model.stringAppendValue(str, value)\n  }\n\n  processStringAppendSlice() {\n    let left = this.read() as number\n    let right = this.read() as number\n    let str = this.outputString()\n    let val = this.inputEntry().value\n    this.model.stringAppendSlice(str, val, left, right)\n  }\n}\n","export function utf8charSize(code: number): 1 | 2 | 3 | 4 {\n  if (code >> 16) {\n    return 4\n  } else if (code >> 11) {\n    return 3\n  } else if (code >> 7) {\n    return 2\n  } else {\n    return 1\n  }\n}\n\nexport function utf8stringSize(str: string): number {\n  let b = 0\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i)!\n    let size = utf8charSize(code)\n    if (size == 4) i++\n    b += size\n  }\n  return b\n}\n\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nexport function utf8resolveIndex(str: string, idx: number, start = 0) {\n  let byteCount = start\n  let ucsIdx = 0\n\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx)!\n    let size = utf8charSize(code)\n    if (size === 4) ucsIdx++ // Surrogate pair.\n    byteCount += size\n  }\n\n  return ucsIdx\n}\n\nexport function commonPrefix(str: string, str2: string) {\n  let len = Math.min(str.length, str2.length)\n  let b = 0\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(i)!\n    let bPoint = str2.codePointAt(i)!\n    if (aPoint !== bPoint) return b\n    let size = utf8charSize(aPoint)\n    b += size\n    i += size === 4 ? 2 : 1\n  }\n  return b\n}\n\nexport function commonSuffix(str: string, str2: string, prefix: number = 0) {\n  let len = Math.min(str.length, str2.length) - prefix\n  let b = 0\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(str.length - 1 - i)!\n    let bPoint = str2.codePointAt(str2.length - 1 - i)!\n    if (aPoint !== bPoint) return b\n    let size = utf8charSize(aPoint)\n    b += size\n    i += size === 4 ? 2 : 1\n  }\n  return b\n}\n","import {Patcher} from './internal-patcher'\nimport type {ObjectModel} from './object-model'\nimport type {RawPatch} from './patch'\nimport {commonPrefix, commonSuffix, utf8charSize, utf8stringSize} from './utf8'\n\n// The incremental patcher allows you to apply multiple patches and tracks the history of every element.\n// It also allows you to extract a simple diff between the documents.\n\nexport type Value<T> = {\n  data?: unknown\n  content?: Content<T>\n  startMeta: T\n  endMeta: T\n}\n\nexport type Type = 'array' | 'string' | 'object' | 'number' | 'boolean' | 'null'\n\nexport type Content<T> = ObjectContent<T> | ArrayContent<T> | StringContent<T>\n\nexport type ObjectContent<T> = {\n  type: 'object'\n  fields: {[key: string]: Value<T>}\n}\n\nexport type ArrayContent<T> = {\n  type: 'array'\n  elements: Value<T>[]\n  metas: T[]\n}\n\nexport type StringContent<T> = {\n  type: 'string'\n  parts: StringPart<T>[]\n}\n\nexport type StringPart<T> = {\n  value: string\n  utf8size: number\n  uses: StringContent<T>[]\n  startMeta: T\n  endMeta: T\n}\n\nclass IncrementalModel<T>\n  implements ObjectModel<Value<T>, StringContent<T>, ObjectContent<T>, ArrayContent<T>>\n{\n  meta: T\n\n  constructor(meta: T) {\n    this.meta = meta\n  }\n\n  wrap(data: unknown): Value<T> {\n    return this.wrapWithMeta(data, this.meta, this.meta)\n  }\n\n  wrapWithMeta(data: unknown, startMeta: T, endMeta: T = this.meta): Value<T> {\n    return {data, startMeta, endMeta}\n  }\n\n  asObject(value: Value<T>): ObjectContent<T> {\n    if (!value.content) {\n      let fields: ObjectContent<T>['fields'] = {}\n      for (let [key, val] of Object.entries(value.data as any)) {\n        fields[key] = this.wrapWithMeta(val, value.startMeta)\n      }\n      value.content = {type: 'object', fields}\n    }\n\n    return value.content as ObjectContent<T>\n  }\n\n  asArray(value: Value<T>): ArrayContent<T> {\n    if (!value.content) {\n      let elements = (value.data as unknown[]).map((item) =>\n        this.wrapWithMeta(item, value.startMeta),\n      )\n      let metas = elements.map(() => this.meta)\n      value.content = {type: 'array', elements, metas}\n    }\n\n    return value.content as ArrayContent<T>\n  }\n\n  asString(value: Value<T>): StringContent<T> {\n    if (!value.content) {\n      let str = value.data as string\n\n      let part: StringPart<T> = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta,\n      }\n      value.content = this.stringFromParts([part])\n    }\n\n    return value.content as StringContent<T>\n  }\n\n  stringFromParts(parts: StringPart<T>[]): StringContent<T> {\n    let str: StringContent<T> = {\n      type: 'string',\n      parts,\n    }\n\n    for (let part of parts) {\n      part.uses.push(str)\n    }\n\n    return str\n  }\n\n  objectGetKeys(value: Value<T>): string[] {\n    if (value.content) {\n      return Object.keys((value.content as ObjectContent<T>).fields)\n    } else {\n      return Object.keys(value.data as any)\n    }\n  }\n\n  objectGetField(value: Value<T>, key: string): Value<T> {\n    let obj = this.asObject(value)\n    return obj.fields[key]\n  }\n\n  arrayGetElement(value: Value<T>, idx: number): Value<T> {\n    let arr = this.asArray(value)\n    return arr.elements[idx]\n  }\n\n  finalize(content: Content<T>): Value<T> {\n    this.updateEndMeta(content)\n    return {content, startMeta: this.meta, endMeta: this.meta}\n  }\n\n  markChanged(value: Value<T>): Value<T> {\n    return this.wrap(unwrap(value))\n  }\n\n  updateEndMeta(content: Content<T>) {\n    if (content.type == 'string') {\n      for (let part of content.parts) {\n        part.endMeta = this.meta\n      }\n    } else {\n      if (content.type === 'array') {\n        for (let val of content.elements) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content)\n          }\n          val.endMeta = this.meta\n        }\n      } else {\n        for (let val of Object.values(content.fields)) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content)\n          }\n          val.endMeta = this.meta\n        }\n      }\n    }\n  }\n\n  copyString(value: Value<T> | null): StringContent<T> {\n    if (value) {\n      let other = this.asString(value)\n      return this.stringFromParts(other.parts.slice())\n    } else {\n      return {\n        type: 'string',\n        parts: [],\n      }\n    }\n  }\n\n  copyObject(value: Value<T> | null): ObjectContent<T> {\n    let obj: ObjectContent<T> = {\n      type: 'object',\n      fields: {},\n    }\n\n    if (value) {\n      let other = this.asObject(value)\n      Object.assign(obj.fields, other.fields)\n    }\n\n    return obj\n  }\n\n  copyArray(value: Value<T> | null): ArrayContent<T> {\n    let arr = value ? this.asArray(value) : null\n    let elements = arr ? arr.elements : []\n    let metas = arr ? arr.metas : []\n\n    return {\n      type: 'array',\n      elements,\n      metas,\n    }\n  }\n\n  objectSetField(target: ObjectContent<T>, key: string, value: Value<T>): void {\n    target.fields[key] = value\n  }\n\n  objectDeleteField(target: ObjectContent<T>, key: string): void {\n    delete target.fields[key]\n  }\n\n  arrayAppendValue(target: ArrayContent<T>, value: Value<T>): void {\n    target.elements.push(value)\n    target.metas.push(this.meta)\n  }\n\n  arrayAppendSlice(target: ArrayContent<T>, source: Value<T>, left: number, right: number): void {\n    let arr = this.asArray(source)\n    let samePosition = arr.elements.length === left\n\n    target.elements.push(...arr.elements.slice(left, right))\n\n    if (samePosition) {\n      target.metas.push(...arr.metas.slice(left, right))\n    } else {\n      for (let i = left; i < right; i++) {\n        target.metas.push(this.meta)\n      }\n    }\n  }\n\n  stringAppendValue(target: StringContent<T>, value: Value<T>): void {\n    let str = this.asString(value)\n    for (let part of str.parts) {\n      this.stringAppendPart(target, part)\n    }\n  }\n\n  stringAppendPart(target: StringContent<T>, part: StringPart<T>): void {\n    target.parts.push(part)\n    part.uses.push(target)\n  }\n\n  resolveStringPart(str: StringContent<T>, from: number, len: number): number {\n    if (len === 0) return from\n\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i]\n\n      if (len === part.utf8size) {\n        // Matches perfect!\n        return i + 1\n      }\n\n      if (len < part.utf8size) {\n        // It's a part of this chunk. We now need to split it up.\n        this.splitString(part, len)\n        return i + 1\n      }\n\n      len -= part.utf8size\n    }\n\n    throw new Error('splitting string out of bounds')\n  }\n\n  splitString(part: StringPart<T>, idx: number) {\n    let leftValue\n    let rightValue\n    let leftSize = idx\n    let rightSize = part.utf8size - leftSize\n\n    // idx is here in UTF-8 index, not codepoint index.\n    // This means we might to adjust for multi-byte characters.\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0\n\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx)!\n        let size = utf8charSize(code)\n        if (size === 4) idx++ // Surrogate pair.\n        byteCount += size\n      }\n    }\n\n    leftValue = part.value.slice(0, idx)\n    rightValue = part.value.slice(idx)\n\n    let newPart: StringPart<T> = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta,\n    }\n\n    part.value = leftValue\n    part.utf8size = leftSize\n\n    for (let use of part.uses) {\n      // Insert the new part.\n      let ndx = use.parts.indexOf(part)\n      if (ndx === -1) throw new Error('bug: mismatch between string parts and use.')\n      use.parts.splice(ndx + 1, 0, newPart)\n    }\n  }\n\n  stringAppendSlice(target: StringContent<T>, source: Value<T>, left: number, right: number): void {\n    let str = this.asString(source)\n    let firstPart = this.resolveStringPart(str, 0, left)\n    let lastPart = this.resolveStringPart(str, firstPart, right - left)\n\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i]\n      this.stringAppendPart(target, part)\n    }\n  }\n}\n\n// Turns a native JavaScript object into a Value with a given origin.\nexport function wrap<T>(data: unknown, meta: T): Value<T> {\n  return {data, startMeta: meta, endMeta: meta}\n}\n\n// Converts a Value into a native JavaScript type.\nexport function unwrap<T>(value: Value<T>): unknown {\n  if (typeof value.data !== 'undefined') return value.data\n\n  let result: any\n  let content = value.content!\n  switch (content.type) {\n    case 'string':\n      result = content.parts.map((part) => part.value).join('')\n      break\n    case 'array':\n      result = content.elements.map((val) => unwrap(val))\n      break\n    case 'object': {\n      result = {}\n      for (let [key, val] of Object.entries(content.fields)) {\n        result[key] = unwrap(val)\n      }\n    }\n  }\n\n  value.data = result\n  return result\n}\n\n// Returns the type of a Value.\nexport function getType<T>(value: Value<T>): Type {\n  if (value.content) return value.content.type\n  if (Array.isArray(value.data!)) return 'array'\n  if (value.data === null) return 'null'\n\n  return typeof value.data as Type\n}\n\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nexport function rebaseValue<T>(left: Value<T>, right: Value<T>): Value<T> {\n  let leftType = getType(left)\n  let rightType = getType(right)\n  if (leftType !== rightType) return right\n\n  let leftModel = new IncrementalModel(left.endMeta)\n  let rightModel = new IncrementalModel(right.endMeta)\n\n  switch (leftType) {\n    case 'object': {\n      let leftObj = leftModel.asObject(left)\n      let rightObj = rightModel.asObject(right)\n\n      // Number of fields which are identical in left and right.\n      let identicalFieldCount = 0\n      let leftFieldCount = Object.keys(leftObj.fields).length\n      let rightFieldCount = Object.keys(rightObj.fields).length\n\n      for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n        let leftVal = leftObj.fields[key]\n        if (leftVal) {\n          rightObj.fields[key] = rebaseValue(leftVal, rightVal)\n          if (rightObj.fields[key] === leftVal) {\n            identicalFieldCount++\n          }\n        }\n      }\n\n      let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount\n      return isIdentical ? left : right\n    }\n    case 'array': {\n      let leftArr = leftModel.asArray(left)\n      let rightArr = rightModel.asArray(right)\n\n      if (leftArr.elements.length !== rightArr.elements.length) {\n        break\n      }\n\n      let numRebased = 0\n      for (let i = 0; i < rightArr.elements.length; i++) {\n        rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i])\n        if (rightArr.elements[i] !== leftArr.elements[i]) {\n          numRebased++\n        }\n      }\n\n      return numRebased === 0 ? left : right\n    }\n    case 'null':\n    case 'boolean':\n    case 'number': {\n      if (unwrap(left) === unwrap(right)) return left\n      break\n    }\n    case 'string': {\n      let leftRaw = unwrap(left) as string\n      let rightRaw = unwrap(right) as string\n      if (leftRaw === rightRaw) return left\n\n      let result = rightModel.copyString(null)\n      let prefix = commonPrefix(leftRaw, rightRaw)\n      let suffix = commonSuffix(leftRaw, rightRaw, prefix)\n\n      let rightLen = utf8stringSize(rightRaw)\n      let leftLen = utf8stringSize(leftRaw)\n\n      if (0 < prefix) {\n        rightModel.stringAppendSlice(result, left, 0, prefix)\n      }\n      if (prefix < rightLen - suffix) {\n        rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix)\n      }\n      if (leftLen - suffix < leftLen) {\n        rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen)\n      }\n      let value = rightModel.finalize(result)\n      if (unwrap(value) !== rightRaw) throw new Error('incorrect string rebase')\n      return value\n    }\n  }\n\n  return right\n}\n\nexport function applyPatch<T>(left: Value<T>, patch: RawPatch, startMeta: T) {\n  let model = new IncrementalModel(startMeta)\n  let patcher = new Patcher(model, left, patch)\n  return patcher.process()\n}\n","import {Patcher} from './internal-patcher'\nimport {ObjectModel} from './object-model'\nimport {RawPatch} from './patch'\nimport {utf8resolveIndex} from './utf8'\n\ntype StringBuilder = {type: 'string'; data: string}\ntype ObjectBuilder = {type: 'object'; data: {[key: string]: unknown}}\ntype ArrayBuilder = unknown[]\n\nclass SimpleModel implements ObjectModel<unknown, StringBuilder, ObjectBuilder, ArrayBuilder> {\n  wrap(data: any): unknown {\n    return data\n  }\n\n  finalize(b: StringBuilder | ObjectBuilder | ArrayBuilder): unknown {\n    if (Array.isArray(b)) {\n      return b\n    } else {\n      return b.data\n    }\n  }\n\n  markChanged(value: unknown) {\n    return value\n  }\n\n  objectGetKeys(value: unknown): string[] {\n    return Object.keys(value as any)\n  }\n\n  objectGetField(value: unknown, key: string): unknown {\n    return (value as any)[key]\n  }\n\n  arrayGetElement(value: unknown, idx: number): unknown {\n    return (value as any[])[idx]\n  }\n\n  copyObject(value: unknown | null): ObjectBuilder {\n    let res: ObjectBuilder = {\n      type: 'object',\n      data: {},\n    }\n    if (value !== null) {\n      for (let [key, val] of Object.entries(value as ObjectBuilder)) {\n        res.data[key] = val\n      }\n    }\n    return res\n  }\n\n  copyArray(value: unknown | null): ArrayBuilder {\n    if (value === null) return []\n    return (value as ArrayBuilder).slice()\n  }\n\n  copyString(value: unknown | null): StringBuilder {\n    return {\n      type: 'string',\n      data: value === null ? '' : (value as string),\n    }\n  }\n\n  objectSetField(target: ObjectBuilder, key: string, value: unknown): void {\n    target.data[key] = value\n  }\n\n  objectDeleteField(target: ObjectBuilder, key: string): void {\n    delete target.data[key]\n  }\n\n  arrayAppendValue(target: ArrayBuilder, value: unknown): void {\n    target.push(value)\n  }\n\n  arrayAppendSlice(target: ArrayBuilder, source: unknown, left: number, right: number): void {\n    target.push(...(source as ArrayBuilder).slice(left, right))\n  }\n\n  stringAppendSlice(target: StringBuilder, source: unknown, left: number, right: number): void {\n    const sourceString = source as string\n\n    const leftPos = utf8resolveIndex(sourceString, left)\n    const rightPos = utf8resolveIndex(sourceString, right, leftPos)\n\n    target.data += sourceString.slice(leftPos, rightPos)\n  }\n\n  stringAppendValue(target: StringBuilder, value: unknown): void {\n    target.data += value as string\n  }\n}\n\n// Applies a patch on a JavaScript object.\nexport function applyPatch(left: any, patch: RawPatch): any {\n  let root = left // No need to wrap because the representation is the same.\n  let patcher = new Patcher(new SimpleModel(), root, patch)\n  return patcher.process()\n}\n"],"names":["applyPatch"],"mappings":"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"}