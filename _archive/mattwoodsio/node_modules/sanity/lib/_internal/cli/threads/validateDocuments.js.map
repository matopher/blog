{"version":3,"file":"validateDocuments.js","sources":["../../../../src/_internal/cli/util/extractDocumentsFromNdjsonOrTarball.ts","../../../../src/_internal/cli/threads/validateDocuments.ts"],"sourcesContent":["import {type SanityDocument} from '@sanity/types'\nimport path from 'path'\nimport readline from 'readline'\nimport {Readable, type Writable} from 'stream'\nimport tar from 'tar-stream'\nimport zlib from 'zlib'\n\nconst HEADER_SIZE = 300\n\n// https://github.com/kevva/is-gzip/blob/13dab7c877787bd5cff9de5482b1736f00df99c6/index.js\nconst isGzip = (buf: Buffer) =>\n  buf.length >= 3 && buf[0] === 0x1f && buf[1] === 0x8b && buf[2] === 0x08\n\n// https://github.com/watson/is-deflate/blob/f9e8f0c7814eed715e13e29e97c69acee319686a/index.js\nconst isDeflate = (buf: Buffer) =>\n  buf.length >= 2 && buf[0] === 0x78 && (buf[1] === 1 || buf[1] === 0x9c || buf[1] === 0xda)\n\n// https://github.com/kevva/is-tar/blob/d295ffa2002a5d415946fc3d49f024ace8c28bd3/index.js\nconst isTar = (buf: Buffer) =>\n  buf.length >= 262 &&\n  buf[257] === 0x75 &&\n  buf[258] === 0x73 &&\n  buf[259] === 0x74 &&\n  buf[260] === 0x61 &&\n  buf[261] === 0x72\n\nasync function* extract<TReturn>(\n  stream: AsyncIterable<Buffer>,\n  extractor: Writable & AsyncIterable<TReturn>,\n) {\n  // set up a task to drain the input iterable into the extractor asynchronously\n  // before this function delegates to the extractor's iterable (containing the\n  // result of the extraction)\n  const drained = new Promise<void>((resolve, reject) => {\n    // setTimeout is used here to ensure draining occurs after delegation\n    setTimeout(async () => {\n      try {\n        for await (const chunk of stream) extractor.write(chunk)\n        extractor.end()\n        resolve()\n      } catch (err) {\n        reject(err)\n      }\n    })\n  })\n\n  // have this function delegate the results of the extractor\n  yield* extractor\n  await drained\n  extractor.destroy()\n}\n\n/**\n * Given a async iterable of buffers, looks at the header of the file in the\n * first few bytes to see the file type then extracts the contents tries again.\n * If the given iterable of buffers is a tarball then it looks for an ndjson\n * files and returns another iterable of buffers with the contents of the\n * ndjson file\n */\nasync function* maybeExtractNdjson(stream: AsyncIterable<Buffer>): AsyncIterable<Buffer> {\n  let buffer = Buffer.alloc(0)\n\n  for await (const chunk of stream) {\n    buffer = Buffer.concat([buffer, chunk])\n    if (buffer.length < HEADER_SIZE) continue\n\n    const fileHeader = buffer\n    const restOfStream = async function* restOfStream() {\n      yield fileHeader\n      yield* stream\n    }\n\n    if (isGzip(fileHeader)) {\n      yield* maybeExtractNdjson(extract(restOfStream(), zlib.createGunzip()))\n      return\n    }\n\n    if (isDeflate(fileHeader)) {\n      yield* maybeExtractNdjson(extract(restOfStream(), zlib.createDeflate()))\n      return\n    }\n\n    if (isTar(fileHeader)) {\n      for await (const entry of extract(restOfStream(), tar.extract())) {\n        const filename = path.basename(entry.header.name)\n        const extname = path.extname(filename).toLowerCase()\n        // ignore hidden and non-ndjson files\n        if (extname !== '.ndjson' || filename.startsWith('.')) continue\n\n        for await (const ndjsonChunk of entry) yield ndjsonChunk\n        return\n      }\n    }\n\n    yield* restOfStream()\n  }\n}\n\n/**\n * Takes in an async iterable of buffers from an ndjson file or tarball and\n * returns an async iterable of sanity documents.\n */\nexport async function* extractDocumentsFromNdjsonOrTarball(\n  file: AsyncIterable<Buffer>,\n): AsyncIterable<SanityDocument> {\n  const lines = readline.createInterface({\n    input: Readable.from(maybeExtractNdjson(file)),\n  })\n\n  for await (const line of lines) {\n    const trimmed = line.trim()\n    if (trimmed) yield JSON.parse(trimmed) as SanityDocument\n  }\n  lines.close()\n}\n","import {\n  type ClientConfig,\n  createClient,\n  type SanityClient,\n  type SanityDocument,\n} from '@sanity/client'\nimport {isReference, type ValidationContext, type ValidationMarker} from '@sanity/types'\nimport fs from 'fs'\nimport os from 'os'\nimport path from 'path'\nimport readline from 'readline'\nimport {isRecord, validateDocument} from 'sanity'\nimport {Readable} from 'stream'\nimport {isMainThread, parentPort, workerData as _workerData} from 'worker_threads'\n\nimport {extractDocumentsFromNdjsonOrTarball} from '../util/extractDocumentsFromNdjsonOrTarball'\nimport {getStudioWorkspaces} from '../util/getStudioWorkspaces'\nimport {mockBrowserEnvironment} from '../util/mockBrowserEnvironment'\nimport {\n  createReporter,\n  type WorkerChannel,\n  type WorkerChannelEvent,\n  type WorkerChannelStream,\n} from '../util/workerChannels'\n\nconst MAX_VALIDATION_CONCURRENCY = 100\nconst DOCUMENT_VALIDATION_TIMEOUT = 30000\nconst REFERENCE_INTEGRITY_BATCH_SIZE = 100\n\ninterface AvailabilityResponse {\n  omitted: {id: string; reason: 'existence' | 'permission'}[]\n}\n\nexport interface ValidateDocumentsWorkerData {\n  workDir: string\n  configPath?: string\n  workspace?: string\n  clientConfig?: Partial<ClientConfig>\n  projectId?: string\n  dataset?: string\n  ndjsonFilePath?: string\n  level?: ValidationMarker['level']\n  maxCustomValidationConcurrency?: number\n}\n\nexport type ValidationWorkerChannel = WorkerChannel<{\n  loadedWorkspace: WorkerChannelEvent<{\n    name: string\n    projectId: string\n    dataset: string\n    studioHost: string | null\n    basePath: string\n  }>\n  loadedDocumentCount: WorkerChannelEvent<{documentCount: number}>\n  exportProgress: WorkerChannelStream<{downloadedCount: number; documentCount: number}>\n  exportFinished: WorkerChannelEvent<{totalDocumentsToValidate: number}>\n  loadedReferenceIntegrity: WorkerChannelEvent\n  validation: WorkerChannelStream<{\n    validatedCount: number\n    documentId: string\n    documentType: string\n    intentUrl?: string\n    revision: string\n    level: ValidationMarker['level']\n    markers: ValidationMarker[]\n  }>\n}>\n\nconst {\n  clientConfig,\n  workDir,\n  workspace: workspaceName,\n  configPath,\n  dataset,\n  ndjsonFilePath,\n  projectId,\n  level,\n  maxCustomValidationConcurrency,\n} = _workerData as ValidateDocumentsWorkerData\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nconst levelValues = {error: 0, warning: 1, info: 2} as const\n\nconst report = createReporter<ValidationWorkerChannel>(parentPort)\n\nconst getReferenceIds = (value: unknown) => {\n  const ids = new Set<string>()\n\n  function traverse(node: unknown) {\n    if (isReference(node)) {\n      ids.add(node._ref)\n      return\n    }\n\n    if (typeof node === 'object' && node) {\n      // Note: this works for arrays too\n      for (const item of Object.values(node)) traverse(item)\n    }\n  }\n\n  traverse(value)\n\n  return ids\n}\n\nconst idRegex = /^[^-][A-Z0-9._-]*$/i\n\n// during testing, the `doc` endpoint 502'ed if given an invalid ID\nconst isValidId = (id: unknown) => typeof id === 'string' && idRegex.test(id)\nconst shouldIncludeDocument = (document: SanityDocument) => {\n  // Filter out system documents\n  return !document._type.startsWith('system.')\n}\n\nasync function* readerToGenerator(reader: ReadableStreamDefaultReader<Uint8Array>) {\n  while (true) {\n    const {value, done} = await reader.read()\n    if (value) yield value\n    if (done) return\n  }\n}\n\nvalidateDocuments()\n\nasync function loadWorkspace() {\n  const workspaces = await getStudioWorkspaces({basePath: workDir, configPath})\n\n  if (!workspaces.length) {\n    throw new Error(`Configuration did not return any workspaces.`)\n  }\n\n  let _workspace\n  if (workspaceName) {\n    _workspace = workspaces.find((w) => w.name === workspaceName)\n    if (!_workspace) {\n      throw new Error(`Could not find any workspaces with name \\`${workspaceName}\\``)\n    }\n  } else {\n    if (workspaces.length !== 1) {\n      throw new Error(\n        \"Multiple workspaces found. Please specify which workspace to use with '--workspace'.\",\n      )\n    }\n    _workspace = workspaces[0]\n  }\n  const workspace = _workspace\n\n  const client = createClient({\n    ...clientConfig,\n    dataset: dataset || workspace.dataset,\n    projectId: projectId || workspace.projectId,\n    requestTagPrefix: 'sanity.cli.validate',\n  }).config({apiVersion: 'v2021-03-25'})\n\n  let studioHost\n  try {\n    const project = await client.projects.getById(projectId || workspace.projectId)\n    studioHost = project.metadata.externalStudioHost || project.studioHost\n  } catch {\n    // no big deal if we fail to get the studio host\n    studioHost = null\n  }\n\n  report.event.loadedWorkspace({\n    projectId: workspace.projectId,\n    dataset: workspace.dataset,\n    name: workspace.name,\n    studioHost,\n    basePath: workspace.basePath,\n  })\n\n  return {workspace, client, studioHost}\n}\n\nasync function downloadFromExport(client: SanityClient) {\n  const exportUrl = new URL(client.getUrl(`/data/export/${client.config().dataset}`, false))\n\n  const documentCount = await client.fetch('length(*)')\n  report.event.loadedDocumentCount({documentCount})\n\n  const {token} = client.config()\n  const response = await fetch(exportUrl, {\n    headers: new Headers({...(token && {Authorization: `Bearer ${token}`})}),\n  })\n\n  const reader = response.body?.getReader()\n  if (!reader) throw new Error('Could not get reader from response body.')\n\n  let downloadedCount = 0\n  const referencedIds = new Set<string>()\n  const documentIds = new Set<string>()\n  const lines = readline.createInterface({input: Readable.from(readerToGenerator(reader))})\n\n  // Note: we stream the export to a file and then re-read from that file to\n  // make this less memory intensive.\n  // this is a similar pattern to the import/export CLI commands\n  const slugDate = new Date()\n    .toISOString()\n    .replace(/[^a-z0-9]/gi, '-')\n    .toLowerCase()\n  const tempOutputFile = path.join(os.tmpdir(), `sanity-validate-${slugDate}.ndjson`)\n  const outputStream = fs.createWriteStream(tempOutputFile)\n\n  for await (const line of lines) {\n    const document = JSON.parse(line) as SanityDocument\n\n    if (shouldIncludeDocument(document)) {\n      documentIds.add(document._id)\n      for (const referenceId of getReferenceIds(document)) {\n        referencedIds.add(referenceId)\n      }\n\n      outputStream.write(`${line}\\n`)\n    }\n\n    downloadedCount++\n    report.stream.exportProgress.emit({downloadedCount, documentCount})\n  }\n\n  await new Promise<void>((resolve, reject) =>\n    outputStream.close((err) => (err ? reject(err) : resolve())),\n  )\n\n  report.stream.exportProgress.end()\n  report.event.exportFinished({totalDocumentsToValidate: documentIds.size})\n\n  const getDocuments = () =>\n    extractDocumentsFromNdjsonOrTarball(fs.createReadStream(tempOutputFile))\n\n  return {documentIds, referencedIds, getDocuments, cleanup: () => fs.promises.rm(tempOutputFile)}\n}\n\nasync function downloadFromFile(filePath: string) {\n  const referencedIds = new Set<string>()\n  const documentIds = new Set<string>()\n  const getDocuments = () => extractDocumentsFromNdjsonOrTarball(fs.createReadStream(filePath))\n\n  for await (const document of getDocuments()) {\n    if (shouldIncludeDocument(document)) {\n      documentIds.add(document._id)\n      for (const referenceId of getReferenceIds(document)) {\n        referencedIds.add(referenceId)\n      }\n    }\n  }\n\n  report.event.exportFinished({totalDocumentsToValidate: documentIds.size})\n\n  return {documentIds, referencedIds, getDocuments, cleanup: undefined}\n}\n\ninterface CheckReferenceExistenceOptions {\n  client: SanityClient\n  referencedIds: Set<string>\n  documentIds: Set<string>\n}\n\nasync function checkReferenceExistence({\n  client,\n  documentIds,\n  referencedIds: _referencedIds,\n}: CheckReferenceExistenceOptions) {\n  const existingIds = new Set(documentIds)\n  const idsToCheck = Array.from(_referencedIds)\n    .filter((id) => !existingIds.has(id) && isValidId(id))\n    .sort()\n\n  const batches = idsToCheck.reduce<string[][]>(\n    (acc, next, index) => {\n      const batchIndex = Math.floor(index / REFERENCE_INTEGRITY_BATCH_SIZE)\n      const batch = acc[batchIndex]\n      batch.push(next)\n      return acc\n    },\n    Array.from<string[]>({\n      length: Math.ceil(idsToCheck.length / REFERENCE_INTEGRITY_BATCH_SIZE),\n    }).map(() => []),\n  )\n\n  for (const batch of batches) {\n    const {omitted} = await client.request<AvailabilityResponse>({\n      uri: client.getDataUrl('doc', batch.join(',')),\n      json: true,\n      query: {excludeContent: 'true'},\n      tag: 'documents-availability',\n    })\n\n    const omittedIds = omitted.reduce<Record<string, 'existence' | 'permission'>>((acc, next) => {\n      acc[next.id] = next.reason\n      return acc\n    }, {})\n\n    for (const id of batch) {\n      // unless the document ID is in the `omitted` object explictly due to\n      // the reason `'existence'`, then it should exist\n      if (omittedIds[id] !== 'existence') {\n        existingIds.add(id)\n      }\n    }\n  }\n  report.event.loadedReferenceIntegrity()\n\n  return {existingIds}\n}\n\nasync function validateDocuments() {\n  // note: this is dynamically imported because this module is ESM only and this\n  // file gets compiled to CJS at this time\n  const {default: pMap} = await import('p-map')\n\n  const cleanupBrowserEnvironment = mockBrowserEnvironment(workDir)\n\n  let cleanupDownloadedDocuments: (() => Promise<void>) | undefined\n\n  try {\n    const {client, workspace, studioHost} = await loadWorkspace()\n    const {documentIds, referencedIds, getDocuments, cleanup} = ndjsonFilePath\n      ? await downloadFromFile(ndjsonFilePath)\n      : await downloadFromExport(client)\n    cleanupDownloadedDocuments = cleanup\n    const {existingIds} = await checkReferenceExistence({client, referencedIds, documentIds})\n\n    const getClient = <TOptions extends Partial<ClientConfig>>(options: TOptions) =>\n      client.withConfig(options)\n\n    const getDocumentExists: ValidationContext['getDocumentExists'] = ({id}) =>\n      Promise.resolve(existingIds.has(id))\n\n    const getLevel = (markers: ValidationMarker[]) => {\n      let foundWarning = false\n      for (const marker of markers) {\n        if (marker.level === 'error') return 'error'\n        if (marker.level === 'warning') foundWarning = true\n      }\n\n      if (foundWarning) return 'warning'\n      return 'info'\n    }\n\n    let validatedCount = 0\n\n    const validate = async (document: SanityDocument) => {\n      let markers: ValidationMarker[]\n\n      try {\n        const timeout = Symbol('timeout')\n\n        const result = await Promise.race([\n          validateDocument({\n            document,\n            workspace,\n            getClient,\n            getDocumentExists,\n            environment: 'cli',\n            maxCustomValidationConcurrency,\n          }),\n          new Promise<typeof timeout>((resolve) =>\n            setTimeout(() => resolve(timeout), DOCUMENT_VALIDATION_TIMEOUT),\n          ),\n        ])\n\n        if (result === timeout) {\n          throw new Error(\n            `Document '${document._id}' failed to validate within ${DOCUMENT_VALIDATION_TIMEOUT}ms.`,\n          )\n        }\n\n        markers = result\n          // remove deprecated `item` from the marker\n          .map(({item, ...marker}) => marker)\n          // filter out unwanted levels\n          .filter((marker) => {\n            const markerValue = levelValues[marker.level]\n            const flagLevelValue =\n              levelValues[level as keyof typeof levelValues] ?? levelValues.info\n            return markerValue <= flagLevelValue\n          })\n      } catch (err) {\n        const errorMessage =\n          isRecord(err) && typeof err.message === 'string' ? err.message : 'Unknown error'\n\n        const message = `Exception occurred while validating value: ${errorMessage}`\n\n        markers = [\n          {\n            message,\n            level: 'error',\n            path: [],\n          },\n        ]\n      }\n\n      validatedCount++\n\n      const intentUrl =\n        studioHost &&\n        `${studioHost}${path.resolve(\n          workspace.basePath,\n          `/intent/edit/id=${encodeURIComponent(document._id)};type=${encodeURIComponent(\n            document._type,\n          )}`,\n        )}`\n\n      report.stream.validation.emit({\n        documentId: document._id,\n        documentType: document._type,\n        revision: document._rev,\n        ...(intentUrl && {intentUrl}),\n        markers,\n        validatedCount,\n        level: getLevel(markers),\n      })\n    }\n\n    await pMap(getDocuments(), validate, {concurrency: MAX_VALIDATION_CONCURRENCY})\n\n    report.stream.validation.end()\n  } finally {\n    await cleanupDownloadedDocuments?.()\n    cleanupBrowserEnvironment()\n  }\n}\n"],"names":["HEADER_SIZE","isGzip","buf","length","isDeflate","isTar","extract","stream","extractor","drained","Promise","resolve","reject","setTimeout","chunk","write","end","err","destroy","maybeExtractNdjson","buffer","Buffer","alloc","concat","fileHeader","restOfStream","restOfStream2","zlib","createGunzip","createDeflate","entry","tar","default","filename","path","basename","header","name","extname","toLowerCase","startsWith","ndjsonChunk","extractDocumentsFromNdjsonOrTarball","file","lines","readline","createInterface","input","Readable","from","line","trimmed","trim","JSON","parse","close","MAX_VALIDATION_CONCURRENCY","DOCUMENT_VALIDATION_TIMEOUT","REFERENCE_INTEGRITY_BATCH_SIZE","clientConfig","workDir","workspace","workspaceName","configPath","dataset","ndjsonFilePath","projectId","level","maxCustomValidationConcurrency","_workerData","isMainThread","parentPort","Error","levelValues","error","warning","info","report","createReporter","getReferenceIds","value","ids","Set","traverse","node","isReference","add","_ref","item","Object","values","idRegex","isValidId","id","test","shouldIncludeDocument","document","_type","readerToGenerator","reader","done","read","validateDocuments","loadWorkspace","workspaces","getStudioWorkspaces","basePath","_workspace","find","w","client","createClient","requestTagPrefix","config","apiVersion","studioHost","project","projects","getById","metadata","externalStudioHost","event","loadedWorkspace","downloadFromExport","_a","exportUrl","URL","getUrl","documentCount","fetch","loadedDocumentCount","token","response","headers","Headers","Authorization","body","getReader","downloadedCount","referencedIds","documentIds","slugDate","Date","toISOString","replace","tempOutputFile","join","os","tmpdir","outputStream","fs","createWriteStream","_id","referenceId","exportProgress","emit","exportFinished","totalDocumentsToValidate","size","getDocuments","createReadStream","cleanup","promises","rm","downloadFromFile","filePath","checkReferenceExistence","_referencedIds","existingIds","idsToCheck","Array","filter","has","sort","batches","reduce","acc","next","index","batchIndex","Math","floor","batch","push","ceil","map","omitted","request","uri","getDataUrl","json","query","excludeContent","tag","omittedIds","reason","loadedReferenceIntegrity","pMap","cleanupBrowserEnvironment","mockBrowserEnvironment","cleanupDownloadedDocuments","getClient","options","withConfig","getDocumentExists","_ref2","getLevel","markers","foundWarning","marker","validatedCount","validate","timeout","Symbol","result","race","validateDocument","environment","_ref3","markerValue","flagLevelValue","errorMessage","isRecord","message","intentUrl","encodeURIComponent","validation","documentId","documentType","revision","_rev","concurrency"],"mappings":"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"}