'use strict';

var jsxRuntime = require('react/jsx-runtime');
var ui = require('@sanity/ui');
var React = require('react');
var sanity = require('sanity');
var StructureToolProvider = require('./StructureToolProvider-DndCsu52.js');
var router = require('sanity/router');
var omit = require('lodash/omit.js');
var rxjs = require('rxjs');
var nanoid = require('nanoid');
var operators = require('rxjs/operators');
var generateHelpUrl = require('@sanity/generate-help-url');
var isEqual = require('lodash/isEqual.js');
var uuid = require('@sanity/uuid');
var icons = require('@sanity/icons');
var styled = require('styled-components');
var TooltipDelayGroupProvider = require('./TooltipDelayGroupProvider-CXQG_E3r.js');
require('lodash/camelCase.js');
require('speakingurl');
require('lodash/uniqueId.js');
require('react-is');
require('lodash/uniq.js');
require('lodash/kebabCase.js');
require('lodash/find.js');
require('lodash/startCase.js');
var isHotkey = require('is-hotkey');
var PathUtils = require('@sanity/util/paths');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var omit__default = /*#__PURE__*/_interopDefaultCompat(omit);
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);
var styled__default = /*#__PURE__*/_interopDefaultCompat(styled);
var isHotkey__default = /*#__PURE__*/_interopDefaultCompat(isHotkey);
const emptyArray = [];
function PaneRouterProvider(props) {
  const {
    children,
    flatIndex,
    index,
    params,
    payload,
    siblingIndex
  } = props;
  const {
    navigate,
    navigateIntent,
    resolvePathFromState
  } = router.useRouter();
  const routerState = router.useRouterState();
  const {
    panes,
    expand
  } = StructureToolProvider.usePaneLayout();
  const routerPaneGroups = React.useMemo(() => (routerState == null ? void 0 : routerState.panes) || emptyArray, [routerState == null ? void 0 : routerState.panes]);
  const lastPane = React.useMemo(() => panes == null ? void 0 : panes[panes.length - 2], [panes]);
  const groupIndex = index - 1;
  const createNextRouterState = React.useCallback(modifier => {
    const currentGroup = routerPaneGroups[groupIndex] || [];
    const currentItem = currentGroup[siblingIndex];
    const nextGroup = modifier(currentGroup, currentItem);
    const nextPanes = [...routerPaneGroups.slice(0, groupIndex), nextGroup, ...routerPaneGroups.slice(groupIndex + 1)];
    const nextRouterState = {
      ...(routerState || {}),
      panes: nextPanes
    };
    return nextRouterState;
  }, [groupIndex, routerPaneGroups, routerState, siblingIndex]);
  const modifyCurrentGroup = React.useCallback(modifier => {
    const nextRouterState = createNextRouterState(modifier);
    setTimeout(() => navigate(nextRouterState), 0);
    return nextRouterState;
  }, [createNextRouterState, navigate]);
  const createPathWithParams = React.useCallback(nextParams => {
    const nextRouterState = createNextRouterState((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
    return resolvePathFromState(nextRouterState);
  }, [createNextRouterState, resolvePathFromState, siblingIndex]);
  const setPayload = React.useCallback(nextPayload => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      payload: nextPayload
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const setParams = React.useCallback(nextParams => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const handleEditReference = React.useCallback(_ref => {
    let {
      id,
      parentRefPath,
      type,
      template
    } = _ref;
    navigate({
      panes: [...routerPaneGroups.slice(0, groupIndex + 1), [{
        id,
        params: {
          template: template.id,
          parentRefPath: PathUtils.toString(parentRefPath),
          type
        },
        payload: template.params
      }]]
    });
  }, [groupIndex, navigate, routerPaneGroups]);
  const ctx = React.useMemo(() => ({
    // Zero-based index (position) of pane, visually
    index: flatIndex,
    // Zero-based index of pane group (within URL structure)
    groupIndex,
    // Zero-based index of pane within sibling group
    siblingIndex,
    // Payload of the current pane
    payload,
    // Params of the current pane
    params,
    // Whether or not the pane has any siblings (within the same group)
    hasGroupSiblings: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length > 1 : false,
    // The length of the current group
    groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,
    // Current router state for the "panes" property
    routerPanesState: routerPaneGroups,
    // Curried StateLink that passes the correct state automatically
    ChildLink: StructureToolProvider.ChildLink,
    // Curried StateLink that pops off the last pane group
    BackLink: StructureToolProvider.BackLink,
    // A specialized `ChildLink` that takes in the needed props to open a
    // referenced document to the right
    ReferenceChildLink: StructureToolProvider.ReferenceChildLink,
    // Similar to `ReferenceChildLink` expect without the wrapping component
    handleEditReference,
    // Curried StateLink that passed the correct state, but merges params/payload
    ParameterizedLink: StructureToolProvider.ParameterizedLink,
    // Replaces the current pane with a new one
    replaceCurrent: function () {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      modifyCurrentGroup(() => [{
        id: opts.id || "",
        payload: opts.payload,
        params: opts.params || {}
      }]);
    },
    // Removes the current pane from the group
    closeCurrent: () => {
      modifyCurrentGroup((siblings, item) => siblings.length > 1 ? siblings.filter(sibling => sibling !== item) : siblings);
    },
    // Removes all panes to the right including current
    closeCurrentAndAfter: function () {
      let expandLast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (expandLast && lastPane) {
        expand(lastPane.element);
      }
      navigate({
        panes: [...routerPaneGroups.slice(0, groupIndex)]
      }, {
        replace: true
      });
    },
    // Duplicate the current pane, with optional overrides for payload, parameters
    duplicateCurrent: options => {
      modifyCurrentGroup((siblings, item) => {
        const duplicatedItem = {
          ...item,
          payload: (options == null ? void 0 : options.payload) || item.payload,
          params: (options == null ? void 0 : options.params) || item.params
        };
        return [...siblings.slice(0, siblingIndex), duplicatedItem, ...siblings.slice(siblingIndex)];
      });
    },
    // Set the view for the current pane
    setView: viewId => {
      const restParams = omit__default.default(params, "view");
      return setParams(viewId ? {
        ...restParams,
        view: viewId
      } : restParams);
    },
    // Set the parameters for the current pane
    setParams,
    // Set the payload for the current pane
    setPayload,
    // A function that returns a path with the given parameters
    createPathWithParams,
    // Proxied navigation to a given intent. Consider just exposing `router` instead?
    navigateIntent
  }), [flatIndex, groupIndex, siblingIndex, payload, params, routerPaneGroups, handleEditReference, setParams, setPayload, createPathWithParams, navigateIntent, modifyCurrentGroup, lastPane, navigate, expand]);
  return /* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.PaneRouterContext.Provider, {
    value: ctx,
    children
  });
}
class PaneResolutionError extends Error {
  constructor(_ref2) {
    let {
      message,
      context,
      helpId,
      cause
    } = _ref2;
    super(message);
    this.context = context;
    this.helpId = helpId;
    this.cause = cause;
  }
}
const randomIdCache = /* @__PURE__ */new WeakMap();
function assignId(obj) {
  const cachedValue = randomIdCache.get(obj);
  if (cachedValue) return cachedValue;
  const id = nanoid.nanoid();
  randomIdCache.set(obj, id);
  return id;
}
const isPromise = thing => {
  return !!thing && typeof (thing == null ? void 0 : thing.then) === "function";
};
const isSerializable = thing => {
  if (!sanity.isRecord(thing)) return false;
  return typeof thing.serialize === "function";
};
const rethrowWithPaneResolutionErrors = next => (unresolvedPane, context, flatIndex) => {
  try {
    return next(unresolvedPane, context, flatIndex);
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      throw e;
    }
    throw new PaneResolutionError({
      message: typeof (e == null ? void 0 : e.message) === "string" ? e.message : "",
      context,
      cause: e
    });
  }
};
const wrapWithPublishReplay = next => function () {
  return next(...arguments).pipe(
  // need to add publishReplay + refCount to ensure new subscribers always
  // get an emission. without this, memoized observables may get stuck
  // waiting for their first emissions resulting in a loading pane
  operators.publishReplay(1), operators.refCount());
};
function createPaneResolver(middleware) {
  const resolvePane = rethrowWithPaneResolutionErrors(wrapWithPublishReplay(middleware((unresolvedPane, context, flatIndex) => {
    if (!unresolvedPane) {
      throw new PaneResolutionError({
        message: "Pane returned no child",
        context,
        helpId: "structure-item-returned-no-child"
      });
    }
    if (isPromise(unresolvedPane) || rxjs.isObservable(unresolvedPane)) {
      return rxjs.from(unresolvedPane).pipe(operators.switchMap(result => resolvePane(result, context, flatIndex)));
    }
    if (isSerializable(unresolvedPane)) {
      return resolvePane(unresolvedPane.serialize(context), context, flatIndex);
    }
    if (typeof unresolvedPane === "function") {
      return resolvePane(unresolvedPane(context.id, context), context, flatIndex);
    }
    return rxjs.of(unresolvedPane);
  })));
  return resolvePane;
}
const bindCache = /* @__PURE__ */new WeakMap();
function memoBind(obj, methodKey) {
  const boundMethods = bindCache.get(obj) || /* @__PURE__ */new Map();
  if (boundMethods) {
    const bound2 = boundMethods.get(methodKey);
    if (bound2) return bound2;
  }
  const method = obj[methodKey];
  if (typeof method !== "function") {
    throw new Error("Expected property `".concat(methodKey, "` to be a function but got ").concat(typeof method, " instead."));
  }
  const bound = method.bind(obj);
  boundMethods.set(methodKey, bound);
  bindCache.set(obj, boundMethods);
  return bound;
}
async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */new Map();
  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };
  const resolvePane = createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: {
      ...omit__default.default(options.params, ["id"]),
      type: options.params.type
    },
    payload: options.payload
  }]];
  async function traverse(_ref3) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref3;
    var _a;
    if (!unresolvedPane) return [];
    const {
      id: targetId,
      type: schemaTypeName,
      ...otherParams
    } = params;
    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await rxjs.firstValueFrom(resolvePane(unresolvedPane, context, flatIndex));
    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (
    // if the resolve pane's `canHandleIntent` returns true, then resolve
    ((_a = resolvedPane.canHandleIntent) == null ? void 0 : _a.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    })) ||
    // if the pane's `canHandleIntent` did not return true, then match against
    // this default case. we will resolve the intent if:
    resolvedPane.type === "documentList" &&
    // 1. the schema type matches (this required for the document to render)
    resolvedPane.schemaTypeName === schemaTypeName &&
    // 2. the filter is the default filter.
    //
    // NOTE: this case is to prevent false positive matches where the user
    // has configured a more specific filter for a particular type. In that
    // case, the user can implement their own `canHandleIntent` function
    resolvedPane.options.filter === "_type == $type") {
      return [{
        panes: [
        // map the current path to router panes
        ...path.map(id => [{
          id
        }]),
        // then augment with the intents IDs and params
        [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider") return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }
    return [];
  }
  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];
  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }
  return fallbackEditorPanes;
}
const fallbackEditorChild = (nodeId, context) => {
  const id = nodeId.replace(/^__edit__/, "");
  const {
    params,
    payload,
    structureContext: {
      resolveDocumentNode
    }
  } = context;
  const {
    type,
    template
  } = params;
  if (!type) {
    throw new Error("Document type for document with ID ".concat(id, " was not provided in the router params."));
  }
  let defaultDocumentBuilder = resolveDocumentNode({
    schemaType: type,
    documentId: id
  }).id("editor");
  if (template) {
    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(template, payload);
  }
  return defaultDocumentBuilder.serialize();
};
function hashContext(context) {
  var _a, _b;
  return "contextHash(".concat(JSON.stringify({
    id: context.id,
    parentId: parent && assignId(parent),
    path: context.path,
    index: context.index,
    splitIndex: context.splitIndex,
    serializeOptionsIndex: (_a = context.serializeOptions) == null ? void 0 : _a.index,
    serializeOptionsPath: (_b = context.serializeOptions) == null ? void 0 : _b.path
  }), ")");
}
const hashResolvedPaneMeta = meta => {
  const normalized = {
    type: meta.type,
    id: meta.routerPaneSibling.id,
    params: meta.routerPaneSibling.params || {},
    payload: meta.routerPaneSibling.payload || null,
    flatIndex: meta.flatIndex,
    groupIndex: meta.groupIndex,
    siblingIndex: meta.siblingIndex,
    path: meta.path,
    paneNode: meta.type === "resolvedMeta" ? assignId(meta.paneNode) : null
  };
  return "metaHash(".concat(JSON.stringify(normalized), ")");
};
function resolvePaneTree(_ref4) {
  let {
    unresolvedPane,
    flattenedRouterPanes,
    parent: parent2,
    path,
    resolvePane,
    structureContext
  } = _ref4;
  const [current, ...rest] = flattenedRouterPanes;
  const next = rest[0];
  const context = {
    id: current.routerPaneSibling.id,
    splitIndex: current.siblingIndex,
    parent: parent2,
    path: [...path, current.routerPaneSibling.id],
    index: current.flatIndex,
    params: current.routerPaneSibling.params || {},
    payload: current.routerPaneSibling.payload,
    structureContext
  };
  try {
    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(
    // this switch map receives a resolved pane
    operators.switchMap(paneNode => {
      const resolvedPaneMeta = {
        type: "resolvedMeta",
        ...current,
        paneNode,
        path: context.path
      };
      const loadingPanes = rest.map((i, restIndex) => {
        const loadingPanePath = [...context.path, ...rest.slice(restIndex).map((_, currentIndex) => "[".concat(i.flatIndex + currentIndex, "]"))];
        const loadingPane = {
          type: "loading",
          path: loadingPanePath,
          paneNode: null,
          ...i
        };
        return loadingPane;
      });
      if (!rest.length) {
        return rxjs.of([resolvedPaneMeta]);
      }
      let nextStream;
      if (
      // the fallback editor case
      next == null ? void 0 : next.routerPaneSibling.id.startsWith("__edit__")) {
        nextStream = resolvePaneTree({
          unresolvedPane: fallbackEditorChild,
          flattenedRouterPanes: rest,
          parent: parent2,
          path: context.path,
          resolvePane,
          structureContext
        });
      } else if (current.groupIndex === (next == null ? void 0 : next.groupIndex)) {
        nextStream = resolvePaneTree({
          unresolvedPane,
          flattenedRouterPanes: rest,
          parent: parent2,
          path,
          resolvePane,
          structureContext
        });
      } else {
        nextStream = resolvePaneTree({
          unresolvedPane: typeof paneNode.child === "function" ? memoBind(paneNode, "child") : paneNode.child,
          flattenedRouterPanes: rest,
          parent: paneNode,
          path: context.path,
          resolvePane,
          structureContext
        });
      }
      return rxjs.concat(
      // we emit the loading panes first in a concat (this emits immediately)
      rxjs.of([resolvedPaneMeta, ...loadingPanes]),
      // then whenever the next stream is done, the results will be combined.
      nextStream.pipe(operators.map(nextResolvedPanes => [resolvedPaneMeta, ...nextResolvedPanes])));
    }));
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      if (e.context) {
        console.warn("Pane resolution error at index ".concat(e.context.index).concat(e.context.splitIndex > 0 ? " for split pane index ".concat(e.context.splitIndex) : "", ": ").concat(e.message).concat(e.helpId ? " - see ".concat(generateHelpUrl.generateHelpUrl(e.helpId)) : ""), e);
      }
      if (e.helpId === "structure-item-returned-no-child") {
        return rxjs.of([]);
      }
    }
    throw e;
  }
}
function createResolvedPaneNodeStream(_ref5) {
  let {
    routerPanesStream,
    rootPaneNode,
    initialCacheState = {
      cacheKeysByFlatIndex: [],
      flattenedRouterPanes: [],
      resolvedPaneCache: /* @__PURE__ */new Map(),
      resolvePane: () => rxjs.NEVER
    },
    structureContext
  } = _ref5;
  const resolvedPanes$ = routerPanesStream.pipe(
  // add in implicit "root" router pane
  operators.map(rawRouterPanes => [[{
    id: "root"
  }], ...rawRouterPanes]),
  // create flattened router panes
  operators.map(routerPanes => {
    const flattenedRouterPanes = routerPanes.flatMap((routerPaneGroup, groupIndex) => routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({
      routerPaneSibling,
      groupIndex,
      siblingIndex
    }))).map((i, index) => ({
      ...i,
      flatIndex: index
    }));
    return flattenedRouterPanes;
  }),
  // calculate a "diffIndex" used for clearing the memo cache
  operators.startWith([]), operators.pairwise(), operators.map(_ref6 => {
    let [prev, curr] = _ref6;
    for (let i = 0; i < curr.length; i++) {
      const prevValue = prev[i];
      const currValue = curr[i];
      if (!isEqual__default.default(prevValue, currValue)) {
        return {
          flattenedRouterPanes: curr,
          diffIndex: i
        };
      }
    }
    return {
      flattenedRouterPanes: curr,
      diffIndex: curr.length
    };
  }),
  // create the memoized `resolvePane` function and manage the memo cache
  operators.scan((acc, next) => {
    const {
      cacheKeysByFlatIndex,
      resolvedPaneCache
    } = acc;
    const {
      flattenedRouterPanes,
      diffIndex
    } = next;
    const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1);
    const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1);
    const keysToKeep = new Set(beforeDiffIndex.flatMap(keySet => Array.from(keySet)));
    const keysToDelete = afterDiffIndex.flatMap(keySet => Array.from(keySet)).filter(key => !keysToKeep.has(key));
    for (const key of keysToDelete) {
      resolvedPaneCache.delete(key);
    }
    const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
      const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(hashContext(context));
      const cachedResolvedPane = key && resolvedPaneCache.get(key);
      if (cachedResolvedPane) return cachedResolvedPane;
      const result = nextFn(unresolvedPane, context, flatIndex);
      if (!key) return result;
      const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || /* @__PURE__ */new Set();
      cacheKeySet.add(key);
      cacheKeysByFlatIndex[flatIndex] = cacheKeySet;
      resolvedPaneCache.set(key, result);
      return result;
    };
    return {
      flattenedRouterPanes,
      cacheKeysByFlatIndex,
      resolvedPaneCache,
      resolvePane: createPaneResolver(memoize)
    };
  }, initialCacheState),
  // run the memoized, recursive resolving
  operators.switchMap(_ref7 => {
    let {
      flattenedRouterPanes,
      resolvePane
    } = _ref7;
    return resolvePaneTree({
      unresolvedPane: rootPaneNode,
      flattenedRouterPanes,
      parent: null,
      path: [],
      resolvePane,
      structureContext
    });
  }));
  return resolvedPanes$.pipe(
  // this diffs the previous emission with the current one. if there is a new
  // loading pane at the same position where a previous pane already had a
  // resolved value (looking at the IDs to compare), then return the previous
  // pane instead of the loading pane
  operators.scan((prev, next) => next.map((nextPane, index) => {
    const prevPane = prev[index];
    if (!prevPane) return nextPane;
    if (nextPane.type !== "loading") return nextPane;
    if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {
      return prevPane;
    }
    return nextPane;
  }), []),
  // this prevents duplicate emissions
  operators.distinctUntilChanged((prev, next) => {
    if (prev.length !== next.length) return false;
    for (let i = 0; i < next.length; i++) {
      const prevValue = prev[i];
      const nextValue = next[i];
      if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {
        return false;
      }
    }
    return true;
  }));
}
function useRouterPanesStream() {
  const routerStateSubject = React.useMemo(() => new rxjs.ReplaySubject(1), []);
  const routerPanes$ = React.useMemo(() => routerStateSubject.asObservable().pipe(operators.map(_routerState => (_routerState == null ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = router.useRouter();
  React.useEffect(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}
function useResolvedPanes() {
  const [error, setError] = React.useState();
  if (error) throw error;
  const {
    structureContext,
    rootPaneNode
  } = StructureToolProvider.useStructureTool();
  const [data, setData] = React.useState({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  React.useEffect(() => {
    const resolvedPanes$ = createResolvedPaneNodeStream({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe(operators.map(resolvedPanes => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map(pane => {
        var _a;
        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_a = nextGroup == null ? void 0 : nextGroup[0].id) != null ? _a : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === "loading" ? "unknown" : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === "loading" ? StructureToolProvider.LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(";"),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map(pane => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: result => setData(result),
      error: e => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}
async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type) return {
    id,
    type
  };
  if (!id && type) return {
    id: uuid.uuid(),
    type
  };
  if (id && !type) {
    const resolvedType = await rxjs.firstValueFrom(documentStore.resolveTypeForDocument(id));
    return {
      id,
      type: resolvedType
    };
  }
  throw new PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}
const EMPTY_RECORD = {};
const IntentResolver = React.memo(function IntentResolver2() {
  const {
    navigate
  } = router.useRouter();
  const maybeIntent = router.useRouterState(React.useCallback(routerState => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    return intentName ? {
      intent: intentName,
      params: sanity.isRecord(routerState.params) ? routerState.params : EMPTY_RECORD,
      payload: routerState.payload
    } : void 0;
  }, []));
  const {
    rootPaneNode,
    structureContext
  } = StructureToolProvider.useStructureTool();
  const documentStore = sanity.useDocumentStore();
  const [error, setError] = React.useState(null);
  if (error) throw error;
  React.useEffect(() => {
    if (maybeIntent) {
      const {
        intent,
        params,
        payload
      } = maybeIntent;
      let cancelled = false;
      async function effect() {
        const {
          id,
          type
        } = await ensureDocumentIdAndType(documentStore, typeof params.id === "string" ? params.id : void 0, typeof params.type === "string" ? params.type : void 0);
        if (cancelled) return;
        const panes = await resolveIntent({
          intent,
          params: {
            ...params,
            id,
            type
          },
          payload,
          rootPaneNode,
          structureContext
        });
        if (cancelled) return;
        navigate({
          panes
        }, {
          replace: true
        });
      }
      effect().catch(setError);
      return () => {
        cancelled = true;
      };
    }
  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext]);
  return null;
});
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const PathSegment = styled__default.default.span(_a$1 || (_a$1 = __template$1(["\n  &:not(:last-child)::after {\n    content: ' \u279D ';\n    opacity: 0.5;\n  }\n"])));
function formatStack(stack) {
  return stack.replace(/\(\.\.\.\)\./g, "(...)\n  .").replace(/__WEBPACK_IMPORTED_MODULE_\d+_+/g, "").replace(/___default\./g, ".").replace(new RegExp(" \\(https?:\\/\\/".concat(window.location.host), "g"), " (");
}
function StructureError(_ref8) {
  let {
    error
  } = _ref8;
  if (!(error instanceof PaneResolutionError)) {
    throw error;
  }
  const {
    cause
  } = error;
  const {
    t
  } = sanity.useTranslation(StructureToolProvider.structureLocaleNamespace);
  const stack = (cause == null ? void 0 : cause.stack) || error.stack;
  const showStack = stack && !(cause instanceof StructureToolProvider.SerializeError) && !error.message.includes("Module build failed:");
  const path = cause instanceof StructureToolProvider.SerializeError ? cause.path : [];
  const helpId = cause instanceof StructureToolProvider.SerializeError && cause.helpId || error.helpId;
  const handleReload = React.useCallback(() => {
    window.location.reload();
  }, []);
  return /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
    height: "fill",
    overflow: "auto",
    padding: 4,
    sizing: "border",
    tone: "critical",
    children: /* @__PURE__ */jsxRuntime.jsxs(ui.Container, {
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Heading, {
        as: "h2",
        children: t("structure-error.header.text")
      }), /* @__PURE__ */jsxRuntime.jsxs(ui.Card, {
        marginTop: 4,
        padding: 4,
        radius: 2,
        overflow: "auto",
        shadow: 1,
        tone: "inherit",
        children: [path.length > 0 && /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
          space: 2,
          children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            size: 1,
            weight: "medium",
            children: t("structure-error.structure-path.label")
          }), /* @__PURE__ */jsxRuntime.jsx(ui.Code, {
            children: path.slice(1).map((segment, i) =>
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */
            jsxRuntime.jsx(PathSegment, {
              children: segment
            }, "".concat(segment, "-").concat(i)))
          })]
        }), /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
          marginTop: 4,
          space: 2,
          children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            size: 1,
            weight: "medium",
            children: t("structure-error.error.label")
          }), /* @__PURE__ */jsxRuntime.jsx(ui.Code, {
            children: showStack ? formatStack(stack) : error.message
          })]
        }), helpId && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            children: /* @__PURE__ */jsxRuntime.jsx("a", {
              href: generateHelpUrl.generateHelpUrl(helpId),
              rel: "noopener noreferrer",
              target: "_blank",
              children: t("structure-error.docs-link.text")
            })
          })
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsxRuntime.jsx(TooltipDelayGroupProvider.Button, {
            text: t("structure-error.reload-button.text"),
            icon: icons.SyncIcon,
            tone: "primary",
            onClick: handleReload
          })
        })]
      })]
    })
  });
}
function UnknownPane(props) {
  const {
    isSelected,
    pane,
    paneKey
  } = props;
  const type = sanity.isRecord(pane) && pane.type || null;
  const {
    t
  } = sanity.useTranslation(StructureToolProvider.structureLocaleNamespace);
  return /* @__PURE__ */jsxRuntime.jsxs(StructureToolProvider.Pane, {
    id: paneKey,
    selected: isSelected,
    children: [/* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.PaneHeader, {
      title: t("panes.unknown-pane-type.title")
    }), /* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.PaneContent, {
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        padding: 4,
        children: typeof type === "string" ? /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          as: "p",
          muted: true,
          children: /* @__PURE__ */jsxRuntime.jsx(sanity.Translate, {
            t,
            i18nKey: "panes.unknown-pane-type.unknown-type.text",
            values: {
              type
            }
          })
        }) : /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          as: "p",
          muted: true,
          children: /* @__PURE__ */jsxRuntime.jsx(sanity.Translate, {
            t,
            i18nKey: "panes.unknown-pane-type.missing-type.text"
          })
        })
      })
    })]
  });
}
const paneMap = {
  component: React.lazy(() => Promise.resolve().then(function () {
    return require('./index-D9-enJnZ.js');
  })),
  document: React.lazy(() => Promise.resolve().then(function () {
    return require('./pane-BrIEXSvp.js');
  })),
  documentList: React.lazy(() => Promise.resolve().then(function () {
    return require('./pane-gOwlY3Gt.js');
  })),
  list: React.lazy(() => Promise.resolve().then(function () {
    return require('./index-DR3UC8pX.js');
  }))
};
const StructureToolPane = React.memo(function StructureToolPane2(props) {
  const {
    active,
    childItemId,
    groupIndex,
    index,
    itemId,
    pane,
    paneKey,
    params,
    payload,
    path,
    selected,
    siblingIndex
  } = props;
  const PaneComponent = paneMap[pane.type] || UnknownPane;
  return /* @__PURE__ */jsxRuntime.jsx(PaneRouterProvider, {
    flatIndex: index,
    index: groupIndex,
    params,
    payload,
    siblingIndex,
    children: /* @__PURE__ */jsxRuntime.jsx(React.Suspense, {
      fallback: /* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.LoadingPane, {
        paneKey,
        path,
        selected
      }),
      children: /* @__PURE__ */jsxRuntime.jsx(PaneComponent, {
        childItemId: childItemId || "",
        index,
        itemId,
        isActive: active,
        isSelected: selected,
        paneKey,
        pane
      })
    })
  });
}, (_ref9, _ref10) => {
  let {
    params: prevParams = {},
    payload: prevPayload = null,
    ...prev
  } = _ref9;
  let {
    params: nextParams = {},
    payload: nextPayload = null,
    ...next
  } = _ref10;
  if (!isEqual__default.default(prevParams, nextParams)) return false;
  if (!isEqual__default.default(prevPayload, nextPayload)) return false;
  const keys = /* @__PURE__ */new Set([...Object.keys(prev), ...Object.keys(next)]);
  for (const key of keys) {
    if (prev[key] !== next[key]) return false;
  }
  return true;
});
function NoDocumentTypesScreen() {
  const {
    t
  } = sanity.useTranslation(StructureToolProvider.structureLocaleNamespace);
  return /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
    height: "fill",
    children: /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
      align: "center",
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Container, {
        width: 0,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
          padding: 4,
          radius: 2,
          shadow: 1,
          tone: "caution",
          children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
            children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                size: 1,
                children: /* @__PURE__ */jsxRuntime.jsx(icons.WarningOutlineIcon, {})
              })
            }), /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
              flex: 1,
              marginLeft: 3,
              space: 3,
              children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                as: "h1",
                size: 1,
                weight: "medium",
                children: t("no-document-types-screen.title")
              }), /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                as: "p",
                muted: true,
                size: 1,
                children: t("no-document-types-screen.subtitle")
              }), /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                as: "p",
                muted: true,
                size: 1,
                children: /* @__PURE__ */jsxRuntime.jsx("a", {
                  href: "https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio",
                  target: "_blank",
                  rel: "noreferrer",
                  children: t("no-document-types-screen.link-text")
                })
              })]
            })]
          })
        })
      })
    })
  });
}
const DocumentTitle = props => {
  const {
    documentId,
    documentType
  } = props;
  const editState = sanity.useEditState(documentId, documentType);
  const schema = sanity.useSchema();
  const {
    t
  } = sanity.useTranslation(StructureToolProvider.structureLocaleNamespace);
  const isNewDocument = !(editState == null ? void 0 : editState.published) && !(editState == null ? void 0 : editState.draft);
  const documentValue = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published);
  const schemaType = schema.get(documentType);
  const {
    value,
    isLoading: previewValueIsLoading
  } = sanity.unstable_useValuePreview({
    enabled: true,
    schemaType,
    value: documentValue
  });
  const documentTitle = isNewDocument ? t("browser-document-title.new-document", {
    schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)
  }) : (value == null ? void 0 : value.title) || t("browser-document-title.untitled-document");
  const settled = editState.ready && !previewValueIsLoading;
  const newTitle = useConstructDocumentTitle(documentTitle);
  React.useEffect(() => {
    if (!settled) return;
    document.title = newTitle;
  }, [documentTitle, settled, newTitle]);
  return null;
};
const PassthroughTitle = props => {
  const {
    title
  } = props;
  const newTitle = useConstructDocumentTitle(title);
  React.useEffect(() => {
    document.title = newTitle;
  }, [newTitle, title]);
  return null;
};
const StructureTitle = props => {
  const {
    resolvedPanes
  } = props;
  if (!(resolvedPanes == null ? void 0 : resolvedPanes.length)) return null;
  const lastPane = resolvedPanes[resolvedPanes.length - 1];
  if (isLoadingPane(lastPane)) {
    return /* @__PURE__ */jsxRuntime.jsx(PassthroughTitle, {});
  }
  if (isDocumentPane(lastPane)) {
    if (lastPane == null ? void 0 : lastPane.title) {
      return /* @__PURE__ */jsxRuntime.jsx(PassthroughTitle, {
        title: lastPane.title
      });
    }
    return /* @__PURE__ */jsxRuntime.jsx(DocumentTitle, {
      documentId: lastPane.options.id,
      documentType: lastPane.options.type
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(PassthroughTitle, {
    title: lastPane == null ? void 0 : lastPane.title
  });
};
function useConstructDocumentTitle(activeTitle) {
  const structureToolBaseTitle = StructureToolProvider.useStructureTool().structureContext.title;
  return [activeTitle, structureToolBaseTitle].filter(title => title).join(" | ");
}
function isDocumentPane(pane) {
  return pane !== StructureToolProvider.LOADING_PANE && pane.type === "document";
}
function isLoadingPane(pane) {
  return pane === StructureToolProvider.LOADING_PANE;
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const StyledPaneLayout = styled__default.default(StructureToolProvider.PaneLayout)(_a || (_a = __template(["\n  min-height: 100%;\n  min-width: 320px;\n"])));
const isSaveHotkey = isHotkey__default.default("mod+s");
const StructureTool = React.memo(function StructureTool2(_ref11) {
  let {
    onPaneChange
  } = _ref11;
  var _a2;
  const {
    push: pushToast
  } = ui.useToast();
  const schema = sanity.useSchema();
  const {
    layoutCollapsed,
    setLayoutCollapsed
  } = StructureToolProvider.useStructureTool();
  const {
    paneDataItems,
    resolvedPanes
  } = useResolvedPanes();
  const isResolvingIntent = router.useRouterState(React.useCallback(routerState => typeof routerState.intent === "string", []));
  const {
    sanity: {
      media
    }
  } = ui.useTheme();
  const [portalElement, setPortalElement] = React.useState(null);
  const handleRootCollapse = React.useCallback(() => setLayoutCollapsed(true), [setLayoutCollapsed]);
  const handleRootExpand = React.useCallback(() => setLayoutCollapsed(false), [setLayoutCollapsed]);
  React.useEffect(() => {
    if (resolvedPanes.length) {
      onPaneChange(resolvedPanes);
    }
  }, [onPaneChange, resolvedPanes]);
  React.useEffect(() => {
    const handleGlobalKeyDown = event => {
      if (isSaveHotkey(event)) {
        event.preventDefault();
        pushToast({
          closable: true,
          id: "auto-save-message",
          status: "info",
          title: "Your work is automatically saved!",
          duration: 4e3
        });
      }
    };
    window.addEventListener("keydown", handleGlobalKeyDown);
    return () => window.removeEventListener("keydown", handleGlobalKeyDown);
  }, [pushToast]);
  const hasDefinedDocumentTypes = (_a2 = schema._original) == null ? void 0 : _a2.types.some(sanity._isCustomDocumentTypeDefinition);
  if (!hasDefinedDocumentTypes) {
    return /* @__PURE__ */jsxRuntime.jsx(NoDocumentTypesScreen, {});
  }
  return /* @__PURE__ */jsxRuntime.jsxs(ui.PortalProvider, {
    element: portalElement || null,
    children: [/* @__PURE__ */jsxRuntime.jsxs(StyledPaneLayout, {
      flex: 1,
      height: layoutCollapsed ? void 0 : "fill",
      minWidth: media[1],
      onCollapse: handleRootCollapse,
      onExpand: handleRootExpand,
      children: [paneDataItems.map(_ref12 => {
        let {
          active,
          childItemId,
          groupIndex,
          itemId,
          key: paneKey,
          pane,
          index: paneIndex,
          params: paneParams,
          path,
          payload,
          siblingIndex,
          selected
        } = _ref12;
        return /* @__PURE__ */jsxRuntime.jsx(React.Fragment, {
          children: pane === StructureToolProvider.LOADING_PANE ? /* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.LoadingPane, {
            paneKey,
            path,
            selected
          }) : /* @__PURE__ */jsxRuntime.jsx(StructureToolPane, {
            active,
            groupIndex,
            index: paneIndex,
            pane,
            childItemId,
            itemId,
            paneKey,
            params: paneParams,
            payload,
            path,
            selected,
            siblingIndex
          })
        }, "".concat(pane === StructureToolProvider.LOADING_PANE ? "loading" : pane.type, "-").concat(paneIndex));
      }), paneDataItems.length <= 1 && isResolvingIntent && /* @__PURE__ */jsxRuntime.jsx(StructureToolProvider.LoadingPane, {
        paneKey: "intent-resolver"
      })]
    }), /* @__PURE__ */jsxRuntime.jsx(StructureTitle, {
      resolvedPanes
    }), /* @__PURE__ */jsxRuntime.jsx("div", {
      "data-portal": "",
      ref: setPortalElement
    })]
  });
});
function StructureToolBoundary(_ref13) {
  let {
    tool: {
      options
    }
  } = _ref13;
  const {
    unstable_sources: sources
  } = sanity.useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  React.useEffect(() => {
    StructureToolProvider.setActivePanes([]);
    return () => StructureToolProvider.setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = React.useState({
    error: null
  });
  if (error) return /* @__PURE__ */jsxRuntime.jsx(StructureError, {
    error
  });
  return /* @__PURE__ */jsxRuntime.jsx(ui.ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.SourceProvider, {
      name: source || firstSource.name,
      children: /* @__PURE__ */jsxRuntime.jsxs(StructureToolProvider.StructureToolProvider, {
        defaultDocumentNode,
        structure,
        children: [/* @__PURE__ */jsxRuntime.jsx(StructureTool, {
          onPaneChange: StructureToolProvider.setActivePanes
        }), /* @__PURE__ */jsxRuntime.jsx(IntentResolver, {})]
      })
    })
  });
}
exports.default = StructureToolBoundary;
//# sourceMappingURL=index-p6kem93c.js.map
