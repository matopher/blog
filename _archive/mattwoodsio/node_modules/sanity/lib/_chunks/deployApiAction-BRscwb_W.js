import get from 'lodash/get.js';
import oneline from 'oneline';
import { hideBin } from 'yargs/helpers';
import yargs from 'yargs/yargs';
import { getClientUrl, debug } from './_internal-C-K0p2lV.js';
import { getIt } from 'get-it';
import { promise } from 'get-it/middleware';
import { generateHelpUrl } from '@sanity/generate-help-url';
import { Schema } from '@sanity/schema';
import { isDeprecationConfiguration } from '@sanity/types';
import startCase from 'lodash/startCase.js';
import uniqBy from 'lodash/uniqBy.js';
import upperFirst from 'lodash/upperFirst.js';
import logSymbols from 'log-symbols';
import flatten from 'lodash/flatten.js';
import pluralize from 'pluralize-esm';
import { getGraphQLAPIs } from './getGraphQLAPIs-CF_07sLx.js';
const request = getIt([promise()]);
class HttpError extends Error {}
async function getUrlHeaders(url) {
  let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const response = await request({
    url,
    stream: true,
    maxRedirects: 0,
    method: "HEAD",
    headers
  });
  if (response.statusCode >= 400) {
    const error = new HttpError("Request returned HTTP ".concat(response.statusCode));
    error.statusCode = response.statusCode;
    throw error;
  }
  response.body.resume();
  return response.headers;
}
const SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE = "schema-lift-anonymous-object-type";
const consoleOutputter = {
  error: function () {
    return console.error(...arguments);
  }
};
class SchemaError extends Error {
  constructor(problemGroups) {
    super("Schema errors encountered");
    this.problemGroups = problemGroups;
  }
  print(output) {
    const logger = output || consoleOutputter;
    logger.error("Uh oh\u2026 found errors in schema:\n");
    this.problemGroups.forEach(group => {
      group.problems.forEach(problem => {
        const icon = logSymbols[problem.severity] || logSymbols.info;
        output.error("  ".concat(icon, " ").concat(upperFirst(problem.severity), ": ").concat(getPath(group.path)));
        output.error("  ".concat(problem.message));
        if (problem.helpId) {
          output.error("  See ".concat(generateHelpUrl(problem.helpId)));
        }
        output.error("");
      });
    });
  }
}
function getPath(path) {
  return path.map(segment => {
    if (segment.kind === "type" && segment.name && segment.type) {
      return "".concat(segment.name, " - (").concat(segment.type, ")");
    }
    if (segment.kind === "property" && segment.name) {
      return segment.name;
    }
    return null;
  }).filter(Boolean).join(" / ");
}
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1, _b;
const skipTypes = ["document", "reference"];
const allowedJsonTypes = ["object", "array"];
const disallowedCustomizedMembers = ["object", "array", "image", "file", "block"];
const disabledBlockFields = ["markDefs"];
const scalars = ["string", "number", "boolean"];
const internal = Symbol("internal");
function getBaseType(baseSchema, typeName) {
  var _a2, _b2;
  if (typeName === "crossDatasetReference") {
    return Schema.compile({
      types: (((_a2 = baseSchema._original) == null ? void 0 : _a2.types) || []).concat([{
        name: "__placeholder__",
        type: "crossDatasetReference",
        // Just needs _something_ to refer to, doesn't matter what
        to: [{
          type: "sanity.imageAsset"
        }]
      }])
    }).get("__placeholder__");
  }
  return Schema.compile({
    types: (((_b2 = baseSchema._original) == null ? void 0 : _b2.types) || []).concat([{
      name: "__placeholder__",
      type: typeName,
      options: {
        hotspot: true
      }
    }])
  }).get("__placeholder__");
}
function getTypeName(str) {
  const name = startCase(str).replace(/\s+/g, "");
  return name === "Number" ? "Float" : name;
}
function isBaseType(type) {
  return type.name !== type.jsonType && allowedJsonTypes.includes(type.jsonType) && !skipTypes.includes(type.name) && !isReference(type);
}
function isBlockType(typeDef) {
  if (typeDef.name === "block") {
    return true;
  }
  if (typeDef.type) {
    return isBlockType(typeDef.type);
  }
  return false;
}
function hasBlockParent(typeDef) {
  if (typeDef.type && typeDef.type.name === "block" && !typeDef.type.type) {
    return true;
  }
  return Boolean(typeDef.type && hasBlockParent(typeDef.type));
}
function isArrayOfBlocks(typeDef) {
  const type = typeDef.type || typeDef;
  if (!("jsonType" in type) || type.jsonType !== "array") {
    return false;
  }
  return (type.of || []).some(hasBlockParent);
}
function isType(typeDef, typeName) {
  let type = typeDef;
  while (type) {
    if (type.name === typeName || type.type && type.type.name === typeName) {
      return true;
    }
    type = type.type;
  }
  return false;
}
function isReference(typeDef) {
  return isType(typeDef, "reference");
}
function isCrossDatasetReference(typeDef) {
  return isType(typeDef, "crossDatasetReference");
}
function getCrossDatasetReferenceMetadata(typeDef) {
  if (!isCrossDatasetReference(typeDef)) return void 0;
  function getTypeNames(type) {
    if (!type) return void 0;
    if (!("to" in type)) return getTypeNames(type.type);
    return type.to.map(t => t.type).filter(t => typeof t === "string");
  }
  function getDataset(type) {
    if (!type) return void 0;
    if ("dataset" in type && typeof type.dataset === "string") return type.dataset;
    if (type.type) return getDataset(type.type);
    return void 0;
  }
  const typeNames = getTypeNames(typeDef);
  if (!typeNames) return void 0;
  const dataset = getDataset(typeDef);
  if (typeof dataset !== "string") return void 0;
  return {
    typeNames,
    dataset
  };
}
function extractFromSanitySchema(sanitySchema) {
  let extractOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _a2;
  const {
    nonNullDocumentFields,
    withUnionCache
  } = extractOptions;
  const unionRecursionGuards = /* @__PURE__ */new Set();
  const unionDefinitionCache = /* @__PURE__ */new Map();
  const hasErrors = sanitySchema._validation && sanitySchema._validation.some(group => group.problems.some(problem => problem.severity === "error"));
  if (hasErrors && Array.isArray(sanitySchema._validation)) {
    throw new SchemaError(sanitySchema._validation);
  }
  const sanityTypes = ((_a2 = sanitySchema._original) == null ? void 0 : _a2.types) || [];
  const typeNames = sanitySchema.getTypeNames();
  const unionTypes = [];
  const types = [];
  for (const typeName of typeNames) {
    const schemaType = sanitySchema.get(typeName);
    if (schemaType === void 0) {
      continue;
    }
    if (!isBaseType(schemaType)) {
      continue;
    }
    const convertedType = convertType(schemaType);
    types.push(convertedType);
  }
  const withUnions = [...types, ...unionTypes];
  return {
    types: withUnions,
    interfaces: [getDocumentInterfaceDefinition()]
  };
  function isTopLevelType(typeName) {
    return typeNames.includes(typeName);
  }
  function mapFieldType(field) {
    if (!field.type) {
      throw new Error("Field has no type!");
    }
    const jsonType = "jsonType" in field ? field.jsonType : "";
    const isScalar = scalars.includes(jsonType);
    if (isScalar && jsonType === "number") {
      return hasValidationFlag(field, "integer") ? "Int" : "Float";
    } else if (isScalar) {
      return getTypeName(jsonType);
    }
    const type = field.type.type || field.type;
    if (type.type) {
      return mapFieldType(type);
    }
    switch (type.name) {
      case "number":
        return hasValidationFlag(field, "integer") ? "Int" : "Float";
      default:
        return getTypeName(type.name);
    }
  }
  function isArrayType(type) {
    return Boolean("jsonType" in type && type.jsonType === "array" || type.type && type.type.jsonType === "array");
  }
  function _convertType(type, parent, options) {
    let name;
    if (type.type) {
      name = type.type.name;
    } else if ("jsonType" in type) {
      name = type.jsonType;
    }
    if (isReference(type)) {
      return getReferenceDefinition(type, parent);
    }
    if (isArrayType(type)) {
      return getArrayDefinition(type, parent, options);
    }
    if (name === "document") {
      return getDocumentDefinition(type);
    }
    if (name === "block" || name === "object") {
      return getObjectDefinition(type, parent);
    }
    if (hasFields(type)) {
      return getObjectDefinition(type, parent);
    }
    return {
      type: mapFieldType(type),
      description: getDescription(type)
    };
  }
  function convertType(type, parent) {
    let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const mapped = _convertType(type, parent || "", {
      isField: Boolean(props.fieldName)
    });
    const gqlName = props.fieldName || mapped.name;
    const originalName = type.name;
    const original = gqlName === originalName ? {} : {
      originalName
    };
    const crossDatasetReferenceMetadata = getCrossDatasetReferenceMetadata(type);
    return {
      ...getDeprecation$1(type.type),
      ...props,
      ...mapped,
      ...original,
      ...(crossDatasetReferenceMetadata && {
        crossDatasetReferenceMetadata
      })
    };
  }
  function isField(def) {
    return !("jsonType" in def) || !def.jsonType;
  }
  function getObjectDefinition(def, parent) {
    const isInline = isField(def);
    const isDocument = def.type ? def.type.name === "document" : false;
    const actualType = isInline ? def.type : def;
    if (typeNeedsHoisting(actualType)) {
      throw createLiftTypeError(def.name, parent || "", actualType.name);
    }
    if (isInline && parent && def.type.name === "object") {
      throw createLiftTypeError(def.name, parent);
    }
    if (parent && def.type && isTopLevelType(def.type.name)) {
      return {
        type: getTypeName(def.type.name)
      };
    }
    const name = "".concat(parent || "").concat(getTypeName(def.name));
    const fields = collectFields(def);
    const firstUnprefixed = Math.max(0, fields.findIndex(field => field.name[0] !== "_"));
    const keyField = createStringField("_key");
    fields.splice(firstUnprefixed, 0, keyField);
    if (!isDocument) {
      fields.splice(firstUnprefixed + 1, 0, createStringField("_type"));
    }
    const objectIsBlock = isBlockType(def);
    const objectFields = objectIsBlock ? fields.filter(field => !disabledBlockFields.includes(field.name)) : fields;
    return {
      kind: "Type",
      name,
      type: "Object",
      description: getDescription(def),
      fields: objectFields.map(field => isArrayOfBlocks(field) ? buildRawField(field, name) : convertType(field, name, {
        fieldName: field.name,
        ...getDeprecation$1(def)
      })),
      [internal]: {
        ...getDeprecation$1(def)
      }
    };
  }
  function buildRawField(field, parentName) {
    return {
      ...convertType(field, parentName, {
        fieldName: "".concat(field.name, "Raw")
      }),
      type: "JSON",
      isRawAlias: true
    };
  }
  function createStringField(name) {
    return {
      name,
      type: {
        jsonType: "string",
        name: "string",
        type: {
          name: "string",
          type: void 0,
          jsonType: "string"
        }
      }
    };
  }
  function collectFields(def) {
    const fields = gatherAllFields(def);
    if (fields.length > 0) {
      return fields;
    }
    const extended = getBaseType(sanitySchema, def.name);
    return gatherAllFields(extended);
  }
  function getReferenceDefinition(def, parent) {
    const base = {
      description: getDescription(def),
      isReference: true
    };
    const candidates = arrayify(gatherAllReferenceCandidates(def));
    if (candidates.length === 0) {
      throw new Error("No candidates for reference");
    }
    if (candidates.length === 1) {
      return {
        type: getTypeName(candidates[0].type.name),
        ...base
      };
    }
    const unionDefinition = getUnionDefinition(candidates, def, {
      grandParent: parent
    });
    return {
      ...unionDefinition,
      ...base
    };
  }
  function getArrayDefinition(def, parent) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a3;
    const base = {
      description: getDescription(def),
      kind: "List"
    };
    const name = !options.isField && def.name ? {
      name: getTypeName(def.name)
    } : {};
    const candidates = ((_a3 = def.type) == null ? void 0 : _a3.type) && "of" in def.type ? arrayify(def.type.of) : def.of;
    return candidates.length === 1 ? {
      children: getArrayChildDefinition(candidates[0], def),
      ...base,
      ...name
    } : {
      children: getUnionDefinition(candidates, def, {
        grandParent: parent
      }),
      ...base,
      ...name
    };
  }
  function getArrayChildDefinition(child, arrayDef) {
    if (typeNeedsHoisting(child)) {
      throw createLiftTypeError(child.name, arrayDef.name);
    }
    if (isReference(child)) {
      return getReferenceDefinition(child, arrayDef.name);
    }
    if (scalars.includes(child.jsonType) && !scalars.includes(child.name)) {
      return {
        type: mapFieldType(child)
      };
    }
    return {
      type: getTypeName(child.name)
    };
  }
  function typeNeedsHoisting(type) {
    if (type.name === "object") {
      return true;
    }
    if (type.jsonType === "object" && !isTopLevelType(type.name)) {
      return true;
    }
    if (type.isCustomized && !isTopLevelType(type.name)) {
      return true;
    }
    if (type.isCustomized && disallowedCustomizedMembers.includes(type.name)) {
      return true;
    }
    return false;
  }
  function getUnionDefinition(candidates, parent) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (candidates.length < 2) {
      throw new Error("Not enough candidates for a union type");
    }
    const guardPathName = "".concat(typeof parent === "object" ? parent.name : parent);
    if (unionRecursionGuards.has(guardPathName)) {
      return {};
    }
    const unionCacheKey = "".concat(options.grandParent, "-").concat(guardPathName, "-").concat(candidates.map(c => {
      var _a3;
      return (_a3 = c.type) == null ? void 0 : _a3.name;
    }).join("-"));
    if (withUnionCache && unionDefinitionCache.has(unionCacheKey)) {
      return unionDefinitionCache.get(unionCacheKey);
    }
    try {
      unionRecursionGuards.add(guardPathName);
      candidates.forEach((def, i) => {
        if (typeNeedsHoisting(def)) {
          throw createLiftTypeArrayError(i, parent.name, def.type ? def.type.name : def.name, options.grandParent);
        }
      });
      const converted = candidates.map(def => convertType(def));
      const getName = def => typeof def.type === "string" ? def.type : def.type.name;
      const flattened = converted.reduce((acc, candidate) => {
        const union = unionTypes.find(item => item.name === candidate.type);
        return union ? acc.concat(union.types.map(type => ({
          type,
          isReference: candidate.isReference
        }))) : acc.concat(candidate);
      }, []);
      let allCandidatesAreDocuments = true;
      const refs = [];
      const inlineObjs = [];
      const allTypeNames = [];
      for (const def of flattened) {
        if (def.isReference) {
          refs.push(def.type);
        }
        if (!isReference) {
          inlineObjs.push(def.name || "");
        }
        const typeName = typeof def.type === "string" ? def.type : def.type.name;
        if (def.name || def.type) {
          allTypeNames.push(def.isReference ? typeName : def.name || "");
        }
        const typeDef = sanityTypes.find(type => type.name === getName(def));
        if (!typeDef || typeDef.type !== "document") {
          allCandidatesAreDocuments = false;
        }
      }
      const interfaces = allCandidatesAreDocuments ? ["Document"] : void 0;
      const possibleTypes = [...new Set(allTypeNames)].sort();
      if (possibleTypes.length < 2) {
        throw new Error("Not enough types for a union type. Parent: ".concat(parent.name));
      }
      const name = possibleTypes.join("Or");
      if (!unionTypes.some(item => item.name === name)) {
        unionTypes.push({
          kind: "Union",
          name,
          types: possibleTypes,
          interfaces
        });
      }
      const references = refs.length > 0 ? refs : void 0;
      const inlineObjects = inlineObjs.length > 0 ? inlineObjs : void 0;
      const unionDefinition = isReference(parent) ? {
        type: name,
        references
      } : {
        type: name,
        references,
        inlineObjects
      };
      unionDefinitionCache.set(unionCacheKey, unionDefinition);
      return unionDefinition;
    } finally {
      unionRecursionGuards.delete(guardPathName);
    }
  }
  function getDocumentDefinition(def) {
    const objectDef = getObjectDefinition(def);
    const fields = getDocumentInterfaceFields(def).concat(objectDef.fields);
    return {
      ...objectDef,
      fields,
      interfaces: ["Document"]
    };
  }
  function getDocumentInterfaceDefinition() {
    return {
      kind: "Interface",
      name: "Document",
      description: "A Sanity document",
      fields: getDocumentInterfaceFields()
    };
  }
  function getDocumentInterfaceFields(type) {
    const isNullable = typeof nonNullDocumentFields === "boolean" ? !nonNullDocumentFields : true;
    return [{
      fieldName: "_id",
      type: "ID",
      isNullable,
      description: "Document ID",
      ...getDeprecation$1(type)
    }, {
      fieldName: "_type",
      type: "String",
      isNullable,
      description: "Document type",
      ...getDeprecation$1(type)
    }, {
      fieldName: "_createdAt",
      type: "Datetime",
      isNullable,
      description: "Date the document was created",
      ...getDeprecation$1(type)
    }, {
      fieldName: "_updatedAt",
      type: "Datetime",
      isNullable,
      description: "Date the document was last modified",
      ...getDeprecation$1(type)
    }, {
      fieldName: "_rev",
      type: "String",
      isNullable,
      description: "Current document revision",
      ...getDeprecation$1(type)
    }];
  }
  function arrayify(thing) {
    if (Array.isArray(thing)) {
      return thing;
    }
    return thing === null || typeof thing === "undefined" ? [] : [thing];
  }
  function hasValidationFlag(field, flag) {
    return "validation" in field && Array.isArray(field.validation) && field.validation.some(rule => rule && "_rules" in rule && rule._rules.some(item => item.flag === flag));
  }
  function getDescription(type) {
    const description = type.type && type.type.description;
    return typeof description === "string" ? description : void 0;
  }
  function gatherAllReferenceCandidates(type) {
    const allFields = gatherReferenceCandidates(type);
    return uniqBy(allFields, "name");
  }
  function gatherReferenceCandidates(type) {
    const refTo = "to" in type ? type.to : [];
    return "type" in type && type.type ? [...gatherReferenceCandidates(type.type), ...refTo] : refTo;
  }
  function gatherAllFields(type) {
    const allFields = gatherFields(type);
    return uniqBy(allFields, "name");
  }
  function gatherFields(type) {
    if ("fields" in type) {
      return type.type ? gatherFields(type.type).concat(type.fields) : type.fields;
    }
    return [];
  }
  function hasFieldsLikeShape(type) {
    return typeof type === "object" && type !== null && "fields" in type;
  }
  function hasArrayOfFields(type) {
    return hasFieldsLikeShape(type) && Array.isArray(type.fields);
  }
  function hasFields(type) {
    if (hasArrayOfFields(type)) {
      return gatherAllFields(type).length > 0;
    }
    return "type" in type && type.type ? hasFields(type.type) : false;
  }
}
function createLiftTypeArrayError(index, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
  let grandParent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
  const helpUrl = generateHelpUrl(SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  const context = [grandParent, parent].filter(Boolean).join("/");
  return new HelpfulError(oneline(_a$1 || (_a$1 = __template$1(["\n    Encountered anonymous inline ", " at index ", " for type/field ", ".\n    To use this type with GraphQL you will need to create a top-level schema type for it.\n    See ", ""])), inlineType, index, context, helpUrl), helpUrl);
}
function createLiftTypeError(typeName, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "object";
  const helpUrl = generateHelpUrl(SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  return new HelpfulError(oneline(_b || (_b = __template$1(["\n    Encountered anonymous inline ", ' "', '" for field/type "', '".\n    To use this field with GraphQL you will need to create a top-level schema type for it.\n    See ', ""])), inlineType, typeName, parent, helpUrl), helpUrl);
}
class HelpfulError extends Error {
  constructor(message, helpUrl) {
    super(message);
    this.helpUrl = helpUrl;
  }
}
function getDeprecation$1(type) {
  return isDeprecationConfiguration(type) ? {
    deprecationReason: type.deprecated.reason
  } : {};
}
function isUnion(type) {
  return type.kind === "Union";
}
function isNonUnion(type) {
  return !isUnion(type) && "type" in type;
}
function isDocumentType(type) {
  return isNonUnion(type) && type.type === "Object" && Array.isArray(type.interfaces) && type.interfaces.includes("Document");
}
const filterCreators$2 = {
  ID: createIdFilters$1,
  String: createStringFilters$1,
  Url: createStringFilters$1,
  Float: createNumberFilters,
  Integer: createNumberFilters,
  Boolean: createBooleanFilters$1,
  Datetime: createDateFilters$1,
  Date: createDateFilters$1,
  Object: createObjectFilters
};
function generateTypeFilters$2(types) {
  const queryable = types.filter(isNonUnion).filter(type => type.type === "Object" && type.interfaces && type.interfaces.includes("Document"));
  return queryable.map(type => {
    const name = "".concat(type.name, "Filter");
    const fields = flatten(type.fields.map(createFieldFilters$2)).filter(Boolean);
    return {
      name,
      kind: "InputObject",
      fields: [...fields, ...getDocumentFilters$2()]
    };
  });
}
function createFieldFilters$2(field) {
  if (filterCreators$2[field.type]) {
    return filterCreators$2[field.type](field);
  }
  if (field.kind === "List") {
    return createListFilters();
  }
  if (field.isReference) {
    return createReferenceFilters(field);
  }
  return createInlineTypeFilters();
}
function getFieldName(field) {
  let modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  const suffix = modifier ? "_".concat(modifier) : "";
  return "".concat(field.fieldName).concat(suffix);
}
function getDocumentFilters$2() {
  return [{
    fieldName: "references",
    type: "ID",
    description: "All documents references the given document ID",
    constraint: {
      comparator: "REFERENCES"
    }
  }, {
    fieldName: "is_draft",
    type: "Boolean",
    description: "All documents that are drafts",
    constraint: {
      field: "_id",
      comparator: "IS_DRAFT"
    }
  }];
}
function createIsDefinedFilter(field) {
  return {
    fieldName: getFieldName(field, "is_defined"),
    type: "Boolean",
    description: "All documents that have a value for this field",
    constraint: {
      field: field.fieldName,
      comparator: "IS_DEFINED"
    }
  };
}
function createEqualityFilter(field) {
  return {
    fieldName: getFieldName(field),
    type: field.type,
    description: "All documents that are equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "EQUALS"
    }
  };
}
function createInequalityFilter(field) {
  return {
    fieldName: getFieldName(field, "not"),
    type: field.type,
    description: "All documents that are not equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "NOT_EQUALS"
    }
  };
}
function createDefaultFilters(field) {
  return [createEqualityFilter(field), createInequalityFilter(field), createIsDefinedFilter(field)];
}
function createGtLtFilters(field) {
  return [{
    fieldName: getFieldName(field, "lt"),
    type: field.type,
    description: "All documents are less than given value",
    constraint: {
      field: field.fieldName,
      comparator: "LT"
    }
  }, {
    fieldName: getFieldName(field, "lte"),
    type: field.type,
    description: "All documents are less than or equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "LTE"
    }
  }, {
    fieldName: getFieldName(field, "gt"),
    type: field.type,
    description: "All documents are greater than given value",
    constraint: {
      field: field.fieldName,
      comparator: "GT"
    }
  }, {
    fieldName: getFieldName(field, "gte"),
    type: field.type,
    description: "All documents are greater than or equal to given value",
    constraint: {
      field: field.fieldName,
      comparator: "GTE"
    }
  }];
}
function createBooleanFilters$1(field) {
  return createDefaultFilters(field);
}
function createIdFilters$1(field) {
  return createStringFilters$1(field);
}
function createDateFilters$1(field) {
  return createDefaultFilters(field).concat(createGtLtFilters(field));
}
function createStringFilters$1(field) {
  return [...createDefaultFilters(field), {
    fieldName: getFieldName(field, "matches"),
    type: "String",
    description: "All documents contain (match) the given word/words",
    constraint: {
      field: field.fieldName,
      comparator: "MATCHES"
    }
  }, {
    fieldName: getFieldName(field, "in"),
    kind: "List",
    children: {
      type: "String",
      isNullable: false
    },
    description: "All documents match one of the given values",
    constraint: {
      field: field.fieldName,
      comparator: "IN"
    }
  }, {
    fieldName: getFieldName(field, "not_in"),
    kind: "List",
    children: {
      type: "String",
      isNullable: false
    },
    description: "None of the values match any of the given values",
    constraint: {
      field: field.fieldName,
      comparator: "NOT_IN"
    }
  }];
}
function createNumberFilters(field) {
  return createDefaultFilters(field).concat(createGtLtFilters(field));
}
function createObjectFilters(field) {
  return [];
}
function createListFilters() {
  return [];
}
function createInlineTypeFilters() {
  return [];
}
function createReferenceFilters(field) {
  return [{
    fieldName: getFieldName(field),
    type: "ID",
    constraint: {
      field: "".concat(field.fieldName, "._ref"),
      comparator: "EQUALS"
    }
  }];
}
function pluralizeTypeName(name) {
  const words = startCase(name).split(" ");
  const last = words[words.length - 1];
  const plural = pluralize(last.toLowerCase()).replace(/(\d)s$/g, "$1S");
  words[words.length - 1] = upperFirst(plural);
  return words.join("");
}
function generateTypeQueries$2(types, filters) {
  const queries = [];
  const queryable = types.filter(isNonUnion).filter(type => type.type === "Object" && type.interfaces && type.interfaces.includes("Document"));
  queryable.forEach(type => {
    queries.push({
      fieldName: type.name,
      type: type.name,
      constraints: [{
        field: "_id",
        comparator: "EQUALS",
        value: {
          kind: "argumentValue",
          argName: "id"
        }
      }],
      args: [{
        name: "id",
        description: "".concat(type.name, " document ID"),
        type: "ID",
        isNullable: false
      }]
    });
  });
  queryable.forEach(type => {
    const filterName = "".concat(type.name, "Filter");
    const hasFilter = filters.find(filter => filter.name === filterName);
    queries.push({
      fieldName: "all".concat(pluralizeTypeName(type.name)),
      filter: '_type == "'.concat(type.originalName || type.name, '"'),
      type: {
        kind: "List",
        isNullable: false,
        children: {
          type: type.name,
          isNullable: false
        }
      },
      args: hasFilter ? [{
        name: "where",
        type: filterName,
        isFieldFilter: true
      }, ...getLimitOffsetArgs()] : getLimitOffsetArgs()
    });
  });
  return queries;
}
function getLimitOffsetArgs() {
  return [{
    name: "limit",
    type: "Int",
    description: "Max documents to return",
    isFieldFilter: false
  }, {
    name: "offset",
    type: "Int",
    description: "Offset at which to start returning documents from",
    isFieldFilter: false
  }];
}
var gen1 = extracted => {
  const filters = generateTypeFilters$2(extracted.types);
  const queries = generateTypeQueries$2(extracted.types, filters);
  const types = [...extracted.types, ...filters];
  return {
    types,
    queries,
    interfaces: extracted.interfaces,
    generation: "gen1"
  };
};
function createBooleanFilters() {
  return {
    name: "BooleanFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "Boolean",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "Boolean",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
function createDateFilters() {
  return {
    name: "DateFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "Date",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "Date",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "gt",
      type: "Date",
      description: "Checks if the value is greater than the given input."
    }, {
      fieldName: "gte",
      type: "Date",
      description: "Checks if the value is greater than or equal to the given input."
    }, {
      fieldName: "lt",
      type: "Date",
      description: "Checks if the value is lesser than the given input."
    }, {
      fieldName: "lte",
      type: "Date",
      description: "Checks if the value is lesser than or equal to the given input."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
function createDateTimeFilters() {
  return {
    name: "DatetimeFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "Datetime",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "Datetime",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "gt",
      type: "Datetime",
      description: "Checks if the value is greater than the given input."
    }, {
      fieldName: "gte",
      type: "Datetime",
      description: "Checks if the value is greater than or equal to the given input."
    }, {
      fieldName: "lt",
      type: "Datetime",
      description: "Checks if the value is lesser than the given input."
    }, {
      fieldName: "lte",
      type: "Datetime",
      description: "Checks if the value is lesser than or equal to the given input."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
function createDocumentFilters$1() {
  return {
    name: "DocumentFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "references",
      type: "ID",
      description: "All documents referencing the given document ID."
    }, {
      fieldName: "is_draft",
      type: "Boolean",
      description: "All documents that are drafts."
    }]
  };
}
function createFloatFilters() {
  return {
    name: "FloatFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "Float",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "Float",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "gt",
      type: "Float",
      description: "Checks if the value is greater than the given input."
    }, {
      fieldName: "gte",
      type: "Float",
      description: "Checks if the value is greater than or equal to the given input."
    }, {
      fieldName: "lt",
      type: "Float",
      description: "Checks if the value is lesser than the given input."
    }, {
      fieldName: "lte",
      type: "Float",
      description: "Checks if the value is lesser than or equal to the given input."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
function createIdFilters() {
  return {
    name: "IDFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "ID",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "ID",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "matches",
      type: "ID",
      description: "Checks if the value matches the given word/words."
    }, {
      fieldName: "in",
      kind: "List",
      children: {
        type: "ID",
        isNullable: false
      },
      description: "Checks if the value is equal to one of the given values."
    }, {
      fieldName: "nin",
      kind: "List",
      children: {
        type: "ID",
        isNullable: false
      },
      description: "Checks if the value is not equal to one of the given values."
    }]
  };
}
function createIntegerFilters() {
  return {
    name: "IntFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "Int",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "Int",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "gt",
      type: "Int",
      description: "Checks if the value is greater than the given input."
    }, {
      fieldName: "gte",
      type: "Int",
      description: "Checks if the value is greater than or equal to the given input."
    }, {
      fieldName: "lt",
      type: "Int",
      description: "Checks if the value is lesser than the given input."
    }, {
      fieldName: "lte",
      type: "Int",
      description: "Checks if the value is lesser than or equal to the given input."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
function createStringFilters() {
  return {
    name: "StringFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "eq",
      type: "String",
      description: "Checks if the value is equal to the given input."
    }, {
      fieldName: "neq",
      type: "String",
      description: "Checks if the value is not equal to the given input."
    }, {
      fieldName: "matches",
      type: "String",
      description: "Checks if the value matches the given word/words."
    }, {
      fieldName: "in",
      kind: "List",
      children: {
        type: "String",
        isNullable: false
      },
      description: "Checks if the value is equal to one of the given values."
    }, {
      fieldName: "nin",
      kind: "List",
      children: {
        type: "String",
        isNullable: false
      },
      description: "Checks if the value is not equal to one of the given values."
    }, {
      fieldName: "is_defined",
      type: "Boolean",
      description: "Checks if the value is defined."
    }]
  };
}
const typeAliases$1 = {
  Url: "String",
  Text: "String",
  Email: "String"
};
const filterCreators$1 = {
  ID: createIdFilters,
  String: createStringFilters,
  Float: createFloatFilters,
  Integer: createIntegerFilters,
  Boolean: createBooleanFilters,
  Datetime: createDateTimeFilters,
  Date: createDateFilters,
  Document: createDocumentFilters$1
};
function generateTypeFilters$1(types) {
  const builtInTypeKeys = Object.keys(filterCreators$1);
  const builtinTypeValues = Object.values(filterCreators$1);
  const objectTypes = types.filter(isNonUnion).filter(type => type.type === "Object" && !["Block", "Span"].includes(type.name) && !type.interfaces && !builtInTypeKeys.includes(type.type));
  const unionTypes = types.filter(isUnion).map(type => type.name);
  const documentTypes = types.filter(isNonUnion).filter(type => type.type === "Object" && type.interfaces && type.interfaces.includes("Document"));
  const builtinTypeFilters = createBuiltinTypeFilters$1(builtinTypeValues);
  const objectTypeFilters = createObjectTypeFilters$1(objectTypes, {
    unionTypes
  });
  const documentTypeFilters = createDocumentTypeFilters$1(documentTypes, {
    unionTypes
  });
  return [...builtinTypeFilters, ...objectTypeFilters, ...documentTypeFilters];
}
function createBuiltinTypeFilters$1(builtinTypeValues) {
  return builtinTypeValues.map(filterCreator => filterCreator());
}
function createObjectTypeFilters$1(objectTypes, options) {
  return objectTypes.map(objectType => ({
    name: "".concat(objectType.name, "Filter"),
    kind: "InputObject",
    fields: createFieldFilters$1(objectType, options)
  }));
}
function createDocumentTypeFilters$1(documentTypes, options) {
  return documentTypes.map(documentType => ({
    name: "".concat(documentType.name, "Filter"),
    kind: "InputObject",
    fields: [...getDocumentFilters$1(), ...createFieldFilters$1(documentType, options)]
  }));
}
function createFieldFilters$1(objectType, options) {
  const {
    unionTypes
  } = options;
  return objectType.fields.filter(field => field.type !== "JSON" && field.kind !== "List" && !unionTypes.includes(field.type)).map(field => ({
    fieldName: field.fieldName,
    type: "".concat(typeAliases$1[field.type] || field.type, "Filter"),
    isReference: field.isReference
  }));
}
function getDocumentFilters$1() {
  return [{
    fieldName: "_",
    type: "DocumentFilter",
    description: "Apply filters on document level"
  }];
}
function generateTypeQueries$1(types, sortings) {
  const queries = [];
  const queryable = types.filter(isDocumentType);
  const isSortable = type => sortings.some(sorting => sorting.name === "".concat(type.name, "Sorting"));
  queries.push({
    fieldName: "Document",
    type: "Document",
    constraints: [{
      field: "_id",
      comparator: "eq",
      value: {
        kind: "argumentValue",
        argName: "id"
      }
    }],
    args: [{
      name: "id",
      description: "Document ID",
      type: "ID",
      isNullable: false
    }]
  });
  queryable.forEach(type => {
    queries.push({
      fieldName: type.name,
      type: type.name,
      constraints: [{
        field: "_id",
        comparator: "eq",
        value: {
          kind: "argumentValue",
          argName: "id"
        }
      }],
      args: [{
        name: "id",
        description: "".concat(type.name, " document ID"),
        type: "ID",
        isNullable: false
      }]
    });
  });
  queryable.forEach(type => {
    const sorting = [];
    if (isSortable(type)) {
      sorting.push({
        name: "sort",
        type: {
          kind: "List",
          isNullable: true,
          children: {
            type: "".concat(type.name, "Sorting"),
            isNullable: false
          }
        }
      });
    }
    queries.push({
      fieldName: "all".concat(upperFirst(type.name)),
      filter: '_type == "'.concat(type.originalName || type.name, '"'),
      type: {
        kind: "List",
        isNullable: false,
        children: {
          type: type.name,
          isNullable: false
        }
      },
      args: [{
        name: "where",
        type: "".concat(type.name, "Filter"),
        isFieldFilter: true
      }, ...sorting, {
        name: "limit",
        type: "Int",
        description: "Max documents to return",
        isFieldFilter: false
      }, {
        name: "offset",
        type: "Int",
        description: "Offset at which to start returning documents from",
        isFieldFilter: false
      }]
    });
  });
  return queries;
}
const builtInTypes$1 = ["Boolean", "Date", "Datetime", "Email", "Float", "ID", "Integer", "String", "Text", "Url"];
const builtInSortingEnum$1 = {
  name: "SortOrder",
  kind: "Enum",
  values: [{
    name: "ASC",
    description: "Sorts on the value in ascending order.",
    value: 1
  }, {
    name: "DESC",
    description: "Sorts on the value in descending order.",
    value: 2
  }]
};
function generateTypeSortings$1(types) {
  const objectTypes = types.filter(isNonUnion).filter(type => type.type === "Object" && !["Block", "Span"].includes(type.name) &&
  // TODO: What do we do with blocks?
  !type.interfaces && !builtInTypes$1.includes(type.name));
  const documentTypes = types.filter(isDocumentType);
  const hasFields = type => type.fields.length > 0;
  const objectTypeSortings = createObjectTypeSortings$1(objectTypes);
  const documentTypeSortings = createDocumentTypeSortings$1(documentTypes);
  const allSortings = [...objectTypeSortings, ...documentTypeSortings].filter(hasFields);
  return [...allSortings, builtInSortingEnum$1];
}
function createObjectTypeSortings$1(objectTypes) {
  return objectTypes.map(objectType => ({
    name: "".concat(objectType.name, "Sorting"),
    kind: "InputObject",
    fields: objectType.fields.filter(field => field.type !== "JSON" && field.kind !== "List").filter(field => !field.isReference).map(field => ({
      fieldName: field.fieldName,
      type: builtInTypes$1.includes(field.type) ? builtInSortingEnum$1.name : "".concat(field.type, "Sorting")
    }))
  }));
}
function createDocumentTypeSortings$1(documentTypes) {
  return documentTypes.map(documentType => ({
    name: "".concat(documentType.name, "Sorting"),
    kind: "InputObject",
    fields: documentType.fields.filter(field => field.type !== "JSON" && field.kind !== "List").filter(field => !field.isReference).map(field => ({
      fieldName: field.fieldName,
      type: builtInTypes$1.includes(field.type) ? builtInSortingEnum$1.name : "".concat(field.type, "Sorting")
    }))
  }));
}
var gen2 = extracted => {
  const filters = generateTypeFilters$1(extracted.types);
  const sortings = generateTypeSortings$1(extracted.types);
  const queries = generateTypeQueries$1(extracted.types, sortings.filter(node => node.kind === "InputObject"));
  const types = [...extracted.types, ...filters, ...sortings];
  return {
    types,
    queries,
    interfaces: extracted.interfaces,
    generation: "gen2"
  };
};
function createDocumentFilters() {
  return {
    name: "Sanity_DocumentFilter",
    kind: "InputObject",
    isConstraintFilter: true,
    fields: [{
      fieldName: "references",
      type: "ID",
      description: "All documents referencing the given document ID."
    }, {
      fieldName: "is_draft",
      type: "Boolean",
      description: "All documents that are drafts."
    }]
  };
}
function getFilterFieldName(fieldName) {
  let suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Filter";
  return "".concat(fieldName).concat(suffix);
}
const typeAliases = {
  Url: "String",
  Text: "String",
  Email: "String"
};
const filterCreators = {
  ID: createIdFilters,
  String: createStringFilters,
  Float: createFloatFilters,
  Integer: createIntegerFilters,
  Boolean: createBooleanFilters,
  Datetime: createDateTimeFilters,
  Date: createDateFilters,
  Document: createDocumentFilters
};
function generateTypeFilters(types, options) {
  const {
    filterSuffix
  } = options || {};
  const builtInTypeKeys = Object.keys(filterCreators);
  const builtinTypeValues = Object.values(filterCreators);
  const objectTypes = types.filter(isNonUnion).filter(type => type.type === "Object" && !["Block", "Span"].includes(type.name) &&
  // TODO: What do we do with blocks?
  !type.interfaces && !builtInTypeKeys.includes(type.type));
  const unionTypes = types.filter(isUnion).map(type => type.name);
  const documentTypes = types.filter(type => type.name === "Document" || isDocumentType(type));
  const builtinTypeFilters = createBuiltinTypeFilters(builtinTypeValues);
  const objectTypeFilters = createObjectTypeFilters(objectTypes, {
    unionTypes,
    filterSuffix
  });
  const documentTypeFilters = createDocumentTypeFilters(documentTypes, {
    unionTypes,
    filterSuffix
  });
  return builtinTypeFilters.concat(objectTypeFilters).concat(documentTypeFilters);
}
function createBuiltinTypeFilters(builtinTypeValues) {
  return builtinTypeValues.map(filterCreator => filterCreator());
}
function createObjectTypeFilters(objectTypes, options) {
  return objectTypes.map(objectType => ({
    name: getFilterFieldName(objectType.name, options.filterSuffix),
    kind: "InputObject",
    fields: createFieldFilters(objectType, options)
  }));
}
function createDocumentTypeFilters(documentTypes, options) {
  return documentTypes.map(documentType => ({
    name: getFilterFieldName(documentType.name, options.filterSuffix),
    kind: "InputObject",
    fields: [...getDocumentFilters(), ...createFieldFilters(documentType, options)]
  }));
}
function createFieldFilters(objectType, options) {
  const {
    unionTypes
  } = options;
  if (!objectType.fields) {
    return [];
  }
  return objectType.fields.filter(field => field.type !== "JSON" && field.kind !== "List" && !unionTypes.includes(field.type)).map(field => {
    const typeName = typeAliases[field.type] || field.type;
    const filterSuffix = Object.keys({
      ...typeAliases,
      ...filterCreators
    }).includes(typeName) ? void 0 : options.filterSuffix;
    return {
      fieldName: field.fieldName,
      type: getFilterFieldName(typeAliases[field.type] || field.type, filterSuffix),
      isReference: field.isReference
    };
  });
}
function getDocumentFilters() {
  return [{
    fieldName: "_",
    type: "Sanity_DocumentFilter",
    description: "Apply filters on document level"
  }];
}
function generateTypeQueries(types, sortings, options) {
  const {
    filterSuffix
  } = options || {};
  const queries = [];
  const documentTypes = types.filter(isDocumentType);
  const documentTypeNames = documentTypes.map(docType => JSON.stringify(docType.originalName || docType.name));
  const documentsFilter = "_type in [".concat(documentTypeNames.join(", "), "]");
  const documentInterface = types.find(type => type.name === "Document");
  if (!documentInterface || isUnion(documentInterface)) {
    throw new Error("Failed to find document interface");
  }
  const queryable = [...documentTypes, documentInterface];
  const isSortable = type => sortings.some(sorting => sorting.name === "".concat(type.name, "Sorting"));
  queryable.forEach(type => {
    queries.push({
      fieldName: type.name,
      type: type.name,
      constraints: [{
        field: "_id",
        comparator: "eq",
        value: {
          kind: "argumentValue",
          argName: "id"
        }
      }],
      args: [{
        name: "id",
        description: "".concat(type.name, " document ID"),
        type: "ID",
        isNullable: false
      }],
      ...getDeprecation(type)
    });
  });
  queryable.forEach(type => {
    const sorting = [];
    if (isSortable(type)) {
      sorting.push({
        name: "sort",
        type: {
          kind: "List",
          isNullable: true,
          children: {
            type: "".concat(type.name, "Sorting"),
            isNullable: false
          }
        }
      });
    }
    queries.push({
      fieldName: "all".concat(upperFirst(type.name)),
      filter: type.name === "Document" && type.kind === "Interface" ? documentsFilter : "_type == ".concat(JSON.stringify(type.originalName || type.name)),
      type: {
        kind: "List",
        isNullable: false,
        children: {
          type: type.name,
          isNullable: false
        }
      },
      args: [{
        name: "where",
        type: getFilterFieldName(type.name, filterSuffix),
        isFieldFilter: true
      }, ...sorting, {
        name: "limit",
        type: "Int",
        description: "Max documents to return",
        isFieldFilter: false
      }, {
        name: "offset",
        type: "Int",
        description: "Offset at which to start returning documents from",
        isFieldFilter: false
      }],
      ...getDeprecation(type)
    });
  });
  return queries;
}
function getDeprecation(type) {
  var _a;
  return ((_a = type[internal]) == null ? void 0 : _a.deprecationReason) ? {
    deprecationReason: type[internal].deprecationReason
  } : {};
}
const builtInTypes = ["Boolean", "Date", "Datetime", "Email", "Float", "ID", "Integer", "String", "Text", "Url"];
const builtInSortingEnum = {
  name: "SortOrder",
  kind: "Enum",
  values: [{
    name: "ASC",
    description: "Sorts on the value in ascending order.",
    value: 1
  }, {
    name: "DESC",
    description: "Sorts on the value in descending order.",
    value: 2
  }]
};
function generateTypeSortings(types) {
  const objectTypes = types.filter(isNonUnion).filter(type => type.type === "Object" && !["Block", "Span"].includes(type.name) &&
  // TODO: What do we do with blocks?
  !type.interfaces && !builtInTypes.includes(type.name));
  const documentTypes = types.filter(type => type.name === "Document" || isDocumentType(type));
  const hasFields = type => type.fields.length > 0;
  const objectTypeSortings = createObjectTypeSortings(objectTypes);
  const documentTypeSortings = createDocumentTypeSortings(documentTypes);
  const allSortings = [...objectTypeSortings, ...documentTypeSortings].filter(hasFields);
  return [...allSortings, builtInSortingEnum];
}
function createObjectTypeSortings(objectTypes) {
  return objectTypes.map(objectType => ({
    name: "".concat(objectType.name, "Sorting"),
    kind: "InputObject",
    fields: objectType.fields.filter(field => field.type !== "JSON" && field.kind !== "List").filter(field => !field.isReference).map(field => ({
      fieldName: field.fieldName,
      type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : "".concat(field.type, "Sorting")
    }))
  }));
}
function createDocumentTypeSortings(documentTypes) {
  return documentTypes.map(documentType => ({
    name: "".concat(documentType.name, "Sorting"),
    kind: "InputObject",
    fields: documentType.fields.filter(field => field.type !== "JSON" && field.kind !== "List").filter(field => !field.isReference).map(field => ({
      fieldName: field.fieldName,
      type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : "".concat(field.type, "Sorting")
    }))
  }));
}
var gen3 = (extracted, options) => {
  const documentInterface = extracted.interfaces.find(iface => iface.name === "Document");
  if (!documentInterface || isUnion(documentInterface)) {
    throw new Error("Failed to find document interface");
  }
  const types = [...extracted.types, documentInterface];
  const filters = generateTypeFilters(types, options);
  const sortings = generateTypeSortings(types);
  const queries = generateTypeQueries(types, sortings.filter(node => node.kind === "InputObject"), options);
  const graphqlTypes = [...extracted.types, ...filters, ...sortings];
  return {
    types: graphqlTypes,
    queries,
    interfaces: extracted.interfaces,
    generation: "gen3"
  };
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const latestGeneration = "gen3";
const generations = {
  gen1,
  gen2,
  gen3
};
const apiIdRegex = /^[a-z0-9_-]+$/;
const isInteractive = process.stdout.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env);
const ignoredWarnings = ["OPTIONAL_INPUT_FIELD_ADDED"];
const ignoredBreaking = [];
async function deployGraphQLApiAction(args, context) {
  const flags = await parseCliFlags(args);
  const {
    force,
    dryRun,
    api: onlyApis,
    dataset: datasetFlag,
    tag: tagFlag,
    playground: playgroundFlag,
    generation: generationFlag,
    "non-null-document-fields": nonNullDocumentFieldsFlag,
    withUnionCache
  } = flags;
  const {
    apiClient,
    output,
    prompt
  } = context;
  let spinner;
  const client = apiClient({
    requireUser: true,
    // Don't throw if we do not have a project ID defined, as we will infer it from the
    // source/ workspace of each configured API later
    requireProject: false
  }).config({
    apiVersion: "2023-08-01"
  });
  const apiDefs = await getGraphQLAPIs(context);
  const hasMultipleApis = apiDefs.length > 1 || flags.api && flags.api.length > 1;
  const usedFlags = [datasetFlag && "--dataset", tagFlag && "--tag", typeof playgroundFlag !== "undefined" && "--playground", typeof generationFlag !== "undefined" && "--generation", typeof nonNullDocumentFieldsFlag !== "undefined" && "--non-null-document-fields"].filter(Boolean);
  if (hasMultipleApis && usedFlags.length > 0) {
    output.warn("WARN: More than one API defined, and ".concat(usedFlags.join("/"), " is specified"));
    output.warn("WARN: This will use the specified flag(s) for ALL APIs, overriding config!");
    if (flags.force) {
      output.warn("WARN: --force specified, continuing...");
    } else if (!(await prompt.single({
      type: "confirm",
      message: "Continue with flag overrides for all APIs?",
      default: false
    }))) {
      process.exit(1);
    }
  }
  const deployTasks = [];
  const apiNames = /* @__PURE__ */new Set();
  const apiIds = /* @__PURE__ */new Set();
  for (const apiDef of apiDefs) {
    const dataset = datasetFlag || apiDef.dataset;
    const tag = tagFlag || apiDef.tag || "default";
    const apiName = [dataset, tag].join("/");
    if (apiNames.has(apiName)) {
      throw new Error("Multiple GraphQL APIs with the same dataset and tag found (".concat(apiName, ")"));
    }
    if (apiDef.id) {
      if (typeof apiDef.id !== "string" || !apiIdRegex.test(apiDef.id)) {
        throw new Error('Invalid GraphQL API id "'.concat(apiDef.id, '" - only a-z, 0-9, underscore and dashes are allowed'));
      }
      if (apiIds.has(apiDef.id)) {
        throw new Error("Multiple GraphQL APIs with the same ID found (".concat(apiDef.id, ")"));
      }
      apiIds.add(apiDef.id);
    }
    apiNames.add(apiName);
  }
  for (const apiId of onlyApis || []) {
    if (!apiDefs.some(apiDef => apiDef.id === apiId)) {
      throw new Error('GraphQL API with id "'.concat(apiId, '" not found'));
    }
  }
  if (onlyApis) {
    output.warn("Deploying only specified APIs: ".concat(onlyApis.join(", ")));
  }
  let index = -1;
  for (const apiDef of apiDefs) {
    if (onlyApis && (!apiDef.id || !onlyApis.includes(apiDef.id))) {
      continue;
    }
    index++;
    const dataset = datasetFlag || apiDef.dataset;
    const tag = tagFlag || apiDef.tag || "default";
    const {
      projectId,
      playground,
      nonNullDocumentFields,
      schema
    } = apiDef;
    const apiName = [dataset, tag].join("/");
    spinner = output.spinner("Generating GraphQL API: ".concat(apiName)).start();
    if (!dataset) {
      throw new Error("No dataset specified for API at index ".concat(index));
    }
    const projectClient = client.clone().config({
      projectId,
      useProjectHostname: true
    });
    const {
      currentGeneration,
      playgroundEnabled
    } = await getCurrentSchemaProps(projectClient, dataset, tag);
    const specifiedGeneration = typeof generationFlag === "undefined" ? apiDef.generation : generationFlag;
    const generation = await resolveApiGeneration({
      currentGeneration,
      specifiedGeneration,
      index,
      force,
      output,
      prompt
    });
    if (!generation) {
      spinner.fail();
      continue;
    }
    if (!isRecognizedApiGeneration(generation)) {
      throw new Error('Unknown API generation "'.concat(generation, '" for API at index ').concat(index));
    }
    const enablePlayground = await shouldEnablePlayground({
      dryRun,
      spinner,
      playgroundCliFlag: playgroundFlag,
      playgroundConfiguration: playground,
      playgroundCurrentlyEnabled: playgroundEnabled,
      prompt
    });
    let apiSpec;
    try {
      const generateSchema = generations[generation];
      const extracted = extractFromSanitySchema(schema, {
        // Allow CLI flag to override configured setting
        nonNullDocumentFields: typeof nonNullDocumentFieldsFlag === "undefined" ? nonNullDocumentFields : nonNullDocumentFieldsFlag,
        withUnionCache
      });
      apiSpec = generateSchema(extracted, {
        filterSuffix: apiDef.filterSuffix
      });
    } catch (err) {
      spinner.fail();
      if (err instanceof SchemaError) {
        err.print(output);
        process.exit(1);
      }
      throw err;
    }
    let valid;
    try {
      valid = await projectClient.request({
        url: "/apis/graphql/".concat(dataset, "/").concat(tag, "/validate"),
        method: "POST",
        body: {
          enablePlayground,
          schema: apiSpec
        },
        maxRedirects: 0
      });
    } catch (err) {
      const validationError = get(err, "response.body.validationError");
      spinner.fail();
      throw validationError ? new Error(validationError) : err;
    }
    if (!isResultValid(valid, {
      spinner,
      force
    })) {
      if (dryRun) {
        spinner.fail();
        renderBreakingChanges(valid, output);
        process.exit(1);
      }
      if (!isInteractive) {
        spinner.fail();
        renderBreakingChanges(valid, output);
        throw new Error("Dangerous changes found - falling back. Re-run the command with the `--force` flag to force deployment.");
      }
      spinner.stop();
      renderBreakingChanges(valid, output);
      const shouldDeploy = await prompt.single({
        type: "confirm",
        message: "Do you want to deploy a new API despite the dangerous changes?",
        default: false
      });
      if (!shouldDeploy) {
        spinner.fail();
        continue;
      }
      spinner.succeed();
    } else if (dryRun) {
      spinner.succeed();
      output.print("GraphQL API is valid and has no breaking changes");
      process.exit(0);
    }
    deployTasks.push({
      projectId,
      dataset,
      tag,
      enablePlayground,
      schema: apiSpec
    });
  }
  output.print("");
  for (const task of deployTasks) {
    const {
      dataset,
      tag,
      schema,
      projectId,
      enablePlayground
    } = task;
    output.print("Project: ".concat(projectId));
    output.print("Dataset: ".concat(dataset));
    output.print("Tag:     ".concat(tag));
    spinner = output.spinner("Deploying GraphQL API").start();
    try {
      const projectClient = client.clone().config({
        projectId,
        useProjectHostname: true
      });
      const response = await projectClient.request({
        url: "/apis/graphql/".concat(dataset, "/").concat(tag),
        method: "PUT",
        body: {
          enablePlayground,
          schema
        },
        maxRedirects: 0
      });
      spinner.stop();
      const apiUrl = getClientUrl(projectClient, response.location.replace(/^\/(v1|v\d{4}-\d{2}-\d{2})\//, "/"));
      output.print("URL:     ".concat(apiUrl));
      spinner.start("Deployed!").succeed();
      output.print("");
    } catch (err) {
      spinner.fail();
      throw err;
    }
  }
  process.exit(0);
}
async function shouldEnablePlayground(_ref) {
  let {
    dryRun,
    spinner,
    playgroundCliFlag,
    playgroundConfiguration,
    playgroundCurrentlyEnabled,
    prompt
  } = _ref;
  if (dryRun) {
    return true;
  }
  if (typeof playgroundCliFlag !== "undefined") {
    return playgroundCliFlag;
  }
  if (typeof playgroundConfiguration !== "undefined") {
    return playgroundConfiguration;
  }
  if (typeof playgroundCurrentlyEnabled !== "undefined") {
    return playgroundCurrentlyEnabled;
  }
  if (!isInteractive) {
    return true;
  }
  const prevText = spinner.text;
  spinner.warn();
  const shouldDeploy = await prompt.single({
    type: "confirm",
    message: "Do you want to enable a GraphQL playground?",
    default: true
  });
  spinner.clear().start(prevText);
  return shouldDeploy;
}
async function getCurrentSchemaProps(client, dataset, tag) {
  try {
    const apiUrl = getClientUrl(client, "/apis/graphql/".concat(dataset, "/").concat(tag));
    const res = await getUrlHeaders(apiUrl, {
      Authorization: "Bearer ".concat(client.config().token)
    });
    return {
      currentGeneration: res["x-sanity-graphql-generation"],
      playgroundEnabled: res["x-sanity-graphql-playground"] === "true"
    };
  } catch (err) {
    if (err.statusCode === 404) {
      return {};
    }
    throw err;
  }
}
function parseCliFlags(args) {
  return yargs(hideBin(args.argv || process.argv).slice(2)).option("tag", {
    type: "string"
  }).option("dataset", {
    type: "string"
  }).option("api", {
    type: "string",
    array: true
  }).option("dry-run", {
    type: "boolean",
    default: false
  }).option("generation", {
    type: "string"
  }).option("non-null-document-fields", {
    type: "boolean"
  }).option("playground", {
    type: "boolean"
  }).option("with-union-cache", {
    type: "boolean"
  }).option("force", {
    type: "boolean"
  }).argv;
}
function isResultValid(valid, _ref2) {
  let {
    spinner,
    force
  } = _ref2;
  const {
    validationError,
    breakingChanges: breaking,
    dangerousChanges: dangerous
  } = valid;
  if (validationError) {
    spinner.fail();
    throw new Error("GraphQL schema is not valid:\n\n".concat(validationError));
  }
  const breakingChanges = breaking.filter(change => !ignoredBreaking.includes(change.type));
  const dangerousChanges = dangerous.filter(change => !ignoredWarnings.includes(change.type));
  const hasProblematicChanges = breakingChanges.length > 0 || dangerousChanges.length > 0;
  if (force && hasProblematicChanges) {
    spinner.text = "Validating GraphQL API: Dangerous changes. Forced with `--force`.";
    spinner.warn();
    return true;
  } else if (force || !hasProblematicChanges) {
    spinner.succeed();
    return true;
  }
  spinner.warn();
  return false;
}
function renderBreakingChanges(valid, output) {
  const {
    breakingChanges: breaking,
    dangerousChanges: dangerous
  } = valid;
  const breakingChanges = breaking.filter(change => !ignoredBreaking.includes(change.type));
  const dangerousChanges = dangerous.filter(change => !ignoredWarnings.includes(change.type));
  if (dangerousChanges.length > 0) {
    output.print("\nFound potentially dangerous changes from previous schema:");
    dangerousChanges.forEach(change => output.print(" - ".concat(change.description)));
  }
  if (breakingChanges.length > 0) {
    output.print("\nFound BREAKING changes from previous schema:");
    breakingChanges.forEach(change => output.print(" - ".concat(change.description)));
  }
  output.print("");
}
async function resolveApiGeneration(_ref3) {
  let {
    currentGeneration,
    specifiedGeneration,
    index,
    force,
    output,
    prompt
  } = _ref3;
  if (!currentGeneration) {
    const generation = specifiedGeneration || latestGeneration;
    debug("There is no current generation deployed, using %s (%s)", generation, specifiedGeneration ? "specified" : "default");
    return generation;
  }
  if (specifiedGeneration && specifiedGeneration !== currentGeneration) {
    if (!force && !isInteractive) {
      throw new Error(oneline(_a || (_a = __template(["\n        Specified generation (", ") for API at index ", " differs from the one currently deployed (", ").\n        Re-run the command with `--force` to force deployment.\n      "], ["\n        Specified generation (", ") for API at index ", " differs from the one currently deployed (", ").\n        Re-run the command with \\`--force\\` to force deployment.\n      "])), specifiedGeneration, index, currentGeneration));
    }
    output.warn("Specified generation (".concat(specifiedGeneration, ") for API at index ").concat(index, " differs from the one currently deployed (").concat(currentGeneration, ")."));
    const confirmDeploy = force || (await prompt.single({
      type: "confirm",
      message: "Are you sure you want to deploy?",
      default: false
    }));
    return confirmDeploy ? specifiedGeneration : void 0;
  }
  if (specifiedGeneration) {
    debug("Using specified (%s) generation", specifiedGeneration);
    return specifiedGeneration;
  }
  debug("Using the currently deployed version (%s)", currentGeneration);
  return currentGeneration;
}
function isRecognizedApiGeneration(generation) {
  return generations.hasOwnProperty(generation);
}
export { deployGraphQLApiAction as default };
//# sourceMappingURL=deployApiAction-BRscwb_W.js.map
