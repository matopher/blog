import { jsx, jsxs } from 'react/jsx-runtime';
import { Button as Button$1, Dialog as Dialog$1, Flex, Box, MenuButton as MenuButton$1, MenuGroup as MenuGroup$1, Text, Stack, Hotkeys, Badge, MenuItem as MenuItem$1, Popover as Popover$1, Tab as Tab$1, Tooltip as Tooltip$1, TooltipDelayGroupProvider as TooltipDelayGroupProvider$1 } from '@sanity/ui';
import { forwardRef, useCallback, useMemo, isValidElement, createElement } from 'react';
import { isValidElementType } from 'react-is';
import styled from 'styled-components';
import { useTranslation } from 'react-i18next';
function ConditionalWrapper(_ref) {
  let {
    children,
    condition,
    wrapper
  } = _ref;
  if (!condition) {
    return children;
  }
  return wrapper(children);
}
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const LARGE_BUTTON_PROPS = {
  space: 3,
  padding: 3
};
const DEFAULT_BUTTON_PROPS = {
  space: 2,
  padding: 2
};
const TooltipButtonWrapper = styled.span(_a$1 || (_a$1 = __template$1(["\n  display: inline-flex;\n"])));
const Button = forwardRef(function Button2(_ref2, ref) {
  let {
    size = "default",
    mode = "default",
    paddingY,
    tone = "default",
    tooltipProps,
    ...rest
  } = _ref2;
  const renderWrapper = useCallback(children => {
    return /* @__PURE__ */jsx(Tooltip, {
      content: tooltipProps == null ? void 0 : tooltipProps.content,
      portal: true,
      ...tooltipProps,
      children: /* @__PURE__ */jsx(TooltipButtonWrapper, {
        children
      })
    });
  }, [tooltipProps]);
  const sizeProps = size === "default" ? DEFAULT_BUTTON_PROPS : LARGE_BUTTON_PROPS;
  return /* @__PURE__ */jsx(ConditionalWrapper, {
    condition: !!tooltipProps,
    wrapper: renderWrapper,
    children: /* @__PURE__ */jsx(Button$1, {
      ...rest,
      ...sizeProps,
      paddingY,
      ref,
      mode,
      tone
    })
  });
});
const Dialog = forwardRef(function Dialog2(_ref3, ref) {
  let {
    bodyHeight,
    children,
    footer,
    padding = true,
    ...props
  } = _ref3;
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */jsx(Dialog$1, {
    ...props,
    animate: true,
    ref,
    footer: ((footer == null ? void 0 : footer.confirmButton) || (footer == null ? void 0 : footer.cancelButton)) && /* @__PURE__ */jsxs(Flex, {
      width: "full",
      gap: 3,
      justify: "flex-end",
      padding: 3,
      children: [props.onClose && /* @__PURE__ */jsx(Button$1, {
        mode: "bleed",
        padding: 2,
        text: t("common.dialog.cancel-button.text"),
        tone: "default",
        onClick: props.onClose,
        ...footer.cancelButton
      }), footer.confirmButton && /* @__PURE__ */jsx(Button$1, {
        mode: "default",
        padding: 2,
        text: t("common.dialog.confirm-button.text"),
        tone: "critical",
        ...footer.confirmButton
      })]
    }),
    children: /* @__PURE__ */jsx(Box, {
      height: bodyHeight,
      padding: padding ? 4 : 0,
      children
    })
  });
});
const MenuButton = forwardRef(function MenuButton2(props, ref) {
  return /* @__PURE__ */jsx(MenuButton$1, {
    ...props,
    ref,
    popover: {
      ...props.popover,
      animate: true
    }
  });
});
const MenuGroup = props => {
  return /* @__PURE__ */jsx(MenuGroup$1, {
    ...props,
    fontSize: 1,
    padding: 3
  });
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a, _b;
const FONT_SIZE = 1;
const SUBTITLE_FONT_SIZE = 0;
const SubtitleText = styled(Text)(_a || (_a = __template(["\n  margin-top: 2px;\n"])));
const PreviewWrapper = styled(Box)(_b || (_b = __template(["\n  height: 25px;\n  width: 25px;\n  overflow: hidden;\n"])));
const MenuItem = forwardRef(function MenuItem2(_ref4, ref) {
  let {
    badgeText,
    children: childrenProp,
    disabled,
    hotkeys,
    icon,
    iconRight,
    preview = null,
    renderMenuItem,
    text,
    tooltipProps,
    __unstable_subtitle,
    __unstable_space,
    ...rest
  } = _ref4;
  const menuItemContent = useMemo(() => {
    return /* @__PURE__ */jsxs(Flex, {
      align: "center",
      gap: 2,
      children: [preview && /* @__PURE__ */jsx(PreviewWrapper, {
        style: {
          opacity: disabled ? 0.25 : void 0
        },
        paddingRight: __unstable_space ? 1 : 0,
        children: /* @__PURE__ */jsx(Flex, {
          align: "center",
          height: "fill",
          justify: "center",
          children: preview
        })
      }), icon && /* @__PURE__ */jsx(Box, {
        paddingRight: 1,
        children: /* @__PURE__ */jsxs(Text, {
          size: FONT_SIZE,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        })
      }), text && /* @__PURE__ */jsxs(Stack, {
        flex: 1,
        space: __unstable_subtitle ? 1 : 2,
        paddingLeft: __unstable_subtitle ? 1 : 0,
        children: [/* @__PURE__ */jsx(Text, {
          size: FONT_SIZE,
          textOverflow: "ellipsis",
          weight: "medium",
          children: text
        }), __unstable_subtitle && /* @__PURE__ */jsx(SubtitleText, {
          size: SUBTITLE_FONT_SIZE,
          textOverflow: "ellipsis",
          weight: "medium",
          muted: true,
          children: __unstable_subtitle
        })]
      }), (badgeText || hotkeys || iconRight) && /* @__PURE__ */jsxs(Flex, {
        align: "center",
        gap: 3,
        marginLeft: 3,
        children: [hotkeys && /* @__PURE__ */jsx(Hotkeys, {
          keys: hotkeys,
          style: {
            marginTop: -4,
            marginBottom: -4
          }
        }), badgeText && /* @__PURE__ */jsx(Badge, {
          fontSize: 0,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: badgeText
        }), iconRight && /* @__PURE__ */jsxs(Text, {
          size: FONT_SIZE,
          children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
        })]
      })]
    });
  }, [preview, disabled, __unstable_space, icon, text, __unstable_subtitle, badgeText, hotkeys, iconRight]);
  const renderWrapper = useCallback(children => {
    return /* @__PURE__ */jsx(Tooltip, {
      content: tooltipProps == null ? void 0 : tooltipProps.content,
      portal: true,
      ...tooltipProps,
      children: /* @__PURE__ */jsx("div", {
        children
      })
    });
  }, [tooltipProps]);
  return /* @__PURE__ */jsx(ConditionalWrapper, {
    condition: !!tooltipProps,
    wrapper: renderWrapper,
    children: /* @__PURE__ */jsx(MenuItem$1, {
      disabled,
      paddingLeft: preview ? 1 : 3,
      paddingRight: 3,
      paddingY: preview ? 1 : 3,
      ref,
      ...rest,
      children: typeof childrenProp === "undefined" && typeof renderMenuItem === "function" ? renderMenuItem(menuItemContent) : menuItemContent
    })
  });
});
const Popover = forwardRef(function Popover2(props, ref) {
  return /* @__PURE__ */jsx(Popover$1, {
    ...props,
    animate: true,
    ref
  });
});
const Tab = forwardRef(function Tab2(_ref5, ref) {
  let {
    tone = "default",
    ...props
  } = _ref5;
  return /* @__PURE__ */jsx(Tab$1, {
    ...props,
    muted: true,
    padding: 2,
    ref,
    tone
  });
});
const TOOLTIP_DELAY_PROPS = {
  open: 400
};
const TOOLTIP_SHARED_PROPS = {
  animate: true,
  arrow: false,
  boundaryElement: null,
  delay: TOOLTIP_DELAY_PROPS,
  fallbackPlacements: ["bottom-start", "bottom-end", "top-start", "top-end"],
  placement: "bottom",
  portal: true
};
const Tooltip = forwardRef(function Tooltip2(props, ref) {
  const {
    content,
    hotkeys,
    ...rest
  } = props;
  if (typeof content === "string") {
    return /* @__PURE__ */jsx(Tooltip$1, {
      ...TOOLTIP_SHARED_PROPS,
      content: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [content && /* @__PURE__ */jsx(Box, {
          flex: 1,
          padding: 1,
          children: /* @__PURE__ */jsx(Text, {
            size: 1,
            children: content
          })
        }), hotkeys && /* @__PURE__ */jsx(Box, {
          flex: "none",
          children: /* @__PURE__ */jsx(Hotkeys, {
            keys: hotkeys
          })
        })]
      }),
      padding: 1,
      ref,
      ...rest
    });
  }
  return /* @__PURE__ */jsx(Tooltip$1, {
    ...TOOLTIP_SHARED_PROPS,
    content,
    ref,
    ...rest
  });
});
const TooltipDelayGroupProvider = props => {
  return /* @__PURE__ */jsx(TooltipDelayGroupProvider$1, {
    delay: TOOLTIP_DELAY_PROPS,
    children: props.children
  });
};
export { Button, ConditionalWrapper, Dialog, MenuButton, MenuGroup, MenuItem, Popover, Tab, Tooltip, TooltipDelayGroupProvider };
//# sourceMappingURL=TooltipDelayGroupProvider-CvFQ5MgA.js.map
