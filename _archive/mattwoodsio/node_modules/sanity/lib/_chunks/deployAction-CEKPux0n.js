'use strict';

var fs = require('fs');
var path = require('path');
var tar = require('tar-fs');
var zlib = require('zlib');
var buildAction = require('./buildAction-BdD3ajZy.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var tar__default = /*#__PURE__*/_interopDefaultCompat(tar);
var zlib__default = /*#__PURE__*/_interopDefaultCompat(zlib);
async function deployStudio(args, context) {
  const {
    apiClient,
    workDir,
    chalk,
    output,
    prompt
  } = context;
  const flags = {
    build: true,
    ...args.extOptions
  };
  const destFolder = args.argsWithoutOptions[0];
  const sourceDir = path__default.default.resolve(process.cwd(), destFolder || path__default.default.join(workDir, "dist"));
  if (destFolder === "graphql") {
    throw new Error("Did you mean `sanity graphql deploy`?");
  }
  if (destFolder) {
    let relativeOutput = path__default.default.relative(process.cwd(), sourceDir);
    if (relativeOutput[0] !== ".") {
      relativeOutput = "./".concat(relativeOutput);
    }
    const isEmpty = await dirIsEmptyOrNonExistent(sourceDir);
    const shouldProceed = isEmpty || (await prompt.single({
      type: "confirm",
      message: '"'.concat(relativeOutput, '" is not empty, do you want to proceed?'),
      default: false
    }));
    if (!shouldProceed) {
      output.print("Cancelled.");
      return;
    }
    output.print("Building to ".concat(relativeOutput, "\n"));
  }
  const client = apiClient({
    requireUser: true,
    requireProject: true
  });
  let spinner = output.spinner("Checking project info").start();
  const project = await client.projects.getById(client.config().projectId);
  let studioHostname = project && project.studioHost;
  spinner.succeed();
  if (!studioHostname) {
    output.print("Your project has not been assigned a studio hostname.");
    output.print("To deploy your Sanity Studio to our hosted Sanity.Studio service,");
    output.print("you will need one. Please enter the part you want to use.");
    studioHostname = await prompt.single({
      type: "input",
      filter: inp => inp.replace(/\.sanity\.studio$/i, ""),
      message: "Studio hostname (<value>.sanity.studio):",
      validate: name => validateHostname(name, client)
    });
  }
  const shouldBuild = flags.build;
  if (shouldBuild) {
    const buildArgs = [destFolder].filter(Boolean);
    const {
      didCompile
    } = await buildAction.default({
      ...args,
      extOptions: flags,
      argsWithoutOptions: buildArgs
    }, context, {
      basePath: "/"
    });
    if (!didCompile) {
      return;
    }
  }
  spinner = output.spinner("Verifying local content").start();
  try {
    await checkDir(sourceDir);
    spinner.succeed();
  } catch (err) {
    spinner.fail();
    throw err;
  }
  const parentDir = path__default.default.dirname(sourceDir);
  const base = path__default.default.basename(sourceDir);
  const tarball = tar__default.default.pack(parentDir, {
    entries: [base]
  }).pipe(zlib__default.default.createGzip());
  spinner = output.spinner("Deploying to Sanity.Studio").start();
  try {
    const response = await client.request({
      method: "POST",
      url: "/deploy",
      body: tarball,
      maxRedirects: 0
    });
    spinner.succeed();
    output.print("\nSuccess! Studio deployed to ".concat(chalk.cyan(response.location)));
  } catch (err) {
    spinner.fail();
    throw err;
  }
}
async function dirIsEmptyOrNonExistent(sourceDir) {
  try {
    const stats = await fs.promises.stat(sourceDir);
    if (!stats.isDirectory()) {
      throw new Error("Directory ".concat(sourceDir, " is not a directory"));
    }
  } catch (err) {
    if (err.code === "ENOENT") {
      return true;
    }
    throw err;
  }
  const content = await fs.promises.readdir(sourceDir);
  return content.length === 0;
}
async function checkDir(sourceDir) {
  try {
    const stats = await fs.promises.stat(sourceDir);
    if (!stats.isDirectory()) {
      throw new Error("Directory ".concat(sourceDir, " is not a directory"));
    }
  } catch (err) {
    const error = err.code === "ENOENT" ? new Error('Directory "'.concat(sourceDir, '" does not exist')) : err;
    throw error;
  }
  try {
    await fs.promises.stat(path__default.default.join(sourceDir, "index.html"));
  } catch (err) {
    const error = err.code === "ENOENT" ? new Error(['"'.concat(sourceDir, '/index.html" does not exist -'), "[SOURCE_DIR] must be a directory containing", 'a Sanity studio built using "sanity build"'].join(" ")) : err;
    throw error;
  }
}
async function validateHostname(value, client) {
  var _a, _b;
  const projectId = client.config().projectId;
  const uri = "/projects/".concat(projectId);
  const studioHost = value || "";
  if (!/^[a-z0-9_-]+$/i.test(studioHost)) {
    return "Hostname can contain only A-Z, 0-9, _ and -";
  }
  try {
    await client.request({
      uri,
      method: "PATCH",
      body: {
        studioHost
      }
    });
    return true;
  } catch (error) {
    if ((_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.body) == null ? void 0 : _b.message) {
      return error.response.body.message;
    }
    throw error;
  }
}
exports.default = deployStudio;
//# sourceMappingURL=deployAction-CEKPux0n.js.map
