'use strict';

class MessageQueue {
  constructor() {
    this.resolver = null;
    this.queue = [];
  }
  push(message) {
    if (this.resolver) {
      this.resolver({
        value: message,
        done: false
      });
      this.resolver = null;
    } else {
      this.queue.push(message);
    }
  }
  next() {
    if (this.queue.length) {
      return Promise.resolve({
        value: this.queue.shift(),
        done: false
      });
    }
    return new Promise(resolve => this.resolver = resolve);
  }
  end() {
    if (this.resolver) {
      this.resolver({
        value: void 0,
        done: true
      });
    }
  }
}
function isWorkerChannelMessage(message) {
  if (typeof message !== "object") return false;
  if (!message) return false;
  if (!("type" in message)) return false;
  if (typeof message.type !== "string") return false;
  const types = ["event", "emission", "end"];
  return types.includes(message.type);
}
function createReceiver(worker) {
  const _events = /* @__PURE__ */new Map();
  const _streams = /* @__PURE__ */new Map();
  const errors = new MessageQueue();
  const eventQueue = name => {
    var _a;
    const queue = (_a = _events.get(name)) != null ? _a : new MessageQueue();
    if (!_events.has(name)) _events.set(name, queue);
    return queue;
  };
  const streamQueue = name => {
    var _a;
    const queue = (_a = _streams.get(name)) != null ? _a : new MessageQueue();
    if (!_streams.has(name)) _streams.set(name, queue);
    return queue;
  };
  const handleMessage = message => {
    if (!isWorkerChannelMessage(message)) return;
    if (message.type === "event") eventQueue(message.name).push(message);
    if (message.type === "emission") streamQueue(message.name).push(message);
    if (message.type === "end") streamQueue(message.name).end();
  };
  const handleError = error => {
    errors.push({
      type: "error",
      error
    });
  };
  worker.addListener("message", handleMessage);
  worker.addListener("error", handleError);
  return {
    event: new Proxy({}, {
      get: (target, name) => {
        if (typeof name !== "string") return target[name];
        const eventReceiver = async () => {
          const {
            value
          } = await Promise.race([eventQueue(name).next(), errors.next()]);
          if (value.type === "error") throw value.error;
          return value.payload;
        };
        return eventReceiver;
      }
    }),
    stream: new Proxy({}, {
      get: (target, prop) => {
        if (typeof prop !== "string") return target[prop];
        const name = prop;
        async function* streamReceiver() {
          while (true) {
            const {
              value,
              done
            } = await Promise.race([streamQueue(name).next(), errors.next()]);
            if (done) return;
            if (value.type === "error") throw value.error;
            yield value.payload;
          }
        }
        return streamReceiver;
      }
    }),
    dispose: () => {
      worker.removeListener("message", handleMessage);
      worker.removeListener("error", handleError);
      return worker.terminate();
    }
  };
}
function createReporter(parentPort) {
  if (!parentPort) {
    throw new Error("parentPart was falsy");
  }
  return {
    event: new Proxy({}, {
      get: (target, name) => {
        if (typeof name !== "string") return target[name];
        const eventReporter = payload => {
          const message = {
            type: "event",
            name,
            payload
          };
          parentPort.postMessage(message);
        };
        return eventReporter;
      }
    }),
    stream: new Proxy({}, {
      get: (target, name) => {
        if (typeof name !== "string") return target[name];
        const streamReporter = {
          emit: payload => {
            const message = {
              type: "emission",
              name,
              payload
            };
            parentPort.postMessage(message);
          },
          end: () => {
            const message = {
              type: "end",
              name
            };
            parentPort.postMessage(message);
          }
        };
        return streamReporter;
      }
    })
  };
}
exports.createReceiver = createReceiver;
exports.createReporter = createReporter;
//# sourceMappingURL=workerChannels-BZhuLtcy.js.map
