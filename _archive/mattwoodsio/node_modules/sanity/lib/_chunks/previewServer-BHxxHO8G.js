import { constants } from 'fs';
import fs from 'fs/promises';
import path from 'path';
import readPkgUp from 'read-pkg-up';
import { build, preview } from 'vite';
import { debug as debug$2, writeSanityRuntime, getViteConfig, extendViteConfigWithUserConfig, finalizeViteConfig, generateWebManifest } from './runtime-B_bGx0NP.js';
import chalk from 'chalk';
const debug$1 = debug$2.extend("static");
async function buildStaticFiles(options) {
  const {
    cwd,
    outputDir,
    sourceMap = false,
    minify = true,
    basePath,
    vite: extendViteConfig
  } = options;
  debug$1("Writing Sanity runtime files");
  await writeSanityRuntime({
    cwd,
    reactStrictMode: false,
    watch: false,
    basePath
  });
  debug$1("Resolving vite config");
  const mode = "production";
  let viteConfig = await getViteConfig({
    cwd,
    basePath,
    outputDir,
    minify,
    sourceMap,
    mode
  });
  if (extendViteConfig) {
    viteConfig = await extendViteConfigWithUserConfig({
      command: "build",
      mode
    }, viteConfig, extendViteConfig);
    viteConfig = finalizeViteConfig(viteConfig);
  }
  debug$1("Copying static files from /static to output dir");
  const staticPath = path.join(outputDir, "static");
  await copyDir(path.join(cwd, "static"), staticPath);
  debug$1("Writing favicons to output dir");
  const faviconBasePath = "".concat(basePath.replace(/\/+$/, ""), "/static");
  await writeFavicons(faviconBasePath, staticPath);
  debug$1("Bundling using vite");
  const bundle = await build(viteConfig);
  debug$1("Bundling complete");
  if (Array.isArray(bundle) || !("output" in bundle)) {
    return {
      chunks: []
    };
  }
  const stats = [];
  bundle.output.forEach(chunk => {
    if (chunk.type !== "chunk") {
      return;
    }
    stats.push({
      name: chunk.name,
      modules: Object.entries(chunk.modules).map(_ref => {
        let [rawFilePath, chunkModule] = _ref;
        const filePath = rawFilePath.startsWith("\0") ? rawFilePath.slice("\0".length) : rawFilePath;
        return {
          name: path.isAbsolute(filePath) ? path.relative(cwd, filePath) : filePath,
          originalLength: chunkModule.originalLength,
          renderedLength: chunkModule.renderedLength
        };
      })
    });
  });
  return {
    chunks: stats
  };
}
async function copyDir(srcDir, destDir, skipExisting) {
  await fs.mkdir(destDir, {
    recursive: true
  });
  for (const file of await tryReadDir(srcDir)) {
    const srcFile = path.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = path.resolve(destDir, file);
    const stat = await fs.stat(srcFile);
    if (stat.isDirectory()) {
      await copyDir(srcFile, destFile, skipExisting);
    } else if (skipExisting) {
      await fs.copyFile(srcFile, destFile, constants.COPYFILE_EXCL).catch(skipIfExistsError);
    } else {
      await fs.copyFile(srcFile, destFile);
    }
  }
}
async function tryReadDir(dir) {
  try {
    const content = await fs.readdir(dir);
    return content;
  } catch (err) {
    if (err.code === "ENOENT") {
      return [];
    }
    throw err;
  }
}
function skipIfExistsError(err) {
  if (err.code === "EEXIST") {
    return;
  }
  throw err;
}
async function writeFavicons(basePath, destDir) {
  var _a;
  const sanityPkgPath = (_a = await readPkgUp({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  const faviconsPath = sanityPkgPath ? path.join(path.dirname(sanityPkgPath), "static", "favicons") : void 0;
  if (!faviconsPath) {
    throw new Error("Unable to resolve `sanity` module root");
  }
  await fs.mkdir(destDir, {
    recursive: true
  });
  await copyDir(faviconsPath, destDir, true);
  await writeWebManifest(basePath, destDir);
  await fs.copyFile(path.join(destDir, "favicon.ico"), path.join(destDir, "..", "favicon.ico"));
}
async function writeWebManifest(basePath, destDir) {
  const content = JSON.stringify(generateWebManifest(basePath), null, 2);
  await fs.writeFile(path.join(destDir, "manifest.webmanifest"), content, "utf8").catch(skipIfExistsError);
}
function sanityBasePathRedirectPlugin(basePath) {
  return {
    name: "sanity/server/sanity-base-path-redirect",
    apply: "serve",
    configurePreviewServer(vitePreviewServer) {
      return () => {
        if (!basePath) {
          return;
        }
        vitePreviewServer.middlewares.use((req, res, next) => {
          if (req.url !== "/") {
            next();
            return;
          }
          res.writeHead(302, {
            Location: basePath
          });
          res.end();
        });
      };
    }
  };
}
const debug = debug$2.extend("preview");
async function startPreviewServer(options) {
  const {
    httpPort,
    httpHost,
    root,
    vite: extendViteConfig
  } = options;
  const startTime = Date.now();
  const indexPath = path.join(root, "index.html");
  let basePath;
  try {
    const index = await fs.readFile(indexPath, "utf8");
    basePath = tryResolveBasePathFromIndex(index);
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
    const error = new Error("Could not find a production build in the '".concat(root, "' directory.\nTry building your studio app with 'sanity build' before starting the preview server."));
    error.name = "BUILD_NOT_FOUND";
    throw error;
  }
  const mode = "production";
  let previewConfig = {
    root,
    base: basePath || "/",
    plugins: [sanityBasePathRedirectPlugin(basePath)],
    configFile: false,
    preview: {
      port: httpPort,
      host: httpHost,
      strictPort: true
    },
    // Needed for vite to not serve `root/dist`
    build: {
      outDir: root
    },
    mode
  };
  if (extendViteConfig) {
    previewConfig = await extendViteConfigWithUserConfig({
      command: "serve",
      mode
    }, previewConfig, extendViteConfig);
  }
  debug("Creating vite server");
  const server = await preview(previewConfig);
  const warn = server.config.logger.warn;
  const info = server.config.logger.info;
  const url = server.resolvedUrls.local[0];
  if (typeof basePath === "undefined") {
    warn('Could not determine base path from index.html, using "/" as default');
  } else if (basePath && basePath !== "/") {
    info("Using resolved base path from static build: ".concat(chalk.cyan(basePath)));
  }
  const startupDuration = Date.now() - startTime;
  info("Sanity Studio " + "using ".concat(chalk.cyan("vite@".concat(require("vite/package.json").version)), " ") + "ready in ".concat(chalk.cyan("".concat(Math.ceil(startupDuration), "ms")), " ") + "and running at ".concat(chalk.cyan(url), " (production preview mode)"));
  return {
    urls: server.resolvedUrls,
    close: () => new Promise((resolve, reject) => server.httpServer.close(err => err ? reject(err) : resolve()))
  };
}
function tryResolveBasePathFromIndex(index) {
  var _a;
  const basePath = (_a = index.match(/<script[^>]+src="(.*?)\/static\/sanity-/)) == null ? void 0 : _a[1];
  if (typeof basePath === "undefined") {
    return void 0;
  }
  return basePath === "" ? "/" : basePath;
}
export { buildStaticFiles, startPreviewServer };
//# sourceMappingURL=previewServer-BHxxHO8G.js.map
