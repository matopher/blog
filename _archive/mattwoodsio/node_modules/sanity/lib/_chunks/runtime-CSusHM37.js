'use strict';

var viteReact = require('@vitejs/plugin-react');
var debug$4 = require('debug');
var path = require('path');
var readPkgUp = require('read-pkg-up');
var vite = require('vite');
var cli = require('../cli.js');
require('resolve-from');
var history = require('connect-history-api-fallback');
var fs = require('fs');
var fs$1 = require('fs/promises');
var chokidar = require('chokidar');
var chalk = require('chalk');
var importFresh = require('import-fresh');
var React = require('react');
var server = require('react-dom/server');
var worker_threads = require('worker_threads');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var viteReact__default = /*#__PURE__*/_interopDefaultCompat(viteReact);
var debug__default = /*#__PURE__*/_interopDefaultCompat(debug$4);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var readPkgUp__default = /*#__PURE__*/_interopDefaultCompat(readPkgUp);
var history__default = /*#__PURE__*/_interopDefaultCompat(history);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var fs__default$1 = /*#__PURE__*/_interopDefaultCompat(fs$1);
var chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var importFresh__default = /*#__PURE__*/_interopDefaultCompat(importFresh);
const debug$3 = debug__default.default("sanity:server");
function getAliases(opts) {
  const {
    monorepo
  } = opts;
  if (!(monorepo == null ? void 0 : monorepo.path)) {
    return {};
  }
  const aliasesPath = path__default.default.resolve(monorepo.path, "dev/aliases.cjs");
  const devAliases = require(aliasesPath);
  const monorepoAliases = Object.fromEntries(Object.entries(devAliases).map(_ref => {
    let [key, modulePath] = _ref;
    return [key, path__default.default.resolve(monorepo.path, modulePath)];
  }));
  return monorepoAliases;
}
function normalizeBasePath(pathName) {
  return "/".concat(pathName, "/").replace(/^\/+/, "/").replace(/\/+$/, "/");
}
async function loadSanityMonorepo(cwd) {
  let p = cwd;
  while (p !== "/") {
    const readResult = await readPkgUp__default.default({
      cwd: p
    });
    if (!readResult) {
      return void 0;
    }
    if (readResult.packageJson.isSanityMonorepo) {
      return {
        path: path__default.default.dirname(readResult.path)
      };
    }
    p = path__default.default.dirname(path__default.default.dirname(readResult.path));
  }
  return void 0;
}
const debug$2 = debug$3.extend("renderDocument");
const useThreads = typeof process.env.JEST_WORKER_ID === "undefined";
const hasWarnedAbout = /* @__PURE__ */new Set();
const defaultProps = {
  entryPath: "./.sanity/runtime/app.js"
};
const autoGeneratedWarning = '\nThis file is auto-generated from "sanity dev".\nModifications to this file are automatically discarded.\n'.trim();
function renderDocument(options) {
  return new Promise((resolve, reject) => {
    if (!useThreads) {
      resolve(getDocumentHtml(options.studioRootPath, options.props));
      return;
    }
    debug$2("Starting worker thread for %s", __filename);
    const worker = new worker_threads.Worker(__filename, {
      execArgv: void 0,
      workerData: {
        ...options,
        dev: false,
        shouldWarn: true
      },
      // eslint-disable-next-line no-process-env
      env: process.env
    });
    worker.on("message", msg => {
      if (msg.type === "warning") {
        if (hasWarnedAbout.has(msg.warnKey)) {
          return;
        }
        if (Array.isArray(msg.message)) {
          msg.message.forEach(warning => console.warn("".concat(chalk__default.default.yellow("[warn]"), " ").concat(warning)));
        } else {
          console.warn("".concat(chalk__default.default.yellow("[warn]"), " ").concat(msg.message));
        }
        hasWarnedAbout.add(msg.warnKey);
        return;
      }
      if (msg.type === "error") {
        debug$2("Error from worker: %s", msg.error || "Unknown error");
        reject(new Error(msg.error || "Document rendering worker stopped with an unknown error"));
        return;
      }
      if (msg.type === "result") {
        debug$2("Document HTML rendered, %d bytes", msg.html.length);
        resolve(msg.html);
      }
    });
    worker.on("error", err => {
      debug$2("Worker errored: %s", err.message);
      reject(err);
    });
    worker.on("exit", code => {
      if (code !== 0) {
        debug$2("Worker stopped with code %d", code);
        reject(new Error("Document rendering worker stopped with exit code ".concat(code)));
      }
    });
  });
}
function decorateIndexWithAutoGeneratedWarning(template) {
  return template.replace(/<head/, "\n<!--\n".concat(autoGeneratedWarning, "\n-->\n<head"));
}
function getPossibleDocumentComponentLocations(studioRootPath) {
  return [path__default.default.join(studioRootPath, "_document.js"), path__default.default.join(studioRootPath, "_document.tsx")];
}
function _prefixUrlWithBasePath(url, basePath) {
  const normalizedBasePath = basePath.startsWith("/") ? basePath : "/".concat(basePath);
  if (url.startsWith("/")) {
    if (normalizedBasePath.endsWith("/")) {
      return "".concat(normalizedBasePath.slice(0, -1)).concat(url);
    }
    return "".concat(normalizedBasePath).concat(url);
  }
  if (normalizedBasePath.endsWith("/")) {
    return "".concat(normalizedBasePath).concat(url);
  }
  return "".concat(normalizedBasePath, "/").concat(url);
}
if (!worker_threads.isMainThread && worker_threads.parentPort) {
  renderDocumentFromWorkerData();
}
function renderDocumentFromWorkerData() {
  var _a;
  if (!worker_threads.parentPort || !worker_threads.workerData) {
    throw new Error("Must be used as a Worker with a valid options object in worker data");
  }
  const {
    monorepo,
    studioRootPath,
    props
  } = worker_threads.workerData || {};
  if ((_a = worker_threads.workerData) == null ? void 0 : _a.dev) {
    global.__DEV__ = true;
  }
  if (typeof studioRootPath !== "string") {
    worker_threads.parentPort.postMessage({
      type: "error",
      message: "Missing/invalid `studioRootPath` option"
    });
    return;
  }
  if (props && typeof props !== "object") {
    worker_threads.parentPort.postMessage({
      type: "error",
      message: "`props` must be an object if provided"
    });
    return;
  }
  debug$2("Registering potential aliases");
  require("module-alias").addAliases(getAliases({
    monorepo
  }));
  debug$2("Registering esbuild for node %s", process.version);
  const {
    unregister
  } = require("esbuild-register/dist/node").register({
    target: "node".concat(process.version.slice(1)),
    jsx: "automatic",
    extensions: [".jsx", ".ts", ".tsx", ".mjs"]
  });
  debug$2("Registering esbuild for .js files using jsx loader");
  const {
    unregister: unregisterJs
  } = require("esbuild-register/dist/node").register({
    target: "node".concat(process.version.slice(1)),
    extensions: [".js"],
    jsx: "automatic",
    loader: "jsx"
  });
  const html = getDocumentHtml(studioRootPath, props);
  worker_threads.parentPort.postMessage({
    type: "result",
    html
  });
  unregister();
  unregisterJs();
}
function getDocumentHtml(studioRootPath, props) {
  var _a;
  const Document = getDocumentComponent(studioRootPath);
  const css = (_a = props == null ? void 0 : props.css) == null ? void 0 : _a.map(url => {
    try {
      return new URL(url).toString();
    } catch {
      return _prefixUrlWithBasePath(url, props.basePath);
    }
  });
  debug$2("Rendering document component using React");
  const result = server.renderToStaticMarkup(React.createElement(Document, {
    ...defaultProps,
    ...props,
    css
  }));
  return "<!DOCTYPE html>".concat(result);
}
function getDocumentComponent(studioRootPath) {
  var _a;
  debug$2("Loading default document component from `sanity` module");
  const {
    DefaultDocument
  } = require("sanity");
  debug$2("Attempting to load user-defined document component from %s", studioRootPath);
  const userDefined = tryLoadDocumentComponent(studioRootPath);
  if (!userDefined) {
    debug$2("Using default document component");
    return DefaultDocument;
  }
  debug$2("Found user defined document component at %s", userDefined.path);
  const DocumentComp = userDefined.component.default || userDefined.component;
  if (typeof DocumentComp === "function") {
    debug$2("User defined document component is a function, assuming valid");
    return DocumentComp;
  }
  debug$2("User defined document component did not have a default export");
  const userExports = Object.keys(userDefined.component).join(", ") || "None";
  const relativePath = path__default.default.relative(process.cwd(), userDefined.path);
  const typeHint = typeof userDefined.component.default === "undefined" ? "" : " (type was ".concat(typeof userDefined.component.default, ")");
  const warnKey = "".concat(relativePath, "/").concat(userDefined.modified);
  (_a = worker_threads.parentPort) == null ? void 0 : _a.postMessage({
    type: "warning",
    message: ["".concat(relativePath, " did not have a default export that is a React component").concat(typeHint), "Named exports/properties found: ".concat(userExports).trim(), 'Using default document component from "sanity".'],
    warnKey
  });
  return DefaultDocument;
}
function tryLoadDocumentComponent(studioRootPath) {
  var _a;
  const locations = getPossibleDocumentComponentLocations(studioRootPath);
  for (const componentPath of locations) {
    debug$2("Trying to load document component from %s", componentPath);
    try {
      return {
        // eslint-disable-next-line import/no-dynamic-require
        component: importFresh__default.default(componentPath),
        path: componentPath,
        // eslint-disable-next-line no-sync
        modified: Math.floor((_a = fs__default.default.statSync(componentPath)) == null ? void 0 : _a.mtimeMs)
      };
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND") {
        debug$2("Failed to load document component: %s", err.message);
        throw err;
      }
      debug$2("Document component not found at %s", componentPath);
    }
  }
  return null;
}
const entryChunkId = ".sanity/runtime/app.js";
function sanityBuildEntries(options) {
  const {
    cwd,
    monorepo,
    basePath
  } = options;
  return {
    name: "sanity/server/build-entries",
    apply: "build",
    buildStart() {
      this.emitFile({
        type: "chunk",
        id: entryChunkId,
        name: "sanity"
      });
    },
    async generateBundle(_options, outputBundle) {
      var _a;
      const bundle = outputBundle;
      const entryFile = Object.values(bundle).find(file => {
        var _a2;
        return file.type === "chunk" && file.name === "sanity" && ((_a2 = file.facadeModuleId) == null ? void 0 : _a2.endsWith(entryChunkId));
      });
      if (!entryFile) {
        throw new Error("Failed to find entry file in bundle (".concat(entryChunkId, ")"));
      }
      if (entryFile.type !== "chunk") {
        throw new Error("Entry file is not a chunk");
      }
      const entryFileName = entryFile.fileName;
      const entryPath = [basePath.replace(/\/+$/, ""), entryFileName].join("/");
      let css = [];
      if ((_a = entryFile.viteMetadata) == null ? void 0 : _a.importedCss) {
        css = [...entryFile.viteMetadata.importedCss];
        for (const key of entryFile.imports) {
          const entry = bundle[key];
          const importedCss = entry && entry.type === "chunk" ? entry.viteMetadata.importedCss : void 0;
          if (importedCss) {
            css.push(...importedCss);
          }
        }
      }
      this.emitFile({
        type: "asset",
        fileName: "index.html",
        source: await renderDocument({
          monorepo,
          studioRootPath: cwd,
          props: {
            basePath,
            entryPath,
            css
          }
        })
      });
    }
  };
}
function sanityDotWorkaroundPlugin() {
  return {
    name: "sanity/server/dot-workaround",
    configureServer(server) {
      const {
        root
      } = server.config;
      return () => {
        const handler = history__default.default({
          disableDotRule: true,
          rewrites: [{
            from: /\/index.html$/,
            to: _ref2 => {
              let {
                parsedUrl
              } = _ref2;
              const pathname = parsedUrl.pathname;
              if (pathname && fs__default.default.existsSync(path__default.default.join(root, pathname))) {
                return pathname;
              }
              return "/index.html";
            }
          }]
        });
        server.middlewares.use((req, res, next) => {
          handler(req, res, next);
        });
      };
    }
  };
}
function generateWebManifest(basePath) {
  return {
    icons: [{
      src: "".concat(basePath, "/favicon-192.png"),
      type: "image/png",
      sizes: "192x192"
    }, {
      src: "".concat(basePath, "/favicon-512.png"),
      type: "image/png",
      sizes: "512x512"
    }]
  };
}
const mimeTypes = {
  ".ico": "image/x-icon",
  ".svg": "image/svg+xml",
  ".png": "image/png"
};
function sanityFaviconsPlugin(_ref3) {
  let {
    defaultFaviconsPath,
    customFaviconsPath,
    staticUrlPath
  } = _ref3;
  const cache = {};
  async function getFavicons() {
    if (cache.favicons) {
      return cache.favicons;
    }
    cache.favicons = await fs__default$1.default.readdir(defaultFaviconsPath);
    return cache.favicons;
  }
  async function hasCustomFavicon() {
    try {
      await fs__default$1.default.access(path__default.default.join(customFaviconsPath, "favicon.ico"));
      return true;
    } catch (err) {
      return false;
    }
  }
  return {
    name: "sanity/server/sanity-favicons",
    apply: "serve",
    configureServer(viteDevServer) {
      const webManifest = JSON.stringify(generateWebManifest(staticUrlPath), null, 2);
      const webManifestPath = "".concat(staticUrlPath, "/manifest.webmanifest");
      return () => {
        viteDevServer.middlewares.use(async (req, res, next) => {
          var _a;
          if ((_a = req.url) == null ? void 0 : _a.endsWith(webManifestPath)) {
            res.writeHead(200, "OK", {
              "content-type": "application/manifest+json"
            });
            res.write(webManifest);
            res.end();
            return;
          }
          const parsedUrl = req._parsedUrl || new URL(req.url || "/", "http://localhost:3333");
          const pathName = parsedUrl.pathname || "";
          const fileName = path__default.default.basename(pathName || "");
          const icons = await getFavicons();
          const isIconRequest = pathName.startsWith("/favicon.ico") || icons.includes(fileName) && pathName.includes(staticUrlPath);
          if (!isIconRequest) {
            next();
            return;
          }
          const faviconPath = fileName === "favicon.ico" && (await hasCustomFavicon()) ? path__default.default.join(customFaviconsPath, "favicon.ico") : path__default.default.join(defaultFaviconsPath, fileName);
          const mimeType = mimeTypes[path__default.default.extname(fileName)] || "application/octet-stream";
          res.writeHead(200, "OK", {
            "content-type": mimeType
          });
          res.write(await fs__default$1.default.readFile(faviconPath));
          res.end();
        });
      };
    }
  };
}
function sanityRuntimeRewritePlugin() {
  return {
    name: "sanity/server/sanity-runtime-rewrite",
    apply: "serve",
    configureServer(viteDevServer) {
      return () => {
        viteDevServer.middlewares.use((req, res, next) => {
          if (req.url === "/index.html") {
            req.url = "/.sanity/runtime/index.html";
          }
          next();
        });
      };
    }
  };
}
async function getViteConfig(options) {
  var _a;
  const {
    cwd,
    mode,
    outputDir,
    // default to `true` when `mode=development`
    sourceMap = options.mode === "development",
    server,
    minify,
    basePath: rawBasePath = "/"
  } = options;
  const monorepo = await loadSanityMonorepo(cwd);
  const basePath = normalizeBasePath(rawBasePath);
  const sanityPkgPath = (_a = await readPkgUp__default.default({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  if (!sanityPkgPath) {
    throw new Error("Unable to resolve `sanity` module root");
  }
  const customFaviconsPath = path__default.default.join(cwd, "static");
  const defaultFaviconsPath = path__default.default.join(path__default.default.dirname(sanityPkgPath), "static", "favicons");
  const staticPath = "".concat(basePath, "static");
  const viteConfig = {
    // Define a custom cache directory so that sanity's vite cache
    // does not conflict with any potential local vite projects
    cacheDir: "node_modules/.sanity/vite",
    root: cwd,
    base: basePath,
    build: {
      outDir: outputDir || path__default.default.resolve(cwd, "dist"),
      sourcemap: sourceMap
    },
    server: {
      host: server == null ? void 0 : server.host,
      port: (server == null ? void 0 : server.port) || 3333,
      strictPort: true
    },
    configFile: false,
    mode,
    plugins: [viteReact__default.default(), sanityFaviconsPlugin({
      defaultFaviconsPath,
      customFaviconsPath,
      staticUrlPath: staticPath
    }), sanityDotWorkaroundPlugin(), sanityRuntimeRewritePlugin(), sanityBuildEntries({
      basePath,
      cwd,
      monorepo
    })],
    envPrefix: "SANITY_STUDIO_",
    logLevel: mode === "production" ? "silent" : "info",
    resolve: {
      alias: getAliases({
        monorepo
      })
    },
    define: {
      // eslint-disable-next-line no-process-env
      __SANITY_STAGING__: process.env.SANITY_INTERNAL_ENV === "staging",
      "process.env.MODE": JSON.stringify(mode),
      ...cli.getStudioEnvironmentVariables({
        prefix: "process.env.",
        jsonEncode: true
      })
    }
  };
  if (mode === "production") {
    viteConfig.build = {
      ...viteConfig.build,
      assetsDir: "static",
      minify: minify ? "esbuild" : false,
      emptyOutDir: false,
      // Rely on CLI to do this
      rollupOptions: {
        input: {
          sanity: path__default.default.join(cwd, ".sanity", "runtime", "app.js")
        }
      }
    };
  }
  return viteConfig;
}
function finalizeViteConfig(config) {
  var _a, _b;
  if (typeof ((_b = (_a = config.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) !== "object") {
    throw new Error("Vite config must contain `build.rollupOptions.input`, and it must be an object");
  }
  if (!config.root) {
    throw new Error("Vite config must contain `root` property, and must point to the Sanity root directory");
  }
  return vite.mergeConfig(config, {
    build: {
      rollupOptions: {
        input: {
          sanity: path__default.default.join(config.root, ".sanity", "runtime", "app.js")
        }
      }
    }
  });
}
async function extendViteConfigWithUserConfig(env, defaultConfig, userConfig) {
  let config = defaultConfig;
  if (typeof userConfig === "function") {
    debug__default.default("Extending vite config using user-specified function");
    config = await userConfig(config, env);
  } else if (typeof userConfig === "object") {
    debug__default.default("Merging vite config using user-specified object");
    config = vite.mergeConfig(config, userConfig);
  }
  return config;
}
const entryModule = '\n// This file is auto-generated on \'sanity dev\'\n// Modifications to this file is automatically discarded\nimport {renderStudio} from "sanity"\nimport studioConfig from %STUDIO_CONFIG_LOCATION%\n\nrenderStudio(\n  document.getElementById("sanity"),\n  studioConfig,\n  {reactStrictMode: %STUDIO_REACT_STRICT_MODE%, basePath: %STUDIO_BASE_PATH%}\n)\n';
const noConfigEntryModule = '\n// This file is auto-generated on \'sanity dev\'\n// Modifications to this file is automatically discarded\nimport {renderStudio} from "sanity"\n\nconst studioConfig = {missingConfigFile: true}\n\nrenderStudio(\n  document.getElementById("sanity"),\n  studioConfig,\n  {reactStrictMode: %STUDIO_REACT_STRICT_MODE%, basePath: %STUDIO_BASE_PATH%}\n)\n';
function getEntryModule(options) {
  const {
    reactStrictMode,
    relativeConfigLocation,
    basePath
  } = options;
  const sourceModule = relativeConfigLocation ? entryModule : noConfigEntryModule;
  return sourceModule.replace(/%STUDIO_REACT_STRICT_MODE%/, JSON.stringify(Boolean(reactStrictMode))).replace(/%STUDIO_CONFIG_LOCATION%/, JSON.stringify(relativeConfigLocation)).replace(/%STUDIO_BASE_PATH%/, JSON.stringify(basePath || "/"));
}
const debug$1 = debug$3.extend("config");
async function getSanityStudioConfigPath(studioRootPath) {
  const configPaths = [path__default.default.join(studioRootPath, "sanity.config.mjs"), path__default.default.join(studioRootPath, "sanity.config.js"), path__default.default.join(studioRootPath, "sanity.config.ts"), path__default.default.join(studioRootPath, "sanity.config.jsx"), path__default.default.join(studioRootPath, "sanity.config.tsx")];
  debug$1("Looking for configuration file in %d possible locations", configPaths.length);
  const configs = await Promise.all(configPaths.map(async configPath => ({
    path: configPath,
    exists: await fileExists(configPath)
  })));
  const availableConfigs = configs.filter(config => config.exists);
  debug$1("Found %d available configuration files", availableConfigs.length);
  if (availableConfigs.length === 0) {
    console.warn("No `sanity.config.js`/`sanity.config.ts` found - using default studio config");
    return null;
  }
  if (availableConfigs.length > 1) {
    console.warn("Found multiple potential studio configs:");
    availableConfigs.forEach(config => console.warn(" - ".concat(config.path)));
    console.warn("Using ".concat(availableConfigs[0].path));
  }
  return availableConfigs[0].path;
}
function fileExists(filePath) {
  return fs__default$1.default.stat(filePath).then(() => true, () => false);
}
const debug = debug$3.extend("runtime");
async function writeSanityRuntime(_ref4) {
  let {
    cwd,
    reactStrictMode,
    watch,
    basePath
  } = _ref4;
  debug("Resolving Sanity monorepo information");
  const monorepo = await loadSanityMonorepo(cwd);
  const runtimeDir = path__default.default.join(cwd, ".sanity", "runtime");
  debug("Making runtime directory");
  await fs__default$1.default.mkdir(runtimeDir, {
    recursive: true
  });
  async function renderAndWriteDocument() {
    debug("Rendering document template");
    const indexHtml = decorateIndexWithAutoGeneratedWarning(await renderDocument({
      studioRootPath: cwd,
      monorepo,
      props: {
        entryPath: "/".concat(path__default.default.relative(cwd, path__default.default.join(runtimeDir, "app.js"))),
        basePath: basePath || "/"
      }
    }));
    debug("Writing index.html to runtime directory");
    await fs__default$1.default.writeFile(path__default.default.join(runtimeDir, "index.html"), indexHtml);
  }
  if (watch) {
    chokidar__default.default.watch(getPossibleDocumentComponentLocations(cwd)).on("all", () => renderAndWriteDocument());
  }
  await renderAndWriteDocument();
  debug("Writing app.js to runtime directory");
  const studioConfigPath = await getSanityStudioConfigPath(cwd);
  const relativeConfigLocation = studioConfigPath ? path__default.default.relative(runtimeDir, studioConfigPath) : null;
  await fs__default$1.default.writeFile(path__default.default.join(runtimeDir, "app.js"), getEntryModule({
    reactStrictMode,
    relativeConfigLocation,
    basePath
  }));
}
exports.debug = debug$3;
exports.extendViteConfigWithUserConfig = extendViteConfigWithUserConfig;
exports.finalizeViteConfig = finalizeViteConfig;
exports.generateWebManifest = generateWebManifest;
exports.getViteConfig = getViteConfig;
exports.writeSanityRuntime = writeSanityRuntime;
//# sourceMappingURL=runtime-CSusHM37.js.map
