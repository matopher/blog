{"version":3,"file":"workerChannels-BZhuLtcy.js","sources":["../../src/_internal/cli/util/workerChannels.ts"],"sourcesContent":["import {type MessagePort, type Worker} from 'worker_threads'\n\ntype StreamReporter<TPayload = unknown> = {emit: (payload: TPayload) => void; end: () => void}\ntype EventReporter<TPayload = unknown> = (payload: TPayload) => void\ntype EventReceiver<TPayload = unknown> = () => Promise<TPayload>\ntype StreamReceiver<TPayload = unknown> = () => AsyncIterable<TPayload>\n\ntype EventKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelEvent<any> ? K : never\n}[keyof TWorkerChannel]\ntype StreamKeys<TWorkerChannel extends WorkerChannel> = {\n  [K in keyof TWorkerChannel]: TWorkerChannel[K] extends WorkerChannelStream<any> ? K : never\n}[keyof TWorkerChannel]\n\ntype EventMessage<TPayload = unknown> = {type: 'event'; name: string; payload: TPayload}\ntype StreamEmissionMessage<TPayload = unknown> = {type: 'emission'; name: string; payload: TPayload}\ntype StreamEndMessage = {type: 'end'; name: string}\ntype WorkerChannelMessage = EventMessage | StreamEmissionMessage | StreamEndMessage\n\n/**\n * Represents the definition of a \"worker channel\" to report progress from the\n * worker to the parent. Worker channels can define named events or streams and\n * the worker will report events and streams while the parent will await them.\n * This allows the control flow of the parent to follow the control flow of the\n * worker 1-to-1.\n */\nexport type WorkerChannel<\n  TWorkerChannel extends Record<\n    string,\n    WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>\n  > = Record<string, WorkerChannelEvent<unknown> | WorkerChannelStream<unknown>>,\n> = TWorkerChannel\n\nexport type WorkerChannelEvent<TPayload = void> = {type: 'event'; payload: TPayload}\nexport type WorkerChannelStream<TPayload = void> = {type: 'stream'; payload: TPayload}\n\nexport interface WorkerChannelReporter<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReporter<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReporter<TPayload>\n      : void\n  }\n}\n\nexport interface WorkerChannelReceiver<TWorkerChannel extends WorkerChannel> {\n  event: {\n    [K in EventKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelEvent<infer TPayload>\n      ? EventReceiver<TPayload>\n      : void\n  }\n  stream: {\n    [K in StreamKeys<TWorkerChannel>]: TWorkerChannel[K] extends WorkerChannelStream<infer TPayload>\n      ? StreamReceiver<TPayload>\n      : void\n  }\n  // TODO: good candidate for [Symbol.asyncDispose] when our tooling better supports it\n  dispose: () => Promise<number>\n}\n\n/**\n * A simple queue that has two primary methods: `push(message)` and\n * `await next()`. This message queue is used by the \"receiver\" of the worker\n * channel and this class handles buffering incoming messages if the worker is\n * producing faster than the parent as well as returning a promise if there is\n * no message yet in the queue when the parent awaits `next()`.\n */\nclass MessageQueue<T> {\n  resolver: ((result: IteratorResult<T>) => void) | null = null\n  queue: T[] = []\n\n  push(message: T) {\n    if (this.resolver) {\n      this.resolver({value: message, done: false})\n      this.resolver = null\n    } else {\n      this.queue.push(message)\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    if (this.queue.length) {\n      return Promise.resolve({value: this.queue.shift()!, done: false})\n    }\n\n    return new Promise((resolve) => (this.resolver = resolve))\n  }\n\n  end() {\n    if (this.resolver) {\n      this.resolver({value: undefined, done: true})\n    }\n  }\n}\n\nfunction isWorkerChannelMessage(message: unknown): message is WorkerChannelMessage {\n  if (typeof message !== 'object') return false\n  if (!message) return false\n  if (!('type' in message)) return false\n  if (typeof message.type !== 'string') return false\n  const types: string[] = ['event', 'emission', 'end'] satisfies WorkerChannelMessage['type'][]\n  return types.includes(message.type)\n}\n\n/**\n * Creates a \"worker channel receiver\" that subscribes to incoming messages\n * from the given worker and returns promises for worker channel events and\n * async iterators for worker channel streams.\n */\nexport function createReceiver<TWorkerChannel extends WorkerChannel>(\n  worker: Worker,\n): WorkerChannelReceiver<TWorkerChannel> {\n  const _events = new Map<string, MessageQueue<EventMessage>>()\n  const _streams = new Map<string, MessageQueue<StreamEmissionMessage>>()\n  const errors = new MessageQueue<{type: 'error'; error: unknown}>()\n\n  const eventQueue = (name: string) => {\n    const queue = _events.get(name) ?? new MessageQueue()\n    if (!_events.has(name)) _events.set(name, queue)\n    return queue\n  }\n\n  const streamQueue = (name: string) => {\n    const queue = _streams.get(name) ?? new MessageQueue()\n    if (!_streams.has(name)) _streams.set(name, queue)\n    return queue\n  }\n\n  const handleMessage = (message: unknown) => {\n    if (!isWorkerChannelMessage(message)) return\n    if (message.type === 'event') eventQueue(message.name).push(message)\n    if (message.type === 'emission') streamQueue(message.name).push(message)\n    if (message.type === 'end') streamQueue(message.name).end()\n  }\n\n  const handleError = (error: unknown) => {\n    errors.push({type: 'error', error})\n  }\n\n  worker.addListener('message', handleMessage)\n  worker.addListener('error', handleError)\n\n  return {\n    event: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReceiver: EventReceiver = async () => {\n          const {value} = await Promise.race([eventQueue(name).next(), errors.next()])\n          if (value.type === 'error') throw value.error\n          return value.payload\n        }\n\n        return eventReceiver\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReceiver<TWorkerChannel>['stream'], {\n      get: (target, prop) => {\n        if (typeof prop !== 'string') return target[prop as keyof typeof target]\n        const name = prop // alias for better typescript narrowing\n\n        async function* streamReceiver() {\n          while (true) {\n            const {value, done} = await Promise.race([streamQueue(name).next(), errors.next()])\n            if (done) return\n            if (value.type === 'error') throw value.error\n            yield value.payload\n          }\n        }\n\n        return streamReceiver satisfies StreamReceiver\n      },\n    }),\n    dispose: () => {\n      worker.removeListener('message', handleMessage)\n      worker.removeListener('error', handleError)\n      return worker.terminate()\n    },\n  }\n}\n\n/**\n * Creates a \"worker channel reporter\" that sends messages to the given\n * `parentPort` to be received by a worker channel receiver.\n */\nexport function createReporter<TWorkerChannel extends WorkerChannel>(\n  parentPort: MessagePort | null,\n): WorkerChannelReporter<TWorkerChannel> {\n  if (!parentPort) {\n    throw new Error('parentPart was falsy')\n  }\n\n  return {\n    event: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['event'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const eventReporter: EventReporter = (payload) => {\n          const message: EventMessage = {type: 'event', name, payload}\n          parentPort.postMessage(message)\n        }\n\n        return eventReporter\n      },\n    }),\n    stream: new Proxy({} as WorkerChannelReporter<TWorkerChannel>['stream'], {\n      get: (target, name) => {\n        if (typeof name !== 'string') return target[name as keyof typeof target]\n\n        const streamReporter: StreamReporter = {\n          emit: (payload) => {\n            const message: StreamEmissionMessage = {type: 'emission', name, payload}\n            parentPort.postMessage(message)\n          },\n          end: () => {\n            const message: StreamEndMessage = {type: 'end', name}\n            parentPort.postMessage(message)\n          },\n        }\n\n        return streamReporter\n      },\n    }),\n  }\n}\n"],"names":["MessageQueue","constructor","resolver","queue","push","message","value","done","next","length","Promise","resolve","shift","end","isWorkerChannelMessage","type","types","includes","createReceiver","worker","_events","Map","_streams","errors","eventQueue","name","_a","get","has","set","streamQueue","handleMessage","handleError","error","addListener","event","Proxy","target","eventReceiver","race","payload","stream","prop","streamReceiver","dispose","removeListener","terminate","createReporter","parentPort","Error","eventReporter","postMessage","streamReporter","emit"],"mappings":"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"}