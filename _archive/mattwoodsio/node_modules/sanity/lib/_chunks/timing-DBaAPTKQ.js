'use strict';

var generateHelpUrl = require('@sanity/generate-help-url');
var fs = require('fs');
var path = require('path');
var resolveFrom = require('resolve-from');
var semver = require('semver');
var execa = require('execa');
var fs$1 = require('fs/promises');
var oneline = require('oneline');
var perf_hooks = require('perf_hooks');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var resolveFrom__default = /*#__PURE__*/_interopDefaultCompat(resolveFrom);
var semver__default = /*#__PURE__*/_interopDefaultCompat(semver);
var execa__default = /*#__PURE__*/_interopDefaultCompat(execa);
var oneline__default = /*#__PURE__*/_interopDefaultCompat(oneline);
const PACKAGES = [{
  name: "react",
  supported: ["^18"],
  deprecatedBelow: null
}, {
  name: "react-dom",
  supported: ["^18"],
  deprecatedBelow: null
}];
function checkStudioDependencyVersions(workDir) {
  const manifest = readPackageJson$1(path__default.default.join(workDir, "package.json"));
  const dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  };
  const packageInfo = PACKAGES.map(pkg => {
    const dependency = dependencies[pkg.name];
    if (!dependency) {
      return false;
    }
    const manifestPath = resolveFrom__default.default.silent(workDir, path__default.default.join(pkg.name, "package.json"));
    const installed = semver__default.default.coerce(manifestPath ? readPackageJson$1(manifestPath).version : dependency.replace(/[\D.]/g, ""));
    if (!installed) {
      return false;
    }
    const supported = pkg.supported.join(" || ");
    const isUntested = !semver__default.default.satisfies(installed, supported) && semver__default.default.gtr(installed, supported);
    const isUnsupported = !semver__default.default.satisfies(installed, supported) && !isUntested;
    const isDeprecated = pkg.deprecatedBelow ? semver__default.default.ltr(installed, pkg.deprecatedBelow) : false;
    return {
      ...pkg,
      installed,
      isUnsupported,
      isDeprecated,
      isUntested
    };
  });
  const installedPackages = packageInfo.filter(inp => inp !== false);
  const unsupported = installedPackages.filter(pkg => pkg.isUnsupported);
  const deprecated = installedPackages.filter(pkg => !pkg.isUnsupported && pkg.isDeprecated);
  const untested = installedPackages.filter(pkg => pkg.isUntested);
  if (deprecated.length > 0) {
    console.warn("\n[WARN] The following package versions have been deprecated and should be upgraded:\n\n  ".concat(listPackages(deprecated), "\n\nSupport for these will be removed in a future release!\n\n  ").concat(getUpgradeInstructions(deprecated), "\n"));
  }
  if (untested.length > 0) {
    console.warn("\n[WARN] The following package versions have not yet been marked as supported:\n\n  ".concat(listPackages(untested), "\n\nYou _may_ encounter bugs while using these versions.\n\n  ").concat(getDowngradeInstructions(untested), "\n"));
  }
  if (unsupported.length > 0) {
    console.error("\n[ERROR] The following package versions are no longer supported and needs to be upgraded:\n\n  ".concat(listPackages(unsupported), "\n\n  ").concat(getUpgradeInstructions(unsupported), "\n"));
    process.exit(1);
  }
}
function listPackages(pkgs) {
  return pkgs.map(pkg => "".concat(pkg.name, " (installed: ").concat(pkg.installed, ", want: ").concat(pkg.deprecatedBelow || pkg.supported.join(" || "), ")")).join("\n  ");
}
function getUpgradeInstructions(pkgs) {
  const inst = pkgs.map(pkg => {
    const [highestSupported] = pkg.supported.map(version => (semver__default.default.coerce(version) || {
      version: ""
    }).version).sort(semver__default.default.rcompare);
    return '"'.concat(pkg.name, "@").concat(highestSupported, '"');
  }).join(" ");
  return "To upgrade, run either:\n\n  npm install ".concat(inst, "\n\n  or\n\n  yarn add ").concat(inst, "\n\n  or\n\n  pnpm add ").concat(inst, "\n\n\nRead more at ").concat(generateHelpUrl.generateHelpUrl("upgrade-packages"));
}
function getDowngradeInstructions(pkgs) {
  const inst = pkgs.map(pkg => {
    const [highestSupported] = pkg.supported.map(version => (semver__default.default.coerce(version) || {
      version: ""
    }).version).sort(semver__default.default.rcompare);
    return '"'.concat(pkg.name, "@").concat(highestSupported, '"');
  }).join(" ");
  return "To downgrade, run either:\n\n  yarn add ".concat(inst, "\n\n  or\n\n  npm install ").concat(inst, "\n\n  or\n\n  pnpm install ").concat(inst);
}
function readPackageJson$1(filePath) {
  try {
    return JSON.parse(fs__default.default.readFileSync(filePath, "utf8"));
  } catch (err) {
    throw new Error('Failed to read "'.concat(filePath, '": ').concat(err.message));
  }
}
var peerDependencies = {
  react: "^18",
  "react-dom": "^18",
  "styled-components": "^5.2 || ^6"
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a, _b, _c, _d;
const defaultStudioManifestProps = {
  name: "studio",
  version: "1.0.0"
};
async function checkRequiredDependencies(context) {
  const {
    workDir: studioPath,
    output
  } = context;
  const [studioPackageManifest, installedStyledComponentsVersion] = await Promise.all([await readPackageManifest(path__default.default.join(studioPath, "package.json"), defaultStudioManifestProps), await readModuleVersion(studioPath, "styled-components")]);
  const wantedStyledComponentsVersionRange = peerDependencies["styled-components"];
  const declaredStyledComponentsVersion = studioPackageManifest.dependencies["styled-components"];
  if (!declaredStyledComponentsVersion) {
    const [file, ...args] = process.argv;
    const deps = {
      "styled-components": wantedStyledComponentsVersionRange
    };
    await installDependencies(deps, context);
    await execa__default.default(file, args, {
      cwd: studioPath,
      stdio: "inherit"
    });
    return {
      didInstall: true
    };
  }
  let minDeclaredStyledComponentsVersion = null;
  try {
    minDeclaredStyledComponentsVersion = semver__default.default.minVersion(declaredStyledComponentsVersion);
  } catch (err) {}
  if (!minDeclaredStyledComponentsVersion) {
    throw new Error(oneline__default.default(_a || (_a = __template(["\n      Declared dependency `styled-components` has an invalid version range:\n      `", "`.\n    "], ["\n      Declared dependency \\`styled-components\\` has an invalid version range:\n      \\`", "\\`.\n    "])), declaredStyledComponentsVersion));
  }
  if (isComparableRange(declaredStyledComponentsVersion) && !semver__default.default.satisfies(minDeclaredStyledComponentsVersion, wantedStyledComponentsVersionRange)) {
    output.warn(oneline__default.default(_b || (_b = __template(["\n      Declared version of styled-components (", ")\n      is not compatible with the version required by sanity (", ").\n      This might cause problems!\n    "])), declaredStyledComponentsVersion, wantedStyledComponentsVersionRange));
  }
  if (!installedStyledComponentsVersion) {
    throw new Error(oneline__default.default(_c || (_c = __template(["\n      Declared dependency `styled-components` is not installed - run\n      `npm install`, `yarn install` or `pnpm install` to install it before re-running this command.\n    "], ["\n      Declared dependency \\`styled-components\\` is not installed - run\n      \\`npm install\\`, \\`yarn install\\` or \\`pnpm install\\` to install it before re-running this command.\n    "]))));
  }
  if (!semver__default.default.satisfies(installedStyledComponentsVersion, wantedStyledComponentsVersionRange)) {
    output.warn(oneline__default.default(_d || (_d = __template(["\n      Installed version of styled-components (", ")\n      is not compatible with the version required by sanity (", ").\n      This might cause problems!\n    "])), installedStyledComponentsVersion, wantedStyledComponentsVersionRange));
  }
  return {
    didInstall: false
  };
}
async function readModuleVersion(studioPath, moduleName) {
  const manifestPath = resolveFrom__default.default.silent(studioPath, path__default.default.join(moduleName, "package.json"));
  return manifestPath ? (await readPackageManifest(manifestPath)).version : null;
}
async function readPackageManifest(packageJsonPath) {
  let defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let manifest;
  try {
    manifest = {
      ...defaults,
      ...(await readPackageJson(packageJsonPath))
    };
  } catch (err) {
    throw new Error('Failed to read "'.concat(packageJsonPath, '": ').concat(err.message));
  }
  if (!isPackageManifest(manifest)) {
    throw new Error('Failed to read "'.concat(packageJsonPath, '": Invalid package manifest'));
  }
  const {
    name,
    version,
    dependencies = {},
    devDependencies = {}
  } = manifest;
  return {
    name,
    version,
    dependencies,
    devDependencies
  };
}
async function installDependencies(dependencies, context) {
  const {
    output,
    prompt,
    workDir,
    cliPackageManager
  } = context;
  const packages = [];
  output.print("The Sanity studio needs to install missing dependencies:");
  for (const [pkgName, version] of Object.entries(dependencies)) {
    const declaration = "".concat(pkgName, "@").concat(version);
    output.print("- ".concat(declaration));
    packages.push(declaration);
  }
  if (!cliPackageManager) {
    output.error("ERROR: Could not determine package manager choice - run `npm install` or equivalent");
    return;
  }
  const {
    getPackageManagerChoice,
    installNewPackages
  } = cliPackageManager;
  const {
    mostOptimal,
    chosen: pkgManager
  } = await getPackageManagerChoice(workDir, {
    prompt
  });
  if (mostOptimal && pkgManager !== mostOptimal) {
    output.warn("WARN: This project appears to be installed with or using ".concat(mostOptimal, " - using a different package manager _may_ result in errors."));
  }
  await installNewPackages({
    packages,
    packageManager: pkgManager
  }, context);
}
function isPackageManifest(item) {
  return typeof item === "object" && item !== null && "name" in item && "version" in item;
}
function isComparableRange(range) {
  return /^[\^~]?\d+(\.\d+)?(\.\d+)?$/.test(range);
}
function readPackageJson(filePath) {
  return fs$1.readFile(filePath, "utf8").then(res => JSON.parse(res));
}
function getTimer() {
  const timings = {};
  const startTimes = {};
  function start(name) {
    if (typeof startTimes[name] !== "undefined") {
      throw new Error('Timer "'.concat(name, '" already started, cannot overwrite'));
    }
    startTimes[name] = perf_hooks.performance.now();
  }
  function end(name) {
    if (typeof startTimes[name] === "undefined") {
      throw new Error('Timer "'.concat(name, '" never started, cannot end'));
    }
    timings[name] = perf_hooks.performance.now() - startTimes[name];
    return timings[name];
  }
  return {
    start,
    end,
    getTimings: () => timings
  };
}
exports.checkRequiredDependencies = checkRequiredDependencies;
exports.checkStudioDependencyVersions = checkStudioDependencyVersions;
exports.getTimer = getTimer;
//# sourceMappingURL=timing-DBaAPTKQ.js.map
