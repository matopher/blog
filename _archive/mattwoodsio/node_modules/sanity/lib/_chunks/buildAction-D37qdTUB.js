import path from 'path';
import { promisify } from 'util';
import chalk from 'chalk';
import { defineTrace, noopLogger } from '@sanity/telemetry';
import rimraf$1 from 'rimraf';
import { buildStaticFiles } from './previewServer-BHxxHO8G.js';
import 'vite';
import './runtime-B_bGx0NP.js';
import '@vitejs/plugin-react';
import 'debug';
import 'read-pkg-up';
import '@sanity/cli';
import 'resolve-from';
import 'connect-history-api-fallback';
import 'fs';
import 'fs/promises';
import { checkStudioDependencyVersions, checkRequiredDependencies, getTimer } from './timing-DjElMkC8.js';
const BuildTrace = defineTrace({
  name: "Studio Build Completed",
  version: 0,
  description: "A Studio build completed"
});
const rimraf = promisify(rimraf$1);
async function buildSanityStudio(args, context, overrides) {
  var _a;
  const timer = getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig,
    telemetry = noopLogger
  } = context;
  const flags = {
    minify: true,
    stats: false,
    "source-maps": false,
    ...args.extOptions
  };
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path.resolve(path.join(workDir, "dist"));
  const outputDir = path.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await checkStudioDependencyVersions(workDir);
  if ((await checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }
  const envVarKeys = getSanityEnvVars();
  if (envVarKeys.length > 0) {
    output.print("\nIncluding the following environment variables as part of the JavaScript bundle:");
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print("");
  }
  let shouldClean = true;
  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: "confirm",
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }
  let basePath = "/";
  const envBasePath = process.env.SANITY_STUDIO_BASEPATH;
  const configBasePath = (_a = cliConfig == null ? void 0 : cliConfig.project) == null ? void 0 : _a.basePath;
  if (overrides == null ? void 0 : overrides.basePath) {
    basePath = overrides.basePath;
  } else if (envBasePath) {
    basePath = envBasePath;
  } else if (configBasePath) {
    basePath = configBasePath;
  }
  if (envBasePath && configBasePath) {
    output.warn("Overriding configured base path (".concat(configBasePath, ") with value from environment variable (").concat(envBasePath, ")"));
  }
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder");
    spin = output.spinner("Clean output folder").start();
    await rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  const trace = telemetry.trace(BuildTrace);
  trace.start();
  try {
    timer.start("bundleStudio");
    const bundle = await buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath,
      sourceMap: Boolean(flags["source-maps"]),
      minify: Boolean(flags.minify),
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0
    });
    trace.log({
      outputSize: bundle.chunks.flatMap(chunk => chunk.modules.flatMap(mod => mod.renderedLength)).reduce((sum, n) => sum + n, 0)
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();
    trace.complete();
    if (flags.stats) {
      output.print("\nLargest module files:");
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    trace.error(err);
    throw err;
  }
  return {
    didCompile: true
  };
}
function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
  const lines = [];
  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }
  return lines.join("\n");
}
function formatModuleName(modName) {
  const delimiter = "/node_modules/";
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
  return chalk.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}
export { buildSanityStudio as default };
//# sourceMappingURL=buildAction-D37qdTUB.js.map
