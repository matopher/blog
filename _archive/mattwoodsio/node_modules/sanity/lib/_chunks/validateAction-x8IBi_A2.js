import logSymbols from 'log-symbols';
import path from 'path';
import readPkgUp from 'read-pkg-up';
import { Worker } from 'worker_threads';
import chalk from 'chalk';
import { isatty } from 'tty';
const isTty = isatty(1);
const headers = {
  error: isTty ? chalk.bold(chalk.bgRed(chalk.black(" ERROR "))) : chalk.red("[ERROR]"),
  warning: isTty ? chalk.bold(chalk.bgYellow(chalk.black(" WARN "))) : chalk.yellow("[WARN]")
};
const severityValues = {
  error: 0,
  warning: 1
};
function formatPath(pathSegments) {
  const format = function (_ref) {
    let [curr, ...next] = _ref;
    let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "object";
    if (!curr) return "";
    if (curr.kind === "property") return format(next, curr.name === "of" ? "array" : "object");
    const name = curr.name ? curr.name : "<anonymous_".concat(curr.type, ">");
    return "".concat(mode === "array" ? "[".concat(name, "]") : ".".concat(name)).concat(format(next));
  };
  return format(pathSegments.slice(1)).substring(1);
}
function getAggregatedSeverity(groupOrGroups) {
  const groups = Array.isArray(groupOrGroups) ? groupOrGroups : [groupOrGroups];
  return groups.flatMap(group => group.problems.map(problem => problem.severity)).find(severity => severity === "error") ? "error" : "warning";
}
function formatSchemaValidation(validation) {
  let unnamedTopLevelTypeCount = 0;
  const validationByType = Object.entries(validation.reduce((acc, next) => {
    var _a;
    const [firstSegment] = next.path;
    if (!firstSegment) return acc;
    if (firstSegment.kind !== "type") return acc;
    const topLevelType = firstSegment.name || "<unnamed_".concat(firstSegment.type, "_type_").concat(unnamedTopLevelTypeCount++, ">");
    const problems = (_a = acc[topLevelType]) != null ? _a : [];
    problems.push(next);
    acc[topLevelType] = problems;
    return acc;
  }, {}));
  const formatted = validationByType.sort((a, b) => {
    const [aType, aGroups] = a;
    const [bType, bGroups] = b;
    const aValue = severityValues[getAggregatedSeverity(aGroups)];
    const bValue = severityValues[getAggregatedSeverity(bGroups)];
    if (aValue === bValue) return aType.localeCompare(bType, "en-US");
    return aValue - bValue;
  }).map(_ref2 => {
    let [topLevelType, groups] = _ref2;
    const formattedTopLevelType = isTty ? chalk.bgWhite(chalk.black(" ".concat(topLevelType, " "))) : "[".concat(topLevelType, "]");
    const header = "".concat(headers[getAggregatedSeverity(groups)], " ").concat(formattedTopLevelType);
    const body = groups.sort((a, b) => severityValues[getAggregatedSeverity(a)] - severityValues[getAggregatedSeverity(b)]).map(group => {
      const formattedPath = "  ".concat(chalk.bold(formatPath(group.path) || "(root)"));
      const formattedMessages = group.problems.sort((a, b) => severityValues[a.severity] - severityValues[b.severity]).map(_ref3 => {
        let {
          severity,
          message
        } = _ref3;
        return "    ".concat(logSymbols[severity], " ").concat(message);
      }).join("\n");
      return "".concat(formattedPath, "\n").concat(formattedMessages);
    }).join("\n");
    return "".concat(header, "\n").concat(body);
  }).join("\n\n");
  return formatted;
}
async function validateAction(args, _ref4) {
  let {
    workDir,
    output
  } = _ref4;
  var _a;
  const flags = args.extOptions;
  const rootPkgPath = (_a = readPkgUp.sync({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  if (!rootPkgPath) {
    throw new Error("Could not find root directory for `sanity` package");
  }
  const workerPath = path.join(path.dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "validateSchema.js");
  const level = flags.level || "warning";
  if (level !== "error" && level !== "warning") {
    throw new Error("Invalid level. Available levels are 'error' and 'warning'.");
  }
  const format = flags.format || "pretty";
  if (!["pretty", "ndjson", "json"].includes(format)) {
    throw new Error("Did not recognize format '".concat(flags.format, "'. Available formats are 'pretty', 'ndjson', and 'json'."));
  }
  let spinner;
  if (format === "pretty") {
    spinner = output.spinner(flags.workspace ? "Validating schema from workspace '".concat(flags.workspace, "'\u2026") : "Validating schema\u2026").start();
  }
  const worker = new Worker(workerPath, {
    workerData: {
      workDir,
      level,
      workspace: flags.workspace
    },
    // eslint-disable-next-line no-process-env
    env: process.env
  });
  const {
    validation
  } = await new Promise((resolve, reject) => {
    worker.addListener("message", resolve);
    worker.addListener("error", reject);
  });
  const problems = validation.flatMap(group => group.problems);
  const errorCount = problems.filter(problem => problem.severity === "error").length;
  const warningCount = problems.filter(problem => problem.severity === "warning").length;
  const overallSeverity = getAggregatedSeverity(validation);
  switch (format) {
    case "ndjson":
      {
        for (const group of validation) {
          output.print(JSON.stringify(group));
        }
        break;
      }
    case "json":
      {
        output.print(JSON.stringify(validation));
        break;
      }
    default:
      {
        spinner == null ? void 0 : spinner.succeed("Validated schema");
        output.print("\nValidation results:");
        output.print("".concat(logSymbols.error, " Errors:   ").concat(errorCount.toLocaleString("en-US"), " error").concat(errorCount === 1 ? "" : "s"));
        if (level !== "error") {
          output.print("".concat(logSymbols.warning, " Warnings: ").concat(warningCount.toLocaleString("en-US"), " warning").concat(warningCount === 1 ? "" : "s"));
        }
        output.print();
        output.print(formatSchemaValidation(validation));
      }
  }
  process.exitCode = overallSeverity === "error" ? 1 : 0;
}
export { validateAction as default };
//# sourceMappingURL=validateAction-x8IBi_A2.js.map
