'use strict';

var path = require('path');
var util = require('util');
var chalk = require('chalk');
var telemetry = require('@sanity/telemetry');
var rimraf$1 = require('rimraf');
var previewServer = require('./previewServer-DZ4NiF4u.js');
require('vite');
require('./runtime-CSusHM37.js');
require('@vitejs/plugin-react');
require('debug');
require('read-pkg-up');
require('@sanity/cli');
require('resolve-from');
require('connect-history-api-fallback');
require('fs');
require('fs/promises');
var timing = require('./timing-DBaAPTKQ.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var rimraf__default = /*#__PURE__*/_interopDefaultCompat(rimraf$1);
const BuildTrace = telemetry.defineTrace({
  name: "Studio Build Completed",
  version: 0,
  description: "A Studio build completed"
});
const rimraf = util.promisify(rimraf__default.default);
async function buildSanityStudio(args, context, overrides) {
  var _a;
  const timer = timing.getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig,
    telemetry: telemetry$1 = telemetry.noopLogger
  } = context;
  const flags = {
    minify: true,
    stats: false,
    "source-maps": false,
    ...args.extOptions
  };
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path__default.default.resolve(path__default.default.join(workDir, "dist"));
  const outputDir = path__default.default.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await timing.checkStudioDependencyVersions(workDir);
  if ((await timing.checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }
  const envVarKeys = getSanityEnvVars();
  if (envVarKeys.length > 0) {
    output.print("\nIncluding the following environment variables as part of the JavaScript bundle:");
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print("");
  }
  let shouldClean = true;
  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: "confirm",
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }
  let basePath = "/";
  const envBasePath = process.env.SANITY_STUDIO_BASEPATH;
  const configBasePath = (_a = cliConfig == null ? void 0 : cliConfig.project) == null ? void 0 : _a.basePath;
  if (overrides == null ? void 0 : overrides.basePath) {
    basePath = overrides.basePath;
  } else if (envBasePath) {
    basePath = envBasePath;
  } else if (configBasePath) {
    basePath = configBasePath;
  }
  if (envBasePath && configBasePath) {
    output.warn("Overriding configured base path (".concat(configBasePath, ") with value from environment variable (").concat(envBasePath, ")"));
  }
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder");
    spin = output.spinner("Clean output folder").start();
    await rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  const trace = telemetry$1.trace(BuildTrace);
  trace.start();
  try {
    timer.start("bundleStudio");
    const bundle = await previewServer.buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath,
      sourceMap: Boolean(flags["source-maps"]),
      minify: Boolean(flags.minify),
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0
    });
    trace.log({
      outputSize: bundle.chunks.flatMap(chunk => chunk.modules.flatMap(mod => mod.renderedLength)).reduce((sum, n) => sum + n, 0)
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();
    trace.complete();
    if (flags.stats) {
      output.print("\nLargest module files:");
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    trace.error(err);
    throw err;
  }
  return {
    didCompile: true
  };
}
function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
  const lines = [];
  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }
  return lines.join("\n");
}
function formatModuleName(modName) {
  const delimiter = "/node_modules/";
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
  return chalk__default.default.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}
exports.default = buildSanityStudio;
//# sourceMappingURL=buildAction-BdD3ajZy.js.map
