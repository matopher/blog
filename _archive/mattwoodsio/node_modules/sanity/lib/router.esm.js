import { jsx } from 'react/jsx-runtime';
import { createContext, useContext, useCallback, useMemo, forwardRef, useRef } from 'react';
import difference from 'lodash/difference.js';
import intersection from 'lodash/intersection.js';
import isPlainObject from 'lodash/isPlainObject.js';
import pick from 'lodash/pick.js';
import debug$1 from 'debug';
import identity from 'lodash/identity.js';
const RouterContext = createContext(null);
function useRouter() {
  const router = useContext(RouterContext);
  if (!router) {
    throw new Error("Router: missing context value");
  }
  return router;
}
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLink(options) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace = false
  } = options;
  const {
    navigateUrl
  } = useRouter();
  const onClick = useCallback(event => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (!href) return;
    if (onClickProp) {
      onClickProp(event);
    }
    if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
      return;
    }
    if (target) {
      return;
    }
    event.preventDefault();
    navigateUrl({
      path: href,
      replace
    });
  }, [href, navigateUrl, onClickProp, replace, target]);
  return {
    onClick
  };
}
function useIntentLink(options) {
  const {
    intent,
    onClick: onClickProp,
    params,
    replace,
    target
  } = options;
  const {
    resolveIntentLink
  } = useRouter();
  const href = useMemo(() => resolveIntentLink(intent, params), [intent, params, resolveIntentLink]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const IntentLink = forwardRef(function IntentLink2(props, ref) {
  const {
    intent,
    params,
    target,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useIntentLink({
    intent,
    params,
    target,
    onClick: props.onClick
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    href,
    onClick,
    ref,
    target
  });
});
const Link = forwardRef(function Link2(props, ref) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace,
    ...restProps
  } = props;
  const {
    onClick
  } = useLink({
    onClick: onClickProp,
    href,
    target,
    replace
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    onClick,
    href,
    target,
    ref
  });
});
const VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/;
function createSegment(segment) {
  if (!segment) {
    return null;
  }
  if (segment.startsWith(":")) {
    const paramName = segment.substring(1);
    if (!VALID_PARAM_SEGMENT.test(paramName)) {
      const addendum = segment.includes("*") ? " Splats are not supported. Consider using child routes instead" : "";
      console.error(new Error('Warning: Param segments "'.concat(segment, '" includes invalid characters.').concat(addendum)));
    }
    return {
      type: "param",
      name: paramName
    };
  }
  return {
    type: "dir",
    name: segment
  };
}
function _parseRoute(route) {
  const [pathname] = route.split("?");
  const segments = pathname.split("/").map(createSegment).filter(Boolean);
  return {
    raw: route,
    segments
  };
}
function arrayify(val) {
  if (Array.isArray(val)) {
    return val;
  }
  return val ? [val] : [];
}
function isRecord(value) {
  return isPlainObject(value);
}
function createMatchError(node, missingKeys, unmappableStateKeys) {
  return {
    type: "error",
    node,
    missingKeys,
    unmappableStateKeys
  };
}
function createMatchOk(node, matchedState, searchParams, child) {
  return {
    type: "ok",
    node,
    matchedState,
    searchParams,
    child
  };
}
function _findMatchingRoutes(node, _state) {
  if (!_state) {
    return createMatchOk(node, {}, []);
  }
  const scopedState = node.scope ? _state[node.scope] : _state;
  const {
    _searchParams: searchParams = [],
    ...state
  } = scopedState || {};
  const requiredParams = node.route.segments.filter(seg => seg.type === "param").map(seg => seg.name);
  const stateKeys = isRecord(state) ? Object.keys(state) : [];
  const consumedParams = intersection(stateKeys, requiredParams);
  const missingParams = difference(requiredParams, consumedParams);
  const remainingParams = difference(stateKeys, consumedParams);
  if (missingParams.length > 0) {
    return createMatchError(node, missingParams, []);
  }
  const scopedParams = searchParams.map(_ref => {
    let [key, value] = _ref;
    return [[key], value];
  });
  const consumedState = pick(state, consumedParams);
  if (remainingParams.length === 0) {
    return createMatchOk(node, consumedState, scopedParams);
  }
  const children = arrayify((typeof node.children === "function" ? node.children(isRecord(state) ? state : {}) : node.children) || []);
  if (remainingParams.length > 0 && children.length === 0) {
    return createMatchError(node, [], remainingParams);
  }
  const remainingState = pick(state, remainingParams);
  const childResult = children.map(childNode => _findMatchingRoutes(childNode, remainingState));
  const found = childResult.find(res => res.type === "ok");
  return found ? createMatchOk(node, consumedState, scopedParams, found) : createMatchError(node, [], remainingParams);
}
function encodeURIComponentExcept(uriComponent, unescaped) {
  const chars = [...String(uriComponent)];
  let res = "";
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (unescaped.includes(char)) {
      res += char;
    } else {
      res += encodeURIComponent(char);
    }
  }
  return res;
}
const debug = debug$1("state-router");
function _resolvePathFromState(node, _state) {
  debug("Resolving path from state %o", _state);
  const match = _findMatchingRoutes(node, _state);
  if (match.type === "error") {
    const unmappable = match.unmappableStateKeys;
    if (unmappable.length > 0) {
      throw new Error("Unable to find matching route for state. Could not map the following state key".concat(unmappable.length == 1 ? "" : "s", " to a valid url: ").concat(unmappable.map(quote).join(", ")));
    }
    const missingKeys = match.missingKeys;
    throw new Error("Unable to find matching route for state. State object is missing the following key".concat(missingKeys.length == 1 ? "" : "s", " defined in route: ").concat(missingKeys.map(quote).join(", ")));
  }
  const {
    path,
    searchParams
  } = pathFromMatchResult(match);
  const search = searchParams.length > 0 ? encodeParams$1(searchParams) : "";
  return "/".concat(path.join("/")).concat(search ? "?".concat(search) : "");
}
function bracketify(value) {
  return "[".concat(value, "]");
}
function encodeParams$1(params) {
  return params.flatMap(_ref2 => {
    let [key, value] = _ref2;
    if (value === void 0) {
      return [];
    }
    return [encodeSearchParamKey(serializeScopedPath(key)), encodeSearchParamValue(value)].join("=");
  }).join("&");
}
function serializeScopedPath(scopedPath) {
  const [head, ...tail] = scopedPath;
  return tail.length > 0 ? [head, ...tail.map(bracketify)].join("") : head;
}
function encodeSearchParamValue(value) {
  return encodeURIComponentExcept(value, "/");
}
function encodeSearchParamKey(value) {
  return encodeURIComponentExcept(value, "[]");
}
function pathFromMatchResult(match) {
  const matchedState = match.matchedState;
  const base = match.node.route.segments.map(segment => {
    if (segment.type === "dir") {
      return segment.name;
    }
    const transform = match.node.transform && match.node.transform[segment.name];
    return transform ? transform.toPath(matchedState[segment.name]) : matchedState[segment.name];
  });
  const childMatch = match.child ? pathFromMatchResult(match.child) : void 0;
  const searchParams = (childMatch == null ? void 0 : childMatch.searchParams) ? [...match.searchParams, ...childMatch.searchParams] : match.searchParams;
  return {
    searchParams: addNodeScope(match.node, searchParams),
    path: [...(base || []), ...((childMatch == null ? void 0 : childMatch.path) || [])]
  };
}
function addNodeScope(node, searchParams) {
  const scope = node.scope;
  return scope && !node.__unsafe_disableScopedSearchParams ? searchParams.map(_ref3 => {
    let [namespaces, value] = _ref3;
    return [[scope, ...namespaces], value];
  }) : searchParams;
}
function quote(value) {
  return '"'.concat(value, '"');
}
function parseScopedParams(params) {
  return params.map(_ref4 => {
    let [key, value] = _ref4;
    return [parse(key), value];
  });
}
const OPEN = 1;
const CLOSED = 0;
function parse(str) {
  const result = [];
  let i = 0;
  let state = CLOSED;
  while (i < str.length) {
    const nextBracketIdx = str.indexOf("[", i);
    if (nextBracketIdx === -1) {
      result.push(str.slice(i, str.length));
      break;
    }
    if (state === OPEN) {
      throw new Error("Nested brackets not supported");
    }
    state = OPEN;
    if (nextBracketIdx > i) {
      result.push(str.slice(i, nextBracketIdx));
      i = nextBracketIdx;
    }
    const nextClosing = str.indexOf("]", nextBracketIdx);
    if (nextClosing === -1) {
      if (state === OPEN) {
        throw new Error("Unclosed bracket");
      }
      break;
    }
    state = CLOSED;
    result.push(str.slice(i + 1, nextClosing));
    i = nextClosing + 1;
  }
  return result;
}
function matchPath(node, path, searchParams) {
  const parts = path.split("/").filter(Boolean);
  const segmentsLength = node.route.segments.length;
  if (parts.length < segmentsLength) {
    return null;
  }
  const state = {};
  const isMatching = node.route.segments.every((segment, i) => {
    if (segment.type === "dir") {
      return segment.name === parts[i];
    }
    const transform = node.transform && node.transform[segment.name];
    state[segment.name] = transform ? transform.toState(parts[i]) : parts[i];
    return true;
  });
  if (!isMatching) {
    return null;
  }
  const rest = parts.slice(segmentsLength);
  let childState = null;
  const children = typeof node.children === "function" ? arrayify(node.children(state)) : node.children;
  const unscopedParams = removeScope(node.scope, searchParams);
  children.some(childNode => {
    if (childNode) {
      const childParams = childNode.scope ? unscopedParams.filter(_ref5 => {
        let [namespaces] = _ref5;
        return childNode.scope === namespaces[0];
      }) : unscopedParams;
      childState = matchPath(childNode, rest.join("/"), childParams);
      return childState;
    }
    return void 0;
  });
  if (rest.length > 0 && !childState) {
    return null;
  }
  const selfParams = unscopedParams.flatMap(_ref6 => {
    let [namespace, value] = _ref6;
    return namespace.length === 1 ? [[namespace[0], value]] : [];
  });
  const mergedState = {
    ...state,
    ...(childState || {}),
    ...(selfParams.length > 0 ? {
      _searchParams: selfParams
    } : {})
  };
  return node.scope ? {
    [node.scope]: mergedState
  } : mergedState;
}
function _resolveStateFromPath(node, path) {
  debug("resolving state from path %s", path);
  const [pathname, search] = path.split("?");
  const urlSearchParams = Array.from(new URLSearchParams(search).entries());
  const pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams));
  debug("resolved: %o", pathMatch || null);
  return pathMatch || null;
}
function removeScope(scope, searchParams) {
  return scope ? searchParams.map(_ref7 => {
    let [namespaces, value] = _ref7;
    return [namespaces[0] === scope ? namespaces.slice(1) : namespaces, value];
  }) : searchParams;
}
function encodeBase64Url(str) {
  return encodeBase64(str).replace(/\//g, "_").replace(/\+/g, "-").replace(/[=]+$/, "");
}
function decodeBase64Url(str) {
  return decodeBase64(str.replace(/-/g, "+").replace(/_/g, "/"));
}
function percentToByte(p) {
  return String.fromCharCode(parseInt(p.slice(1), 16));
}
function encodeBase64(str) {
  return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));
}
function byteToPercent(b) {
  return "%".concat("00".concat(b.charCodeAt(0).toString(16)).slice(-2));
}
function decodeBase64(str) {
  return decodeURIComponent(Array.from(atob(str), byteToPercent).join(""));
}
function decodeJsonParams() {
  let pathSegment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  const segment = decodeURIComponent(pathSegment);
  if (!segment) {
    return {};
  }
  try {
    return JSON.parse(decodeBase64Url(segment));
  } catch (err) {}
  try {
    return JSON.parse(atob(segment));
  } catch (err) {}
  try {
    return JSON.parse(segment);
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
  }
  return {};
}
function encodeJsonParams(params) {
  return params ? encodeBase64Url(JSON.stringify(params)) : "";
}
function decodeParams(pathSegment) {
  return pathSegment.split(";").reduce((params, pair) => {
    const [key, value] = pair.split("=");
    params[decodeURIComponent(key)] = decodeURIComponent(value);
    return params;
  }, {});
}
function encodeParams(params) {
  return Object.entries(params).filter(_ref8 => {
    let [, value] = _ref8;
    return value !== void 0 && value !== null;
  }).map(_ref9 => {
    let [key, value] = _ref9;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  }).join(";");
}
const route = {
  create: (routeOrOpts, childrenOrOpts, children) => _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),
  intents: base => {
    const basePath = normalize(base).join("/");
    return route.create("".concat(basePath, "/:intent"), [route.create(":params", {
      transform: {
        params: {
          toState: decodeParams,
          toPath: encodeParams
        }
      }
    }, [route.create(":payload", {
      transform: {
        payload: {
          toState: decodeJsonParams,
          toPath: encodeJsonParams
        }
      }
    })])]);
  },
  scope(scopeName, routeOrOpts, childrenOrOpts, children) {
    const options = normalizeArgs(routeOrOpts, childrenOrOpts, children);
    return _createNode({
      ...options,
      scope: scopeName
    });
  }
};
function normalizeChildren(children) {
  if (Array.isArray(children) || typeof children === "function") {
    return children;
  }
  return children ? [children] : [];
}
function isRoute(val) {
  return val && "_isRoute" in val;
}
function normalizeArgs(path, childrenOrOpts, children) {
  if (typeof path === "object") {
    return path;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === "function" || isRoute(childrenOrOpts)) {
    return {
      path,
      children: normalizeChildren(childrenOrOpts)
    };
  }
  if (children) {
    return {
      path,
      ...childrenOrOpts,
      children: normalizeChildren(children)
    };
  }
  return {
    path,
    ...childrenOrOpts
  };
}
function normalize() {
  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }
  return paths.reduce((acc, path) => acc.concat(path.split("/")), []).filter(Boolean);
}
const EMPTY_STATE$1 = {};
function isRoot(pathname) {
  return pathname.split("/").every(segment => !segment);
}
function _createNode(options) {
  const {
    path,
    scope,
    transform,
    children,
    __unsafe_disableScopedSearchParams
  } = options;
  if (!path) {
    throw new TypeError("Missing path");
  }
  const parsedRoute = _parseRoute(path);
  return {
    _isRoute: true,
    // todo: make a Router class instead
    scope,
    // eslint-disable-next-line camelcase
    __unsafe_disableScopedSearchParams,
    route: parsedRoute,
    children: children || [],
    transform,
    encode(state) {
      return _resolvePathFromState(this, state);
    },
    decode(_path) {
      return _resolveStateFromPath(this, _path);
    },
    isRoot,
    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },
    getBasePath() {
      return this.encode(EMPTY_STATE$1);
    },
    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}
function RouterProvider(props) {
  const {
    onNavigate,
    router: routerProp,
    state
  } = props;
  const resolveIntentLink = useCallback((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = useCallback(nextState => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = useCallback(function (nextState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    onNavigate({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [onNavigate, resolvePathFromState]);
  const navigateIntent = useCallback(function (intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    onNavigate({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [onNavigate, resolveIntentLink]);
  const router = useMemo(() => ({
    navigate,
    navigateIntent,
    navigateUrl: onNavigate,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, onNavigate, resolveIntentLink, resolvePathFromState, state]);
  return /* @__PURE__ */jsx(RouterContext.Provider, {
    value: router,
    children: props.children
  });
}
function addScope(routerState, scope, scopedState) {
  return scopedState && {
    ...routerState,
    [scope]: scopedState
  };
}
function RouteScope(props) {
  const {
    children,
    scope,
    __unsafe_disableScopedSearchParams
  } = props;
  const parentRouter = useRouter();
  const {
    resolvePathFromState: parent_resolvePathFromState,
    navigate: parent_navigate
  } = parentRouter;
  const parentStateRef = useRef(parentRouter.state);
  parentStateRef.current = parentRouter.state;
  const resolveNextParentState = useCallback(_nextState => {
    const {
      _searchParams,
      ...nextState
    } = _nextState;
    const nextParentState = addScope(parentStateRef.current, scope, nextState);
    if (__unsafe_disableScopedSearchParams) {
      nextParentState._searchParams = _searchParams;
    } else {
      nextParentState[scope]._searchParams = _searchParams;
    }
    return nextParentState;
  }, [scope, __unsafe_disableScopedSearchParams]);
  const resolvePathFromState = useCallback(nextState => parent_resolvePathFromState(resolveNextParentState(nextState)), [parent_resolvePathFromState, resolveNextParentState]);
  const navigate = useCallback(nextState => parent_navigate(resolveNextParentState(nextState)), [parent_navigate, resolveNextParentState]);
  const childRouter = useMemo(() => {
    const parentState = parentRouter.state;
    const childState = {
      ...(parentState[scope] || {})
    };
    if (__unsafe_disableScopedSearchParams) {
      childState._searchParams = parentState._searchParams;
    }
    return {
      ...parentRouter,
      navigate,
      resolvePathFromState,
      state: childState
    };
  }, [scope, parentRouter, navigate, resolvePathFromState, __unsafe_disableScopedSearchParams]);
  return /* @__PURE__ */jsx(RouterContext.Provider, {
    value: childRouter,
    children
  });
}
const EMPTY_STATE = {};
function useStateLink(options) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false
  } = options;
  if (state && toIndex) {
    throw new Error("Passing both `state` and `toIndex={true}` as props to StateLink is invalid");
  }
  if (!state && !toIndex) {
    console.error(new Error("No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property"));
  }
  const {
    resolvePathFromState
  } = useRouter();
  const href = useMemo(() => resolvePathFromState(toIndex ? EMPTY_STATE : state || EMPTY_STATE), [resolvePathFromState, state, toIndex]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const StateLink = forwardRef(function StateLink2(props, ref) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useStateLink({
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    href,
    onClick,
    ref
  });
});
function useRouterState() {
  let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
  const {
    state
  } = useRouter();
  return useMemo(() => selector(state), [selector, state]);
}
function withRouter(Component) {
  function WithRouter2(props) {
    const router = useRouter();
    return /* @__PURE__ */jsx(Component, {
      ...props,
      router
    });
  }
  WithRouter2.displayName = "withRouter(".concat(Component.displayName || Component.name, ")");
  return WithRouter2;
}
const WithRouter = withRouter(props => props.children(props.router));
export { IntentLink, Link, RouteScope, RouterContext, RouterProvider, StateLink, WithRouter, _createNode, decodeJsonParams, encodeJsonParams, route, useIntentLink, useLink, useRouter, useRouterState, useStateLink, withRouter };
//# sourceMappingURL=router.esm.js.map
