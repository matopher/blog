import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import * as PathUtils from '@sanity/util/paths';
import { pathFor, isEqual as isEqual$1, toString, trimChildPath as trimChildPath$1, startsWith } from '@sanity/util/paths';
import { useRef, useContext, useState, useCallback, useMemo, useEffect, createElement, StrictMode, useLayoutEffect } from 'react';
import deepCompare from 'react-fast-compare';
import { ConnectorContext, useReporter, ScrollContext, resizeObserver, useReportedValues, SvgWrapper, Connector, DEBUG_LAYER_BOUNDS, isNonNullable as isNonNullable$1, Tracker, ScrollContainer, useUserColorManager, useTranslation, getAnnotationColor, DiffTooltip, Checkbox, FromToArrow, Preview, DiffFromTo, SlugPreview, StringPreview, DatetimeFieldDiff, pathToString, HoveredFieldContext, FormFieldPresenceContext, ArrayOfObjectsItem, MemberItemError, ReviewChangesContext, defaultResolveAnnotationComponent, defaultResolveBlockComponent, defaultResolveInlineBlockComponent, defaultResolveFieldComponent, defaultResolveInputComponent, defaultResolveItemComponent, ArrayOfObjectsFunctions, DefaultMarkers, FormBuilderContext, FormCallbacksProvider, DocumentIdProvider, PresenceProvider, ValidationProvider, EMPTY_ARRAY as EMPTY_ARRAY$2, useSource, useInputComponent, useFieldComponent, usePreviewComponent, useItemComponent, useBlockComponent, useInlineBlockComponent, useAnnotationComponent, PreviewLoader, PatchEvent, GetFormValueProvider, FormValueProvider, DocumentFieldActionsProvider, memoize, memoizeKeyGen, memoizedPair, validateTemplates, isBuilder, useDocumentStore, getPublishedId, useHistoryStore, useClient, DEFAULT_STUDIO_CLIENT_OPTIONS, useProjectStore, prepareConfig, useWorkspace, AddonDatasetContext, StudioProvider, GlobalStyle, StudioLayout, useCurrentLocale, useListFormat, intlCache, useRelativeTime, useUserStore, grantsPermissionOn, HookStateContainer, useReferringDocuments, ZIndexContext, defaults, getFieldLevel, isRecord, useCurrentUser, immutableReconcile, isMemberArrayOfObjects, isMemberObject, SANITY_PATCH_TYPE } from './_chunks/TransformPatches-s4n9R8_j.js';
export { ActiveWorkspaceMatcher, ActiveWorkspaceMatcherContext, ArrayOfObjectOptionsInput, ArrayOfObjectsInput, ArrayOfOptionsInput, ArrayOfPrimitiveOptionsInput, ArrayOfPrimitivesFunctions, ArrayOfPrimitivesInput, ArrayOfPrimitivesItem, AutoCollapseMenu, PortableTextInput as BlockEditor, BlockImagePreview, BlockPreview, BooleanInput, CONNECTING, ChangeBreadcrumb, ChangeIndicator, ChangeIndicatorContext, ChangeList, ChangeResolver, ChangeTitleSegment, CircularProgress, CollapseMenu, CollapseMenuButton, ColorSchemeCustomProvider, ColorSchemeLocalStorageProvider, ColorSchemeProvider, ColorSchemeSetValueContext, ColorSchemeValueContext, CommandList, CompactPreview, ConfigPropertyError, ConfigResolutionError, ContextMenuButton, CorsOriginError, StudioCrossDatasetReferenceInput as CrossDatasetReferenceInput, DEFAULT_MAX_RECURSION_DEPTH, DRAFTS_FOLDER, DateInput, DateTimeInput, DefaultPreview, DetailPreview, DiffCard, DiffContext, DiffErrorBoundary, DiffInspectWrapper, DiffString, DiffStringSegment, DocumentChangeContext, DocumentPreviewPresence, DocumentStatus, DocumentStatusIndicator, EMPTY_OBJECT, EmailInput, FallbackDiff, FieldActionMenu, FieldActionsProvider, FieldActionsResolver, FieldChange, FieldPresence, FieldPresenceInner, FieldPresenceWithOverlay, FieldPresenceWithoutOverlay, StudioFileInput as FileInput, FormCallbacksContext, FormField, FormFieldHeaderText, FormFieldSet, FormFieldStatus, FormFieldValidationStatus, FormInput, FromTo, GroupChange, StudioImageInput as ImageInput, ImperativeToast, InlinePreview, InsufficientPermissionsMessage, LegacyLayerProvider, LinearProgress, LoadingBlock, LocaleProvider, LocaleProviderBase, MediaPreview, MemberField, MemberFieldError, MemberFieldSet, MetaInfo, NavbarContext, NoChanges, NumberInput, ObjectInput, ObjectInputMember, ObjectInputMembers, ObjectMembers, OverlayDisabled, PopoverDialog, PortableTextInput, PresenceOverlay, PreviewCard, StudioReferenceInput as ReferenceInput, ReferenceInputOptionsProvider, ResourceCacheProvider, RevertChangesButton, SANITY_VERSION, SESSION_ID, SanityDefaultPreview, SchemaError, SearchButton, SearchDialog, SelectInput, SlugInput, SourceProvider, StatusButton, StringInput, StudioLayoutComponent, StudioNavbar, StudioToolMenu, TagsArrayInput, TemplatePreview, TextInput, TextWithTone, Timeline, TimelineController, ToolLink, TooltipOfDisabled, TransformPatches, Translate, UniversalArrayInput, UpsellDescriptionSerializer, UpsellDialogDismissed, UpsellDialogLearnMoreCtaClicked, UpsellDialogUpgradeCtaClicked, UpsellDialogViewed, UrlInput, UserAvatar, UserColorManagerProvider, ValueError, VirtualizerScrollInstanceContext, VirtualizerScrollInstanceProvider, WorkspaceProvider, WorkspacesContext, WorkspacesProvider, __tmp_wrap_presenceStore, _createAuthStore, _useColorSchemeInternalValue, asLoadable, checkoutPair, collate, createAuthStore, createBufferedDocument, createConnectionStatusStore, createDocumentPreviewStore, createDocumentStore, createDraftFrom, createGrantsStore, createHistoryStore, createHookFromObservableFactory, createKeyValueStore, createObservableBufferedDocument, createProjectStore, createPublishedFrom, createSchema, createSearchQuery, createSharedResizeObserver, createTrackerScope, createUseReporter, createUserColorManager, createUserStore, dec, defaultLocale, defaultTheme, defineLocale, defineLocaleResourceBundle, defineLocalesResources, defineSearchFilter, defineSearchFilterOperators, defineSearchOperator, diffMatchPatch, documentFieldActionsReducer, documentIdEquals, editState, emitOperation, escapeField, fieldNeedsEscape, findIndex, flattenConfig, getAnnotationAtPath, getDiffAtPath, getDocumentPairPermissions, getDocumentValuePermissions, getDraftId, getIdPair, getInitialValueStream, getItemKey, getItemKeySegment, getNamelessWorkspaceIdentifier, getPairListener, getPreviewPaths, getPreviewStateObservable, getPreviewValueWithFallback, getProviderTitle, getSchemaTypeTitle, getTemplatePermissions, getValueAtPath, getValueError, getWorkspaceIdentifier, globalScope, inc, initialDocumentFieldActions, insert, isAddedItemDiff, isArrayOfBlocksInputProps, isArrayOfObjectsInputProps, isArrayOfPrimitivesInputProps, isAuthStore, isBooleanInputProps, isCookielessCompatibleLoginMethod, isDev, isDraft, isDraftId, isEmptyObject, isFieldChange, isGroupChange, isNumberInputProps, isObjectInputProps, isObjectItemProps, isProd, isPublishedId, isRemovedItemDiff, isString, isStringInputProps, isUnchangedDiff, joinPath, listenQuery, matchWorkspace, newDraftFrom, noop, normalizeIndexSegment, normalizeIndexTupleSegment, normalizeKeySegment, normalizePathSegment, onRetry, operationEvents, operatorDefinitions, pathsAreEqual, prefixPath, prepareForPreview, removeDupes, removeMissingReferences, removeUndefinedLocaleResources, resolveDiffComponent, resolveInitialObjectValue, resolveInitialValue, resolveInitialValueForType, resolveSchemaTypes, set, setIfMissing, sliceString, snapshotPair, stringToPath, supportsTouch, truncateString, unset, useDocumentPreview as unstable_useValuePreview, usEnglishLocale, useActiveWorkspace, useAnnotationColor, useColorScheme, useColorSchemeOptions, useColorSchemeSetValue, useColorSchemeValue, useConnectionStatusStore, useDataset, useDateTimeFormat, useDidUpdate, useDiffAnnotationColor, useDocumentChange, useDocumentOperation, useDocumentPairPermissions, useDocumentPairPermissionsFromHookFactory, useDocumentPresence, useDocumentPreviewStore, useDocumentValuePermissions, useDocumentValuePermissionsFromHookFactory, useDocumentValues, useFeatureEnabled, useFieldActions, useFormBuilder, useFormCallbacks, useFormValue, useGetI18nText, useGlobalPresence, useGrantsStore, useHoveredField, useI18nText, useInitialValue, useInitialValueResolverContext, useKeyValueStore, useLoadable, useLocale, useMiddlewareComponents, usePresenceStore, usePreviewCard, useProjectId, useReferenceInputOptions, useResolveInitialValueForType, useResourceCache, useRovingFocus, useSchema, useTemplatePermissions, useTemplatePermissionsFromHookFactory, useTemplates, useUnique, useUnitFormatter, useUser, useUserColor, useVirtualizerScrollInstance, useWorkspaces, useZIndex, userHasRole, validateBasePaths, validateDocument, validateNames, validateWorkspaces, validation, visitDiff } from './_chunks/TransformPatches-s4n9R8_j.js';
import sortBy from 'lodash/sortBy.js';
import { useMemoObservable } from 'react-rx';
import { of, merge, BehaviorSubject, tap, map, distinctUntilChanged, catchError, combineLatest, firstValueFrom, timer, switchMap as switchMap$1, forkJoin, mergeMap, concat } from 'rxjs';
import { switchMap, map as map$1, mapTo, startWith, distinctUntilChanged as distinctUntilChanged$1, share, take, skip, debounce } from 'rxjs/operators';
import isEqual$2 from 'lodash/isEqual.js';
import throttle from 'lodash/throttle.js';
import { isKeyedObject, isKeySegment, isObjectSchemaType, isArraySchemaType, isArrayOfObjectsSchemaType } from '@sanity/types';
export * from '@sanity/types';
import { Badge, Flex, Box, Text, studioTheme, Hotkeys as Hotkeys$1, TextInput } from '@sanity/ui';
import { IntentLink } from 'sanity/router';
import { Button } from './_chunks/TooltipDelayGroupProvider-CvFQ5MgA.js';
import isString from 'lodash/isString.js';
import 'history';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';
import 'lodash/escapeRegExp.js';
import 'date-fns';
import 'react-i18next';
import '@sanity/portable-text-editor';
import '@sanity/icons';
import 'lodash/omit.js';
import '@sanity/diff-match-patch';
import flatten from 'lodash/flatten.js';
import 'lodash/orderBy.js';
import 'lodash/uniq.js';
import 'lodash/xor.js';
import 'sanity-diff-patch';
import 'lodash/startCase.js';
import 'lodash/debounce.js';
import 'nano-pubsub';
import 'shallow-equals';
import 'scroll-into-view-if-needed';
import '@sanity/schema/_internal';
import 'lodash/isFinite.js';
import 'lodash/compact.js';
import 'lodash/intersection.js';
import 'lodash/keyBy.js';
import 'lodash/partition.js';
import 'lodash/toLower.js';
import 'lodash/union.js';
import 'lodash/words.js';
import 'lodash/get.js';
import 'get-random-values-esm';
import { resolveTypeName as resolveTypeName$1 } from '@sanity/util/content';
import 'lodash/isPlainObject.js';
import '@tanstack/react-virtual';
import '@sanity/util/legacyDateFormat';
import 'speakingurl';
import '@sanity/telemetry/react';
import 'lodash/find.js';
import castArray from 'lodash/castArray.js';
import pick from 'lodash/pick.js';
import { arrayToJSONMatchPath } from '@sanity/mutator';
import '@sanity/schema';
import '@sanity/asset-utils';
import '@sanity/image-url';
import '@sanity/uuid';
import 'exif-component';
import 'react-is';
import 'lodash/difference.js';
import 'lodash/memoize.js';
import 'lodash/identity.js';
import 'lodash/values.js';
import 'lodash/assignWith.js';
import 'lodash/capitalize.js';
import { createRoot } from 'react-dom/client';
import 'lodash/groupBy.js';
import 'json-reduce';
import 'rxjs-exhaustmap-with-trailing';
import 'groq-js';
import 'rxjs-etc/operators';
import 'mendoza';
import '@sanity/diff';
import 'dataloader';
import 'raf';
import '@sanity/bifur-client';
import '@sanity/client';
import 'i18next';
import { hues, black, white, blue, gray, red, green, yellow } from '@sanity/color';
import { parseColor, rgbToHex, multiply, screen, createColorTheme, rgba } from '@sanity/ui/theme';
import { getLuminance, mix, parseToRgb, rgb } from 'polished';
function noop() {}
function NoopTracker(_ref) {
  let {
    children
  } = _ref;
  return /* @__PURE__ */jsx(Fragment, {
    children
  });
}
function createNoopTrackerScope() {
  return {
    useReportedValues: noop,
    Tracker: NoopTracker,
    useReporter: noop
  };
}
const ChangeFieldWrapper = props => {
  const ref = useRef(null);
  const {
    onSetFocus
  } = useContext(ConnectorContext);
  const [isHover, setHover] = useState(false);
  const onMouseEnter = useCallback(() => {
    setHover(true);
  }, []);
  const onMouseLeave = useCallback(() => {
    setHover(false);
  }, []);
  useReporter("change-".concat(PathUtils.toString(props.path)), () => ({
    element: ref.current,
    path: props.path,
    isChanged: true,
    hasFocus: false,
    hasHover: isHover,
    hasRevertHover: props.hasHover
  }),
  // note: deepCompare should be ok here since we're not comparing deep values
  deepCompare);
  const handleClick = useCallback(event => {
    setFocusWithStopPropagation(event, onSetFocus, props.path);
  }, [onSetFocus, props.path]);
  return /* @__PURE__ */jsx("div", {
    ref,
    onClick: handleClick,
    onMouseLeave,
    onMouseEnter,
    children: props.children
  });
};
function setFocusWithStopPropagation(event, onSetFocus, path) {
  event.stopPropagation();
  onSetFocus(path);
}
function isArray(value) {
  return Array.isArray(value);
}
function isTruthy(value) {
  return Boolean(value);
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
const FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif";
const FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace";
const uncaughtErrorHandler = () =>
// prettier-ignore
["window.onerror = function(m,u,l,c,e) {", "var p=window.location.port;", "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');", "var r=document.getElementById('sanity');", "while(r.firstChild){r.removeChild(r.firstChild);}", "var s=document.createElement('style');", "s.appendChild(document.createTextNode('", "html,body,#sanityBody,#sanity,#sanityError{height:100%;}", "body{-webkit-font-smoothing:antialiased;margin:0;}", "#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:".concat(FONT_SANS_SERIF, ";font-size:16px;line-height:21px;min-height:100%;}"), "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}", "@media(min-width:512px){", "#sanityError>div{", "padding:47px 84px;", "}", "}", "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}", "#sanityError button:hover{background-color:#1E63D0;}", "#sanityError button:active{background-color:#1B50A5;}", "'));", "document.head.appendChild(s);", "var f=document.createElement('div');", "f.id='sanityError';", "f.innerHTML='", "<div>", '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>', '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>', '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>', '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">', '<code style="font-family:'.concat(FONT_MONOSPACE, ';">'), "'+e.stack.replaceAll(h,'')+'", "</code>", "</pre>", "</div>", "';", "var b=f.querySelector('.sanity-error-handler__reload-btn');", "if(b){", "b.onclick=function() {", "window.location.reload();", "}", "};", "r.appendChild(f);", "};"].join("");
function useThrottledCallback(callback, wait, options) {
  const throttledCallback = useMemo(() => throttle(callback, wait, options), [callback, options, wait]);
  return throttledCallback;
}
function useOnScroll(callback) {
  const parentContext = useContext(ScrollContext);
  useEffect(() => {
    return parentContext == null ? void 0 : parentContext.subscribe(callback);
  }, [callback, parentContext]);
}
function ScrollMonitor(_ref2) {
  let {
    onScroll,
    children
  } = _ref2;
  useOnScroll(onScroll);
  return /* @__PURE__ */jsx(Fragment, {
    children
  });
}
function findMostSpecificTarget(targetType, id, values) {
  const pathString = id.slice(id.indexOf("-") + 1) || "[]";
  const path = PathUtils.fromString(pathString);
  const exactId = "".concat(targetType, "-").concat(PathUtils.toString(path));
  if (values.has(exactId)) {
    return values.get(exactId);
  }
  let mostSpecific;
  for (const [targetId, target] of values) {
    if (!("path" in target) || !targetId.startsWith(targetType)) {
      continue;
    }
    const numEqual = PathUtils.numEqualSegments(path, target.path);
    const lastPathSegment = target.path[target.path.length - 1];
    const pathOnlyDiffersByKey = numEqual === target.path.length - 1 && isKeyedObject(lastPathSegment);
    if (numEqual === 0) {
      continue;
    } else if (numEqual !== target.path.length && !pathOnlyDiffersByKey) {
      continue;
    }
    mostSpecific = target;
    if (numEqual === path.length) {
      break;
    }
  }
  return mostSpecific;
}
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el) {
  const scrollableContent = el.scrollHeight !== el.offsetHeight || el.scrollWidth !== el.offsetWidth;
  return scrollableContent && hasOverflowScroll(el);
}
const getOffsetsTo = (source, target) => {
  const bounds = {
    top: 0,
    left: 0,
    height: target.offsetHeight,
    width: target.offsetWidth
  };
  const rect = {
    top: 0,
    left: 0,
    height: source.offsetHeight,
    width: source.offsetWidth
  };
  let foundScrollContainer = false;
  let el = source;
  while (el && el !== target && target.contains(el)) {
    if (foundScrollContainer) {
      bounds.top += el.offsetTop;
      bounds.left += el.offsetLeft;
    }
    if (hasOverflowScroll(el)) {
      bounds.top = el.offsetTop;
      bounds.height = el.offsetHeight;
      bounds.left = el.offsetLeft;
      bounds.width = el.offsetWidth;
      foundScrollContainer = true;
    }
    rect.top += el.offsetTop - el.scrollTop;
    rect.left += el.offsetLeft - el.scrollLeft;
    el = el.offsetParent;
  }
  return {
    rect,
    bounds
  };
};
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
const SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  const element = field.element;
  let parentElementWithScroll = element;
  while (!isScrollable(parentElementWithScroll)) {
    parentElementWithScroll = parentElementWithScroll.parentElement;
    if (!parentElementWithScroll) {
      return;
    }
  }
  parentElementWithScroll.scroll({
    top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING,
    left: 0,
    behavior: "smooth"
  });
}
function useResizeObserver(element, onResize) {
  useEffect(() => resizeObserver.observe(element, onResize), [element, onResize]);
}
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [];
  const changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged) {
      continue;
    }
    const [id, reportedChangeBar] = value;
    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
  const connectors = changeBars.map(_ref3 => {
    let [id] = _ref3;
    const field = findMostSpecificTarget("field", id, byId);
    const change = findMostSpecificTarget("change", id, byId);
    if (!field || !change) return null;
    return {
      field: {
        id,
        ...field
      },
      change: {
        id,
        ...change
      }
    };
  }).filter(isNonNullable$1).map(_ref4 => {
    let {
      field,
      change
    } = _ref4;
    return {
      hasHover: field.hasHover || change.hasHover,
      hasFocus: field.hasFocus,
      hasRevertHover: change.hasRevertHover,
      field: {
        ...field,
        ...getOffsetsTo(field.element, rootElement)
      },
      change: {
        ...change,
        ...getOffsetsTo(change.element, rootElement)
      }
    };
  });
  return {
    connectors,
    isHoverConnector
  };
}
function ConnectorsOverlay(props) {
  const {
    rootElement,
    onSetFocus
  } = props;
  const [hovered, setHovered] = useState(null);
  const allReportedValues = useReportedValues();
  const byId = useMemo(() => new Map(allReportedValues), [allReportedValues]);
  const [{
    connectors
  }, setState] = useState(() => getState(allReportedValues, hovered, byId, rootElement));
  const visibleConnectors = useMemo(() => sortBy(connectors, c => 0 - c.field.path.length).slice(0, 1), [connectors]);
  const handleScrollOrResize = useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  useResizeObserver(rootElement, handleScrollOrResize);
  return /* @__PURE__ */jsx(ScrollMonitor, {
    onScroll: handleScrollOrResize,
    children: /* @__PURE__ */jsx(SvgWrapper, {
      style: {
        zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex
      },
      children: visibleConnectors.map(_ref5 => {
        let {
          field,
          change
        } = _ref5;
        if (!change) {
          return null;
        }
        return /* @__PURE__ */jsx(ConnectorGroup, {
          field,
          change,
          onSetFocus,
          setHovered
        }, field.id);
      })
    })
  });
}
function ConnectorGroup(props) {
  const {
    change,
    field,
    onSetFocus,
    setHovered
  } = props;
  const onConnectorClick = useCallback(() => {
    scrollIntoView(field);
    scrollIntoView(change);
    onSetFocus(field.path);
  }, [field, change, onSetFocus]);
  const handleMouseEnter = useCallback(() => setHovered(field.id), [field, setHovered]);
  const handleMouseLeave = useCallback(() => setHovered(null), [setHovered]);
  const from = useMemo(() => ({
    rect: {
      ...field.rect,
      left: field.rect.left + 3
    },
    bounds: field.bounds
  }), [field.bounds, field.rect]);
  const to = useMemo(() => ({
    rect: {
      ...change.rect,
      left: change.rect.left + 1
    },
    bounds: change.bounds
  }), [change.bounds, change.rect]);
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx("g", {
      onClick: onConnectorClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: /* @__PURE__ */jsx(Connector, {
        from,
        to
      })
    }), DEBUG_LAYER_BOUNDS]
  });
}
function EnabledChangeConnectorRoot(_ref6) {
  let {
    children,
    className,
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus,
    ...restProps
  } = _ref6;
  const [rootElement, setRootElement] = useState();
  const contextValue = useMemo(() => ({
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus
  }), [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]);
  return /* @__PURE__ */jsx(ConnectorContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */jsx(Tracker, {
      children: /* @__PURE__ */jsxs(ScrollContainer, {
        ...restProps,
        ref: setRootElement,
        className,
        children: [children, rootElement && /* @__PURE__ */jsx(ConnectorsOverlay, {
          rootElement,
          onSetFocus
        })]
      })
    })
  });
}
function DisabledChangeConnectorRoot(_ref7) {
  let {
    children,
    className
  } = _ref7;
  return /* @__PURE__ */jsx(ScrollContainer, {
    className,
    children
  });
}
const ChangeConnectorRoot = EnabledChangeConnectorRoot;
function BetaBadge(props) {
  const {
    fontSize = 1,
    children = "Beta",
    ...rest
  } = props;
  return /* @__PURE__ */jsx(Badge, {
    ...rest,
    fontSize,
    radius: 2,
    tone: "primary",
    children
  });
}
function Favicons(_ref8) {
  let {
    basePath
  } = _ref8;
  const base = "".concat(basePath.replace(/\/+$/, ""), "/static");
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx("link", {
      rel: "icon",
      href: "".concat(base, "/favicon.ico"),
      sizes: "any"
    }), /* @__PURE__ */jsx("link", {
      rel: "icon",
      href: "".concat(base, "/favicon.svg"),
      type: "image/svg+xml"
    }), /* @__PURE__ */jsx("link", {
      rel: "apple-touch-icon",
      href: "".concat(base, "/apple-touch-icon.png")
    }), /* @__PURE__ */jsx("link", {
      rel: "manifest",
      href: "".concat(base, "/manifest.webmanifest")
    })]
  });
}
const errorHandlerScript = "\n;(function () {\n  var _caughtErrors = []\n\n  var errorChannel = (function () {\n    var subscribers = []\n\n    function publish(msg) {\n      for (var i = 0; i < subscribers.length; i += 1) {\n        subscribers[i](msg)\n      }\n    }\n\n    function subscribe(subscriber) {\n      subscribers.push(subscriber)\n\n      return function () {\n        var idx = subscribers.indexOf(subscriber)\n\n        if (idx > -1) {\n          subscribers.splice(idx, 1)\n        }\n      }\n    }\n\n    return {publish, subscribe, subscribers}\n  })()\n\n  // NOTE: Store the error channel instance in the global scope so that the Studio application can\n  // access it and subscribe to errors.\n  window.__sanityErrorChannel = {\n    subscribe: errorChannel.subscribe,\n  }\n\n  function _nextTick(callback) {\n    setTimeout(callback, 0)\n  }\n\n  function _handleError(error, params) {\n    _nextTick(function () {\n      // - If there are error channel subscribers, then we notify them (no console error).\n      // - If there are no subscribers, then we log the error to the console and render the error overlay.\n      if (errorChannel.subscribers.length) {\n        errorChannel.publish({error, params})\n      } else {\n        console.error(error)\n\n        _renderErrorOverlay(error, params)\n      }\n    })\n  }\n\n  var ERROR_BOX_STYLE = [\n    'background: #fff',\n    'border-radius: 6px',\n    'box-sizing: border-box',\n    'color: #121923',\n    'flex: 1',\n    \"font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif\",\n    'font-size: 16px',\n    'line-height: 21px',\n    'margin: 0 auto',\n    'max-width: 960px',\n    'overflow: auto',\n    'padding: 20px',\n    'width: 100%',\n  ].join(';')\n\n  var ERROR_CODE_STYLE = [\n    'color: #972E2A',\n    \"font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace\",\n    'font-size: 13px',\n    'line-height: 17px',\n    'margin: 0',\n  ].join(';')\n\n  function _renderErrorOverlay(error, params) {\n    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')\n    var colno = params.event.colno\n    var lineno = params.event.lineno\n    var filename = params.event.filename\n\n    errorElement.id = '__sanityError'\n    errorElement.innerHTML = [\n      '<div style=\"' + ERROR_BOX_STYLE + '\">',\n      '<div style=\"font-weight: 700;\">Uncaught error: ' + error.message + '</div>',\n      '<div style=\"color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;\">' +\n        filename +\n        ':' +\n        lineno +\n        ':' +\n        colno +\n        '</div>',\n      '<pre style=\"' + ERROR_CODE_STYLE + '\">' + error.stack + '</pre>',\n      '</div>',\n    ].join('')\n\n    errorElement.style.position = 'fixed'\n    errorElement.style.zIndex = 1000000\n    errorElement.style.top = 0\n    errorElement.style.left = 0\n    errorElement.style.right = 0\n    errorElement.style.bottom = 0\n    errorElement.style.padding = '20px'\n    errorElement.style.background = 'rgba(16,17,18,0.66)'\n    errorElement.style.display = 'flex'\n    errorElement.style.alignItems = 'center'\n    errorElement.style.justifyContent = 'center'\n\n    document.body.appendChild(errorElement)\n  }\n\n  // NOTE:\n  // Yes \u2013 we're attaching 2 error listeners below \u{1F440}\n  // This is because React makes the same error throw twice (in development mode).\n  // See: https://github.com/facebook/react/issues/10384\n\n  // Error listener #1\n  window.onerror = function (event, source, lineno, colno, error) {\n    _nextTick(function () {\n      if (_caughtErrors.indexOf(error) !== -1) return\n\n      _caughtErrors.push(error)\n\n      _handleError(error, {\n        event,\n        lineno,\n        colno,\n        source,\n      })\n\n      _nextTick(function () {\n        var idx = _caughtErrors.indexOf(error)\n\n        if (idx > -1) _caughtErrors.splice(idx, 1)\n      })\n    })\n\n    // IMPORTANT: this callback must return `true` to prevent the error from being rendered in\n    // the browser\u2019s console.\n    return true\n  }\n\n  // Error listener #2\n  window.addEventListener('error', function (event) {\n    if (_caughtErrors.indexOf(event.error) !== -1) return true\n\n    _caughtErrors.push(event.error)\n\n    _handleError(event.error, {\n      event,\n      lineno: event.lineno,\n      colno: event.colno,\n    })\n\n    _nextTick(function () {\n      _nextTick(function () {\n        var idx = _caughtErrors.indexOf(event.error)\n\n        if (idx > -1) _caughtErrors.splice(idx, 1)\n      })\n    })\n\n    return true\n  })\n})()\n";
function GlobalErrorHandler() {
  return /* @__PURE__ */jsx("script", {
    dangerouslySetInnerHTML: {
      __html: errorHandlerScript
    }
  });
}
const NoJsStyles = "\n.sanity-app-no-js__root {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background: #fff;\n}\n\n.sanity-app-no-js__content {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  font-family: helvetica, arial, sans-serif;\n}\n";
function NoJavascript() {
  return /* @__PURE__ */jsx("noscript", {
    children: /* @__PURE__ */jsx("div", {
      className: "sanity-app-no-js__root",
      children: /* @__PURE__ */jsxs("div", {
        className: "sanity-app-no-js__content",
        children: [/* @__PURE__ */jsx("style", {
          type: "text/css",
          children: NoJsStyles
        }), /* @__PURE__ */jsx("h1", {
          children: "JavaScript disabled"
        }), /* @__PURE__ */jsxs("p", {
          children: ["Please ", /* @__PURE__ */jsx("a", {
            href: "https://www.enable-javascript.com/",
            children: "enable JavaScript"
          }), " in your browser and reload the page to proceed."]
        })]
      })
    })
  });
}
const globalStyles = '\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 400;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 400;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 500;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 500;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 600;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 600;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 700;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 700;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 800;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 800;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 900;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 900;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");\n  }\n  html {\n    background-color: #f1f3f6;\n  }\n  html,\n  body,\n  #sanity {\n    height: 100%;\n  }\n  body {\n    margin: 0;\n    -webkit-font-smoothing: antialiased;\n  }\n';
const EMPTY_ARRAY$1 = [];
function DefaultDocument(props) {
  const {
    entryPath,
    css = EMPTY_ARRAY$1,
    basePath = "/"
  } = props;
  return /* @__PURE__ */jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */jsxs("head", {
      children: [/* @__PURE__ */jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */jsx("meta", {
        name: "robots",
        content: "noindex"
      }), /* @__PURE__ */jsx("meta", {
        name: "referrer",
        content: "same-origin"
      }), /* @__PURE__ */jsx(Favicons, {
        basePath
      }), /* @__PURE__ */jsx("title", {
        children: "Sanity Studio"
      }), /* @__PURE__ */jsx(GlobalErrorHandler, {}), css.map(href => /* @__PURE__ */jsx("link", {
        rel: "stylesheet",
        href
      }, href)), /* @__PURE__ */jsx("style", {
        dangerouslySetInnerHTML: {
          __html: globalStyles
        }
      })]
    }), /* @__PURE__ */jsxs("body", {
      children: [/* @__PURE__ */jsx("div", {
        id: "sanity"
      }), /* @__PURE__ */jsx("script", {
        type: "module",
        src: entryPath
      }), /* @__PURE__ */jsx(NoJavascript, {})]
    })]
  });
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return defineConfig(config);
}
function validatePlugin(pluginResult) {
  const messages = ["projectId" in pluginResult && "`projectId` not allowed in plugin configuration", "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"].filter(isString);
  if (messages.length) throw new Error("Invalid plugin configuration:\n".concat(messages.map(message => "	".concat(message)).join("\n")));
}
function definePlugin(arg) {
  if (typeof arg === "function") {
    const pluginFactory = arg;
    return options => {
      const result = pluginFactory(options);
      validatePlugin(result);
      return result;
    };
  }
  validatePlugin(arg);
  return () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
function defineDocumentInspector(inspector) {
  return inspector;
}
function createMockAuthStore(_ref9) {
  let {
    client,
    currentUser = null
  } = _ref9;
  return {
    state: of({
      authenticated: true,
      client,
      currentUser
    })
  };
}
function isEqual(item, otherItem) {
  if (item === otherItem) {
    return true;
  }
  if (typeof item !== typeof otherItem) {
    return false;
  }
  if (typeof item !== "object" && !Array.isArray(item)) {
    return item === otherItem;
  }
  if (isKeyedObject(item) && isKeyedObject(otherItem) && item._key === otherItem._key) {
    return true;
  }
  if (Array.isArray(item) && Array.isArray(otherItem)) {
    if (item.length !== otherItem.length) {
      return false;
    }
    return item.every((child, i) => isEqual(child, otherItem[i]));
  }
  if (item === null || otherItem === null) {
    return item === otherItem;
  }
  const obj = item;
  const otherObj = otherItem;
  const keys = Object.keys(obj);
  const otherKeys = Object.keys(otherObj);
  if (keys.length !== otherKeys.length) {
    return false;
  }
  return keys.every(keyName => isEqual(obj[keyName], otherObj[keyName]));
}
const ArrayOfOptionsFieldDiff = _ref10 => {
  let {
    diff,
    schemaType
  } = _ref10;
  var _a;
  const options = (_a = schemaType.options) == null ? void 0 : _a.list;
  const colorManager = useUserColorManager();
  const {
    t
  } = useTranslation();
  if (!Array.isArray(options)) {
    return null;
  }
  return /* @__PURE__ */jsx("div", {
    children: diff.items.map(item => normalizeItems(item, diff, schemaType)).filter(item => item !== null).sort(sortItems).map((item, index) => {
      const {
        annotation,
        isPresent,
        value,
        memberType,
        title
      } = item;
      const color = getAnnotationColor(colorManager, annotation);
      const action = isPresent ? t("changes.added-label") : t("changes.removed-label");
      return /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(DiffTooltip, {
          annotations: annotation ? [annotation] : [],
          description: action,
          children: /* @__PURE__ */jsxs(Flex, {
            align: "center",
            children: [/* @__PURE__ */jsx(Checkbox, {
              checked: !isPresent,
              color
            }), /* @__PURE__ */jsx(Box, {
              margin: 2,
              children: /* @__PURE__ */jsx(FromToArrow, {})
            }), /* @__PURE__ */jsx(Checkbox, {
              checked: isPresent,
              color
            })]
          })
        }), /* @__PURE__ */jsx(Flex, {
          align: "center",
          children: /* @__PURE__ */jsx(ItemPreview, {
            value: title || value,
            memberType
          })
        })]
      }, getItemKey(diff, index));
    })
  });
};
function normalizeItems(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged") {
    return null;
  }
  const {
    fromValue,
    toValue
  } = parentDiff;
  const value = getValue(item.diff);
  const wasPresent = isInArray(value, fromValue);
  const isPresent = isInArray(value, toValue);
  if (wasPresent === isPresent) {
    return null;
  }
  return {
    title: getItemTitle(value, schemaType),
    memberType: resolveMemberType(getValue(item.diff), schemaType),
    itemIndex: getOptionIndex(value, schemaType),
    annotation: item.annotation,
    isPresent,
    value
  };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview(_ref11) {
  let {
    value,
    memberType
  } = _ref11;
  return /* @__PURE__ */jsx(Box, {
    marginX: 2,
    marginY: 1,
    children: typeof value === "string" || typeof value === "number" ? value : /* @__PURE__ */jsx(Preview, {
      schemaType: memberType,
      value,
      layout: "default"
    })
  });
}
function isInArray(value, parent) {
  const array = parent || [];
  return typeof value === "object" && value !== null ? array.some(item => isEqual(item, value)) : array.includes(value);
}
function getItemKey(diff, index) {
  const value = diff.toValue || diff.fromValue;
  return isKeyedObject(value) ? value._key : index;
}
function getValue(diff) {
  return typeof diff.toValue === "undefined" ? diff.fromValue : diff.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find(memberType => memberType.name === itemTypeName);
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object") {
    return jsType;
  }
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isNamedOption(item) {
  return typeof item === "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [];
  return list.findIndex(opt => isEqual(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [];
  const index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
const SlugFieldDiff = _ref12 => {
  let {
    diff,
    schemaType
  } = _ref12;
  return /* @__PURE__ */jsx(DiffFromTo, {
    layout: "inline",
    diff,
    schemaType,
    previewComponent: SlugPreview
  });
};
const UrlFieldDiff = _ref13 => {
  let {
    diff,
    schemaType
  } = _ref13;
  return /* @__PURE__ */jsx(DiffFromTo, {
    diff,
    schemaType,
    previewComponent: StringPreview
  });
};
const diffResolver = _ref14 => {
  let {
    schemaType
  } = _ref14;
  var _a;
  if (["datetime", "date"].includes(schemaType.name)) {
    return DatetimeFieldDiff;
  }
  if (schemaType.name === "url") {
    return UrlFieldDiff;
  }
  if (schemaType.name === "slug") {
    return SlugFieldDiff;
  }
  if (schemaType.jsonType === "array" && Array.isArray((_a = schemaType.options) == null ? void 0 : _a.list)) {
    return ArrayOfOptionsFieldDiff;
  }
  return void 0;
};
function HoveredFieldProvider(props) {
  const {
    children
  } = props;
  const [hoveredStack, setHoveredStack] = useState([]);
  const handleMouseEnter = useCallback(path => {
    const pathString = pathToString(path);
    setHoveredStack(prev => {
      if (prev.includes(pathString)) {
        return prev;
      }
      return [pathString, ...prev];
    });
  }, []);
  const handleMouseLeave = useCallback(path => {
    const pathString = pathToString(path);
    setHoveredStack(prev => {
      if (prev.includes(pathString)) {
        return prev.filter(item => item !== pathString);
      }
      return prev;
    });
  }, []);
  const context = useMemo(() => ({
    hoveredStack,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), [handleMouseEnter, handleMouseLeave, hoveredStack]);
  return /* @__PURE__ */jsx(HoveredFieldContext.Provider, {
    value: context,
    children
  });
}
const EMPTY_ARRAY = [];
function trimChildPath(path, childPath) {
  return PathUtils.startsWith(path, childPath) ? PathUtils.trimLeft(path, childPath) : EMPTY_ARRAY;
}
function PresenceScope(props) {
  const {
    readOnly,
    path,
    children
  } = props;
  const contextPresence = useContext(FormFieldPresenceContext);
  const childPresence = useMemo(() => {
    return readOnly ? EMPTY_ARRAY : (contextPresence || EMPTY_ARRAY).filter(presence => {
      return PathUtils.startsWith(path, presence.path);
    }).map(presence => ({
      ...presence,
      path: trimChildPath(path, presence.path)
    }));
  }, [contextPresence, path, readOnly]);
  return /* @__PURE__ */jsx(FormFieldPresenceContext.Provider, {
    value: childPresence,
    children
  });
}
function createPatchChannel() {
  const _subscribers = [];
  return {
    publish(msg) {
      for (const subscriber of _subscribers) {
        subscriber(msg);
      }
    },
    subscribe(subscriber) {
      _subscribers.push(subscriber);
      return () => {
        const idx = _subscribers.indexOf(subscriber);
        if (idx > -1) {
          _subscribers.splice(idx, 1);
        }
      };
    }
  };
}
function ArrayOfObjectsInputMember(props) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props;
  if (member.kind === "item") {
    return /* @__PURE__ */jsx(ArrayOfObjectsItem, {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    }, member.key);
  }
  if (member.kind === "error") {
    return /* @__PURE__ */jsx(MemberItemError, {
      member
    }, member.key);
  }
  console.warn(new Error("Unhandled member kind ".concat(member.kind)));
  return null;
}
function ArrayOfObjectsInputMembers(props) {
  const {
    members,
    ...rest
  } = props;
  return /* @__PURE__ */jsx(Fragment, {
    children: members.map(member => /* @__PURE__ */jsx(ArrayOfObjectsInputMember, {
      member,
      ...rest
    }, member.key))
  });
}
function useReviewChanges() {
  const reviewChanges = useContext(ReviewChangesContext);
  if (!reviewChanges) {
    throw new Error("Review changes: missing context value");
  }
  return reviewChanges;
}
const defaultRenderAnnotation = props => {
  return createElement(defaultResolveAnnotationComponent(props.schemaType), props);
};
const defaultRenderBlock = props => {
  return createElement(defaultResolveBlockComponent(props.schemaType), props);
};
const defaultRenderInlineBlock = props => {
  return createElement(defaultResolveInlineBlockComponent(props.schemaType), props);
};
const defaultRenderField = props => {
  return createElement(defaultResolveFieldComponent(props.schemaType), props);
};
const defaultRenderInput = props => {
  return createElement(defaultResolveInputComponent(props.schemaType), props);
};
const defaultRenderItem = props => {
  return createElement(defaultResolveItemComponent(props.schemaType), props);
};
const defaultRenderPreview = props => {
  return createElement(Preview, props);
};
function DefaultCustomMarkers() {
  return /* @__PURE__ */jsxs(Text, {
    size: 1,
    children: ["This is a example custom marker, please implement ", /* @__PURE__ */jsx("code", {
      children: "renderCustomMarkers"
    }), " function."]
  });
}
const missingPatchChannel = {
  publish: () => void 0,
  subscribe: () => {
    console.warn("No patch channel provided to form-builder. If you need input based patch updates, please provide one");
    return () => void 0;
  }
};
function FormBuilderProvider(props) {
  const {
    __internal_fieldActions: fieldActions = EMPTY_ARRAY$2,
    __internal_patchChannel: patchChannel = missingPatchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    file,
    filterField,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onFieldGroupSelect,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    unstable,
    validation
  } = props;
  const __internal = useMemo(() => ({
    patchChannel,
    // eslint-disable-line camelcase
    components: {
      ArrayFunctions: ArrayOfObjectsFunctions,
      CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers,
      Markers: (unstable == null ? void 0 : unstable.Markers) || DefaultMarkers
    },
    field: {
      actions: fieldActions
    },
    file: {
      assetSources: file.assetSources,
      directUploads: (file == null ? void 0 : file.directUploads) !== false
    },
    filterField: filterField || (() => true),
    image: {
      assetSources: image.assetSources,
      directUploads: (image == null ? void 0 : image.directUploads) !== false
    },
    onChange
  }), [fieldActions, file.assetSources, file == null ? void 0 : file.directUploads, filterField, image.assetSources, image == null ? void 0 : image.directUploads, onChange, patchChannel, unstable == null ? void 0 : unstable.CustomMarkers, unstable == null ? void 0 : unstable.Markers]);
  const formBuilder = useMemo(() => ({
    __internal,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType
  }), [__internal, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType]);
  return /* @__PURE__ */jsx(FormBuilderContext.Provider, {
    value: formBuilder,
    children: /* @__PURE__ */jsx(FormCallbacksProvider, {
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      children: /* @__PURE__ */jsx(DocumentIdProvider, {
        id,
        children: /* @__PURE__ */jsx(PresenceProvider, {
          presence,
          children: /* @__PURE__ */jsx(ValidationProvider, {
            validation,
            children: /* @__PURE__ */jsx(HoveredFieldProvider, {
              children
            })
          })
        })
      })
    })
  });
}
function FormProvider(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    schemaType,
    validation
  } = props;
  const {
    file,
    image
  } = useSource().form;
  const Input = useInputComponent();
  const Field = useFieldComponent();
  const Preview = usePreviewComponent();
  const Item = useItemComponent();
  const Block = useBlockComponent();
  const InlineBlock = useInlineBlockComponent();
  const Annotation = useAnnotationComponent();
  const renderInput = useCallback(inputProps => /* @__PURE__ */jsx(Input, {
    ...inputProps
  }), [Input]);
  const renderField = useCallback(fieldProps => /* @__PURE__ */jsx(Field, {
    ...fieldProps
  }), [Field]);
  const renderItem = useCallback(itemProps => /* @__PURE__ */jsx(Item, {
    ...itemProps
  }), [Item]);
  const renderPreview = useCallback(previewProps => /* @__PURE__ */jsx(PreviewLoader, {
    component: Preview,
    ...previewProps
  }), [Preview]);
  const renderBlock = useCallback(blockProps => /* @__PURE__ */jsx(Block, {
    ...blockProps
  }), [Block]);
  const renderInlineBlock = useCallback(blockProps => /* @__PURE__ */jsx(InlineBlock, {
    ...blockProps
  }), [InlineBlock]);
  const renderAnnotation = useCallback(annotationProps => /* @__PURE__ */jsx(Annotation, {
    ...annotationProps
  }), [Annotation]);
  return /* @__PURE__ */jsx(FormBuilderProvider, {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    file,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation,
    children
  });
}
function FormBuilder(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    members,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    schemaType,
    validation,
    value
  } = props;
  const handleCollapseField = useCallback(fieldName => onSetPathCollapsed([fieldName], true), [onSetPathCollapsed]);
  const handleExpandField = useCallback(fieldName => onSetPathCollapsed([fieldName], false), [onSetPathCollapsed]);
  const handleBlur = useCallback(() => onPathBlur(EMPTY_ARRAY$2), [onPathBlur]);
  const handleFocus = useCallback(() => onPathFocus(EMPTY_ARRAY$2), [onPathFocus]);
  const handleChange = useCallback(patch => onChange(PatchEvent.from(patch)), [onChange]);
  const focusRef = useRef(null);
  const handleSelectFieldGroup = useCallback(groupName => onFieldGroupSelect(EMPTY_ARRAY$2, groupName), [onFieldGroupSelect]);
  const handleOpenField = useCallback(fieldName => onPathOpen([fieldName]), [onPathOpen]);
  const handleCloseField = useCallback(() => onPathOpen([]), [onPathOpen]);
  const handleCollapseFieldSet = useCallback(fieldSetName => onSetFieldSetCollapsed([fieldSetName], true), [onSetFieldSetCollapsed]);
  const handleExpandFieldSet = useCallback(fieldSetName => onSetFieldSetCollapsed([fieldSetName], false), [onSetFieldSetCollapsed]);
  const Input = useInputComponent();
  const Field = useFieldComponent();
  const Preview = usePreviewComponent();
  const Item = useItemComponent();
  const Block = useBlockComponent();
  const InlineBlock = useInlineBlockComponent();
  const Annotation = useAnnotationComponent();
  const renderInput = useCallback(inputProps => /* @__PURE__ */jsx(Input, {
    ...inputProps
  }), [Input]);
  const renderField = useCallback(fieldProps => /* @__PURE__ */jsx(Field, {
    ...fieldProps
  }), [Field]);
  const renderItem = useCallback(itemProps => /* @__PURE__ */jsx(Item, {
    ...itemProps
  }), [Item]);
  const renderPreview = useCallback(previewProps => /* @__PURE__ */jsx(PreviewLoader, {
    component: Preview,
    ...previewProps
  }), [Preview]);
  const renderBlock = useCallback(blockProps => /* @__PURE__ */jsx(Block, {
    ...blockProps
  }), [Block]);
  const renderInlineBlock = useCallback(blockProps => /* @__PURE__ */jsx(InlineBlock, {
    ...blockProps
  }), [InlineBlock]);
  const renderAnnotation = useCallback(annotationProps => /* @__PURE__ */jsx(Annotation, {
    ...annotationProps
  }), [Annotation]);
  const rootInputProps = {
    focusPath,
    elementProps: {
      ref: focusRef,
      id,
      onBlur: handleBlur,
      onFocus: handleFocus,
      "aria-describedby": void 0
      // Root input should not have any aria-describedby
    },
    changed: members.some(m => m.kind === "field" && m.field.changed),
    focused,
    groups,
    id,
    level: 0,
    members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onPathFocus,
    onFieldOpen: handleOpenField,
    onFieldGroupSelect: handleSelectFieldGroup,
    path: EMPTY_ARRAY$2,
    presence: EMPTY_ARRAY$2,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation: EMPTY_ARRAY$2,
    value
  };
  return /* @__PURE__ */jsx(FormProvider, {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    validation,
    readOnly,
    schemaType,
    children: /* @__PURE__ */jsx(GetFormValueProvider, {
      value,
      children: /* @__PURE__ */jsx(FormValueProvider, {
        value,
        children: /* @__PURE__ */jsx(DocumentFieldActionsProvider, {
          actions: fieldActions,
          children: renderInput(rootInputProps)
        })
      })
    })
  });
}
const remoteSnapshots = memoize((client, idPair, typeName) => {
  return memoizedPair(client, idPair, typeName).pipe(switchMap(_ref15 => {
    let {
      published,
      draft
    } = _ref15;
    return merge(published.remoteSnapshot$, draft.remoteSnapshot$);
  }));
}, memoizeKeyGen);
function maybeSerialize(template) {
  return isBuilder(template) ? template.serialize() : template;
}
function isNonNullable(t) {
  return !!t;
}
function prepareTemplates(schema, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return validateTemplates(schema, serialized);
}
function defaultTemplateForType(schemaType) {
  return {
    id: schemaType.name,
    schemaType: schemaType.name,
    title: schemaType.title || schemaType.name,
    icon: schemaType.icon,
    value: schemaType.initialValue || {
      _type: schemaType.name
    }
  };
}
function defaultTemplatesForSchema(schema) {
  const schemaTypes = schema.getTypeNames().filter(typeName => !/^sanity\./.test(typeName)).map(typeName => schema.get(typeName)).filter(isNonNullable).filter(schemaType => {
    var _a;
    return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
  });
  return prepareTemplates(schema, schemaTypes.map(schemaType => defaultTemplateForType(schemaType)));
}
const LOADING_STATE = {
  isLoaded: false,
  documentType: void 0
};
function useDocumentType(documentId) {
  let specifiedType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const isResolved = Boolean(specifiedType && specifiedType !== "*");
  const SYNC_RESOLVED_STATE = useMemo(() => ({
    documentType: specifiedType,
    isLoaded: true
  }), [specifiedType]);
  const [resolvedState, setDocumentType] = useState(isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE);
  useEffect(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]);
  useEffect(() => {
    if (isResolved) {
      return void 0;
    }
    const sub = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe(documentType => setDocumentType({
      documentType,
      isLoaded: true
    }));
    return () => sub.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]);
  return isResolved ?
  // `isResolved` is only true when we're _synchronously_ resolved
  SYNC_RESOLVED_STATE :
  // Using the document type resolved from the API
  resolvedState;
}
function useTimelineSelector(timelineStore, selector) {
  return useSyncExternalStoreWithSelector(timelineStore.subscribe, timelineStore.getSnapshot, null, selector);
}
const INITIAL_TIMELINE_STATE = {
  chunks: [],
  diff: null,
  hasMoreChunks: null,
  isLoading: false,
  isPristine: null,
  lastNonDeletedRevId: null,
  onOlderRevision: false,
  realRevChunk: null,
  revTime: null,
  selectionState: "inactive",
  sinceAttributes: null,
  sinceTime: null,
  timelineDisplayed: null,
  timelineReady: false
};
function useTimelineStore(_ref16) {
  let {
    documentId,
    documentType,
    onError,
    rev,
    since
  } = _ref16;
  const historyStore = useHistoryStore();
  const snapshotsSubscriptionRef = useRef(null);
  const timelineStateRef = useRef(INITIAL_TIMELINE_STATE);
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const controller = useMemo(() => historyStore.getTimelineController({
    client,
    documentId,
    documentType
  }), [client, documentId, documentType, historyStore]);
  const timelineController$ = useMemo(() => new BehaviorSubject(controller), [controller]);
  useEffect(() => {
    controller.setRange(since || null, rev || null);
    timelineController$.next(controller);
    controller.handler = (err, innerController) => {
      if (err) {
        timelineController$.error(err);
      } else {
        setTimeout(() => {
          innerController.setRange(since || null, rev || null);
          timelineController$.next(innerController);
        }, 0);
      }
    };
    controller.resume();
    return () => controller.suspend();
  }, [rev, since, controller, timelineController$]);
  useEffect(() => {
    if (!snapshotsSubscriptionRef.current) {
      snapshotsSubscriptionRef.current = remoteSnapshots(client, {
        draftId: "drafts.".concat(documentId),
        publishedId: documentId
      }, documentType).subscribe(ev => {
        controller.handleRemoteMutation(ev);
      });
    }
    return () => {
      if (snapshotsSubscriptionRef.current) {
        snapshotsSubscriptionRef.current.unsubscribe();
        snapshotsSubscriptionRef.current = null;
      }
    };
  }, [client, controller, documentId, documentType]);
  const timelineStore = useMemo(() => {
    return {
      findRangeForRev: chunk => controller.findRangeForNewRev(chunk),
      findRangeForSince: chunk => controller.findRangeForNewSince(chunk),
      loadMore: () => {
        controller.setLoadMore(true);
        timelineStateRef.current.isLoading = true;
      },
      getSnapshot: () => timelineStateRef.current,
      subscribe: callback => {
        const subscription = timelineController$.pipe(
        // Manually stop loading transactions in TimelineController, otherwise transaction history
        // will continue to be fetched – even if unwanted.
        tap(innerController => innerController.setLoadMore(false)), map(innerController => {
          var _a;
          const chunks = innerController.timeline.mapChunks(c => c);
          const lastNonDeletedChunk = chunks.filter(chunk => !["delete", "initial"].includes(chunk.type));
          const hasMoreChunks = !innerController.timeline.reachedEarliestEntry;
          const timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return {
            chunks,
            diff: innerController.sinceTime ? innerController.currentObjectDiff() : null,
            isLoading: false,
            isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === false : null,
            hasMoreChunks: !innerController.timeline.reachedEarliestEntry,
            lastNonDeletedRevId: (_a = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a.id,
            onOlderRevision: innerController.onOlderRevision(),
            realRevChunk: innerController.realRevChunk,
            revTime: innerController.revTime,
            selectionState: innerController.selectionState,
            sinceAttributes: innerController.sinceAttributes(),
            sinceTime: innerController.sinceTime,
            timelineDisplayed: innerController.displayed(),
            timelineReady
          };
        }),
        // Only emit (and in turn, re-render) when values have changed
        distinctUntilChanged(deepCompare),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        catchError(err => {
          onError == null ? void 0 : onError(err);
          return of(INITIAL_TIMELINE_STATE);
        }), tap(timelineState => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        tap(callback)).subscribe();
        return () => subscription.unsubscribe();
      }
    };
  }, [controller, onError, timelineController$]);
  return timelineStore;
}
function useProject() {
  const projectStore = useProjectStore();
  const [value, setValue] = useState(null);
  useEffect(() => {
    const project$ = projectStore.get();
    const sub = project$.subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]);
  return {
    value
  };
}
function useProjectDatasets() {
  const projectStore = useProjectStore();
  const [value, setValue] = useState(null);
  useEffect(() => {
    const project$ = projectStore.getDatasets();
    const sub = project$.subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]);
  return {
    value
  };
}
function resolveConfig(config) {
  const {
    workspaces
  } = prepareConfig(config);
  return combineLatest(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  workspaces.flatMap(workspaceSummary => combineLatest(workspaceSummary.__internal.sources.map(_ref17 => {
    let {
      source
    } = _ref17;
    return source;
  })).pipe(map$1(sources => ({
    ...workspaceSummary,
    ...sources[0],
    unstable_sources: sources,
    type: "workspace"
  })))));
}
async function createWorkspaceFromConfig(options) {
  const client = "getClient" in options ? options.getClient({
    apiVersion: "2023-11-13"
  }) : void 0;
  const [workspace] = await firstValueFrom(resolveConfig({
    ...options,
    ...(client && "currentUser" in options && {
      auth: createMockAuthStore({
        ...options,
        client
      })
    })
  }));
  return workspace;
}
async function createSourceFromConfig(options) {
  const workspace = await createWorkspaceFromConfig(options);
  return workspace.unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  } = source;
  return useMemo(() => {
    return {
      projectId,
      dataset,
      schema,
      currentUser,
      getClient,
      i18n
    };
  }, [projectId, dataset, schema, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  } = source;
  return {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  };
}
const API_VERSION = "v2023-11-13";
function AddonDatasetProvider(props) {
  const {
    children
  } = props;
  const {
    dataset,
    projectId
  } = useWorkspace();
  const originalClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [addonDatasetClient, setAddonDatasetClient] = useState(null);
  const [isCreatingDataset, setIsCreatingDataset] = useState(false);
  const getAddonDatasetName = useCallback(async () => {
    var _a;
    const res = await originalClient.withConfig({
      apiVersion: API_VERSION
    }).request({
      uri: "/projects/".concat(projectId, "/datasets?datasetProfile=comments&addonFor=").concat(dataset),
      tag: "sanity.studio"
    });
    return (_a = res == null ? void 0 : res[0]) == null ? void 0 : _a.name;
  }, [dataset, originalClient, projectId]);
  const handleCreateClient = useCallback(addonDatasetName => {
    const client = originalClient.withConfig({
      apiVersion: API_VERSION,
      dataset: addonDatasetName,
      projectId,
      requestTagPrefix: "sanity.studio",
      useCdn: false,
      withCredentials: true
    });
    return client;
  }, [originalClient, projectId]);
  const handleCreateAddonDataset = useCallback(async () => {
    setIsCreatingDataset(true);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client = handleCreateClient(addonDatasetName);
        setAddonDatasetClient(client);
        setIsCreatingDataset(false);
        return client;
      }
    } catch (_) {}
    try {
      const res = await originalClient.withConfig({
        apiVersion: API_VERSION
      }).request({
        uri: "/comments/".concat(dataset, "/setup"),
        method: "POST"
      });
      const datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName) {
        setIsCreatingDataset(false);
        return null;
      }
      const client = handleCreateClient(datasetName);
      setAddonDatasetClient(client);
      return client;
    } catch (err) {
      throw err;
    } finally {
      setIsCreatingDataset(false);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  useEffect(() => {
    getAddonDatasetName().then(addonDatasetName => {
      if (!addonDatasetName) return;
      const client = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = useMemo(() => ({
    client: addonDatasetClient,
    createAddonDataset: handleCreateAddonDataset,
    isCreatingDataset
  }), [addonDatasetClient, handleCreateAddonDataset, isCreatingDataset]);
  return /* @__PURE__ */jsx(AddonDatasetContext.Provider, {
    value: ctxValue,
    children
  });
}
function useAddonDataset() {
  const ctx = useContext(AddonDatasetContext);
  if (!ctx) {
    throw new Error("useAddonDataset: missing context value");
  }
  return ctx;
}
function StudioLogo(props) {
  const {
    title
  } = props;
  return /* @__PURE__ */jsx(Box, {
    padding: 3,
    "data-testid": "studio-logo",
    children: /* @__PURE__ */jsx(Text, {
      weight: "medium",
      children: title
    })
  });
}
function _buildTints(bg, mid, fg) {
  return {
    50: mix(0.1, mid, bg),
    100: mix(0.2, mid, bg),
    200: mix(0.4, mid, bg),
    300: mix(0.6, mid, bg),
    400: mix(0.8, mid, bg),
    500: mid,
    600: mix(0.8, mid, fg),
    700: mix(0.6, mid, fg),
    800: mix(0.4, mid, fg),
    900: mix(0.2, mid, fg),
    950: mix(0.1, mid, fg)
  };
}
function _toHex(color) {
  const {
    red,
    green,
    blue
  } = parseToRgb(color);
  return rgb(red, green, blue);
}
function _isDark(bg, fg) {
  return getLuminance(bg) < getLuminance(fg);
}
function _multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(multiply(b, s));
  return hex;
}
function _screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(screen(b, s));
  return hex;
}
const NEUTRAL_TONES = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return createColorTheme({
    base: _ref18 => {
      let {
        dark: navbar,
        name
      } = _ref18;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = navbar ? _screen : _multiply;
      const tints = stateTones[name] || stateTones.default;
      if (name === "default") {
        const skeletonFrom2 = stateTones.default[100];
        return {
          fg: stateTones.fg,
          bg: stateTones.bg,
          border: stateTones.default[200],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: rgba(stateTones.default[500], 0.4),
            umbra: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.2),
            penumbra: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.14),
            ambient: rgba(dark ? legacyPalette.black : stateTones.default[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (name === "transparent") {
        const bg2 = tints[50];
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          fg: tints[900],
          bg: bg2,
          border: tints[300],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: rgba(tints[500], dark ? 0.2 : 0.4),
            umbra: rgba(dark ? legacyPalette.black : tints[500], 0.2),
            penumbra: rgba(dark ? legacyPalette.black : tints[500], 0.14),
            ambient: rgba(dark ? legacyPalette.black : tints[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = tints[50];
      const skeletonFrom = blend(bg, tints[100]);
      return {
        fg: tints[900],
        bg,
        border: tints[200],
        focusRing: tints[500],
        shadow: {
          outline: rgba(tints[500], dark ? 0.2 : 0.4),
          umbra: rgba(dark ? legacyPalette.black : tints[500], 0.2),
          penumbra: rgba(dark ? legacyPalette.black : tints[500], 0.14),
          ambient: rgba(dark ? legacyPalette.black : tints[500], 0.12)
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    solid: _ref19 => {
      let {
        base,
        dark: navbar,
        name,
        state,
        tone
      } = _ref19;
      const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default;
      const dark = buttonTones.dark;
      const blend = dark ? _screen : _multiply;
      const blendInvert = dark ? _multiply : _screen;
      const defaultTints = buttonTones[name] || buttonTones.default;
      const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = blend(base.bg, tints[200]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[200]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[50])
          },
          accent: {
            fg: blend(base.bg, tints[50])
          },
          link: {
            fg: blend(base.bg, tints[50])
          },
          code: {
            bg: bg2,
            fg: blend(base.bg, tints[50])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[600]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[600]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        const bg2 = blend(base.bg, tints[800]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        if (isNeutral) {
          tints = buttonTones.primary;
        }
        const bg2 = blend(base.bg, tints[800]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = blend(base.bg, tints[500]);
      const skeletonFrom = blendInvert(bg, tints[800]);
      return {
        bg,
        border: blend(base.bg, tints[500]),
        fg: blend(base.bg, buttonTones.bg),
        icon: blend(base.bg, buttonTones.bg),
        muted: {
          fg: blend(base.bg, tints[100])
        },
        accent: {
          fg: blendInvert(bg, buttonTones.critical[200])
        },
        link: {
          fg: blendInvert(bg, buttonTones.primary[100])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(base.bg, tints[100])
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    muted: _ref20 => {
      let {
        base,
        dark: navbar,
        name,
        state,
        tone
      } = _ref20;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      const defaultTints = stateTones[name] || stateTones.default;
      const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = base.bg;
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[200]),
          icon: blend(base.bg, tints[200]),
          muted: {
            fg: blend(bg2, tints[100])
          },
          accent: {
            fg: blend(bg2, tints[100])
          },
          link: {
            fg: blend(bg2, tints[100])
          },
          code: {
            bg: bg2,
            fg: blend(bg2, tints[100])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[50]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[900]),
          icon: blend(base.bg, tints[900]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(base.bg, stateTones.critical[500])
          },
          link: {
            fg: blend(base.bg, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        if (isNeutral) {
          tints = stateTones.primary;
        }
        const bg2 = blend(base.bg, tints[100]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[800]),
          icon: blend(base.bg, tints[800]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        if (isNeutral) {
          tints = stateTones.primary;
        }
        const bg2 = blend(base.bg, tints[100]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(bg2, tints[800]),
          icon: blend(bg2, tints[800]),
          muted: {
            fg: blend(bg2, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = base.bg;
      const skeletonFrom = blend(base.bg, tints[100]);
      return {
        bg,
        border: blend(bg, tints[100]),
        fg: blend(bg, tints[700]),
        icon: blend(bg, tints[700]),
        muted: {
          fg: blend(bg, tints[600])
        },
        accent: {
          fg: blend(bg, stateTones.critical[500])
        },
        link: {
          fg: blend(bg, stateTones.primary[600])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(bg, tints[600])
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    button: _ref21 => {
      let {
        base,
        mode,
        muted,
        solid
      } = _ref21;
      if (mode === "bleed") {
        return {
          enabled: {
            ...muted.enabled,
            border: muted.enabled.bg
          },
          hovered: {
            ...muted.hovered,
            border: muted.hovered.bg
          },
          pressed: {
            ...muted.pressed,
            border: muted.pressed.bg
          },
          selected: {
            ...muted.selected,
            border: muted.selected.bg
          },
          disabled: {
            ...muted.disabled,
            border: muted.disabled.bg
          }
        };
      }
      if (mode === "ghost") {
        return {
          ...solid,
          enabled: {
            ...muted.enabled,
            border: base.border
          },
          disabled: muted.disabled
        };
      }
      return solid;
    },
    card: _ref22 => {
      let {
        base,
        dark: navbar,
        muted,
        name,
        solid,
        state
      } = _ref22;
      if (state === "hovered") {
        return muted[name].hovered;
      }
      if (state === "disabled") {
        return muted[name].disabled;
      }
      const isNeutral = NEUTRAL_TONES.includes(name);
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const tints = stateTones[name] || stateTones.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      if (state === "pressed") {
        if (isNeutral) {
          return muted.primary.pressed;
        }
        return muted[name].pressed;
      }
      if (state === "selected") {
        if (isNeutral) {
          return solid.primary.enabled;
        }
        return solid[name].enabled;
      }
      const bg = base.bg;
      const skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
      return {
        bg,
        fg: base.fg,
        icon: base.fg,
        border: base.border,
        muted: {
          fg: blend(base.bg, tints[dark ? 400 : 600])
        },
        accent: {
          fg: blend(base.bg, stateTones.critical[dark ? 400 : 500])
        },
        link: {
          fg: blend(base.bg, stateTones.primary[dark ? 400 : 600])
        },
        code: {
          bg: blend(base.bg, tints[dark ? 950 : 50]),
          fg: tints[dark ? 400 : 600]
        },
        skeleton: {
          from: skeletonFrom,
          to: rgba(skeletonFrom, 0.5)
        }
      };
    },
    input: _ref23 => {
      let {
        base,
        dark: navbar,
        mode,
        state
      } = _ref23;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      if (mode === "invalid") {
        const tints = stateTones.critical;
        return {
          bg: blend(base.bg, tints[50]),
          bg2: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[700]),
          border: blend(base.bg, tints[200]),
          placeholder: blend(base.bg, tints[400])
        };
      }
      if (state === "hovered") {
        return {
          bg: base.bg,
          bg2: base.bg,
          fg: base.fg,
          border: blend(base.bg, hues.gray[300].hex),
          placeholder: blend(base.bg, hues.gray[400].hex)
        };
      }
      if (state === "disabled") {
        return {
          bg: blend(base.bg, hues.gray[50].hex),
          bg2: blend(base.bg, hues.gray[50].hex),
          fg: blend(base.bg, hues.gray[200].hex),
          border: blend(base.bg, hues.gray[100].hex),
          placeholder: blend(base.bg, hues.gray[100].hex)
        };
      }
      if (state === "readOnly") {
        return {
          bg: blend(base.bg, hues.gray[50].hex),
          bg2: blend(base.bg, hues.gray[50].hex),
          fg: blend(base.bg, hues.gray[800].hex),
          border: blend(base.bg, hues.gray[200].hex),
          placeholder: blend(base.bg, hues.gray[400].hex)
        };
      }
      return {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: base.border,
        placeholder: blend(base.bg, hues.gray[700].hex)
      };
    },
    selectable: _ref24 => {
      let {
        base,
        muted,
        tone,
        solid,
        state
      } = _ref24;
      if (state === "enabled") {
        return {
          ...muted[tone].enabled,
          bg: base.bg
        };
      }
      if (state === "pressed") {
        if (tone === "default") {
          return muted.primary.pressed;
        }
        return muted[tone].pressed;
      }
      if (state === "selected") {
        if (tone === "default") {
          return solid.primary.enabled;
        }
        return solid[tone].enabled;
      }
      if (state === "disabled") {
        return {
          ...muted[tone].disabled,
          bg: base.bg
        };
      }
      return muted[tone][state];
    },
    spot: _ref25 => {
      let {
        base,
        key
      } = _ref25;
      const dark = _isDark(base.bg, base.fg);
      const blend = dark ? _screen : _multiply;
      return blend(base.bg, hues[key][dark ? 400 : 500].hex);
    },
    syntax: _ref26 => {
      let {
        base,
        dark: navbar
      } = _ref26;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      const mainShade = 600;
      const secondaryShade = 400;
      return {
        atrule: blend(base.bg, hues.purple[mainShade].hex),
        attrName: blend(base.bg, stateTones.positive[mainShade]),
        attrValue: blend(base.bg, stateTones.caution[mainShade]),
        attribute: blend(base.bg, stateTones.caution[mainShade]),
        boolean: blend(base.bg, hues.purple[mainShade].hex),
        builtin: blend(base.bg, hues.purple[mainShade].hex),
        cdata: blend(base.bg, stateTones.caution[mainShade]),
        char: blend(base.bg, stateTones.caution[mainShade]),
        class: blend(base.bg, hues.orange[mainShade].hex),
        className: blend(base.bg, hues.cyan[mainShade].hex),
        comment: blend(base.bg, stateTones.default[secondaryShade]),
        constant: blend(base.bg, hues.purple[mainShade].hex),
        deleted: blend(base.bg, stateTones.critical[mainShade]),
        doctype: blend(base.bg, stateTones.default[secondaryShade]),
        entity: blend(base.bg, stateTones.critical[mainShade]),
        function: blend(base.bg, stateTones.positive[mainShade]),
        hexcode: blend(base.bg, stateTones.primary[mainShade]),
        id: blend(base.bg, hues.purple[mainShade].hex),
        important: blend(base.bg, hues.purple[mainShade].hex),
        inserted: blend(base.bg, stateTones.caution[mainShade]),
        keyword: blend(base.bg, hues.magenta[mainShade].hex),
        number: blend(base.bg, hues.purple[mainShade].hex),
        operator: blend(base.bg, hues.magenta[mainShade].hex),
        prolog: blend(base.bg, stateTones.default[secondaryShade]),
        property: blend(base.bg, stateTones.primary[mainShade]),
        pseudoClass: blend(base.bg, stateTones.caution[mainShade]),
        pseudoElement: blend(base.bg, stateTones.caution[mainShade]),
        punctuation: blend(base.bg, stateTones.default[mainShade]),
        regex: blend(base.bg, stateTones.primary[mainShade]),
        selector: blend(base.bg, stateTones.critical[mainShade]),
        string: blend(base.bg, stateTones.caution[mainShade]),
        symbol: blend(base.bg, hues.purple[mainShade].hex),
        tag: blend(base.bg, stateTones.critical[mainShade]),
        unit: blend(base.bg, hues.orange[mainShade].hex),
        url: blend(base.bg, stateTones.critical[mainShade]),
        variable: blend(base.bg, stateTones.critical[mainShade])
      };
    }
  });
}
function buildFonts(cssCustomProperties) {
  return {
    ...studioTheme.fonts,
    code: {
      ...studioTheme.fonts.code,
      family: cssCustomProperties["--font-family-monospace"] || studioTheme.fonts.code.family
    },
    heading: {
      ...studioTheme.fonts.heading,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    },
    label: {
      ...studioTheme.fonts.label,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    },
    text: {
      ...studioTheme.fonts.text,
      family: cssCustomProperties["--font-family-base"] || studioTheme.fonts.code.family
    }
  };
}
function buildLegacyPalette(cssCustomProperties) {
  return {
    black: _toHex(cssCustomProperties["--black"]),
    component: {
      bg: _toHex(cssCustomProperties["--component-bg"]),
      fg: _toHex(cssCustomProperties["--component-text-color"])
    },
    defaultButton: {
      default: {
        base: _toHex(cssCustomProperties["--default-button-color"])
      },
      primary: {
        base: _toHex(cssCustomProperties["--default-button-primary-color"])
      },
      success: {
        base: _toHex(cssCustomProperties["--default-button-success-color"])
      },
      warning: {
        base: _toHex(cssCustomProperties["--default-button-warning-color"])
      },
      danger: {
        base: _toHex(cssCustomProperties["--default-button-danger-color"])
      }
    },
    focus: {
      base: _toHex(cssCustomProperties["--focus-color"])
    },
    gray: {
      base: _toHex(cssCustomProperties["--gray-base"])
    },
    mainNavigation: {
      bg: _toHex(cssCustomProperties["--main-navigation-color"]),
      fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"])
    },
    state: {
      info: {
        fg: _toHex(cssCustomProperties["--state-info-color"])
      },
      success: {
        fg: _toHex(cssCustomProperties["--state-success-color"])
      },
      warning: {
        fg: _toHex(cssCustomProperties["--state-warning-color"])
      },
      danger: {
        fg: _toHex(cssCustomProperties["--state-danger-color"])
      }
    }
  };
}
function buildLegacyTones(legacyPalette) {
  return {
    state: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg),
        transparent: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg),
        primary: _buildTints(legacyPalette.component.bg, legacyPalette.state.info.fg, legacyPalette.component.fg),
        positive: _buildTints(legacyPalette.component.bg, legacyPalette.state.success.fg, legacyPalette.component.fg),
        caution: _buildTints(legacyPalette.component.bg, legacyPalette.state.warning.fg, legacyPalette.component.fg),
        critical: _buildTints(legacyPalette.component.bg, legacyPalette.state.danger.fg, legacyPalette.component.fg)
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg),
        transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg),
        primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.info.fg, legacyPalette.mainNavigation.fg),
        positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.success.fg, legacyPalette.mainNavigation.fg),
        caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.warning.fg, legacyPalette.mainNavigation.fg),
        critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.danger.fg, legacyPalette.mainNavigation.fg)
      }
    },
    button: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg),
        transparent: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg),
        primary: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.primary.base, legacyPalette.component.fg),
        positive: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.success.base, legacyPalette.component.fg),
        caution: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.warning.base, legacyPalette.component.fg),
        critical: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.danger.base, legacyPalette.component.fg)
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg),
        transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg),
        primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.primary.base, legacyPalette.mainNavigation.fg),
        positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.success.base, legacyPalette.mainNavigation.fg),
        caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.warning.base, legacyPalette.mainNavigation.fg),
        critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.danger.base, legacyPalette.mainNavigation.fg)
      }
    }
  };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme);
  const legacyPalette = buildLegacyPalette(legacyTheme);
  const legacyTones = buildLegacyTones(legacyPalette);
  const color = buildColor(legacyPalette, legacyTones);
  const fonts = buildFonts(legacyTheme);
  return {
    __dark: _isDark(color.light.default.base.bg, color.light.default.base.fg),
    __legacy: true,
    color,
    fonts
  };
}
const defaultCustomProperties = {
  "--font-family-monospace": studioTheme.fonts.code.family,
  "--font-family-base": studioTheme.fonts.text.family,
  "--black": black.hex,
  "--white": white.hex,
  // Brand
  "--brand-primary": blue[500].hex,
  // Component
  "--component-bg": white.hex,
  "--component-text-color": black.hex,
  // Gray
  "--gray": gray[500].hex,
  "--gray-base": gray[500].hex,
  // Default button
  "--default-button-color": gray[500].hex,
  "--default-button-danger-color": red[500].hex,
  "--default-button-primary-color": blue[500].hex,
  "--default-button-success-color": green[500].hex,
  "--default-button-warning-color": yellow[500].hex,
  // Focus
  "--focus-color": blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": blue[500].hex,
  "--state-success-color": green[500].hex,
  "--state-warning-color": yellow[500].hex,
  "--state-danger-color": red[500].hex,
  // Navbar
  "--main-navigation-color": black.hex,
  "--main-navigation-color--inverted": white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props = {
    ...defaultCustomProperties,
    ...legacyTheme
  };
  props["--focus-color"] = legacyTheme["--focus-color"] || props["--brand-primary"];
  props["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props["--brand-primary"];
  props["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props["--black"];
  props["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props["--white"];
  props["--state-info-color"] = legacyTheme["--brand-primary"] || props["--brand-primary"];
  return props;
}
function Studio(props) {
  const {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_globalStyles: globalStyles,
    unstable_history,
    unstable_noAuthBoundary
  } = props;
  return /* @__PURE__ */jsxs(StudioProvider, {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_history,
    unstable_noAuthBoundary,
    children: [globalStyles && /* @__PURE__ */jsx(GlobalStyle, {}), /* @__PURE__ */jsx(StudioLayout, {})]
  });
}
function renderStudio(rootElement, config) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!rootElement) {
    throw new Error("Missing root element to mount application into");
  }
  const opts = typeof options === "boolean" ? {
    reactStrictMode: options
  } : options;
  const {
    reactStrictMode = false,
    basePath
  } = opts;
  const root = createRoot(rootElement);
  root.render(reactStrictMode ? /* @__PURE__ */jsx(StrictMode, {
    children: /* @__PURE__ */jsx(Studio, {
      config,
      basePath,
      unstable_globalStyles: true
    })
  }) : /* @__PURE__ */jsx(Studio, {
    config,
    basePath,
    unstable_globalStyles: true
  }));
  return () => root.unmount();
}
const INITIAL$1 = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(map$1(ev => ev.type), map$1(eventType => eventType !== "reconnect"), switchMap(isConnected => isConnected ? of("connected") : timer(200).pipe(mapTo("reconnecting"))), startWith(INITIAL$1), distinctUntilChanged$1()), [documentStore.pair, publishedDocId, docTypeName], INITIAL$1);
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.operationEvents(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName]);
}
function useEditState(publishedDocId, docTypeName) {
  let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
  const documentStore = useDocumentStore();
  return useMemoObservable(() => {
    const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(share());
    if (priority === "low") {
      return merge(base.pipe(take(1)), base.pipe(skip(1), debounce(() => timer(1e3))));
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
const PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const {
    style = "short",
    resolution = "seconds"
  } = options || {};
  const unitDisplay = style;
  const locale = useCurrentLocale().id;
  const listFormat = useListFormat({
    type: "unit",
    style
  });
  const isNegative = durationMs < 0;
  const duration = parseMilliseconds(Math.abs(durationMs));
  const formatters = useMemo(() => ({
    days: intlCache.numberFormat(locale, {
      style: "unit",
      unit: "day",
      unitDisplay
    }),
    hours: intlCache.numberFormat(locale, {
      style: "unit",
      unit: "hour",
      unitDisplay
    }),
    minutes: intlCache.numberFormat(locale, {
      style: "unit",
      unit: "minute",
      unitDisplay
    }),
    seconds: intlCache.numberFormat(locale, {
      style: "unit",
      unit: "second",
      unitDisplay
    }),
    milliseconds: intlCache.numberFormat(locale, {
      style: "unit",
      unit: "millisecond",
      unitDisplay
    })
  }), [locale, unitDisplay]);
  const parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds") {
      continue;
    }
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push("".concat(prefix).concat(formatters[period].format(value)));
  }
  const formatted = parts.length === 0 ?
  // If passing duration 0, we still want to show something
  formatters[resolution].format(0) :
  // Usually, we want to join the parts with the locales list formatter
  listFormat.format(parts);
  const iso8601 = durationToISO8601(duration, isNegative);
  return {
    formatted,
    iso8601
  };
}
function parseMilliseconds(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5) % 24,
    minutes: Math.trunc(milliseconds / 6e4) % 60,
    seconds: Math.trunc(milliseconds / 1e3) % 60,
    milliseconds: Math.trunc(milliseconds) % 1e3
  };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? "".concat(dur.days, "D") : "";
  let time = "";
  if (dur.hours) time += "".concat(dur.hours, "H");
  if (dur.minutes) time += "".concat(dur.minutes, "M");
  if (dur.milliseconds) {
    time += "".concat(((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3), "S");
  } else if (dur.seconds) {
    time += "".concat(dur.seconds, "S");
  }
  if (!date && !time) {
    return "PT0S";
  }
  const parts = time ? [date, time] : [date];
  const duration = "P".concat(parts.join("T"));
  return isNegative ? "-".concat(duration) : duration;
}
function useNumberFormat() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const currentLocale = useCurrentLocale().id;
  return intlCache.numberFormat(currentLocale, options);
}
const SYNCING = {
  isSyncing: true
};
const NOT_SYNCING = {
  isSyncing: false
};
function useSyncState(publishedDocId, documentType) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(map$1(isConsistent => isConsistent ? NOT_SYNCING : SYNCING)), [documentStore.pair, documentType, publishedDocId], NOT_SYNCING);
}
function useTimeAgo(time) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return useRelativeTime(time, {
    minimal: options.minimal,
    useTemporalPhrase: options.agoSuffix
  });
}
function useTools() {
  return useSource().tools;
}
const INITIAL_STATE = {
  data: [],
  error: null,
  loading: true
};
let cachedSystemGroups = null;
function useUserListWithPermissions(opts) {
  const {
    documentValue,
    permission
  } = opts;
  const projectStore = useProjectStore();
  const userStore = useUserStore();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [state, setState] = useState(INITIAL_STATE);
  const list$ = useMemo(() => {
    const members$ = projectStore.get().pipe(map(res => {
      var _a;
      return (_a = res.members) == null ? void 0 : _a.filter(m => !m.isRobot);
    }));
    const users$ = members$.pipe(switchMap$1(async members => {
      const ids = members.map(_ref27 => {
        let {
          id
        } = _ref27;
        return id;
      });
      const users = await userStore.getUsers(ids);
      return users;
    }), map(res => res.map(user => ({
      displayName: user.displayName,
      id: user.id,
      granted: false
    }))));
    const cached = cachedSystemGroups;
    const systemGroup$ = cached ? of(cached) : client.observable.fetch('*[_type == "system.group"]');
    const grants$ = forkJoin([users$, systemGroup$]).pipe(mergeMap(async _ref28 => {
      let [users, groups] = _ref28;
      if (!cached) {
        cachedSystemGroups = groups;
      }
      const grantPromises = users == null ? void 0 : users.map(async user => {
        const grants = groups.map(group => {
          if (group.members.includes(user.id)) {
            return group.grants;
          }
          return [];
        });
        const flattenedGrants = [...grants].flat();
        const {
          granted
        } = await grantsPermissionOn(user.id, flattenedGrants, permission, documentValue);
        return {
          ...user,
          granted
        };
      });
      const usersWithPermission = await Promise.all(grantPromises || []);
      return usersWithPermission;
    }));
    const $alphabetical = grants$.pipe(map(res => ({
      error: null,
      loading: false,
      data: sortBy(res, "displayName")
    })));
    return $alphabetical;
  }, [client.observable, documentValue, projectStore, userStore, permission]);
  useEffect(() => {
    const initial$ = of(INITIAL_STATE);
    const state$ = concat(initial$, list$);
    const sub = state$.subscribe({
      next: setState,
      error: error => {
        setState({
          data: [],
          error,
          loading: false
        });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [list$]);
  return state;
}
const INITIAL = {
  validation: [],
  isValidating: false
};
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return useMemoObservable(() => documentStore.pair.validation(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName], INITIAL);
}
const actionIds = /* @__PURE__ */new WeakMap();
let counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId) return cachedId;
  const id = "".concat(actionHook.name || actionHook.displayName || "<anonymous>", "-").concat(counter++);
  actionIds.set(actionHook, id);
  return id;
}
const requestIdleCallbackShim = callback => {
  const start = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: false,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 1);
};
const cancelIdleCallbackShim = handle => {
  return clearTimeout(handle);
};
const _requestIdleCallback = typeof requestIdleCallback === "undefined" ? requestIdleCallbackShim : requestIdleCallback;
const _cancelIdleCallback = typeof cancelIdleCallback === "undefined" ? cancelIdleCallbackShim : cancelIdleCallback;
const throttleOptions = {
  trailing: true
};
function GetHookCollectionState(props) {
  const {
    hooks,
    args,
    children,
    onReset
  } = props;
  const statesRef = useRef({});
  const [tickId, setTick] = useState(0);
  const [keys, setKeys] = useState({});
  const ricHandle = useRef(null);
  const handleRequestUpdate = useCallback(() => {
    if (ricHandle.current) {
      _cancelIdleCallback(ricHandle.current);
    }
    ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null;
      setTick(tick => tick + 1);
    });
  }, []);
  const handleRequestUpdateThrottled = useThrottledCallback(handleRequestUpdate, 60, throttleOptions);
  const handleNext = useCallback((id, hookState) => {
    if (hookState === null) {
      delete statesRef.current[id];
    } else {
      const current = statesRef.current[id];
      statesRef.current[id] = {
        ...current,
        value: hookState
      };
    }
  }, []);
  const handleReset = useCallback(id => {
    setKeys(currentKeys => ({
      ...currentKeys,
      [id]: (currentKeys[id] || 0) + 1
    }));
    if (onReset) {
      onReset();
    }
  }, [onReset]);
  const hookIds = useMemo(() => hooks.map(hook => getHookId(hook)), [hooks]);
  const states = useMemo(() => hookIds.map(id => {
    var _a;
    return (_a = statesRef.current[id]) == null ? void 0 : _a.value;
  }).filter(isNonNullable$1),
  // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
  [hookIds, tickId]);
  return /* @__PURE__ */jsxs(Fragment, {
    children: [hooks.map(hook => {
      const id = getHookId(hook);
      const key = keys[id] || 0;
      return /* @__PURE__ */jsx(HookStateContainer, {
        hook,
        id,
        args,
        onNext: handleNext,
        onRequestUpdate: handleRequestUpdateThrottled,
        onReset: handleReset
      }, "".concat(id, "-").concat(key));
    }), children({
      states
    })]
  });
}
function Hotkeys(_ref29) {
  let {
    makePlatformAware = true,
    keys: hotKeys = [],
    ...props
  } = _ref29;
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return /* @__PURE__ */jsx(Hotkeys$1, {
    ...props,
    keys
  });
}
const IS_APPLE_DEVICE = typeof navigator === "undefined" || typeof navigator.platform !== "string" ? false : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key) {
  const lowerKey = key.toLowerCase();
  if (lowerKey === "alt" && IS_APPLE_DEVICE) {
    return matchCase(key, "option");
  }
  if (lowerKey === "option" && !IS_APPLE_DEVICE) {
    return matchCase(key, "alt");
  }
  return key;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => {
    return i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char;
  });
}
function IntentButton(props) {
  return props.disabled ? /* @__PURE__ */jsx(Button, {
    ...props,
    as: "a",
    role: "link",
    "aria-disabled": "true"
  }) : /* @__PURE__ */jsx(Button, {
    ...props,
    as: IntentLink
  });
}
function RelativeTime(_ref30) {
  let {
    time,
    ...options
  } = _ref30;
  const timestamp = time instanceof Date ? time : new Date(time);
  const timeAgo = useRelativeTime(timestamp, options);
  return /* @__PURE__ */jsx("time", {
    dateTime: timestamp.toISOString(),
    title: timeAgo,
    children: timeAgo
  });
}
function WithReferringDocuments(_ref31) {
  let {
    children,
    id
  } = _ref31;
  return children(useReferringDocuments(id));
}
function ZIndexProvider(_ref32) {
  let {
    children
  } = _ref32;
  return /* @__PURE__ */jsx(ZIndexContext.Provider, {
    value: defaults,
    children
  });
}
function TelephoneInput(props) {
  const {
    schemaType,
    validationError,
    value,
    elementProps
  } = props;
  return /* @__PURE__ */jsx(TextInput, {
    type: "tel",
    inputMode: "tel",
    customValidity: validationError,
    value: value || "",
    placeholder: schemaType.placeholder,
    ...elementProps
  });
}
function resolveConditionalProperty(property, context) {
  const {
    currentUser,
    document,
    parent,
    value
  } = context;
  if (typeof property === "boolean" || property === void 0) {
    return Boolean(property);
  }
  return property({
    document,
    parent,
    value,
    currentUser
  }) === true;
}
function setAtPath(currentTree, path, value) {
  var _a;
  if (path.length === 0) {
    return {
      ...(currentTree || {}),
      value
    };
  }
  const [head, ...tail] = path;
  const key = isKeySegment(head) ? head._key : String(head);
  const children = (_a = currentTree == null ? void 0 : currentTree.children) != null ? _a : {};
  return {
    value: currentTree == null ? void 0 : currentTree.value,
    children: {
      ...children,
      [key]: setAtPath(children[key] || {}, tail, value)
    }
  };
}
const MAX_FIELD_DEPTH = 20;
const AUTO_COLLAPSE_DEPTH = 3;
const ALL_FIELDS_GROUP = {
  name: "all-fields",
  title: "All fields",
  hidden: false
};
function getCollapsedWithDefaults() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let level = arguments.length > 1 ? arguments[1] : undefined;
  if ((options == null ? void 0 : options.collapsible) === false || (options == null ? void 0 : options.collapsable) === false) {
    return {
      collapsible: false,
      collapsed: false
    };
  }
  const collapsed =
  // eslint-disable-next-line no-nested-ternary
  typeof (options == null ? void 0 : options.collapsed) === "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? true : void 0;
  const collapsible = (options == null ? void 0 : options.collapsible) === true || (options == null ? void 0 : options.collapsable) === true || collapsed === true ? true : void 0;
  return {
    collapsible,
    collapsed
  };
}
function getItemType(arrayType, item) {
  const itemTypeName = resolveTypeName$1(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find(memberType => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = resolveTypeName$1(item);
  return arrayType == null ? void 0 : arrayType.of.find(memberType => memberType.name === itemTypeName || memberType.jsonType === itemTypeName);
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  if (selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  if (fieldGroup === void 0) {
    return false;
  }
  if (groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  return castArray(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value === "undefined" || isRecord(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every(item => isRecord(item));
}
function findDuplicateKeyEntries(array) {
  const seenKeys = /* @__PURE__ */new Set();
  return array.reduce((acc, item, index) => {
    if (seenKeys.has(item._key)) {
      acc.push([index, item._key]);
    }
    seenKeys.add(item._key);
    return acc;
  }, []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array) {
  return array == null ? void 0 : array.every(item => isRecord(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  if (Array.isArray(value) && typeof comparisonValue === "undefined" || Array.isArray(comparisonValue) && typeof value === "undefined") {
    return false;
  }
  if (value && !comparisonValue) {
    return true;
  }
  return !isEqual$2(value, comparisonValue);
}
function prepareFieldMember(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const {
    parent,
    field,
    index
  } = props;
  const fieldPath = pathFor([...parent.path, field.name]);
  const fieldLevel = getFieldLevel(field.type, parent.level + 1);
  const parentValue = parent.value;
  const parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue)) {
    throw new Error("Unexpected non-object value");
  }
  const normalizedFieldGroupNames = field.group ? castArray(field.group) : [];
  const inSelectedGroup = isFieldEnabledByGroupFilter(parent.groups, field.group, parent.selectedGroup);
  if (isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue)) {
      return {
        kind: "error",
        key: field.name,
        fieldName: field.name,
        error: {
          type: "INCOMPATIBLE_TYPE",
          expectedSchemaType: field.type,
          resolvedValueType: resolveTypeName$1(fieldValue),
          value: fieldValue
        }
      };
    }
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return {
        kind: "hidden",
        key: "field-".concat(field.name),
        name: field.name,
        index
      };
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[field.name];
    const scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[field.name];
    const scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[field.name];
    const inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly,
      changesOpen: parent.changesOpen
    });
    if (inputState === null) {
      return null;
    }
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel);
    const collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: "field",
      key: "field-".concat(field.name),
      name: field.name,
      index,
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      open: startsWith(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if (isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (isArrayOfObjectsSchemaType(field.type)) {
      const hasValue = typeof fieldValue !== "undefined";
      if (hasValue && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = resolveTypeName$1(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemIsObject(fieldValue)) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MIXED_ARRAY",
            schemaType: field.type,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemHasKey(fieldValue)) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MISSING_KEYS",
            value: fieldValue,
            schemaType: field.type
          }
        };
      }
      const duplicateKeyEntries = hasValue ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "DUPLICATE_KEYS",
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      }
      const fieldGroupState = (_h = (_g = parent.fieldGroupState) == null ? void 0 : _g.children) == null ? void 0 : _h[field.name];
      const scopedCollapsedPaths = (_j = (_i = parent.collapsedPaths) == null ? void 0 : _i.children) == null ? void 0 : _j[field.name];
      const scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        open: startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = resolveTypeName$1(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name];
      const scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name];
      const scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return null;
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldState = preparePrimitiveInputState({
      ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: "field",
      key: "field-".concat(field.name),
      name: field.name,
      index,
      open: startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: false,
      collapsed: false,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props) {
  let enableHiddenCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var _a;
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const schemaTypeGroupConfig = props.schemaType.groups || [];
  const defaultGroupName = (_a = schemaTypeGroupConfig.find(g => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a.name;
  const groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap(group => {
    var _a2;
    const groupHidden = resolveConditionalProperty(group.hidden, conditionalPropertyContext);
    const isSelected = group.name === (((_a2 = props.fieldGroupState) == null ? void 0 : _a2.value) || defaultGroupName);
    const selected = props.changesOpen ? group.name === ALL_FIELDS_GROUP.name : isSelected;
    const disabled = props.changesOpen ? !selected : false;
    return groupHidden ? [] : [{
      disabled,
      icon: group == null ? void 0 : group.icon,
      name: group.name,
      selected,
      title: group.title
    }];
  });
  const selectedGroup = groups.find(group => group.selected);
  const normalizedSchemaMembers = props.schemaType.fieldsets ? props.schemaType.fieldsets : props.schemaType.fields.map(field => ({
    single: true,
    field
  }));
  const members = normalizedSchemaMembers.flatMap((fieldSet, index) => {
    var _a2, _b, _c, _d;
    if (fieldSet.single) {
      const field = fieldSet.field;
      const fieldMember = prepareFieldMember({
        field,
        parent: {
          ...props,
          readOnly,
          groups,
          selectedGroup
        },
        index
      });
      return fieldMember ? [fieldMember] : [];
    }
    const fieldsetFieldNames = fieldSet.fields.map(f => f.name);
    const fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, {
      currentUser: props.currentUser,
      document: props.document,
      parent: props.value,
      value: pick(props.value, fieldsetFieldNames)
    });
    const fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, {
      currentUser: props.currentUser,
      document: props.document,
      parent: props.value,
      value: pick(props.value, fieldsetFieldNames)
    });
    const fieldsetMembers = fieldSet.fields.flatMap(field => {
      if (fieldsetHidden) {
        return [{
          kind: "hidden",
          key: "field-".concat(field.name),
          name: field.name,
          index
        }];
      }
      const fieldMember = prepareFieldMember({
        field,
        parent: {
          ...props,
          readOnly: readOnly || fieldsetReadOnly,
          groups,
          selectedGroup
        },
        index
      });
      return fieldMember ? [fieldMember] : [];
    });
    const defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props.level);
    const collapsed = (_c = (_b = (((_a2 = props.collapsedFieldSets) == null ? void 0 : _a2.children) || {})[fieldSet.name]) == null ? void 0 : _b.value) != null ? _c : defaultCollapsedState.collapsed;
    return [{
      kind: "fieldSet",
      key: "fieldset-".concat(fieldSet.name),
      _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup),
      groups: fieldSet.group ? castArray(fieldSet.group) : [],
      fieldSet: {
        path: pathFor(props.path.concat(fieldSet.name)),
        name: fieldSet.name,
        title: fieldSet.title,
        description: fieldSet.description,
        hidden: false,
        level: props.level + 1,
        members: fieldsetMembers.filter(member => member.kind !== "hidden"),
        collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible,
        collapsed,
        columns: (_d = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d.columns
      }
    }];
  });
  const hasFieldGroups = schemaTypeGroupConfig.length > 0;
  const filteredPresence = props.presence.filter(item => isEqual$1(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2;
  const validation = props.validation.filter(item => isEqual$1(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const visibleMembers = members.filter(member => member.kind !== "hidden");
  if (visibleMembers.length === 0 && enableHiddenCheck) {
    return null;
  }
  const visibleGroups = hasFieldGroups ? groups.flatMap(group => {
    if (group.name === ALL_FIELDS_GROUP.name) {
      return group;
    }
    const hasVisibleMembers = visibleMembers.some(member => {
      if (member.kind === "error") {
        return false;
      }
      if (member.kind === "field") {
        return member.groups.includes(group.name);
      }
      return member.groups.includes(group.name) || member.fieldSet.members.some(fieldsetMember => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group.name));
    });
    return hasVisibleMembers ? group : [];
  }) : [];
  const filtereredMembers = visibleMembers.flatMap(member => {
    if (member.kind === "error") {
      return [member];
    }
    if (member.kind === "field") {
      return member.inSelectedGroup ? [member] : [];
    }
    const filteredFieldsetMembers = member.fieldSet.members.filter(fieldsetMember => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup);
    return filteredFieldsetMembers.length > 0 ? [{
      ...member,
      fieldSet: {
        ...member.fieldSet,
        members: filteredFieldsetMembers
      }
    }] : [];
  });
  const node = {
    value: props.value,
    changed: isChangedValue(props.value, props.comparisonValue),
    schemaType: props.schemaType,
    readOnly,
    path: props.path,
    id: toString(props.path),
    level: props.level,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    presence,
    validation,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  Object.defineProperty(node, "_allMembers", {
    value: members,
    enumerable: false
  });
  return node;
}
function prepareArrayOfPrimitivesInputState(props) {
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    comparisonValue: props.comparisonValue,
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props.value) ? props.value : [];
  const filteredPresence = props.presence.filter(item => isEqual$1(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2;
  const validation = props.validation.filter(item => isEqual$1(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfPrimitivesMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some(m => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    path: props.path,
    id: toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props) {
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props.value) ? props.value : [];
  const filteredPresence = props.presence.filter(item => isEqual$1(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2;
  const validation = props.validation.filter(item => isEqual$1(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfObjectsMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some(m => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: isEqual$1(props.path, props.focusPath),
    focusPath: trimChildPath$1(props.path, props.focusPath),
    path: props.path,
    id: toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = getItemType(parent.schemaType, arrayItem);
  const key = arrayItem._key;
  if (!itemType) {
    const itemTypeName = resolveTypeName$1(arrayItem);
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }
  const itemPath = pathFor([...parent.path, {
    _key: key
  }]);
  const itemLevel = parent.level + 1;
  const conditionalPropertyContext = {
    value: parent.value,
    parent: props.parent,
    document: parent.document,
    currentUser: parent.currentUser
  };
  const readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext);
  const fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[key];
  const scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[key];
  const scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[key];
  const comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find(i => i._key === arrayItem._key) || void 0;
  const itemState = prepareObjectInputState({
    schemaType: itemType,
    level: itemLevel,
    document: parent.document,
    value: arrayItem,
    comparisonValue,
    changed: isChangedValue(arrayItem, comparisonValue),
    path: itemPath,
    focusPath: parent.focusPath,
    openPath: parent.openPath,
    currentUser: parent.currentUser,
    collapsedPaths: scopedCollapsedPaths,
    collapsedFieldSets: scopedCollapsedFieldsets,
    presence: parent.presence,
    validation: parent.validation,
    fieldGroupState,
    readOnly
  }, false);
  const defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel);
  const collapsed = (_g = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g : defaultCollapsedState.collapsed;
  return {
    kind: "item",
    key,
    index,
    open: startsWith(itemPath, parent.openPath),
    collapsed,
    collapsible: true,
    parentSchemaType: parent.schemaType,
    item: itemState
  };
}
function prepareArrayOfPrimitivesMember(props) {
  var _a, _b;
  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = getPrimitiveItemType(parent.schemaType, arrayItem);
  const itemPath = pathFor([...parent.path, index]);
  const itemValue = (_a = parent.value) == null ? void 0 : _a[index];
  const itemComparisonValue = (_b = parent.comparisonValue) == null ? void 0 : _b[index];
  const itemLevel = parent.level + 1;
  const key = "".concat((itemType == null ? void 0 : itemType.name) || "invalid-type", "-").concat(String(index));
  if (!itemType) {
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        validTypes: parent.schemaType.of,
        resolvedValueType: resolveTypeName$1(itemType),
        value: itemValue
      }
    };
  }
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  });
  const item = preparePrimitiveInputState({
    ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: "item",
    key,
    index,
    parentSchemaType: parent.schemaType,
    open: isEqual$1(itemPath, parent.openPath),
    item
  };
}
function preparePrimitiveInputState(props) {
  const filteredPresence = props.presence.filter(item => isEqual$1(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$2;
  const validation = props.validation.filter(item => isEqual$1(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  return {
    schemaType: props.schemaType,
    changed: isChangedValue(props.value, props.comparisonValue),
    value: props.value,
    level: props.level,
    id: toString(props.path),
    readOnly: props.readOnly,
    focused: isEqual$1(props.path, props.focusPath),
    path: props.path,
    presence,
    validation
  };
}
function prepareFormState(props) {
  return prepareObjectInputState(props);
}
function useFormState(schemaType, _ref33) {
  let {
    comparisonValue,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    openPath,
    presence,
    validation,
    readOnly,
    changesOpen
  } = _ref33;
  const currentUser = useCurrentUser();
  const prev = useRef(null);
  useLayoutEffect(() => {
    prev.current = null;
  }, [schemaType]);
  return useMemo(() => {
    const next = prepareFormState({
      schemaType,
      document: value,
      fieldGroupState,
      collapsedFieldSets,
      collapsedPaths,
      value,
      comparisonValue,
      focusPath,
      openPath,
      readOnly,
      path: pathFor([]),
      level: 0,
      currentUser,
      presence,
      validation,
      changesOpen
    });
    const reconciled = immutableReconcile(prev.current, next);
    prev.current = reconciled;
    return reconciled;
  }, [schemaType, value, fieldGroupState, collapsedFieldSets, collapsedPaths, comparisonValue, focusPath, openPath, readOnly, currentUser, presence, validation, changesOpen]);
}
function isObjectFormNode(formNode) {
  return isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path) {
  return [
  // make sure to expand all intermediate paths
  ...path.map((p, i) => ({
    type: "expandPath",
    path: path.slice(0, i + 1)
  })),
  // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
  ...getFieldsetAndFieldGroupOperations(node, path)];
}
function getFieldsetAndFieldGroupOperations(node, path) {
  if (path.length === 0) {
    return [];
  }
  if (isObjectFormNode(node) && hasAllMembers(node)) {
    return getObjectFieldsetAndFieldGroupOperations(node, path);
  }
  if (isArrayOfObjectsFormNode(node)) {
    return getArrayFieldsetAndFieldGroupOperations(node, path);
  }
  return [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path) {
  var _a, _b;
  if (path.length === 0) {
    return [];
  }
  const [fieldName, ...tail] = path;
  const fieldsetMember = node._allMembers.find(member => member.kind === "fieldSet" && member.fieldSet.members.some(field => field.kind === "field" && field.name === fieldName));
  const members = fieldsetMember ? fieldsetMember.fieldSet.members :
  // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
  node._allMembers;
  const fieldMember = members.find(member => member !== null && member.kind === "field" && member.name === fieldName);
  const schemaField = node.schemaType.fields.find(field => field.name === fieldName);
  const selectedGroupName = (_a = node.groups.find(group => group.selected)) == null ? void 0 : _a.name;
  const defaultGroupName = (_b = (node.schemaType.groups || []).find(group => group.default)) == null ? void 0 : _b.name;
  const inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && castArray(schemaField.group).includes(selectedGroupName));
  const ops = [];
  if (!inSelectedGroup) {
    ops.push({
      type: "setSelectedGroup",
      path: node.path,
      groupName: defaultGroupName || ALL_FIELDS_GROUP.name
    });
  }
  if (fieldsetMember) {
    ops.push({
      type: "expandFieldSet",
      path: fieldsetMember.fieldSet.path
    });
  }
  if (fieldMember && hasAllMembers(fieldMember.field)) {
    if (isMemberArrayOfObjects(fieldMember)) {
      ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    } else if (isMemberObject(fieldMember)) {
      ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    }
  }
  return ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path) {
  if (path.length === 0) {
    return [];
  }
  const [segment, ...rest] = path;
  if (!isKeySegment(segment)) {
    throw new Error("Expected path segment to be an object with a _key property");
  }
  const foundMember = state.members.find(member => member.key === segment._key);
  if (!foundMember) {
    return [];
  }
  return getFieldsetAndFieldGroupOperations(foundMember.item, rest);
}
const IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key] = segment.split("==");
  return {
    [attr]: unquote(key)
  };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map(seg => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return flatten(patches.map(patch => toFormBuilderPatches(origin, patch)));
}
const notIn = values => value => !values.includes(value);
function toFormBuilderPatches(origin, patch) {
  return flatten(Object.keys(patch).filter(notIn(["id", "ifRevisionID", "query"])).map(type => {
    if (type === "unset") {
      return patch.unset.map(path => {
        return {
          type: "unset",
          path: decodePath(path),
          origin
        };
      });
    }
    if (type === "insert") {
      const position = "before" in patch.insert ? "before" : "after";
      return {
        type: "insert",
        position,
        path: decodePath(patch.insert[position]),
        items: patch.insert.items,
        origin
      };
    }
    return Object.keys(patch[type]).map(gradientPath => {
      if (type === "set") {
        return {
          type: "set",
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "inc" || type === "dec") {
        return {
          type,
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "setIfMissing") {
        return {
          type: "setIfMissing",
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "diffMatchPatch") {
        return {
          type,
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}
function toMutationPatch(patch) {
  if (patch.patchType !== SANITY_PATCH_TYPE && patch.type) {
    throw new Error('Patch is missing "patchType" - import and use "'.concat(patch.type, '()" from "sanity/form"'));
  } else if (patch.patchType !== SANITY_PATCH_TYPE) {
    throw new Error('Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"');
  }
  const matchPath = arrayToJSONMatchPath(patch.path || []);
  if (patch.type === "insert") {
    const {
      position,
      items
    } = patch;
    return {
      insert: {
        [position]: matchPath,
        items
      }
    };
  }
  if (patch.type === "unset") {
    return {
      unset: [matchPath]
    };
  }
  if (!patch.type) {
    throw new Error("Missing patch type in patch ".concat(JSON.stringify(patch)));
  }
  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }
  return {
    [patch.type]: patch.value
  };
}
export { AddonDatasetContext, AddonDatasetProvider, ArrayOfObjectsFunctions, ArrayOfObjectsInputMember, ArrayOfObjectsInputMembers, ArrayOfObjectsItem, BetaBadge, ChangeConnectorRoot, ChangeFieldWrapper, ConnectorContext, DEFAULT_STUDIO_CLIENT_OPTIONS, DefaultDocument, DiffFromTo, DiffTooltip, DisabledChangeConnectorRoot, EMPTY_ARRAY$2 as EMPTY_ARRAY, EnabledChangeConnectorRoot, FormBuilder, FormBuilderContext, FormCallbacksProvider, FormFieldPresenceContext, FormProvider, FormValueProvider, FromToArrow, GetHookCollectionState, GlobalErrorHandler, Hotkeys, HoveredFieldProvider, IntentButton, MemberItemError, PatchEvent, PresenceScope, Preview, PreviewLoader, RelativeTime, ReviewChangesContext, SANITY_PATCH_TYPE, ScrollContainer, ScrollMonitor, Studio, StudioLayout, StudioLogo, StudioProvider, TelephoneInput, Tracker, WithReferringDocuments, ZIndexProvider, _isCustomDocumentTypeDefinition, _isSanityDocumentTypeDefinition, buildLegacyTheme, createConfig, createMockAuthStore, createNoopTrackerScope, createPatchChannel, createPlugin, createSourceFromConfig, createWorkspaceFromConfig, decodePath, defaultRenderAnnotation, defaultRenderBlock, defaultRenderField, defaultRenderInlineBlock, defaultRenderInput, defaultRenderItem, defaultRenderPreview, defaultTemplateForType, defaultTemplatesForSchema, defineConfig, defineDocumentFieldAction, defineDocumentInspector, definePlugin, diffResolver, encodePath, fromMutationPatches, getAnnotationColor, getConfigContextFromSource, getExpandOperations, getPublishedId, grantsPermissionOn, isArray, isBuilder, isNonNullable$1 as isNonNullable, isRecord, isTruthy, pathToString, prepareConfig, prepareTemplates, remoteSnapshots, renderStudio, resizeObserver, resolveConditionalProperty, resolveConfig, setAtPath, toMutationPatches, uncaughtErrorHandler, useAddonDataset, useClient, useConfigContextFromSource, useConnectionState, useCurrentLocale, useCurrentUser, useDocumentOperationEvent, useDocumentStore, useDocumentType, useEditState, useFormState, useFormattedDuration, useHistoryStore, useListFormat, useNumberFormat, useOnScroll, useProject, useProjectDatasets, useProjectStore, useRelativeTime, useReportedValues, useReporter, useReviewChanges, useSource, useSyncState, useThrottledCallback, useTimeAgo, useTimelineSelector, useTimelineStore, useTools, useTranslation, useUserColorManager, useUserListWithPermissions, useUserStore, useValidationStatus, useWorkspace };
//# sourceMappingURL=index.esm.js.map
