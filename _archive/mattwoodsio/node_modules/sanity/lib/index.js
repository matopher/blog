'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var PathUtils = require('@sanity/util/paths');
var React = require('react');
var deepCompare = require('react-fast-compare');
var TransformPatches = require('./_chunks/TransformPatches-9Ddwm1na.js');
var sortBy = require('lodash/sortBy.js');
var reactRx = require('react-rx');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
var isEqual$1 = require('lodash/isEqual.js');
var throttle = require('lodash/throttle.js');
var types = require('@sanity/types');
var ui = require('@sanity/ui');
var router = require('sanity/router');
var TooltipDelayGroupProvider = require('./_chunks/TooltipDelayGroupProvider-CXQG_E3r.js');
var isString = require('lodash/isString.js');
require('history');
var withSelector = require('use-sync-external-store/with-selector');
require('lodash/escapeRegExp.js');
require('date-fns');
require('react-i18next');
require('@sanity/portable-text-editor');
require('@sanity/icons');
require('lodash/omit.js');
require('@sanity/diff-match-patch');
var flatten = require('lodash/flatten.js');
require('lodash/orderBy.js');
require('lodash/uniq.js');
require('lodash/xor.js');
require('sanity-diff-patch');
require('lodash/startCase.js');
require('lodash/debounce.js');
require('nano-pubsub');
require('shallow-equals');
require('scroll-into-view-if-needed');
require('@sanity/schema/_internal');
require('lodash/isFinite.js');
require('lodash/compact.js');
require('lodash/intersection.js');
require('lodash/keyBy.js');
require('lodash/partition.js');
require('lodash/toLower.js');
require('lodash/union.js');
require('lodash/words.js');
require('lodash/get.js');
require('get-random-values-esm');
var content = require('@sanity/util/content');
require('lodash/isPlainObject.js');
require('@tanstack/react-virtual');
require('@sanity/util/legacyDateFormat');
require('speakingurl');
require('@sanity/telemetry/react');
require('lodash/find.js');
var castArray = require('lodash/castArray.js');
var pick = require('lodash/pick.js');
var mutator = require('@sanity/mutator');
require('@sanity/schema');
require('@sanity/asset-utils');
require('@sanity/image-url');
require('@sanity/uuid');
require('exif-component');
require('react-is');
require('lodash/difference.js');
require('lodash/memoize.js');
require('lodash/identity.js');
require('lodash/values.js');
require('lodash/assignWith.js');
require('lodash/capitalize.js');
var client = require('react-dom/client');
require('lodash/groupBy.js');
require('json-reduce');
require('rxjs-exhaustmap-with-trailing');
require('groq-js');
require('rxjs-etc/operators');
require('mendoza');
require('@sanity/diff');
require('dataloader');
require('raf');
require('@sanity/bifur-client');
require('@sanity/client');
require('i18next');
var color = require('@sanity/color');
var theme = require('@sanity/ui/theme');
var polished = require('polished');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var PathUtils__namespace = /*#__PURE__*/_interopNamespaceCompat(PathUtils);
var deepCompare__default = /*#__PURE__*/_interopDefaultCompat(deepCompare);
var sortBy__default = /*#__PURE__*/_interopDefaultCompat(sortBy);
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual$1);
var throttle__default = /*#__PURE__*/_interopDefaultCompat(throttle);
var isString__default = /*#__PURE__*/_interopDefaultCompat(isString);
var flatten__default = /*#__PURE__*/_interopDefaultCompat(flatten);
var castArray__default = /*#__PURE__*/_interopDefaultCompat(castArray);
var pick__default = /*#__PURE__*/_interopDefaultCompat(pick);
function noop() {}
function NoopTracker(_ref) {
  let {
    children
  } = _ref;
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children
  });
}
function createNoopTrackerScope() {
  return {
    useReportedValues: noop,
    Tracker: NoopTracker,
    useReporter: noop
  };
}
const ChangeFieldWrapper = props => {
  const ref = React.useRef(null);
  const {
    onSetFocus
  } = React.useContext(TransformPatches.ConnectorContext);
  const [isHover, setHover] = React.useState(false);
  const onMouseEnter = React.useCallback(() => {
    setHover(true);
  }, []);
  const onMouseLeave = React.useCallback(() => {
    setHover(false);
  }, []);
  TransformPatches.useReporter("change-".concat(PathUtils__namespace.toString(props.path)), () => ({
    element: ref.current,
    path: props.path,
    isChanged: true,
    hasFocus: false,
    hasHover: isHover,
    hasRevertHover: props.hasHover
  }),
  // note: deepCompare should be ok here since we're not comparing deep values
  deepCompare__default.default);
  const handleClick = React.useCallback(event => {
    setFocusWithStopPropagation(event, onSetFocus, props.path);
  }, [onSetFocus, props.path]);
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    ref,
    onClick: handleClick,
    onMouseLeave,
    onMouseEnter,
    children: props.children
  });
};
function setFocusWithStopPropagation(event, onSetFocus, path) {
  event.stopPropagation();
  onSetFocus(path);
}
function isArray(value) {
  return Array.isArray(value);
}
function isTruthy(value) {
  return Boolean(value);
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
const FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif";
const FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace";
const uncaughtErrorHandler = () =>
// prettier-ignore
["window.onerror = function(m,u,l,c,e) {", "var p=window.location.port;", "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');", "var r=document.getElementById('sanity');", "while(r.firstChild){r.removeChild(r.firstChild);}", "var s=document.createElement('style');", "s.appendChild(document.createTextNode('", "html,body,#sanityBody,#sanity,#sanityError{height:100%;}", "body{-webkit-font-smoothing:antialiased;margin:0;}", "#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:".concat(FONT_SANS_SERIF, ";font-size:16px;line-height:21px;min-height:100%;}"), "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}", "@media(min-width:512px){", "#sanityError>div{", "padding:47px 84px;", "}", "}", "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}", "#sanityError button:hover{background-color:#1E63D0;}", "#sanityError button:active{background-color:#1B50A5;}", "'));", "document.head.appendChild(s);", "var f=document.createElement('div');", "f.id='sanityError';", "f.innerHTML='", "<div>", '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>', '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>', '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>', '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">', '<code style="font-family:'.concat(FONT_MONOSPACE, ';">'), "'+e.stack.replaceAll(h,'')+'", "</code>", "</pre>", "</div>", "';", "var b=f.querySelector('.sanity-error-handler__reload-btn');", "if(b){", "b.onclick=function() {", "window.location.reload();", "}", "};", "r.appendChild(f);", "};"].join("");
function useThrottledCallback(callback, wait, options) {
  const throttledCallback = React.useMemo(() => throttle__default.default(callback, wait, options), [callback, options, wait]);
  return throttledCallback;
}
function useOnScroll(callback) {
  const parentContext = React.useContext(TransformPatches.ScrollContext);
  React.useEffect(() => {
    return parentContext == null ? void 0 : parentContext.subscribe(callback);
  }, [callback, parentContext]);
}
function ScrollMonitor(_ref2) {
  let {
    onScroll,
    children
  } = _ref2;
  useOnScroll(onScroll);
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children
  });
}
function findMostSpecificTarget(targetType, id, values) {
  const pathString = id.slice(id.indexOf("-") + 1) || "[]";
  const path = PathUtils__namespace.fromString(pathString);
  const exactId = "".concat(targetType, "-").concat(PathUtils__namespace.toString(path));
  if (values.has(exactId)) {
    return values.get(exactId);
  }
  let mostSpecific;
  for (const [targetId, target] of values) {
    if (!("path" in target) || !targetId.startsWith(targetType)) {
      continue;
    }
    const numEqual = PathUtils__namespace.numEqualSegments(path, target.path);
    const lastPathSegment = target.path[target.path.length - 1];
    const pathOnlyDiffersByKey = numEqual === target.path.length - 1 && types.isKeyedObject(lastPathSegment);
    if (numEqual === 0) {
      continue;
    } else if (numEqual !== target.path.length && !pathOnlyDiffersByKey) {
      continue;
    }
    mostSpecific = target;
    if (numEqual === path.length) {
      break;
    }
  }
  return mostSpecific;
}
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el) {
  const scrollableContent = el.scrollHeight !== el.offsetHeight || el.scrollWidth !== el.offsetWidth;
  return scrollableContent && hasOverflowScroll(el);
}
const getOffsetsTo = (source, target) => {
  const bounds = {
    top: 0,
    left: 0,
    height: target.offsetHeight,
    width: target.offsetWidth
  };
  const rect = {
    top: 0,
    left: 0,
    height: source.offsetHeight,
    width: source.offsetWidth
  };
  let foundScrollContainer = false;
  let el = source;
  while (el && el !== target && target.contains(el)) {
    if (foundScrollContainer) {
      bounds.top += el.offsetTop;
      bounds.left += el.offsetLeft;
    }
    if (hasOverflowScroll(el)) {
      bounds.top = el.offsetTop;
      bounds.height = el.offsetHeight;
      bounds.left = el.offsetLeft;
      bounds.width = el.offsetWidth;
      foundScrollContainer = true;
    }
    rect.top += el.offsetTop - el.scrollTop;
    rect.left += el.offsetLeft - el.scrollLeft;
    el = el.offsetParent;
  }
  return {
    rect,
    bounds
  };
};
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
const SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  const element = field.element;
  let parentElementWithScroll = element;
  while (!isScrollable(parentElementWithScroll)) {
    parentElementWithScroll = parentElementWithScroll.parentElement;
    if (!parentElementWithScroll) {
      return;
    }
  }
  parentElementWithScroll.scroll({
    top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING,
    left: 0,
    behavior: "smooth"
  });
}
function useResizeObserver(element, onResize) {
  React.useEffect(() => TransformPatches.resizeObserver.observe(element, onResize), [element, onResize]);
}
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [];
  const changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged) {
      continue;
    }
    const [id, reportedChangeBar] = value;
    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
  const connectors = changeBars.map(_ref3 => {
    let [id] = _ref3;
    const field = findMostSpecificTarget("field", id, byId);
    const change = findMostSpecificTarget("change", id, byId);
    if (!field || !change) return null;
    return {
      field: {
        id,
        ...field
      },
      change: {
        id,
        ...change
      }
    };
  }).filter(TransformPatches.isNonNullable).map(_ref4 => {
    let {
      field,
      change
    } = _ref4;
    return {
      hasHover: field.hasHover || change.hasHover,
      hasFocus: field.hasFocus,
      hasRevertHover: change.hasRevertHover,
      field: {
        ...field,
        ...getOffsetsTo(field.element, rootElement)
      },
      change: {
        ...change,
        ...getOffsetsTo(change.element, rootElement)
      }
    };
  });
  return {
    connectors,
    isHoverConnector
  };
}
function ConnectorsOverlay(props) {
  const {
    rootElement,
    onSetFocus
  } = props;
  const [hovered, setHovered] = React.useState(null);
  const allReportedValues = TransformPatches.useReportedValues();
  const byId = React.useMemo(() => new Map(allReportedValues), [allReportedValues]);
  const [{
    connectors
  }, setState] = React.useState(() => getState(allReportedValues, hovered, byId, rootElement));
  const visibleConnectors = React.useMemo(() => sortBy__default.default(connectors, c => 0 - c.field.path.length).slice(0, 1), [connectors]);
  const handleScrollOrResize = React.useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  useResizeObserver(rootElement, handleScrollOrResize);
  return /* @__PURE__ */jsxRuntime.jsx(ScrollMonitor, {
    onScroll: handleScrollOrResize,
    children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.SvgWrapper, {
      style: {
        zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex
      },
      children: visibleConnectors.map(_ref5 => {
        let {
          field,
          change
        } = _ref5;
        if (!change) {
          return null;
        }
        return /* @__PURE__ */jsxRuntime.jsx(ConnectorGroup, {
          field,
          change,
          onSetFocus,
          setHovered
        }, field.id);
      })
    })
  });
}
function ConnectorGroup(props) {
  const {
    change,
    field,
    onSetFocus,
    setHovered
  } = props;
  const onConnectorClick = React.useCallback(() => {
    scrollIntoView(field);
    scrollIntoView(change);
    onSetFocus(field.path);
  }, [field, change, onSetFocus]);
  const handleMouseEnter = React.useCallback(() => setHovered(field.id), [field, setHovered]);
  const handleMouseLeave = React.useCallback(() => setHovered(null), [setHovered]);
  const from = React.useMemo(() => ({
    rect: {
      ...field.rect,
      left: field.rect.left + 3
    },
    bounds: field.bounds
  }), [field.bounds, field.rect]);
  const to = React.useMemo(() => ({
    rect: {
      ...change.rect,
      left: change.rect.left + 1
    },
    bounds: change.bounds
  }), [change.bounds, change.rect]);
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/* @__PURE__ */jsxRuntime.jsx("g", {
      onClick: onConnectorClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.Connector, {
        from,
        to
      })
    }), TransformPatches.DEBUG_LAYER_BOUNDS]
  });
}
function EnabledChangeConnectorRoot(_ref6) {
  let {
    children,
    className,
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus,
    ...restProps
  } = _ref6;
  const [rootElement, setRootElement] = React.useState();
  const contextValue = React.useMemo(() => ({
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus
  }), [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]);
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.ConnectorContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.Tracker, {
      children: /* @__PURE__ */jsxRuntime.jsxs(TransformPatches.ScrollContainer, {
        ...restProps,
        ref: setRootElement,
        className,
        children: [children, rootElement && /* @__PURE__ */jsxRuntime.jsx(ConnectorsOverlay, {
          rootElement,
          onSetFocus
        })]
      })
    })
  });
}
function DisabledChangeConnectorRoot(_ref7) {
  let {
    children,
    className
  } = _ref7;
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.ScrollContainer, {
    className,
    children
  });
}
const ChangeConnectorRoot = EnabledChangeConnectorRoot;
function BetaBadge(props) {
  const {
    fontSize = 1,
    children = "Beta",
    ...rest
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Badge, {
    ...rest,
    fontSize,
    radius: 2,
    tone: "primary",
    children
  });
}
function Favicons(_ref8) {
  let {
    basePath
  } = _ref8;
  const base = "".concat(basePath.replace(/\/+$/, ""), "/static");
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/* @__PURE__ */jsxRuntime.jsx("link", {
      rel: "icon",
      href: "".concat(base, "/favicon.ico"),
      sizes: "any"
    }), /* @__PURE__ */jsxRuntime.jsx("link", {
      rel: "icon",
      href: "".concat(base, "/favicon.svg"),
      type: "image/svg+xml"
    }), /* @__PURE__ */jsxRuntime.jsx("link", {
      rel: "apple-touch-icon",
      href: "".concat(base, "/apple-touch-icon.png")
    }), /* @__PURE__ */jsxRuntime.jsx("link", {
      rel: "manifest",
      href: "".concat(base, "/manifest.webmanifest")
    })]
  });
}
const errorHandlerScript = "\n;(function () {\n  var _caughtErrors = []\n\n  var errorChannel = (function () {\n    var subscribers = []\n\n    function publish(msg) {\n      for (var i = 0; i < subscribers.length; i += 1) {\n        subscribers[i](msg)\n      }\n    }\n\n    function subscribe(subscriber) {\n      subscribers.push(subscriber)\n\n      return function () {\n        var idx = subscribers.indexOf(subscriber)\n\n        if (idx > -1) {\n          subscribers.splice(idx, 1)\n        }\n      }\n    }\n\n    return {publish, subscribe, subscribers}\n  })()\n\n  // NOTE: Store the error channel instance in the global scope so that the Studio application can\n  // access it and subscribe to errors.\n  window.__sanityErrorChannel = {\n    subscribe: errorChannel.subscribe,\n  }\n\n  function _nextTick(callback) {\n    setTimeout(callback, 0)\n  }\n\n  function _handleError(error, params) {\n    _nextTick(function () {\n      // - If there are error channel subscribers, then we notify them (no console error).\n      // - If there are no subscribers, then we log the error to the console and render the error overlay.\n      if (errorChannel.subscribers.length) {\n        errorChannel.publish({error, params})\n      } else {\n        console.error(error)\n\n        _renderErrorOverlay(error, params)\n      }\n    })\n  }\n\n  var ERROR_BOX_STYLE = [\n    'background: #fff',\n    'border-radius: 6px',\n    'box-sizing: border-box',\n    'color: #121923',\n    'flex: 1',\n    \"font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif\",\n    'font-size: 16px',\n    'line-height: 21px',\n    'margin: 0 auto',\n    'max-width: 960px',\n    'overflow: auto',\n    'padding: 20px',\n    'width: 100%',\n  ].join(';')\n\n  var ERROR_CODE_STYLE = [\n    'color: #972E2A',\n    \"font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace\",\n    'font-size: 13px',\n    'line-height: 17px',\n    'margin: 0',\n  ].join(';')\n\n  function _renderErrorOverlay(error, params) {\n    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')\n    var colno = params.event.colno\n    var lineno = params.event.lineno\n    var filename = params.event.filename\n\n    errorElement.id = '__sanityError'\n    errorElement.innerHTML = [\n      '<div style=\"' + ERROR_BOX_STYLE + '\">',\n      '<div style=\"font-weight: 700;\">Uncaught error: ' + error.message + '</div>',\n      '<div style=\"color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;\">' +\n        filename +\n        ':' +\n        lineno +\n        ':' +\n        colno +\n        '</div>',\n      '<pre style=\"' + ERROR_CODE_STYLE + '\">' + error.stack + '</pre>',\n      '</div>',\n    ].join('')\n\n    errorElement.style.position = 'fixed'\n    errorElement.style.zIndex = 1000000\n    errorElement.style.top = 0\n    errorElement.style.left = 0\n    errorElement.style.right = 0\n    errorElement.style.bottom = 0\n    errorElement.style.padding = '20px'\n    errorElement.style.background = 'rgba(16,17,18,0.66)'\n    errorElement.style.display = 'flex'\n    errorElement.style.alignItems = 'center'\n    errorElement.style.justifyContent = 'center'\n\n    document.body.appendChild(errorElement)\n  }\n\n  // NOTE:\n  // Yes \u2013 we're attaching 2 error listeners below \u{1F440}\n  // This is because React makes the same error throw twice (in development mode).\n  // See: https://github.com/facebook/react/issues/10384\n\n  // Error listener #1\n  window.onerror = function (event, source, lineno, colno, error) {\n    _nextTick(function () {\n      if (_caughtErrors.indexOf(error) !== -1) return\n\n      _caughtErrors.push(error)\n\n      _handleError(error, {\n        event,\n        lineno,\n        colno,\n        source,\n      })\n\n      _nextTick(function () {\n        var idx = _caughtErrors.indexOf(error)\n\n        if (idx > -1) _caughtErrors.splice(idx, 1)\n      })\n    })\n\n    // IMPORTANT: this callback must return `true` to prevent the error from being rendered in\n    // the browser\u2019s console.\n    return true\n  }\n\n  // Error listener #2\n  window.addEventListener('error', function (event) {\n    if (_caughtErrors.indexOf(event.error) !== -1) return true\n\n    _caughtErrors.push(event.error)\n\n    _handleError(event.error, {\n      event,\n      lineno: event.lineno,\n      colno: event.colno,\n    })\n\n    _nextTick(function () {\n      _nextTick(function () {\n        var idx = _caughtErrors.indexOf(event.error)\n\n        if (idx > -1) _caughtErrors.splice(idx, 1)\n      })\n    })\n\n    return true\n  })\n})()\n";
function GlobalErrorHandler() {
  return /* @__PURE__ */jsxRuntime.jsx("script", {
    dangerouslySetInnerHTML: {
      __html: errorHandlerScript
    }
  });
}
const NoJsStyles = "\n.sanity-app-no-js__root {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background: #fff;\n}\n\n.sanity-app-no-js__content {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  font-family: helvetica, arial, sans-serif;\n}\n";
function NoJavascript() {
  return /* @__PURE__ */jsxRuntime.jsx("noscript", {
    children: /* @__PURE__ */jsxRuntime.jsx("div", {
      className: "sanity-app-no-js__root",
      children: /* @__PURE__ */jsxRuntime.jsxs("div", {
        className: "sanity-app-no-js__content",
        children: [/* @__PURE__ */jsxRuntime.jsx("style", {
          type: "text/css",
          children: NoJsStyles
        }), /* @__PURE__ */jsxRuntime.jsx("h1", {
          children: "JavaScript disabled"
        }), /* @__PURE__ */jsxRuntime.jsxs("p", {
          children: ["Please ", /* @__PURE__ */jsxRuntime.jsx("a", {
            href: "https://www.enable-javascript.com/",
            children: "enable JavaScript"
          }), " in your browser and reload the page to proceed."]
        })]
      })
    })
  });
}
const globalStyles = '\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 400;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 400;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 500;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 500;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 600;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 600;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 700;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 700;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 800;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 800;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: normal;\n    font-weight: 900;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");\n  }\n  @font-face {\n    font-family: Inter;\n    font-style: italic;\n    font-weight: 900;\n    font-display: swap;\n    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");\n  }\n  html {\n    background-color: #f1f3f6;\n  }\n  html,\n  body,\n  #sanity {\n    height: 100%;\n  }\n  body {\n    margin: 0;\n    -webkit-font-smoothing: antialiased;\n  }\n';
const EMPTY_ARRAY$1 = [];
function DefaultDocument(props) {
  const {
    entryPath,
    css = EMPTY_ARRAY$1,
    basePath = "/"
  } = props;
  return /* @__PURE__ */jsxRuntime.jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */jsxRuntime.jsxs("head", {
      children: [/* @__PURE__ */jsxRuntime.jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */jsxRuntime.jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */jsxRuntime.jsx("meta", {
        name: "robots",
        content: "noindex"
      }), /* @__PURE__ */jsxRuntime.jsx("meta", {
        name: "referrer",
        content: "same-origin"
      }), /* @__PURE__ */jsxRuntime.jsx(Favicons, {
        basePath
      }), /* @__PURE__ */jsxRuntime.jsx("title", {
        children: "Sanity Studio"
      }), /* @__PURE__ */jsxRuntime.jsx(GlobalErrorHandler, {}), css.map(href => /* @__PURE__ */jsxRuntime.jsx("link", {
        rel: "stylesheet",
        href
      }, href)), /* @__PURE__ */jsxRuntime.jsx("style", {
        dangerouslySetInnerHTML: {
          __html: globalStyles
        }
      })]
    }), /* @__PURE__ */jsxRuntime.jsxs("body", {
      children: [/* @__PURE__ */jsxRuntime.jsx("div", {
        id: "sanity"
      }), /* @__PURE__ */jsxRuntime.jsx("script", {
        type: "module",
        src: entryPath
      }), /* @__PURE__ */jsxRuntime.jsx(NoJavascript, {})]
    })]
  });
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return defineConfig(config);
}
function validatePlugin(pluginResult) {
  const messages = ["projectId" in pluginResult && "`projectId` not allowed in plugin configuration", "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"].filter(isString__default.default);
  if (messages.length) throw new Error("Invalid plugin configuration:\n".concat(messages.map(message => "	".concat(message)).join("\n")));
}
function definePlugin(arg) {
  if (typeof arg === "function") {
    const pluginFactory = arg;
    return options => {
      const result = pluginFactory(options);
      validatePlugin(result);
      return result;
    };
  }
  validatePlugin(arg);
  return () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
function defineDocumentInspector(inspector) {
  return inspector;
}
function createMockAuthStore(_ref9) {
  let {
    client,
    currentUser = null
  } = _ref9;
  return {
    state: rxjs.of({
      authenticated: true,
      client,
      currentUser
    })
  };
}
function isEqual(item, otherItem) {
  if (item === otherItem) {
    return true;
  }
  if (typeof item !== typeof otherItem) {
    return false;
  }
  if (typeof item !== "object" && !Array.isArray(item)) {
    return item === otherItem;
  }
  if (types.isKeyedObject(item) && types.isKeyedObject(otherItem) && item._key === otherItem._key) {
    return true;
  }
  if (Array.isArray(item) && Array.isArray(otherItem)) {
    if (item.length !== otherItem.length) {
      return false;
    }
    return item.every((child, i) => isEqual(child, otherItem[i]));
  }
  if (item === null || otherItem === null) {
    return item === otherItem;
  }
  const obj = item;
  const otherObj = otherItem;
  const keys = Object.keys(obj);
  const otherKeys = Object.keys(otherObj);
  if (keys.length !== otherKeys.length) {
    return false;
  }
  return keys.every(keyName => isEqual(obj[keyName], otherObj[keyName]));
}
const ArrayOfOptionsFieldDiff = _ref10 => {
  let {
    diff,
    schemaType
  } = _ref10;
  var _a;
  const options = (_a = schemaType.options) == null ? void 0 : _a.list;
  const colorManager = TransformPatches.useUserColorManager();
  const {
    t
  } = TransformPatches.useTranslation();
  if (!Array.isArray(options)) {
    return null;
  }
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    children: diff.items.map(item => normalizeItems(item, diff, schemaType)).filter(item => item !== null).sort(sortItems).map((item, index) => {
      const {
        annotation,
        isPresent,
        value,
        memberType,
        title
      } = item;
      const color = TransformPatches.getAnnotationColor(colorManager, annotation);
      const action = isPresent ? t("changes.added-label") : t("changes.removed-label");
      return /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        align: "center",
        children: [/* @__PURE__ */jsxRuntime.jsx(TransformPatches.DiffTooltip, {
          annotations: annotation ? [annotation] : [],
          description: action,
          children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
            align: "center",
            children: [/* @__PURE__ */jsxRuntime.jsx(TransformPatches.Checkbox, {
              checked: !isPresent,
              color
            }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              margin: 2,
              children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.FromToArrow, {})
            }), /* @__PURE__ */jsxRuntime.jsx(TransformPatches.Checkbox, {
              checked: isPresent,
              color
            })]
          })
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
          align: "center",
          children: /* @__PURE__ */jsxRuntime.jsx(ItemPreview, {
            value: title || value,
            memberType
          })
        })]
      }, getItemKey(diff, index));
    })
  });
};
function normalizeItems(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged") {
    return null;
  }
  const {
    fromValue,
    toValue
  } = parentDiff;
  const value = getValue(item.diff);
  const wasPresent = isInArray(value, fromValue);
  const isPresent = isInArray(value, toValue);
  if (wasPresent === isPresent) {
    return null;
  }
  return {
    title: getItemTitle(value, schemaType),
    memberType: resolveMemberType(getValue(item.diff), schemaType),
    itemIndex: getOptionIndex(value, schemaType),
    annotation: item.annotation,
    isPresent,
    value
  };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview(_ref11) {
  let {
    value,
    memberType
  } = _ref11;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
    marginX: 2,
    marginY: 1,
    children: typeof value === "string" || typeof value === "number" ? value : /* @__PURE__ */jsxRuntime.jsx(TransformPatches.Preview, {
      schemaType: memberType,
      value,
      layout: "default"
    })
  });
}
function isInArray(value, parent) {
  const array = parent || [];
  return typeof value === "object" && value !== null ? array.some(item => isEqual(item, value)) : array.includes(value);
}
function getItemKey(diff, index) {
  const value = diff.toValue || diff.fromValue;
  return types.isKeyedObject(value) ? value._key : index;
}
function getValue(diff) {
  return typeof diff.toValue === "undefined" ? diff.fromValue : diff.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find(memberType => memberType.name === itemTypeName);
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object") {
    return jsType;
  }
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isNamedOption(item) {
  return typeof item === "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [];
  return list.findIndex(opt => isEqual(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a;
  const list = ((_a = schemaType.options) == null ? void 0 : _a.list) || [];
  const index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
const SlugFieldDiff = _ref12 => {
  let {
    diff,
    schemaType
  } = _ref12;
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.DiffFromTo, {
    layout: "inline",
    diff,
    schemaType,
    previewComponent: TransformPatches.SlugPreview
  });
};
const UrlFieldDiff = _ref13 => {
  let {
    diff,
    schemaType
  } = _ref13;
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.DiffFromTo, {
    diff,
    schemaType,
    previewComponent: TransformPatches.StringPreview
  });
};
const diffResolver = _ref14 => {
  let {
    schemaType
  } = _ref14;
  var _a;
  if (["datetime", "date"].includes(schemaType.name)) {
    return TransformPatches.DatetimeFieldDiff;
  }
  if (schemaType.name === "url") {
    return UrlFieldDiff;
  }
  if (schemaType.name === "slug") {
    return SlugFieldDiff;
  }
  if (schemaType.jsonType === "array" && Array.isArray((_a = schemaType.options) == null ? void 0 : _a.list)) {
    return ArrayOfOptionsFieldDiff;
  }
  return void 0;
};
function HoveredFieldProvider(props) {
  const {
    children
  } = props;
  const [hoveredStack, setHoveredStack] = React.useState([]);
  const handleMouseEnter = React.useCallback(path => {
    const pathString = TransformPatches.pathToString(path);
    setHoveredStack(prev => {
      if (prev.includes(pathString)) {
        return prev;
      }
      return [pathString, ...prev];
    });
  }, []);
  const handleMouseLeave = React.useCallback(path => {
    const pathString = TransformPatches.pathToString(path);
    setHoveredStack(prev => {
      if (prev.includes(pathString)) {
        return prev.filter(item => item !== pathString);
      }
      return prev;
    });
  }, []);
  const context = React.useMemo(() => ({
    hoveredStack,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), [handleMouseEnter, handleMouseLeave, hoveredStack]);
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.HoveredFieldContext.Provider, {
    value: context,
    children
  });
}
const EMPTY_ARRAY = [];
function trimChildPath(path, childPath) {
  return PathUtils__namespace.startsWith(path, childPath) ? PathUtils__namespace.trimLeft(path, childPath) : EMPTY_ARRAY;
}
function PresenceScope(props) {
  const {
    readOnly,
    path,
    children
  } = props;
  const contextPresence = React.useContext(TransformPatches.FormFieldPresenceContext);
  const childPresence = React.useMemo(() => {
    return readOnly ? EMPTY_ARRAY : (contextPresence || EMPTY_ARRAY).filter(presence => {
      return PathUtils__namespace.startsWith(path, presence.path);
    }).map(presence => ({
      ...presence,
      path: trimChildPath(path, presence.path)
    }));
  }, [contextPresence, path, readOnly]);
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.FormFieldPresenceContext.Provider, {
    value: childPresence,
    children
  });
}
function createPatchChannel() {
  const _subscribers = [];
  return {
    publish(msg) {
      for (const subscriber of _subscribers) {
        subscriber(msg);
      }
    },
    subscribe(subscriber) {
      _subscribers.push(subscriber);
      return () => {
        const idx = _subscribers.indexOf(subscriber);
        if (idx > -1) {
          _subscribers.splice(idx, 1);
        }
      };
    }
  };
}
function ArrayOfObjectsInputMember(props) {
  const {
    member,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview
  } = props;
  if (member.kind === "item") {
    return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.ArrayOfObjectsItem, {
      member,
      renderAnnotation,
      renderBlock,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem,
      renderPreview
    }, member.key);
  }
  if (member.kind === "error") {
    return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.MemberItemError, {
      member
    }, member.key);
  }
  console.warn(new Error("Unhandled member kind ".concat(member.kind)));
  return null;
}
function ArrayOfObjectsInputMembers(props) {
  const {
    members,
    ...rest
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: members.map(member => /* @__PURE__ */jsxRuntime.jsx(ArrayOfObjectsInputMember, {
      member,
      ...rest
    }, member.key))
  });
}
function useReviewChanges() {
  const reviewChanges = React.useContext(TransformPatches.ReviewChangesContext);
  if (!reviewChanges) {
    throw new Error("Review changes: missing context value");
  }
  return reviewChanges;
}
const defaultRenderAnnotation = props => {
  return React.createElement(TransformPatches.defaultResolveAnnotationComponent(props.schemaType), props);
};
const defaultRenderBlock = props => {
  return React.createElement(TransformPatches.defaultResolveBlockComponent(props.schemaType), props);
};
const defaultRenderInlineBlock = props => {
  return React.createElement(TransformPatches.defaultResolveInlineBlockComponent(props.schemaType), props);
};
const defaultRenderField = props => {
  return React.createElement(TransformPatches.defaultResolveFieldComponent(props.schemaType), props);
};
const defaultRenderInput = props => {
  return React.createElement(TransformPatches.defaultResolveInputComponent(props.schemaType), props);
};
const defaultRenderItem = props => {
  return React.createElement(TransformPatches.defaultResolveItemComponent(props.schemaType), props);
};
const defaultRenderPreview = props => {
  return React.createElement(TransformPatches.Preview, props);
};
function DefaultCustomMarkers() {
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
    size: 1,
    children: ["This is a example custom marker, please implement ", /* @__PURE__ */jsxRuntime.jsx("code", {
      children: "renderCustomMarkers"
    }), " function."]
  });
}
const missingPatchChannel = {
  publish: () => void 0,
  subscribe: () => {
    console.warn("No patch channel provided to form-builder. If you need input based patch updates, please provide one");
    return () => void 0;
  }
};
function FormBuilderProvider(props) {
  const {
    __internal_fieldActions: fieldActions = TransformPatches.EMPTY_ARRAY,
    __internal_patchChannel: patchChannel = missingPatchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    file,
    filterField,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onFieldGroupSelect,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    unstable,
    validation
  } = props;
  const __internal = React.useMemo(() => ({
    patchChannel,
    // eslint-disable-line camelcase
    components: {
      ArrayFunctions: TransformPatches.ArrayOfObjectsFunctions,
      CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers,
      Markers: (unstable == null ? void 0 : unstable.Markers) || TransformPatches.DefaultMarkers
    },
    field: {
      actions: fieldActions
    },
    file: {
      assetSources: file.assetSources,
      directUploads: (file == null ? void 0 : file.directUploads) !== false
    },
    filterField: filterField || (() => true),
    image: {
      assetSources: image.assetSources,
      directUploads: (image == null ? void 0 : image.directUploads) !== false
    },
    onChange
  }), [fieldActions, file.assetSources, file == null ? void 0 : file.directUploads, filterField, image.assetSources, image == null ? void 0 : image.directUploads, onChange, patchChannel, unstable == null ? void 0 : unstable.CustomMarkers, unstable == null ? void 0 : unstable.Markers]);
  const formBuilder = React.useMemo(() => ({
    __internal,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType
  }), [__internal, autoFocus, changesOpen, collapsedFieldSets, collapsedPaths, focusPath, focused, groups, id, readOnly, renderAnnotation, renderBlock, renderField, renderInlineBlock, renderInput, renderItem, renderPreview, schemaType]);
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.FormBuilderContext.Provider, {
    value: formBuilder,
    children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.FormCallbacksProvider, {
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.DocumentIdProvider, {
        id,
        children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.PresenceProvider, {
          presence,
          children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.ValidationProvider, {
            validation,
            children: /* @__PURE__ */jsxRuntime.jsx(HoveredFieldProvider, {
              children
            })
          })
        })
      })
    })
  });
}
function FormProvider(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    schemaType,
    validation
  } = props;
  const {
    file,
    image
  } = TransformPatches.useSource().form;
  const Input = TransformPatches.useInputComponent();
  const Field = TransformPatches.useFieldComponent();
  const Preview = TransformPatches.usePreviewComponent();
  const Item = TransformPatches.useItemComponent();
  const Block = TransformPatches.useBlockComponent();
  const InlineBlock = TransformPatches.useInlineBlockComponent();
  const Annotation = TransformPatches.useAnnotationComponent();
  const renderInput = React.useCallback(inputProps => /* @__PURE__ */jsxRuntime.jsx(Input, {
    ...inputProps
  }), [Input]);
  const renderField = React.useCallback(fieldProps => /* @__PURE__ */jsxRuntime.jsx(Field, {
    ...fieldProps
  }), [Field]);
  const renderItem = React.useCallback(itemProps => /* @__PURE__ */jsxRuntime.jsx(Item, {
    ...itemProps
  }), [Item]);
  const renderPreview = React.useCallback(previewProps => /* @__PURE__ */jsxRuntime.jsx(TransformPatches.PreviewLoader, {
    component: Preview,
    ...previewProps
  }), [Preview]);
  const renderBlock = React.useCallback(blockProps => /* @__PURE__ */jsxRuntime.jsx(Block, {
    ...blockProps
  }), [Block]);
  const renderInlineBlock = React.useCallback(blockProps => /* @__PURE__ */jsxRuntime.jsx(InlineBlock, {
    ...blockProps
  }), [InlineBlock]);
  const renderAnnotation = React.useCallback(annotationProps => /* @__PURE__ */jsxRuntime.jsx(Annotation, {
    ...annotationProps
  }), [Annotation]);
  return /* @__PURE__ */jsxRuntime.jsx(FormBuilderProvider, {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    file,
    focusPath,
    focused,
    groups,
    id,
    image,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation,
    children
  });
}
function FormBuilder(props) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    members,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    schemaType,
    validation,
    value
  } = props;
  const handleCollapseField = React.useCallback(fieldName => onSetPathCollapsed([fieldName], true), [onSetPathCollapsed]);
  const handleExpandField = React.useCallback(fieldName => onSetPathCollapsed([fieldName], false), [onSetPathCollapsed]);
  const handleBlur = React.useCallback(() => onPathBlur(TransformPatches.EMPTY_ARRAY), [onPathBlur]);
  const handleFocus = React.useCallback(() => onPathFocus(TransformPatches.EMPTY_ARRAY), [onPathFocus]);
  const handleChange = React.useCallback(patch => onChange(TransformPatches.PatchEvent.from(patch)), [onChange]);
  const focusRef = React.useRef(null);
  const handleSelectFieldGroup = React.useCallback(groupName => onFieldGroupSelect(TransformPatches.EMPTY_ARRAY, groupName), [onFieldGroupSelect]);
  const handleOpenField = React.useCallback(fieldName => onPathOpen([fieldName]), [onPathOpen]);
  const handleCloseField = React.useCallback(() => onPathOpen([]), [onPathOpen]);
  const handleCollapseFieldSet = React.useCallback(fieldSetName => onSetFieldSetCollapsed([fieldSetName], true), [onSetFieldSetCollapsed]);
  const handleExpandFieldSet = React.useCallback(fieldSetName => onSetFieldSetCollapsed([fieldSetName], false), [onSetFieldSetCollapsed]);
  const Input = TransformPatches.useInputComponent();
  const Field = TransformPatches.useFieldComponent();
  const Preview = TransformPatches.usePreviewComponent();
  const Item = TransformPatches.useItemComponent();
  const Block = TransformPatches.useBlockComponent();
  const InlineBlock = TransformPatches.useInlineBlockComponent();
  const Annotation = TransformPatches.useAnnotationComponent();
  const renderInput = React.useCallback(inputProps => /* @__PURE__ */jsxRuntime.jsx(Input, {
    ...inputProps
  }), [Input]);
  const renderField = React.useCallback(fieldProps => /* @__PURE__ */jsxRuntime.jsx(Field, {
    ...fieldProps
  }), [Field]);
  const renderItem = React.useCallback(itemProps => /* @__PURE__ */jsxRuntime.jsx(Item, {
    ...itemProps
  }), [Item]);
  const renderPreview = React.useCallback(previewProps => /* @__PURE__ */jsxRuntime.jsx(TransformPatches.PreviewLoader, {
    component: Preview,
    ...previewProps
  }), [Preview]);
  const renderBlock = React.useCallback(blockProps => /* @__PURE__ */jsxRuntime.jsx(Block, {
    ...blockProps
  }), [Block]);
  const renderInlineBlock = React.useCallback(blockProps => /* @__PURE__ */jsxRuntime.jsx(InlineBlock, {
    ...blockProps
  }), [InlineBlock]);
  const renderAnnotation = React.useCallback(annotationProps => /* @__PURE__ */jsxRuntime.jsx(Annotation, {
    ...annotationProps
  }), [Annotation]);
  const rootInputProps = {
    focusPath,
    elementProps: {
      ref: focusRef,
      id,
      onBlur: handleBlur,
      onFocus: handleFocus,
      "aria-describedby": void 0
      // Root input should not have any aria-describedby
    },
    changed: members.some(m => m.kind === "field" && m.field.changed),
    focused,
    groups,
    id,
    level: 0,
    members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onPathFocus,
    onFieldOpen: handleOpenField,
    onFieldGroupSelect: handleSelectFieldGroup,
    path: TransformPatches.EMPTY_ARRAY,
    presence: TransformPatches.EMPTY_ARRAY,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem,
    renderPreview,
    schemaType,
    validation: TransformPatches.EMPTY_ARRAY,
    value
  };
  return /* @__PURE__ */jsxRuntime.jsx(FormProvider, {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    validation,
    readOnly,
    schemaType,
    children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.GetFormValueProvider, {
      value,
      children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.FormValueProvider, {
        value,
        children: /* @__PURE__ */jsxRuntime.jsx(TransformPatches.DocumentFieldActionsProvider, {
          actions: fieldActions,
          children: renderInput(rootInputProps)
        })
      })
    })
  });
}
const remoteSnapshots = TransformPatches.memoize((client, idPair, typeName) => {
  return TransformPatches.memoizedPair(client, idPair, typeName).pipe(operators.switchMap(_ref15 => {
    let {
      published,
      draft
    } = _ref15;
    return rxjs.merge(published.remoteSnapshot$, draft.remoteSnapshot$);
  }));
}, TransformPatches.memoizeKeyGen);
function maybeSerialize(template) {
  return TransformPatches.isBuilder(template) ? template.serialize() : template;
}
function isNonNullable(t) {
  return !!t;
}
function prepareTemplates(schema, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return TransformPatches.validateTemplates(schema, serialized);
}
function defaultTemplateForType(schemaType) {
  return {
    id: schemaType.name,
    schemaType: schemaType.name,
    title: schemaType.title || schemaType.name,
    icon: schemaType.icon,
    value: schemaType.initialValue || {
      _type: schemaType.name
    }
  };
}
function defaultTemplatesForSchema(schema) {
  const schemaTypes = schema.getTypeNames().filter(typeName => !/^sanity\./.test(typeName)).map(typeName => schema.get(typeName)).filter(isNonNullable).filter(schemaType => {
    var _a;
    return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
  });
  return prepareTemplates(schema, schemaTypes.map(schemaType => defaultTemplateForType(schemaType)));
}
const LOADING_STATE = {
  isLoaded: false,
  documentType: void 0
};
function useDocumentType(documentId) {
  let specifiedType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
  const documentStore = TransformPatches.useDocumentStore();
  const publishedId = TransformPatches.getPublishedId(documentId);
  const isResolved = Boolean(specifiedType && specifiedType !== "*");
  const SYNC_RESOLVED_STATE = React.useMemo(() => ({
    documentType: specifiedType,
    isLoaded: true
  }), [specifiedType]);
  const [resolvedState, setDocumentType] = React.useState(isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE);
  React.useEffect(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]);
  React.useEffect(() => {
    if (isResolved) {
      return void 0;
    }
    const sub = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe(documentType => setDocumentType({
      documentType,
      isLoaded: true
    }));
    return () => sub.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]);
  return isResolved ?
  // `isResolved` is only true when we're _synchronously_ resolved
  SYNC_RESOLVED_STATE :
  // Using the document type resolved from the API
  resolvedState;
}
function useTimelineSelector(timelineStore, selector) {
  return withSelector.useSyncExternalStoreWithSelector(timelineStore.subscribe, timelineStore.getSnapshot, null, selector);
}
const INITIAL_TIMELINE_STATE = {
  chunks: [],
  diff: null,
  hasMoreChunks: null,
  isLoading: false,
  isPristine: null,
  lastNonDeletedRevId: null,
  onOlderRevision: false,
  realRevChunk: null,
  revTime: null,
  selectionState: "inactive",
  sinceAttributes: null,
  sinceTime: null,
  timelineDisplayed: null,
  timelineReady: false
};
function useTimelineStore(_ref16) {
  let {
    documentId,
    documentType,
    onError,
    rev,
    since
  } = _ref16;
  const historyStore = TransformPatches.useHistoryStore();
  const snapshotsSubscriptionRef = React.useRef(null);
  const timelineStateRef = React.useRef(INITIAL_TIMELINE_STATE);
  const client = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const controller = React.useMemo(() => historyStore.getTimelineController({
    client,
    documentId,
    documentType
  }), [client, documentId, documentType, historyStore]);
  const timelineController$ = React.useMemo(() => new rxjs.BehaviorSubject(controller), [controller]);
  React.useEffect(() => {
    controller.setRange(since || null, rev || null);
    timelineController$.next(controller);
    controller.handler = (err, innerController) => {
      if (err) {
        timelineController$.error(err);
      } else {
        setTimeout(() => {
          innerController.setRange(since || null, rev || null);
          timelineController$.next(innerController);
        }, 0);
      }
    };
    controller.resume();
    return () => controller.suspend();
  }, [rev, since, controller, timelineController$]);
  React.useEffect(() => {
    if (!snapshotsSubscriptionRef.current) {
      snapshotsSubscriptionRef.current = remoteSnapshots(client, {
        draftId: "drafts.".concat(documentId),
        publishedId: documentId
      }, documentType).subscribe(ev => {
        controller.handleRemoteMutation(ev);
      });
    }
    return () => {
      if (snapshotsSubscriptionRef.current) {
        snapshotsSubscriptionRef.current.unsubscribe();
        snapshotsSubscriptionRef.current = null;
      }
    };
  }, [client, controller, documentId, documentType]);
  const timelineStore = React.useMemo(() => {
    return {
      findRangeForRev: chunk => controller.findRangeForNewRev(chunk),
      findRangeForSince: chunk => controller.findRangeForNewSince(chunk),
      loadMore: () => {
        controller.setLoadMore(true);
        timelineStateRef.current.isLoading = true;
      },
      getSnapshot: () => timelineStateRef.current,
      subscribe: callback => {
        const subscription = timelineController$.pipe(
        // Manually stop loading transactions in TimelineController, otherwise transaction history
        // will continue to be fetched – even if unwanted.
        rxjs.tap(innerController => innerController.setLoadMore(false)), rxjs.map(innerController => {
          var _a;
          const chunks = innerController.timeline.mapChunks(c => c);
          const lastNonDeletedChunk = chunks.filter(chunk => !["delete", "initial"].includes(chunk.type));
          const hasMoreChunks = !innerController.timeline.reachedEarliestEntry;
          const timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return {
            chunks,
            diff: innerController.sinceTime ? innerController.currentObjectDiff() : null,
            isLoading: false,
            isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === false : null,
            hasMoreChunks: !innerController.timeline.reachedEarliestEntry,
            lastNonDeletedRevId: (_a = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a.id,
            onOlderRevision: innerController.onOlderRevision(),
            realRevChunk: innerController.realRevChunk,
            revTime: innerController.revTime,
            selectionState: innerController.selectionState,
            sinceAttributes: innerController.sinceAttributes(),
            sinceTime: innerController.sinceTime,
            timelineDisplayed: innerController.displayed(),
            timelineReady
          };
        }),
        // Only emit (and in turn, re-render) when values have changed
        rxjs.distinctUntilChanged(deepCompare__default.default),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        rxjs.catchError(err => {
          onError == null ? void 0 : onError(err);
          return rxjs.of(INITIAL_TIMELINE_STATE);
        }), rxjs.tap(timelineState => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        rxjs.tap(callback)).subscribe();
        return () => subscription.unsubscribe();
      }
    };
  }, [controller, onError, timelineController$]);
  return timelineStore;
}
function useProject() {
  const projectStore = TransformPatches.useProjectStore();
  const [value, setValue] = React.useState(null);
  React.useEffect(() => {
    const project$ = projectStore.get();
    const sub = project$.subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]);
  return {
    value
  };
}
function useProjectDatasets() {
  const projectStore = TransformPatches.useProjectStore();
  const [value, setValue] = React.useState(null);
  React.useEffect(() => {
    const project$ = projectStore.getDatasets();
    const sub = project$.subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]);
  return {
    value
  };
}
function resolveConfig(config) {
  const {
    workspaces
  } = TransformPatches.prepareConfig(config);
  return rxjs.combineLatest(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  workspaces.flatMap(workspaceSummary => rxjs.combineLatest(workspaceSummary.__internal.sources.map(_ref17 => {
    let {
      source
    } = _ref17;
    return source;
  })).pipe(operators.map(sources => ({
    ...workspaceSummary,
    ...sources[0],
    unstable_sources: sources,
    type: "workspace"
  })))));
}
async function createWorkspaceFromConfig(options) {
  const client = "getClient" in options ? options.getClient({
    apiVersion: "2023-11-13"
  }) : void 0;
  const [workspace] = await rxjs.firstValueFrom(resolveConfig({
    ...options,
    ...(client && "currentUser" in options && {
      auth: createMockAuthStore({
        ...options,
        client
      })
    })
  }));
  return workspace;
}
async function createSourceFromConfig(options) {
  const workspace = await createWorkspaceFromConfig(options);
  return workspace.unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  } = source;
  return React.useMemo(() => {
    return {
      projectId,
      dataset,
      schema,
      currentUser,
      getClient,
      i18n
    };
  }, [projectId, dataset, schema, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  } = source;
  return {
    projectId,
    dataset,
    schema,
    currentUser,
    getClient,
    i18n
  };
}
const API_VERSION = "v2023-11-13";
function AddonDatasetProvider(props) {
  const {
    children
  } = props;
  const {
    dataset,
    projectId
  } = TransformPatches.useWorkspace();
  const originalClient = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [addonDatasetClient, setAddonDatasetClient] = React.useState(null);
  const [isCreatingDataset, setIsCreatingDataset] = React.useState(false);
  const getAddonDatasetName = React.useCallback(async () => {
    var _a;
    const res = await originalClient.withConfig({
      apiVersion: API_VERSION
    }).request({
      uri: "/projects/".concat(projectId, "/datasets?datasetProfile=comments&addonFor=").concat(dataset),
      tag: "sanity.studio"
    });
    return (_a = res == null ? void 0 : res[0]) == null ? void 0 : _a.name;
  }, [dataset, originalClient, projectId]);
  const handleCreateClient = React.useCallback(addonDatasetName => {
    const client = originalClient.withConfig({
      apiVersion: API_VERSION,
      dataset: addonDatasetName,
      projectId,
      requestTagPrefix: "sanity.studio",
      useCdn: false,
      withCredentials: true
    });
    return client;
  }, [originalClient, projectId]);
  const handleCreateAddonDataset = React.useCallback(async () => {
    setIsCreatingDataset(true);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client = handleCreateClient(addonDatasetName);
        setAddonDatasetClient(client);
        setIsCreatingDataset(false);
        return client;
      }
    } catch (_) {}
    try {
      const res = await originalClient.withConfig({
        apiVersion: API_VERSION
      }).request({
        uri: "/comments/".concat(dataset, "/setup"),
        method: "POST"
      });
      const datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName) {
        setIsCreatingDataset(false);
        return null;
      }
      const client = handleCreateClient(datasetName);
      setAddonDatasetClient(client);
      return client;
    } catch (err) {
      throw err;
    } finally {
      setIsCreatingDataset(false);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  React.useEffect(() => {
    getAddonDatasetName().then(addonDatasetName => {
      if (!addonDatasetName) return;
      const client = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = React.useMemo(() => ({
    client: addonDatasetClient,
    createAddonDataset: handleCreateAddonDataset,
    isCreatingDataset
  }), [addonDatasetClient, handleCreateAddonDataset, isCreatingDataset]);
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.AddonDatasetContext.Provider, {
    value: ctxValue,
    children
  });
}
function useAddonDataset() {
  const ctx = React.useContext(TransformPatches.AddonDatasetContext);
  if (!ctx) {
    throw new Error("useAddonDataset: missing context value");
  }
  return ctx;
}
function StudioLogo(props) {
  const {
    title
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
    padding: 3,
    "data-testid": "studio-logo",
    children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
      weight: "medium",
      children: title
    })
  });
}
function _buildTints(bg, mid, fg) {
  return {
    50: polished.mix(0.1, mid, bg),
    100: polished.mix(0.2, mid, bg),
    200: polished.mix(0.4, mid, bg),
    300: polished.mix(0.6, mid, bg),
    400: polished.mix(0.8, mid, bg),
    500: mid,
    600: polished.mix(0.8, mid, fg),
    700: polished.mix(0.6, mid, fg),
    800: polished.mix(0.4, mid, fg),
    900: polished.mix(0.2, mid, fg),
    950: polished.mix(0.1, mid, fg)
  };
}
function _toHex(color) {
  const {
    red,
    green,
    blue
  } = polished.parseToRgb(color);
  return polished.rgb(red, green, blue);
}
function _isDark(bg, fg) {
  return polished.getLuminance(bg) < polished.getLuminance(fg);
}
function _multiply(bg, fg) {
  const b = theme.parseColor(bg);
  const s = theme.parseColor(fg);
  const hex = theme.rgbToHex(theme.multiply(b, s));
  return hex;
}
function _screen(bg, fg) {
  const b = theme.parseColor(bg);
  const s = theme.parseColor(fg);
  const hex = theme.rgbToHex(theme.screen(b, s));
  return hex;
}
const NEUTRAL_TONES = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return theme.createColorTheme({
    base: _ref18 => {
      let {
        dark: navbar,
        name
      } = _ref18;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = navbar ? _screen : _multiply;
      const tints = stateTones[name] || stateTones.default;
      if (name === "default") {
        const skeletonFrom2 = stateTones.default[100];
        return {
          fg: stateTones.fg,
          bg: stateTones.bg,
          border: stateTones.default[200],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(stateTones.default[500], 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (name === "transparent") {
        const bg2 = tints[50];
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          fg: tints[900],
          bg: bg2,
          border: tints[300],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = tints[50];
      const skeletonFrom = blend(bg, tints[100]);
      return {
        fg: tints[900],
        bg,
        border: tints[200],
        focusRing: tints[500],
        shadow: {
          outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
          umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
          penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
          ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    solid: _ref19 => {
      let {
        base,
        dark: navbar,
        name,
        state,
        tone
      } = _ref19;
      const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default;
      const dark = buttonTones.dark;
      const blend = dark ? _screen : _multiply;
      const blendInvert = dark ? _multiply : _screen;
      const defaultTints = buttonTones[name] || buttonTones.default;
      const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = blend(base.bg, tints[200]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[200]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[50])
          },
          accent: {
            fg: blend(base.bg, tints[50])
          },
          link: {
            fg: blend(base.bg, tints[50])
          },
          code: {
            bg: bg2,
            fg: blend(base.bg, tints[50])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[600]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[600]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        const bg2 = blend(base.bg, tints[800]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        if (isNeutral) {
          tints = buttonTones.primary;
        }
        const bg2 = blend(base.bg, tints[800]);
        const skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = blend(base.bg, tints[500]);
      const skeletonFrom = blendInvert(bg, tints[800]);
      return {
        bg,
        border: blend(base.bg, tints[500]),
        fg: blend(base.bg, buttonTones.bg),
        icon: blend(base.bg, buttonTones.bg),
        muted: {
          fg: blend(base.bg, tints[100])
        },
        accent: {
          fg: blendInvert(bg, buttonTones.critical[200])
        },
        link: {
          fg: blendInvert(bg, buttonTones.primary[100])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(base.bg, tints[100])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    muted: _ref20 => {
      let {
        base,
        dark: navbar,
        name,
        state,
        tone
      } = _ref20;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      const defaultTints = stateTones[name] || stateTones.default;
      const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = base.bg;
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[200]),
          icon: blend(base.bg, tints[200]),
          muted: {
            fg: blend(bg2, tints[100])
          },
          accent: {
            fg: blend(bg2, tints[100])
          },
          link: {
            fg: blend(bg2, tints[100])
          },
          code: {
            bg: bg2,
            fg: blend(bg2, tints[100])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[50]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[900]),
          icon: blend(base.bg, tints[900]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(base.bg, stateTones.critical[500])
          },
          link: {
            fg: blend(base.bg, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        if (isNeutral) {
          tints = stateTones.primary;
        }
        const bg2 = blend(base.bg, tints[100]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[800]),
          icon: blend(base.bg, tints[800]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        if (isNeutral) {
          tints = stateTones.primary;
        }
        const bg2 = blend(base.bg, tints[100]);
        const skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(bg2, tints[800]),
          icon: blend(bg2, tints[800]),
          muted: {
            fg: blend(bg2, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = base.bg;
      const skeletonFrom = blend(base.bg, tints[100]);
      return {
        bg,
        border: blend(bg, tints[100]),
        fg: blend(bg, tints[700]),
        icon: blend(bg, tints[700]),
        muted: {
          fg: blend(bg, tints[600])
        },
        accent: {
          fg: blend(bg, stateTones.critical[500])
        },
        link: {
          fg: blend(bg, stateTones.primary[600])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(bg, tints[600])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    button: _ref21 => {
      let {
        base,
        mode,
        muted,
        solid
      } = _ref21;
      if (mode === "bleed") {
        return {
          enabled: {
            ...muted.enabled,
            border: muted.enabled.bg
          },
          hovered: {
            ...muted.hovered,
            border: muted.hovered.bg
          },
          pressed: {
            ...muted.pressed,
            border: muted.pressed.bg
          },
          selected: {
            ...muted.selected,
            border: muted.selected.bg
          },
          disabled: {
            ...muted.disabled,
            border: muted.disabled.bg
          }
        };
      }
      if (mode === "ghost") {
        return {
          ...solid,
          enabled: {
            ...muted.enabled,
            border: base.border
          },
          disabled: muted.disabled
        };
      }
      return solid;
    },
    card: _ref22 => {
      let {
        base,
        dark: navbar,
        muted,
        name,
        solid,
        state
      } = _ref22;
      if (state === "hovered") {
        return muted[name].hovered;
      }
      if (state === "disabled") {
        return muted[name].disabled;
      }
      const isNeutral = NEUTRAL_TONES.includes(name);
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const tints = stateTones[name] || stateTones.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      if (state === "pressed") {
        if (isNeutral) {
          return muted.primary.pressed;
        }
        return muted[name].pressed;
      }
      if (state === "selected") {
        if (isNeutral) {
          return solid.primary.enabled;
        }
        return solid[name].enabled;
      }
      const bg = base.bg;
      const skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
      return {
        bg,
        fg: base.fg,
        icon: base.fg,
        border: base.border,
        muted: {
          fg: blend(base.bg, tints[dark ? 400 : 600])
        },
        accent: {
          fg: blend(base.bg, stateTones.critical[dark ? 400 : 500])
        },
        link: {
          fg: blend(base.bg, stateTones.primary[dark ? 400 : 600])
        },
        code: {
          bg: blend(base.bg, tints[dark ? 950 : 50]),
          fg: tints[dark ? 400 : 600]
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    input: _ref23 => {
      let {
        base,
        dark: navbar,
        mode,
        state
      } = _ref23;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      if (mode === "invalid") {
        const tints = stateTones.critical;
        return {
          bg: blend(base.bg, tints[50]),
          bg2: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[700]),
          border: blend(base.bg, tints[200]),
          placeholder: blend(base.bg, tints[400])
        };
      }
      if (state === "hovered") {
        return {
          bg: base.bg,
          bg2: base.bg,
          fg: base.fg,
          border: blend(base.bg, color.hues.gray[300].hex),
          placeholder: blend(base.bg, color.hues.gray[400].hex)
        };
      }
      if (state === "disabled") {
        return {
          bg: blend(base.bg, color.hues.gray[50].hex),
          bg2: blend(base.bg, color.hues.gray[50].hex),
          fg: blend(base.bg, color.hues.gray[200].hex),
          border: blend(base.bg, color.hues.gray[100].hex),
          placeholder: blend(base.bg, color.hues.gray[100].hex)
        };
      }
      if (state === "readOnly") {
        return {
          bg: blend(base.bg, color.hues.gray[50].hex),
          bg2: blend(base.bg, color.hues.gray[50].hex),
          fg: blend(base.bg, color.hues.gray[800].hex),
          border: blend(base.bg, color.hues.gray[200].hex),
          placeholder: blend(base.bg, color.hues.gray[400].hex)
        };
      }
      return {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: base.border,
        placeholder: blend(base.bg, color.hues.gray[700].hex)
      };
    },
    selectable: _ref24 => {
      let {
        base,
        muted,
        tone,
        solid,
        state
      } = _ref24;
      if (state === "enabled") {
        return {
          ...muted[tone].enabled,
          bg: base.bg
        };
      }
      if (state === "pressed") {
        if (tone === "default") {
          return muted.primary.pressed;
        }
        return muted[tone].pressed;
      }
      if (state === "selected") {
        if (tone === "default") {
          return solid.primary.enabled;
        }
        return solid[tone].enabled;
      }
      if (state === "disabled") {
        return {
          ...muted[tone].disabled,
          bg: base.bg
        };
      }
      return muted[tone][state];
    },
    spot: _ref25 => {
      let {
        base,
        key
      } = _ref25;
      const dark = _isDark(base.bg, base.fg);
      const blend = dark ? _screen : _multiply;
      return blend(base.bg, color.hues[key][dark ? 400 : 500].hex);
    },
    syntax: _ref26 => {
      let {
        base,
        dark: navbar
      } = _ref26;
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default;
      const dark = stateTones.dark;
      const blend = dark ? _screen : _multiply;
      const mainShade = 600;
      const secondaryShade = 400;
      return {
        atrule: blend(base.bg, color.hues.purple[mainShade].hex),
        attrName: blend(base.bg, stateTones.positive[mainShade]),
        attrValue: blend(base.bg, stateTones.caution[mainShade]),
        attribute: blend(base.bg, stateTones.caution[mainShade]),
        boolean: blend(base.bg, color.hues.purple[mainShade].hex),
        builtin: blend(base.bg, color.hues.purple[mainShade].hex),
        cdata: blend(base.bg, stateTones.caution[mainShade]),
        char: blend(base.bg, stateTones.caution[mainShade]),
        class: blend(base.bg, color.hues.orange[mainShade].hex),
        className: blend(base.bg, color.hues.cyan[mainShade].hex),
        comment: blend(base.bg, stateTones.default[secondaryShade]),
        constant: blend(base.bg, color.hues.purple[mainShade].hex),
        deleted: blend(base.bg, stateTones.critical[mainShade]),
        doctype: blend(base.bg, stateTones.default[secondaryShade]),
        entity: blend(base.bg, stateTones.critical[mainShade]),
        function: blend(base.bg, stateTones.positive[mainShade]),
        hexcode: blend(base.bg, stateTones.primary[mainShade]),
        id: blend(base.bg, color.hues.purple[mainShade].hex),
        important: blend(base.bg, color.hues.purple[mainShade].hex),
        inserted: blend(base.bg, stateTones.caution[mainShade]),
        keyword: blend(base.bg, color.hues.magenta[mainShade].hex),
        number: blend(base.bg, color.hues.purple[mainShade].hex),
        operator: blend(base.bg, color.hues.magenta[mainShade].hex),
        prolog: blend(base.bg, stateTones.default[secondaryShade]),
        property: blend(base.bg, stateTones.primary[mainShade]),
        pseudoClass: blend(base.bg, stateTones.caution[mainShade]),
        pseudoElement: blend(base.bg, stateTones.caution[mainShade]),
        punctuation: blend(base.bg, stateTones.default[mainShade]),
        regex: blend(base.bg, stateTones.primary[mainShade]),
        selector: blend(base.bg, stateTones.critical[mainShade]),
        string: blend(base.bg, stateTones.caution[mainShade]),
        symbol: blend(base.bg, color.hues.purple[mainShade].hex),
        tag: blend(base.bg, stateTones.critical[mainShade]),
        unit: blend(base.bg, color.hues.orange[mainShade].hex),
        url: blend(base.bg, stateTones.critical[mainShade]),
        variable: blend(base.bg, stateTones.critical[mainShade])
      };
    }
  });
}
function buildFonts(cssCustomProperties) {
  return {
    ...ui.studioTheme.fonts,
    code: {
      ...ui.studioTheme.fonts.code,
      family: cssCustomProperties["--font-family-monospace"] || ui.studioTheme.fonts.code.family
    },
    heading: {
      ...ui.studioTheme.fonts.heading,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    label: {
      ...ui.studioTheme.fonts.label,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    text: {
      ...ui.studioTheme.fonts.text,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    }
  };
}
function buildLegacyPalette(cssCustomProperties) {
  return {
    black: _toHex(cssCustomProperties["--black"]),
    component: {
      bg: _toHex(cssCustomProperties["--component-bg"]),
      fg: _toHex(cssCustomProperties["--component-text-color"])
    },
    defaultButton: {
      default: {
        base: _toHex(cssCustomProperties["--default-button-color"])
      },
      primary: {
        base: _toHex(cssCustomProperties["--default-button-primary-color"])
      },
      success: {
        base: _toHex(cssCustomProperties["--default-button-success-color"])
      },
      warning: {
        base: _toHex(cssCustomProperties["--default-button-warning-color"])
      },
      danger: {
        base: _toHex(cssCustomProperties["--default-button-danger-color"])
      }
    },
    focus: {
      base: _toHex(cssCustomProperties["--focus-color"])
    },
    gray: {
      base: _toHex(cssCustomProperties["--gray-base"])
    },
    mainNavigation: {
      bg: _toHex(cssCustomProperties["--main-navigation-color"]),
      fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"])
    },
    state: {
      info: {
        fg: _toHex(cssCustomProperties["--state-info-color"])
      },
      success: {
        fg: _toHex(cssCustomProperties["--state-success-color"])
      },
      warning: {
        fg: _toHex(cssCustomProperties["--state-warning-color"])
      },
      danger: {
        fg: _toHex(cssCustomProperties["--state-danger-color"])
      }
    }
  };
}
function buildLegacyTones(legacyPalette) {
  return {
    state: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg),
        transparent: _buildTints(legacyPalette.component.bg, legacyPalette.gray.base, legacyPalette.component.fg),
        primary: _buildTints(legacyPalette.component.bg, legacyPalette.state.info.fg, legacyPalette.component.fg),
        positive: _buildTints(legacyPalette.component.bg, legacyPalette.state.success.fg, legacyPalette.component.fg),
        caution: _buildTints(legacyPalette.component.bg, legacyPalette.state.warning.fg, legacyPalette.component.fg),
        critical: _buildTints(legacyPalette.component.bg, legacyPalette.state.danger.fg, legacyPalette.component.fg)
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg),
        transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.gray.base, legacyPalette.mainNavigation.fg),
        primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.info.fg, legacyPalette.mainNavigation.fg),
        positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.success.fg, legacyPalette.mainNavigation.fg),
        caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.warning.fg, legacyPalette.mainNavigation.fg),
        critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.state.danger.fg, legacyPalette.mainNavigation.fg)
      }
    },
    button: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg),
        transparent: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.default.base, legacyPalette.component.fg),
        primary: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.primary.base, legacyPalette.component.fg),
        positive: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.success.base, legacyPalette.component.fg),
        caution: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.warning.base, legacyPalette.component.fg),
        critical: _buildTints(legacyPalette.component.bg, legacyPalette.defaultButton.danger.base, legacyPalette.component.fg)
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg),
        transparent: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.default.base, legacyPalette.mainNavigation.fg),
        primary: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.primary.base, legacyPalette.mainNavigation.fg),
        positive: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.success.base, legacyPalette.mainNavigation.fg),
        caution: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.warning.base, legacyPalette.mainNavigation.fg),
        critical: _buildTints(legacyPalette.mainNavigation.bg, legacyPalette.defaultButton.danger.base, legacyPalette.mainNavigation.fg)
      }
    }
  };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme);
  const legacyPalette = buildLegacyPalette(legacyTheme);
  const legacyTones = buildLegacyTones(legacyPalette);
  const color = buildColor(legacyPalette, legacyTones);
  const fonts = buildFonts(legacyTheme);
  return {
    __dark: _isDark(color.light.default.base.bg, color.light.default.base.fg),
    __legacy: true,
    color,
    fonts
  };
}
const defaultCustomProperties = {
  "--font-family-monospace": ui.studioTheme.fonts.code.family,
  "--font-family-base": ui.studioTheme.fonts.text.family,
  "--black": color.black.hex,
  "--white": color.white.hex,
  // Brand
  "--brand-primary": color.blue[500].hex,
  // Component
  "--component-bg": color.white.hex,
  "--component-text-color": color.black.hex,
  // Gray
  "--gray": color.gray[500].hex,
  "--gray-base": color.gray[500].hex,
  // Default button
  "--default-button-color": color.gray[500].hex,
  "--default-button-danger-color": color.red[500].hex,
  "--default-button-primary-color": color.blue[500].hex,
  "--default-button-success-color": color.green[500].hex,
  "--default-button-warning-color": color.yellow[500].hex,
  // Focus
  "--focus-color": color.blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": color.blue[500].hex,
  "--state-success-color": color.green[500].hex,
  "--state-warning-color": color.yellow[500].hex,
  "--state-danger-color": color.red[500].hex,
  // Navbar
  "--main-navigation-color": color.black.hex,
  "--main-navigation-color--inverted": color.white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props = {
    ...defaultCustomProperties,
    ...legacyTheme
  };
  props["--focus-color"] = legacyTheme["--focus-color"] || props["--brand-primary"];
  props["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props["--brand-primary"];
  props["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props["--black"];
  props["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props["--white"];
  props["--state-info-color"] = legacyTheme["--brand-primary"] || props["--brand-primary"];
  return props;
}
function Studio(props) {
  const {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_globalStyles: globalStyles,
    unstable_history,
    unstable_noAuthBoundary
  } = props;
  return /* @__PURE__ */jsxRuntime.jsxs(TransformPatches.StudioProvider, {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_history,
    unstable_noAuthBoundary,
    children: [globalStyles && /* @__PURE__ */jsxRuntime.jsx(TransformPatches.GlobalStyle, {}), /* @__PURE__ */jsxRuntime.jsx(TransformPatches.StudioLayout, {})]
  });
}
function renderStudio(rootElement, config) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!rootElement) {
    throw new Error("Missing root element to mount application into");
  }
  const opts = typeof options === "boolean" ? {
    reactStrictMode: options
  } : options;
  const {
    reactStrictMode = false,
    basePath
  } = opts;
  const root = client.createRoot(rootElement);
  root.render(reactStrictMode ? /* @__PURE__ */jsxRuntime.jsx(React.StrictMode, {
    children: /* @__PURE__ */jsxRuntime.jsx(Studio, {
      config,
      basePath,
      unstable_globalStyles: true
    })
  }) : /* @__PURE__ */jsxRuntime.jsx(Studio, {
    config,
    basePath,
    unstable_globalStyles: true
  }));
  return () => root.unmount();
}
const INITIAL$1 = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(operators.map(ev => ev.type), operators.map(eventType => eventType !== "reconnect"), operators.switchMap(isConnected => isConnected ? rxjs.of("connected") : rxjs.timer(200).pipe(operators.mapTo("reconnecting"))), operators.startWith(INITIAL$1), operators.distinctUntilChanged()), [documentStore.pair, publishedDocId, docTypeName], INITIAL$1);
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => documentStore.pair.operationEvents(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName]);
}
function useEditState(publishedDocId, docTypeName) {
  let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => {
    const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(operators.share());
    if (priority === "low") {
      return rxjs.merge(base.pipe(operators.take(1)), base.pipe(operators.skip(1), operators.debounce(() => rxjs.timer(1e3))));
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
const PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const {
    style = "short",
    resolution = "seconds"
  } = options || {};
  const unitDisplay = style;
  const locale = TransformPatches.useCurrentLocale().id;
  const listFormat = TransformPatches.useListFormat({
    type: "unit",
    style
  });
  const isNegative = durationMs < 0;
  const duration = parseMilliseconds(Math.abs(durationMs));
  const formatters = React.useMemo(() => ({
    days: TransformPatches.intlCache.numberFormat(locale, {
      style: "unit",
      unit: "day",
      unitDisplay
    }),
    hours: TransformPatches.intlCache.numberFormat(locale, {
      style: "unit",
      unit: "hour",
      unitDisplay
    }),
    minutes: TransformPatches.intlCache.numberFormat(locale, {
      style: "unit",
      unit: "minute",
      unitDisplay
    }),
    seconds: TransformPatches.intlCache.numberFormat(locale, {
      style: "unit",
      unit: "second",
      unitDisplay
    }),
    milliseconds: TransformPatches.intlCache.numberFormat(locale, {
      style: "unit",
      unit: "millisecond",
      unitDisplay
    })
  }), [locale, unitDisplay]);
  const parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds") {
      continue;
    }
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push("".concat(prefix).concat(formatters[period].format(value)));
  }
  const formatted = parts.length === 0 ?
  // If passing duration 0, we still want to show something
  formatters[resolution].format(0) :
  // Usually, we want to join the parts with the locales list formatter
  listFormat.format(parts);
  const iso8601 = durationToISO8601(duration, isNegative);
  return {
    formatted,
    iso8601
  };
}
function parseMilliseconds(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5) % 24,
    minutes: Math.trunc(milliseconds / 6e4) % 60,
    seconds: Math.trunc(milliseconds / 1e3) % 60,
    milliseconds: Math.trunc(milliseconds) % 1e3
  };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? "".concat(dur.days, "D") : "";
  let time = "";
  if (dur.hours) time += "".concat(dur.hours, "H");
  if (dur.minutes) time += "".concat(dur.minutes, "M");
  if (dur.milliseconds) {
    time += "".concat(((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3), "S");
  } else if (dur.seconds) {
    time += "".concat(dur.seconds, "S");
  }
  if (!date && !time) {
    return "PT0S";
  }
  const parts = time ? [date, time] : [date];
  const duration = "P".concat(parts.join("T"));
  return isNegative ? "-".concat(duration) : duration;
}
function useNumberFormat() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const currentLocale = TransformPatches.useCurrentLocale().id;
  return TransformPatches.intlCache.numberFormat(currentLocale, options);
}
const SYNCING = {
  isSyncing: true
};
const NOT_SYNCING = {
  isSyncing: false
};
function useSyncState(publishedDocId, documentType) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(operators.map(isConsistent => isConsistent ? NOT_SYNCING : SYNCING)), [documentStore.pair, documentType, publishedDocId], NOT_SYNCING);
}
function useTimeAgo(time) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return TransformPatches.useRelativeTime(time, {
    minimal: options.minimal,
    useTemporalPhrase: options.agoSuffix
  });
}
function useTools() {
  return TransformPatches.useSource().tools;
}
const INITIAL_STATE = {
  data: [],
  error: null,
  loading: true
};
let cachedSystemGroups = null;
function useUserListWithPermissions(opts) {
  const {
    documentValue,
    permission
  } = opts;
  const projectStore = TransformPatches.useProjectStore();
  const userStore = TransformPatches.useUserStore();
  const client = TransformPatches.useClient(TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [state, setState] = React.useState(INITIAL_STATE);
  const list$ = React.useMemo(() => {
    const members$ = projectStore.get().pipe(rxjs.map(res => {
      var _a;
      return (_a = res.members) == null ? void 0 : _a.filter(m => !m.isRobot);
    }));
    const users$ = members$.pipe(rxjs.switchMap(async members => {
      const ids = members.map(_ref27 => {
        let {
          id
        } = _ref27;
        return id;
      });
      const users = await userStore.getUsers(ids);
      return users;
    }), rxjs.map(res => res.map(user => ({
      displayName: user.displayName,
      id: user.id,
      granted: false
    }))));
    const cached = cachedSystemGroups;
    const systemGroup$ = cached ? rxjs.of(cached) : client.observable.fetch('*[_type == "system.group"]');
    const grants$ = rxjs.forkJoin([users$, systemGroup$]).pipe(rxjs.mergeMap(async _ref28 => {
      let [users, groups] = _ref28;
      if (!cached) {
        cachedSystemGroups = groups;
      }
      const grantPromises = users == null ? void 0 : users.map(async user => {
        const grants = groups.map(group => {
          if (group.members.includes(user.id)) {
            return group.grants;
          }
          return [];
        });
        const flattenedGrants = [...grants].flat();
        const {
          granted
        } = await TransformPatches.grantsPermissionOn(user.id, flattenedGrants, permission, documentValue);
        return {
          ...user,
          granted
        };
      });
      const usersWithPermission = await Promise.all(grantPromises || []);
      return usersWithPermission;
    }));
    const $alphabetical = grants$.pipe(rxjs.map(res => ({
      error: null,
      loading: false,
      data: sortBy__default.default(res, "displayName")
    })));
    return $alphabetical;
  }, [client.observable, documentValue, projectStore, userStore, permission]);
  React.useEffect(() => {
    const initial$ = rxjs.of(INITIAL_STATE);
    const state$ = rxjs.concat(initial$, list$);
    const sub = state$.subscribe({
      next: setState,
      error: error => {
        setState({
          data: [],
          error,
          loading: false
        });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [list$]);
  return state;
}
const INITIAL = {
  validation: [],
  isValidating: false
};
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = TransformPatches.useDocumentStore();
  return reactRx.useMemoObservable(() => documentStore.pair.validation(publishedDocId, docTypeName), [documentStore.pair, publishedDocId, docTypeName], INITIAL);
}
const actionIds = /* @__PURE__ */new WeakMap();
let counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId) return cachedId;
  const id = "".concat(actionHook.name || actionHook.displayName || "<anonymous>", "-").concat(counter++);
  actionIds.set(actionHook, id);
  return id;
}
const requestIdleCallbackShim = callback => {
  const start = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: false,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 1);
};
const cancelIdleCallbackShim = handle => {
  return clearTimeout(handle);
};
const _requestIdleCallback = typeof requestIdleCallback === "undefined" ? requestIdleCallbackShim : requestIdleCallback;
const _cancelIdleCallback = typeof cancelIdleCallback === "undefined" ? cancelIdleCallbackShim : cancelIdleCallback;
const throttleOptions = {
  trailing: true
};
function GetHookCollectionState(props) {
  const {
    hooks,
    args,
    children,
    onReset
  } = props;
  const statesRef = React.useRef({});
  const [tickId, setTick] = React.useState(0);
  const [keys, setKeys] = React.useState({});
  const ricHandle = React.useRef(null);
  const handleRequestUpdate = React.useCallback(() => {
    if (ricHandle.current) {
      _cancelIdleCallback(ricHandle.current);
    }
    ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null;
      setTick(tick => tick + 1);
    });
  }, []);
  const handleRequestUpdateThrottled = useThrottledCallback(handleRequestUpdate, 60, throttleOptions);
  const handleNext = React.useCallback((id, hookState) => {
    if (hookState === null) {
      delete statesRef.current[id];
    } else {
      const current = statesRef.current[id];
      statesRef.current[id] = {
        ...current,
        value: hookState
      };
    }
  }, []);
  const handleReset = React.useCallback(id => {
    setKeys(currentKeys => ({
      ...currentKeys,
      [id]: (currentKeys[id] || 0) + 1
    }));
    if (onReset) {
      onReset();
    }
  }, [onReset]);
  const hookIds = React.useMemo(() => hooks.map(hook => getHookId(hook)), [hooks]);
  const states = React.useMemo(() => hookIds.map(id => {
    var _a;
    return (_a = statesRef.current[id]) == null ? void 0 : _a.value;
  }).filter(TransformPatches.isNonNullable),
  // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
  [hookIds, tickId]);
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [hooks.map(hook => {
      const id = getHookId(hook);
      const key = keys[id] || 0;
      return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.HookStateContainer, {
        hook,
        id,
        args,
        onNext: handleNext,
        onRequestUpdate: handleRequestUpdateThrottled,
        onReset: handleReset
      }, "".concat(id, "-").concat(key));
    }), children({
      states
    })]
  });
}
function Hotkeys(_ref29) {
  let {
    makePlatformAware = true,
    keys: hotKeys = [],
    ...props
  } = _ref29;
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Hotkeys, {
    ...props,
    keys
  });
}
const IS_APPLE_DEVICE = typeof navigator === "undefined" || typeof navigator.platform !== "string" ? false : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key) {
  const lowerKey = key.toLowerCase();
  if (lowerKey === "alt" && IS_APPLE_DEVICE) {
    return matchCase(key, "option");
  }
  if (lowerKey === "option" && !IS_APPLE_DEVICE) {
    return matchCase(key, "alt");
  }
  return key;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => {
    return i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char;
  });
}
function IntentButton(props) {
  return props.disabled ? /* @__PURE__ */jsxRuntime.jsx(TooltipDelayGroupProvider.Button, {
    ...props,
    as: "a",
    role: "link",
    "aria-disabled": "true"
  }) : /* @__PURE__ */jsxRuntime.jsx(TooltipDelayGroupProvider.Button, {
    ...props,
    as: router.IntentLink
  });
}
function RelativeTime(_ref30) {
  let {
    time,
    ...options
  } = _ref30;
  const timestamp = time instanceof Date ? time : new Date(time);
  const timeAgo = TransformPatches.useRelativeTime(timestamp, options);
  return /* @__PURE__ */jsxRuntime.jsx("time", {
    dateTime: timestamp.toISOString(),
    title: timeAgo,
    children: timeAgo
  });
}
function WithReferringDocuments(_ref31) {
  let {
    children,
    id
  } = _ref31;
  return children(TransformPatches.useReferringDocuments(id));
}
function ZIndexProvider(_ref32) {
  let {
    children
  } = _ref32;
  return /* @__PURE__ */jsxRuntime.jsx(TransformPatches.ZIndexContext.Provider, {
    value: TransformPatches.defaults,
    children
  });
}
function TelephoneInput(props) {
  const {
    schemaType,
    validationError,
    value,
    elementProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(ui.TextInput, {
    type: "tel",
    inputMode: "tel",
    customValidity: validationError,
    value: value || "",
    placeholder: schemaType.placeholder,
    ...elementProps
  });
}
function resolveConditionalProperty(property, context) {
  const {
    currentUser,
    document,
    parent,
    value
  } = context;
  if (typeof property === "boolean" || property === void 0) {
    return Boolean(property);
  }
  return property({
    document,
    parent,
    value,
    currentUser
  }) === true;
}
function setAtPath(currentTree, path, value) {
  var _a;
  if (path.length === 0) {
    return {
      ...(currentTree || {}),
      value
    };
  }
  const [head, ...tail] = path;
  const key = types.isKeySegment(head) ? head._key : String(head);
  const children = (_a = currentTree == null ? void 0 : currentTree.children) != null ? _a : {};
  return {
    value: currentTree == null ? void 0 : currentTree.value,
    children: {
      ...children,
      [key]: setAtPath(children[key] || {}, tail, value)
    }
  };
}
const MAX_FIELD_DEPTH = 20;
const AUTO_COLLAPSE_DEPTH = 3;
const ALL_FIELDS_GROUP = {
  name: "all-fields",
  title: "All fields",
  hidden: false
};
function getCollapsedWithDefaults() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let level = arguments.length > 1 ? arguments[1] : undefined;
  if ((options == null ? void 0 : options.collapsible) === false || (options == null ? void 0 : options.collapsable) === false) {
    return {
      collapsible: false,
      collapsed: false
    };
  }
  const collapsed =
  // eslint-disable-next-line no-nested-ternary
  typeof (options == null ? void 0 : options.collapsed) === "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? true : void 0;
  const collapsible = (options == null ? void 0 : options.collapsible) === true || (options == null ? void 0 : options.collapsable) === true || collapsed === true ? true : void 0;
  return {
    collapsible,
    collapsed
  };
}
function getItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find(memberType => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return arrayType == null ? void 0 : arrayType.of.find(memberType => memberType.name === itemTypeName || memberType.jsonType === itemTypeName);
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  if (selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  if (fieldGroup === void 0) {
    return false;
  }
  if (groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  }
  return castArray__default.default(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value === "undefined" || TransformPatches.isRecord(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value === "undefined" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every(item => TransformPatches.isRecord(item));
}
function findDuplicateKeyEntries(array) {
  const seenKeys = /* @__PURE__ */new Set();
  return array.reduce((acc, item, index) => {
    if (seenKeys.has(item._key)) {
      acc.push([index, item._key]);
    }
    seenKeys.add(item._key);
    return acc;
  }, []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array) {
  return array == null ? void 0 : array.every(item => TransformPatches.isRecord(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  if (Array.isArray(value) && typeof comparisonValue === "undefined" || Array.isArray(comparisonValue) && typeof value === "undefined") {
    return false;
  }
  if (value && !comparisonValue) {
    return true;
  }
  return !isEqual__default.default(value, comparisonValue);
}
function prepareFieldMember(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const {
    parent,
    field,
    index
  } = props;
  const fieldPath = PathUtils.pathFor([...parent.path, field.name]);
  const fieldLevel = TransformPatches.getFieldLevel(field.type, parent.level + 1);
  const parentValue = parent.value;
  const parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue)) {
    throw new Error("Unexpected non-object value");
  }
  const normalizedFieldGroupNames = field.group ? castArray__default.default(field.group) : [];
  const inSelectedGroup = isFieldEnabledByGroupFilter(parent.groups, field.group, parent.selectedGroup);
  if (types.isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue)) {
      return {
        kind: "error",
        key: field.name,
        fieldName: field.name,
        error: {
          type: "INCOMPATIBLE_TYPE",
          expectedSchemaType: field.type,
          resolvedValueType: content.resolveTypeName(fieldValue),
          value: fieldValue
        }
      };
    }
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return {
        kind: "hidden",
        key: "field-".concat(field.name),
        name: field.name,
        index
      };
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[field.name];
    const scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[field.name];
    const scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[field.name];
    const inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly,
      changesOpen: parent.changesOpen
    });
    if (inputState === null) {
      return null;
    }
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel);
    const collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: "field",
      key: "field-".concat(field.name),
      name: field.name,
      index,
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if (types.isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (types.isArrayOfObjectsSchemaType(field.type)) {
      const hasValue = typeof fieldValue !== "undefined";
      if (hasValue && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemIsObject(fieldValue)) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MIXED_ARRAY",
            schemaType: field.type,
            value: fieldValue
          }
        };
      }
      if (hasValue && !everyItemHasKey(fieldValue)) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MISSING_KEYS",
            value: fieldValue,
            schemaType: field.type
          }
        };
      }
      const duplicateKeyEntries = hasValue ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0) {
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "DUPLICATE_KEYS",
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      }
      const fieldGroupState = (_h = (_g = parent.fieldGroupState) == null ? void 0 : _g.children) == null ? void 0 : _h[field.name];
      const scopedCollapsedPaths = (_j = (_i = parent.collapsedPaths) == null ? void 0 : _i.children) == null ? void 0 : _j[field.name];
      const scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name];
      const scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name];
      const scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name];
      const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      if (fieldState === null) {
        return null;
      }
      return {
        kind: "field",
        key: "field-".concat(field.name),
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name];
    const fieldComparisonValue = TransformPatches.isRecord(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    const hidden = resolveConditionalProperty(field.type.hidden, conditionalPropertyContext);
    if (hidden) {
      return null;
    }
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext);
    const fieldState = preparePrimitiveInputState({
      ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: "field",
      key: "field-".concat(field.name),
      name: field.name,
      index,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: false,
      collapsed: false,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props) {
  let enableHiddenCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var _a;
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const schemaTypeGroupConfig = props.schemaType.groups || [];
  const defaultGroupName = (_a = schemaTypeGroupConfig.find(g => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a.name;
  const groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap(group => {
    var _a2;
    const groupHidden = resolveConditionalProperty(group.hidden, conditionalPropertyContext);
    const isSelected = group.name === (((_a2 = props.fieldGroupState) == null ? void 0 : _a2.value) || defaultGroupName);
    const selected = props.changesOpen ? group.name === ALL_FIELDS_GROUP.name : isSelected;
    const disabled = props.changesOpen ? !selected : false;
    return groupHidden ? [] : [{
      disabled,
      icon: group == null ? void 0 : group.icon,
      name: group.name,
      selected,
      title: group.title
    }];
  });
  const selectedGroup = groups.find(group => group.selected);
  const normalizedSchemaMembers = props.schemaType.fieldsets ? props.schemaType.fieldsets : props.schemaType.fields.map(field => ({
    single: true,
    field
  }));
  const members = normalizedSchemaMembers.flatMap((fieldSet, index) => {
    var _a2, _b, _c, _d;
    if (fieldSet.single) {
      const field = fieldSet.field;
      const fieldMember = prepareFieldMember({
        field,
        parent: {
          ...props,
          readOnly,
          groups,
          selectedGroup
        },
        index
      });
      return fieldMember ? [fieldMember] : [];
    }
    const fieldsetFieldNames = fieldSet.fields.map(f => f.name);
    const fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, {
      currentUser: props.currentUser,
      document: props.document,
      parent: props.value,
      value: pick__default.default(props.value, fieldsetFieldNames)
    });
    const fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, {
      currentUser: props.currentUser,
      document: props.document,
      parent: props.value,
      value: pick__default.default(props.value, fieldsetFieldNames)
    });
    const fieldsetMembers = fieldSet.fields.flatMap(field => {
      if (fieldsetHidden) {
        return [{
          kind: "hidden",
          key: "field-".concat(field.name),
          name: field.name,
          index
        }];
      }
      const fieldMember = prepareFieldMember({
        field,
        parent: {
          ...props,
          readOnly: readOnly || fieldsetReadOnly,
          groups,
          selectedGroup
        },
        index
      });
      return fieldMember ? [fieldMember] : [];
    });
    const defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props.level);
    const collapsed = (_c = (_b = (((_a2 = props.collapsedFieldSets) == null ? void 0 : _a2.children) || {})[fieldSet.name]) == null ? void 0 : _b.value) != null ? _c : defaultCollapsedState.collapsed;
    return [{
      kind: "fieldSet",
      key: "fieldset-".concat(fieldSet.name),
      _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup),
      groups: fieldSet.group ? castArray__default.default(fieldSet.group) : [],
      fieldSet: {
        path: PathUtils.pathFor(props.path.concat(fieldSet.name)),
        name: fieldSet.name,
        title: fieldSet.title,
        description: fieldSet.description,
        hidden: false,
        level: props.level + 1,
        members: fieldsetMembers.filter(member => member.kind !== "hidden"),
        collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible,
        collapsed,
        columns: (_d = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d.columns
      }
    }];
  });
  const hasFieldGroups = schemaTypeGroupConfig.length > 0;
  const filteredPresence = props.presence.filter(item => PathUtils.isEqual(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY;
  const validation = props.validation.filter(item => PathUtils.isEqual(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const visibleMembers = members.filter(member => member.kind !== "hidden");
  if (visibleMembers.length === 0 && enableHiddenCheck) {
    return null;
  }
  const visibleGroups = hasFieldGroups ? groups.flatMap(group => {
    if (group.name === ALL_FIELDS_GROUP.name) {
      return group;
    }
    const hasVisibleMembers = visibleMembers.some(member => {
      if (member.kind === "error") {
        return false;
      }
      if (member.kind === "field") {
        return member.groups.includes(group.name);
      }
      return member.groups.includes(group.name) || member.fieldSet.members.some(fieldsetMember => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group.name));
    });
    return hasVisibleMembers ? group : [];
  }) : [];
  const filtereredMembers = visibleMembers.flatMap(member => {
    if (member.kind === "error") {
      return [member];
    }
    if (member.kind === "field") {
      return member.inSelectedGroup ? [member] : [];
    }
    const filteredFieldsetMembers = member.fieldSet.members.filter(fieldsetMember => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup);
    return filteredFieldsetMembers.length > 0 ? [{
      ...member,
      fieldSet: {
        ...member.fieldSet,
        members: filteredFieldsetMembers
      }
    }] : [];
  });
  const node = {
    value: props.value,
    changed: isChangedValue(props.value, props.comparisonValue),
    schemaType: props.schemaType,
    readOnly,
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    presence,
    validation,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  Object.defineProperty(node, "_allMembers", {
    value: members,
    enumerable: false
  });
  return node;
}
function prepareArrayOfPrimitivesInputState(props) {
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    comparisonValue: props.comparisonValue,
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props.value) ? props.value : [];
  const filteredPresence = props.presence.filter(item => PathUtils.isEqual(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY;
  const validation = props.validation.filter(item => PathUtils.isEqual(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfPrimitivesMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some(m => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props) {
  if (props.level === MAX_FIELD_DEPTH) {
    return null;
  }
  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = resolveConditionalProperty(props.schemaType.hidden, conditionalPropertyContext);
  if (hidden) {
    return null;
  }
  const readOnly = props.readOnly || resolveConditionalProperty(props.schemaType.readOnly, conditionalPropertyContext);
  const items = Array.isArray(props.value) ? props.value : [];
  const filteredPresence = props.presence.filter(item => PathUtils.isEqual(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY;
  const validation = props.validation.filter(item => PathUtils.isEqual(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfObjectsMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props.changed || members.some(m => m.kind === "item" && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    focusPath: PathUtils.trimChildPath(props.path, props.focusPath),
    path: props.path,
    id: PathUtils.toString(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = getItemType(parent.schemaType, arrayItem);
  const key = arrayItem._key;
  if (!itemType) {
    const itemTypeName = content.resolveTypeName(arrayItem);
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }
  const itemPath = PathUtils.pathFor([...parent.path, {
    _key: key
  }]);
  const itemLevel = parent.level + 1;
  const conditionalPropertyContext = {
    value: parent.value,
    parent: props.parent,
    document: parent.document,
    currentUser: parent.currentUser
  };
  const readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext);
  const fieldGroupState = (_b = (_a = parent.fieldGroupState) == null ? void 0 : _a.children) == null ? void 0 : _b[key];
  const scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[key];
  const scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[key];
  const comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find(i => i._key === arrayItem._key) || void 0;
  const itemState = prepareObjectInputState({
    schemaType: itemType,
    level: itemLevel,
    document: parent.document,
    value: arrayItem,
    comparisonValue,
    changed: isChangedValue(arrayItem, comparisonValue),
    path: itemPath,
    focusPath: parent.focusPath,
    openPath: parent.openPath,
    currentUser: parent.currentUser,
    collapsedPaths: scopedCollapsedPaths,
    collapsedFieldSets: scopedCollapsedFieldsets,
    presence: parent.presence,
    validation: parent.validation,
    fieldGroupState,
    readOnly
  }, false);
  const defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel);
  const collapsed = (_g = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g : defaultCollapsedState.collapsed;
  return {
    kind: "item",
    key,
    index,
    open: PathUtils.startsWith(itemPath, parent.openPath),
    collapsed,
    collapsible: true,
    parentSchemaType: parent.schemaType,
    item: itemState
  };
}
function prepareArrayOfPrimitivesMember(props) {
  var _a, _b;
  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = getPrimitiveItemType(parent.schemaType, arrayItem);
  const itemPath = PathUtils.pathFor([...parent.path, index]);
  const itemValue = (_a = parent.value) == null ? void 0 : _a[index];
  const itemComparisonValue = (_b = parent.comparisonValue) == null ? void 0 : _b[index];
  const itemLevel = parent.level + 1;
  const key = "".concat((itemType == null ? void 0 : itemType.name) || "invalid-type", "-").concat(String(index));
  if (!itemType) {
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        validTypes: parent.schemaType.of,
        resolvedValueType: content.resolveTypeName(itemType),
        value: itemValue
      }
    };
  }
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  });
  const item = preparePrimitiveInputState({
    ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: "item",
    key,
    index,
    parentSchemaType: parent.schemaType,
    open: PathUtils.isEqual(itemPath, parent.openPath),
    item
  };
}
function preparePrimitiveInputState(props) {
  const filteredPresence = props.presence.filter(item => PathUtils.isEqual(item.path, props.path));
  const presence = filteredPresence.length ? filteredPresence : TransformPatches.EMPTY_ARRAY;
  const validation = props.validation.filter(item => PathUtils.isEqual(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.message,
    path: v.path
  }));
  return {
    schemaType: props.schemaType,
    changed: isChangedValue(props.value, props.comparisonValue),
    value: props.value,
    level: props.level,
    id: PathUtils.toString(props.path),
    readOnly: props.readOnly,
    focused: PathUtils.isEqual(props.path, props.focusPath),
    path: props.path,
    presence,
    validation
  };
}
function prepareFormState(props) {
  return prepareObjectInputState(props);
}
function useFormState(schemaType, _ref33) {
  let {
    comparisonValue,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    openPath,
    presence,
    validation,
    readOnly,
    changesOpen
  } = _ref33;
  const currentUser = TransformPatches.useCurrentUser();
  const prev = React.useRef(null);
  React.useLayoutEffect(() => {
    prev.current = null;
  }, [schemaType]);
  return React.useMemo(() => {
    const next = prepareFormState({
      schemaType,
      document: value,
      fieldGroupState,
      collapsedFieldSets,
      collapsedPaths,
      value,
      comparisonValue,
      focusPath,
      openPath,
      readOnly,
      path: PathUtils.pathFor([]),
      level: 0,
      currentUser,
      presence,
      validation,
      changesOpen
    });
    const reconciled = TransformPatches.immutableReconcile(prev.current, next);
    prev.current = reconciled;
    return reconciled;
  }, [schemaType, value, fieldGroupState, collapsedFieldSets, collapsedPaths, comparisonValue, focusPath, openPath, readOnly, currentUser, presence, validation, changesOpen]);
}
function isObjectFormNode(formNode) {
  return types.isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return types.isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path) {
  return [
  // make sure to expand all intermediate paths
  ...path.map((p, i) => ({
    type: "expandPath",
    path: path.slice(0, i + 1)
  })),
  // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
  ...getFieldsetAndFieldGroupOperations(node, path)];
}
function getFieldsetAndFieldGroupOperations(node, path) {
  if (path.length === 0) {
    return [];
  }
  if (isObjectFormNode(node) && hasAllMembers(node)) {
    return getObjectFieldsetAndFieldGroupOperations(node, path);
  }
  if (isArrayOfObjectsFormNode(node)) {
    return getArrayFieldsetAndFieldGroupOperations(node, path);
  }
  return [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path) {
  var _a, _b;
  if (path.length === 0) {
    return [];
  }
  const [fieldName, ...tail] = path;
  const fieldsetMember = node._allMembers.find(member => member.kind === "fieldSet" && member.fieldSet.members.some(field => field.kind === "field" && field.name === fieldName));
  const members = fieldsetMember ? fieldsetMember.fieldSet.members :
  // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
  node._allMembers;
  const fieldMember = members.find(member => member !== null && member.kind === "field" && member.name === fieldName);
  const schemaField = node.schemaType.fields.find(field => field.name === fieldName);
  const selectedGroupName = (_a = node.groups.find(group => group.selected)) == null ? void 0 : _a.name;
  const defaultGroupName = (_b = (node.schemaType.groups || []).find(group => group.default)) == null ? void 0 : _b.name;
  const inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && castArray__default.default(schemaField.group).includes(selectedGroupName));
  const ops = [];
  if (!inSelectedGroup) {
    ops.push({
      type: "setSelectedGroup",
      path: node.path,
      groupName: defaultGroupName || ALL_FIELDS_GROUP.name
    });
  }
  if (fieldsetMember) {
    ops.push({
      type: "expandFieldSet",
      path: fieldsetMember.fieldSet.path
    });
  }
  if (fieldMember && hasAllMembers(fieldMember.field)) {
    if (TransformPatches.isMemberArrayOfObjects(fieldMember)) {
      ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    } else if (TransformPatches.isMemberObject(fieldMember)) {
      ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail));
    }
  }
  return ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path) {
  if (path.length === 0) {
    return [];
  }
  const [segment, ...rest] = path;
  if (!types.isKeySegment(segment)) {
    throw new Error("Expected path segment to be an object with a _key property");
  }
  const foundMember = state.members.find(member => member.key === segment._key);
  if (!foundMember) {
    return [];
  }
  return getFieldsetAndFieldGroupOperations(foundMember.item, rest);
}
const IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key] = segment.split("==");
  return {
    [attr]: unquote(key)
  };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map(seg => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return mutator.arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return flatten__default.default(patches.map(patch => toFormBuilderPatches(origin, patch)));
}
const notIn = values => value => !values.includes(value);
function toFormBuilderPatches(origin, patch) {
  return flatten__default.default(Object.keys(patch).filter(notIn(["id", "ifRevisionID", "query"])).map(type => {
    if (type === "unset") {
      return patch.unset.map(path => {
        return {
          type: "unset",
          path: decodePath(path),
          origin
        };
      });
    }
    if (type === "insert") {
      const position = "before" in patch.insert ? "before" : "after";
      return {
        type: "insert",
        position,
        path: decodePath(patch.insert[position]),
        items: patch.insert.items,
        origin
      };
    }
    return Object.keys(patch[type]).map(gradientPath => {
      if (type === "set") {
        return {
          type: "set",
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "inc" || type === "dec") {
        return {
          type,
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "setIfMissing") {
        return {
          type: "setIfMissing",
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      if (type === "diffMatchPatch") {
        return {
          type,
          path: decodePath(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }
      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}
function toMutationPatch(patch) {
  if (patch.patchType !== TransformPatches.SANITY_PATCH_TYPE && patch.type) {
    throw new Error('Patch is missing "patchType" - import and use "'.concat(patch.type, '()" from "sanity/form"'));
  } else if (patch.patchType !== TransformPatches.SANITY_PATCH_TYPE) {
    throw new Error('Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"');
  }
  const matchPath = mutator.arrayToJSONMatchPath(patch.path || []);
  if (patch.type === "insert") {
    const {
      position,
      items
    } = patch;
    return {
      insert: {
        [position]: matchPath,
        items
      }
    };
  }
  if (patch.type === "unset") {
    return {
      unset: [matchPath]
    };
  }
  if (!patch.type) {
    throw new Error("Missing patch type in patch ".concat(JSON.stringify(patch)));
  }
  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }
  return {
    [patch.type]: patch.value
  };
}
exports.ActiveWorkspaceMatcher = TransformPatches.ActiveWorkspaceMatcher;
exports.ActiveWorkspaceMatcherContext = TransformPatches.ActiveWorkspaceMatcherContext;
exports.AddonDatasetContext = TransformPatches.AddonDatasetContext;
exports.ArrayOfObjectOptionsInput = TransformPatches.ArrayOfObjectOptionsInput;
exports.ArrayOfObjectsFunctions = TransformPatches.ArrayOfObjectsFunctions;
exports.ArrayOfObjectsInput = TransformPatches.ArrayOfObjectsInput;
exports.ArrayOfObjectsItem = TransformPatches.ArrayOfObjectsItem;
exports.ArrayOfOptionsInput = TransformPatches.ArrayOfOptionsInput;
exports.ArrayOfPrimitiveOptionsInput = TransformPatches.ArrayOfPrimitiveOptionsInput;
exports.ArrayOfPrimitivesFunctions = TransformPatches.ArrayOfPrimitivesFunctions;
exports.ArrayOfPrimitivesInput = TransformPatches.ArrayOfPrimitivesInput;
exports.ArrayOfPrimitivesItem = TransformPatches.ArrayOfPrimitivesItem;
exports.AutoCollapseMenu = TransformPatches.AutoCollapseMenu;
exports.BlockEditor = TransformPatches.PortableTextInput;
exports.BlockImagePreview = TransformPatches.BlockImagePreview;
exports.BlockPreview = TransformPatches.BlockPreview;
exports.BooleanInput = TransformPatches.BooleanInput;
exports.CONNECTING = TransformPatches.CONNECTING;
exports.ChangeBreadcrumb = TransformPatches.ChangeBreadcrumb;
exports.ChangeIndicator = TransformPatches.ChangeIndicator;
exports.ChangeIndicatorContext = TransformPatches.ChangeIndicatorContext;
exports.ChangeList = TransformPatches.ChangeList;
exports.ChangeResolver = TransformPatches.ChangeResolver;
exports.ChangeTitleSegment = TransformPatches.ChangeTitleSegment;
exports.CircularProgress = TransformPatches.CircularProgress;
exports.CollapseMenu = TransformPatches.CollapseMenu;
exports.CollapseMenuButton = TransformPatches.CollapseMenuButton;
exports.ColorSchemeCustomProvider = TransformPatches.ColorSchemeCustomProvider;
exports.ColorSchemeLocalStorageProvider = TransformPatches.ColorSchemeLocalStorageProvider;
exports.ColorSchemeProvider = TransformPatches.ColorSchemeProvider;
exports.ColorSchemeSetValueContext = TransformPatches.ColorSchemeSetValueContext;
exports.ColorSchemeValueContext = TransformPatches.ColorSchemeValueContext;
exports.CommandList = TransformPatches.CommandList;
exports.CompactPreview = TransformPatches.CompactPreview;
exports.ConfigPropertyError = TransformPatches.ConfigPropertyError;
exports.ConfigResolutionError = TransformPatches.ConfigResolutionError;
exports.ConnectorContext = TransformPatches.ConnectorContext;
exports.ContextMenuButton = TransformPatches.ContextMenuButton;
exports.CorsOriginError = TransformPatches.CorsOriginError;
exports.CrossDatasetReferenceInput = TransformPatches.StudioCrossDatasetReferenceInput;
exports.DEFAULT_MAX_RECURSION_DEPTH = TransformPatches.DEFAULT_MAX_RECURSION_DEPTH;
exports.DEFAULT_STUDIO_CLIENT_OPTIONS = TransformPatches.DEFAULT_STUDIO_CLIENT_OPTIONS;
exports.DRAFTS_FOLDER = TransformPatches.DRAFTS_FOLDER;
exports.DateInput = TransformPatches.DateInput;
exports.DateTimeInput = TransformPatches.DateTimeInput;
exports.DefaultPreview = TransformPatches.DefaultPreview;
exports.DetailPreview = TransformPatches.DetailPreview;
exports.DiffCard = TransformPatches.DiffCard;
exports.DiffContext = TransformPatches.DiffContext;
exports.DiffErrorBoundary = TransformPatches.DiffErrorBoundary;
exports.DiffFromTo = TransformPatches.DiffFromTo;
exports.DiffInspectWrapper = TransformPatches.DiffInspectWrapper;
exports.DiffString = TransformPatches.DiffString;
exports.DiffStringSegment = TransformPatches.DiffStringSegment;
exports.DiffTooltip = TransformPatches.DiffTooltip;
exports.DocumentChangeContext = TransformPatches.DocumentChangeContext;
exports.DocumentPreviewPresence = TransformPatches.DocumentPreviewPresence;
exports.DocumentStatus = TransformPatches.DocumentStatus;
exports.DocumentStatusIndicator = TransformPatches.DocumentStatusIndicator;
exports.EMPTY_ARRAY = TransformPatches.EMPTY_ARRAY;
exports.EMPTY_OBJECT = TransformPatches.EMPTY_OBJECT;
exports.EmailInput = TransformPatches.EmailInput;
exports.FallbackDiff = TransformPatches.FallbackDiff;
exports.FieldActionMenu = TransformPatches.FieldActionMenu;
exports.FieldActionsProvider = TransformPatches.FieldActionsProvider;
exports.FieldActionsResolver = TransformPatches.FieldActionsResolver;
exports.FieldChange = TransformPatches.FieldChange;
exports.FieldPresence = TransformPatches.FieldPresence;
exports.FieldPresenceInner = TransformPatches.FieldPresenceInner;
exports.FieldPresenceWithOverlay = TransformPatches.FieldPresenceWithOverlay;
exports.FieldPresenceWithoutOverlay = TransformPatches.FieldPresenceWithoutOverlay;
exports.FileInput = TransformPatches.StudioFileInput;
exports.FormBuilderContext = TransformPatches.FormBuilderContext;
exports.FormCallbacksContext = TransformPatches.FormCallbacksContext;
exports.FormCallbacksProvider = TransformPatches.FormCallbacksProvider;
exports.FormField = TransformPatches.FormField;
exports.FormFieldHeaderText = TransformPatches.FormFieldHeaderText;
exports.FormFieldPresenceContext = TransformPatches.FormFieldPresenceContext;
exports.FormFieldSet = TransformPatches.FormFieldSet;
exports.FormFieldStatus = TransformPatches.FormFieldStatus;
exports.FormFieldValidationStatus = TransformPatches.FormFieldValidationStatus;
exports.FormInput = TransformPatches.FormInput;
exports.FormValueProvider = TransformPatches.FormValueProvider;
exports.FromTo = TransformPatches.FromTo;
exports.FromToArrow = TransformPatches.FromToArrow;
exports.GroupChange = TransformPatches.GroupChange;
exports.ImageInput = TransformPatches.StudioImageInput;
exports.ImperativeToast = TransformPatches.ImperativeToast;
exports.InlinePreview = TransformPatches.InlinePreview;
exports.InsufficientPermissionsMessage = TransformPatches.InsufficientPermissionsMessage;
exports.LegacyLayerProvider = TransformPatches.LegacyLayerProvider;
exports.LinearProgress = TransformPatches.LinearProgress;
exports.LoadingBlock = TransformPatches.LoadingBlock;
exports.LocaleProvider = TransformPatches.LocaleProvider;
exports.LocaleProviderBase = TransformPatches.LocaleProviderBase;
exports.MediaPreview = TransformPatches.MediaPreview;
exports.MemberField = TransformPatches.MemberField;
exports.MemberFieldError = TransformPatches.MemberFieldError;
exports.MemberFieldSet = TransformPatches.MemberFieldSet;
exports.MemberItemError = TransformPatches.MemberItemError;
exports.MetaInfo = TransformPatches.MetaInfo;
exports.NavbarContext = TransformPatches.NavbarContext;
exports.NoChanges = TransformPatches.NoChanges;
exports.NumberInput = TransformPatches.NumberInput;
exports.ObjectInput = TransformPatches.ObjectInput;
exports.ObjectInputMember = TransformPatches.ObjectInputMember;
exports.ObjectInputMembers = TransformPatches.ObjectInputMembers;
exports.ObjectMembers = TransformPatches.ObjectMembers;
exports.OverlayDisabled = TransformPatches.OverlayDisabled;
exports.PatchEvent = TransformPatches.PatchEvent;
exports.PopoverDialog = TransformPatches.PopoverDialog;
exports.PortableTextInput = TransformPatches.PortableTextInput;
exports.PresenceOverlay = TransformPatches.PresenceOverlay;
exports.Preview = TransformPatches.Preview;
exports.PreviewCard = TransformPatches.PreviewCard;
exports.PreviewLoader = TransformPatches.PreviewLoader;
exports.ReferenceInput = TransformPatches.StudioReferenceInput;
exports.ReferenceInputOptionsProvider = TransformPatches.ReferenceInputOptionsProvider;
exports.ResourceCacheProvider = TransformPatches.ResourceCacheProvider;
exports.RevertChangesButton = TransformPatches.RevertChangesButton;
exports.ReviewChangesContext = TransformPatches.ReviewChangesContext;
exports.SANITY_PATCH_TYPE = TransformPatches.SANITY_PATCH_TYPE;
exports.SANITY_VERSION = TransformPatches.SANITY_VERSION;
exports.SESSION_ID = TransformPatches.SESSION_ID;
exports.SanityDefaultPreview = TransformPatches.SanityDefaultPreview;
exports.SchemaError = TransformPatches.SchemaError;
exports.ScrollContainer = TransformPatches.ScrollContainer;
exports.SearchButton = TransformPatches.SearchButton;
exports.SearchDialog = TransformPatches.SearchDialog;
exports.SelectInput = TransformPatches.SelectInput;
exports.SlugInput = TransformPatches.SlugInput;
exports.SourceProvider = TransformPatches.SourceProvider;
exports.StatusButton = TransformPatches.StatusButton;
exports.StringInput = TransformPatches.StringInput;
exports.StudioLayout = TransformPatches.StudioLayout;
exports.StudioLayoutComponent = TransformPatches.StudioLayoutComponent;
exports.StudioNavbar = TransformPatches.StudioNavbar;
exports.StudioProvider = TransformPatches.StudioProvider;
exports.StudioToolMenu = TransformPatches.StudioToolMenu;
exports.TagsArrayInput = TransformPatches.TagsArrayInput;
exports.TemplatePreview = TransformPatches.TemplatePreview;
exports.TextInput = TransformPatches.TextInput;
exports.TextWithTone = TransformPatches.TextWithTone;
exports.Timeline = TransformPatches.Timeline;
exports.TimelineController = TransformPatches.TimelineController;
exports.ToolLink = TransformPatches.ToolLink;
exports.TooltipOfDisabled = TransformPatches.TooltipOfDisabled;
exports.Tracker = TransformPatches.Tracker;
exports.TransformPatches = TransformPatches.TransformPatches;
exports.Translate = TransformPatches.Translate;
exports.UniversalArrayInput = TransformPatches.UniversalArrayInput;
exports.UpsellDescriptionSerializer = TransformPatches.UpsellDescriptionSerializer;
exports.UpsellDialogDismissed = TransformPatches.UpsellDialogDismissed;
exports.UpsellDialogLearnMoreCtaClicked = TransformPatches.UpsellDialogLearnMoreCtaClicked;
exports.UpsellDialogUpgradeCtaClicked = TransformPatches.UpsellDialogUpgradeCtaClicked;
exports.UpsellDialogViewed = TransformPatches.UpsellDialogViewed;
exports.UrlInput = TransformPatches.UrlInput;
exports.UserAvatar = TransformPatches.UserAvatar;
exports.UserColorManagerProvider = TransformPatches.UserColorManagerProvider;
exports.ValueError = TransformPatches.ValueError;
exports.VirtualizerScrollInstanceContext = TransformPatches.VirtualizerScrollInstanceContext;
exports.VirtualizerScrollInstanceProvider = TransformPatches.VirtualizerScrollInstanceProvider;
exports.WorkspaceProvider = TransformPatches.WorkspaceProvider;
exports.WorkspacesContext = TransformPatches.WorkspacesContext;
exports.WorkspacesProvider = TransformPatches.WorkspacesProvider;
exports.__tmp_wrap_presenceStore = TransformPatches.__tmp_wrap_presenceStore;
exports._createAuthStore = TransformPatches._createAuthStore;
exports._useColorSchemeInternalValue = TransformPatches._useColorSchemeInternalValue;
exports.asLoadable = TransformPatches.asLoadable;
exports.checkoutPair = TransformPatches.checkoutPair;
exports.collate = TransformPatches.collate;
exports.createAuthStore = TransformPatches.createAuthStore;
exports.createBufferedDocument = TransformPatches.createBufferedDocument;
exports.createConnectionStatusStore = TransformPatches.createConnectionStatusStore;
exports.createDocumentPreviewStore = TransformPatches.createDocumentPreviewStore;
exports.createDocumentStore = TransformPatches.createDocumentStore;
exports.createDraftFrom = TransformPatches.createDraftFrom;
exports.createGrantsStore = TransformPatches.createGrantsStore;
exports.createHistoryStore = TransformPatches.createHistoryStore;
exports.createHookFromObservableFactory = TransformPatches.createHookFromObservableFactory;
exports.createKeyValueStore = TransformPatches.createKeyValueStore;
exports.createObservableBufferedDocument = TransformPatches.createObservableBufferedDocument;
exports.createProjectStore = TransformPatches.createProjectStore;
exports.createPublishedFrom = TransformPatches.createPublishedFrom;
exports.createSchema = TransformPatches.createSchema;
exports.createSearchQuery = TransformPatches.createSearchQuery;
exports.createSharedResizeObserver = TransformPatches.createSharedResizeObserver;
exports.createTrackerScope = TransformPatches.createTrackerScope;
exports.createUseReporter = TransformPatches.createUseReporter;
exports.createUserColorManager = TransformPatches.createUserColorManager;
exports.createUserStore = TransformPatches.createUserStore;
exports.dec = TransformPatches.dec;
exports.defaultLocale = TransformPatches.defaultLocale;
exports.defaultTheme = TransformPatches.defaultTheme;
exports.defineLocale = TransformPatches.defineLocale;
exports.defineLocaleResourceBundle = TransformPatches.defineLocaleResourceBundle;
exports.defineLocalesResources = TransformPatches.defineLocalesResources;
exports.defineSearchFilter = TransformPatches.defineSearchFilter;
exports.defineSearchFilterOperators = TransformPatches.defineSearchFilterOperators;
exports.defineSearchOperator = TransformPatches.defineSearchOperator;
exports.diffMatchPatch = TransformPatches.diffMatchPatch;
exports.documentFieldActionsReducer = TransformPatches.documentFieldActionsReducer;
exports.documentIdEquals = TransformPatches.documentIdEquals;
exports.editState = TransformPatches.editState;
exports.emitOperation = TransformPatches.emitOperation;
exports.escapeField = TransformPatches.escapeField;
exports.fieldNeedsEscape = TransformPatches.fieldNeedsEscape;
exports.findIndex = TransformPatches.findIndex;
exports.flattenConfig = TransformPatches.flattenConfig;
exports.getAnnotationAtPath = TransformPatches.getAnnotationAtPath;
exports.getAnnotationColor = TransformPatches.getAnnotationColor;
exports.getDiffAtPath = TransformPatches.getDiffAtPath;
exports.getDocumentPairPermissions = TransformPatches.getDocumentPairPermissions;
exports.getDocumentValuePermissions = TransformPatches.getDocumentValuePermissions;
exports.getDraftId = TransformPatches.getDraftId;
exports.getIdPair = TransformPatches.getIdPair;
exports.getInitialValueStream = TransformPatches.getInitialValueStream;
exports.getItemKey = TransformPatches.getItemKey;
exports.getItemKeySegment = TransformPatches.getItemKeySegment;
exports.getNamelessWorkspaceIdentifier = TransformPatches.getNamelessWorkspaceIdentifier;
exports.getPairListener = TransformPatches.getPairListener;
exports.getPreviewPaths = TransformPatches.getPreviewPaths;
exports.getPreviewStateObservable = TransformPatches.getPreviewStateObservable;
exports.getPreviewValueWithFallback = TransformPatches.getPreviewValueWithFallback;
exports.getProviderTitle = TransformPatches.getProviderTitle;
exports.getPublishedId = TransformPatches.getPublishedId;
exports.getSchemaTypeTitle = TransformPatches.getSchemaTypeTitle;
exports.getTemplatePermissions = TransformPatches.getTemplatePermissions;
exports.getValueAtPath = TransformPatches.getValueAtPath;
exports.getValueError = TransformPatches.getValueError;
exports.getWorkspaceIdentifier = TransformPatches.getWorkspaceIdentifier;
exports.globalScope = TransformPatches.globalScope;
exports.grantsPermissionOn = TransformPatches.grantsPermissionOn;
exports.inc = TransformPatches.inc;
exports.initialDocumentFieldActions = TransformPatches.initialDocumentFieldActions;
exports.insert = TransformPatches.insert;
exports.isAddedItemDiff = TransformPatches.isAddedItemDiff;
exports.isArrayOfBlocksInputProps = TransformPatches.isArrayOfBlocksInputProps;
exports.isArrayOfObjectsInputProps = TransformPatches.isArrayOfObjectsInputProps;
exports.isArrayOfPrimitivesInputProps = TransformPatches.isArrayOfPrimitivesInputProps;
exports.isAuthStore = TransformPatches.isAuthStore;
exports.isBooleanInputProps = TransformPatches.isBooleanInputProps;
exports.isBuilder = TransformPatches.isBuilder;
exports.isCookielessCompatibleLoginMethod = TransformPatches.isCookielessCompatibleLoginMethod;
exports.isDev = TransformPatches.isDev;
exports.isDraft = TransformPatches.isDraft;
exports.isDraftId = TransformPatches.isDraftId;
exports.isEmptyObject = TransformPatches.isEmptyObject;
exports.isFieldChange = TransformPatches.isFieldChange;
exports.isGroupChange = TransformPatches.isGroupChange;
exports.isNonNullable = TransformPatches.isNonNullable;
exports.isNumberInputProps = TransformPatches.isNumberInputProps;
exports.isObjectInputProps = TransformPatches.isObjectInputProps;
exports.isObjectItemProps = TransformPatches.isObjectItemProps;
exports.isProd = TransformPatches.isProd;
exports.isPublishedId = TransformPatches.isPublishedId;
exports.isRecord = TransformPatches.isRecord;
exports.isRemovedItemDiff = TransformPatches.isRemovedItemDiff;
exports.isString = TransformPatches.isString;
exports.isStringInputProps = TransformPatches.isStringInputProps;
exports.isUnchangedDiff = TransformPatches.isUnchangedDiff;
exports.joinPath = TransformPatches.joinPath;
exports.listenQuery = TransformPatches.listenQuery;
exports.matchWorkspace = TransformPatches.matchWorkspace;
exports.newDraftFrom = TransformPatches.newDraftFrom;
exports.noop = TransformPatches.noop;
exports.normalizeIndexSegment = TransformPatches.normalizeIndexSegment;
exports.normalizeIndexTupleSegment = TransformPatches.normalizeIndexTupleSegment;
exports.normalizeKeySegment = TransformPatches.normalizeKeySegment;
exports.normalizePathSegment = TransformPatches.normalizePathSegment;
exports.onRetry = TransformPatches.onRetry;
exports.operationEvents = TransformPatches.operationEvents;
exports.operatorDefinitions = TransformPatches.operatorDefinitions;
exports.pathToString = TransformPatches.pathToString;
exports.pathsAreEqual = TransformPatches.pathsAreEqual;
exports.prefixPath = TransformPatches.prefixPath;
exports.prepareConfig = TransformPatches.prepareConfig;
exports.prepareForPreview = TransformPatches.prepareForPreview;
exports.removeDupes = TransformPatches.removeDupes;
exports.removeMissingReferences = TransformPatches.removeMissingReferences;
exports.removeUndefinedLocaleResources = TransformPatches.removeUndefinedLocaleResources;
exports.resizeObserver = TransformPatches.resizeObserver;
exports.resolveDiffComponent = TransformPatches.resolveDiffComponent;
exports.resolveInitialObjectValue = TransformPatches.resolveInitialObjectValue;
exports.resolveInitialValue = TransformPatches.resolveInitialValue;
exports.resolveInitialValueForType = TransformPatches.resolveInitialValueForType;
exports.resolveSchemaTypes = TransformPatches.resolveSchemaTypes;
exports.set = TransformPatches.set;
exports.setIfMissing = TransformPatches.setIfMissing;
exports.sliceString = TransformPatches.sliceString;
exports.snapshotPair = TransformPatches.snapshotPair;
exports.stringToPath = TransformPatches.stringToPath;
exports.supportsTouch = TransformPatches.supportsTouch;
exports.truncateString = TransformPatches.truncateString;
exports.unset = TransformPatches.unset;
exports.unstable_useValuePreview = TransformPatches.useDocumentPreview;
exports.usEnglishLocale = TransformPatches.usEnglishLocale;
exports.useActiveWorkspace = TransformPatches.useActiveWorkspace;
exports.useAnnotationColor = TransformPatches.useAnnotationColor;
exports.useClient = TransformPatches.useClient;
exports.useColorScheme = TransformPatches.useColorScheme;
exports.useColorSchemeOptions = TransformPatches.useColorSchemeOptions;
exports.useColorSchemeSetValue = TransformPatches.useColorSchemeSetValue;
exports.useColorSchemeValue = TransformPatches.useColorSchemeValue;
exports.useConnectionStatusStore = TransformPatches.useConnectionStatusStore;
exports.useCurrentLocale = TransformPatches.useCurrentLocale;
exports.useCurrentUser = TransformPatches.useCurrentUser;
exports.useDataset = TransformPatches.useDataset;
exports.useDateTimeFormat = TransformPatches.useDateTimeFormat;
exports.useDidUpdate = TransformPatches.useDidUpdate;
exports.useDiffAnnotationColor = TransformPatches.useDiffAnnotationColor;
exports.useDocumentChange = TransformPatches.useDocumentChange;
exports.useDocumentOperation = TransformPatches.useDocumentOperation;
exports.useDocumentPairPermissions = TransformPatches.useDocumentPairPermissions;
exports.useDocumentPairPermissionsFromHookFactory = TransformPatches.useDocumentPairPermissionsFromHookFactory;
exports.useDocumentPresence = TransformPatches.useDocumentPresence;
exports.useDocumentPreviewStore = TransformPatches.useDocumentPreviewStore;
exports.useDocumentStore = TransformPatches.useDocumentStore;
exports.useDocumentValuePermissions = TransformPatches.useDocumentValuePermissions;
exports.useDocumentValuePermissionsFromHookFactory = TransformPatches.useDocumentValuePermissionsFromHookFactory;
exports.useDocumentValues = TransformPatches.useDocumentValues;
exports.useFeatureEnabled = TransformPatches.useFeatureEnabled;
exports.useFieldActions = TransformPatches.useFieldActions;
exports.useFormBuilder = TransformPatches.useFormBuilder;
exports.useFormCallbacks = TransformPatches.useFormCallbacks;
exports.useFormValue = TransformPatches.useFormValue;
exports.useGetI18nText = TransformPatches.useGetI18nText;
exports.useGlobalPresence = TransformPatches.useGlobalPresence;
exports.useGrantsStore = TransformPatches.useGrantsStore;
exports.useHistoryStore = TransformPatches.useHistoryStore;
exports.useHoveredField = TransformPatches.useHoveredField;
exports.useI18nText = TransformPatches.useI18nText;
exports.useInitialValue = TransformPatches.useInitialValue;
exports.useInitialValueResolverContext = TransformPatches.useInitialValueResolverContext;
exports.useKeyValueStore = TransformPatches.useKeyValueStore;
exports.useListFormat = TransformPatches.useListFormat;
exports.useLoadable = TransformPatches.useLoadable;
exports.useLocale = TransformPatches.useLocale;
exports.useMiddlewareComponents = TransformPatches.useMiddlewareComponents;
exports.usePresenceStore = TransformPatches.usePresenceStore;
exports.usePreviewCard = TransformPatches.usePreviewCard;
exports.useProjectId = TransformPatches.useProjectId;
exports.useProjectStore = TransformPatches.useProjectStore;
exports.useReferenceInputOptions = TransformPatches.useReferenceInputOptions;
exports.useRelativeTime = TransformPatches.useRelativeTime;
exports.useReportedValues = TransformPatches.useReportedValues;
exports.useReporter = TransformPatches.useReporter;
exports.useResolveInitialValueForType = TransformPatches.useResolveInitialValueForType;
exports.useResourceCache = TransformPatches.useResourceCache;
exports.useRovingFocus = TransformPatches.useRovingFocus;
exports.useSchema = TransformPatches.useSchema;
exports.useSource = TransformPatches.useSource;
exports.useTemplatePermissions = TransformPatches.useTemplatePermissions;
exports.useTemplatePermissionsFromHookFactory = TransformPatches.useTemplatePermissionsFromHookFactory;
exports.useTemplates = TransformPatches.useTemplates;
exports.useTranslation = TransformPatches.useTranslation;
exports.useUnique = TransformPatches.useUnique;
exports.useUnitFormatter = TransformPatches.useUnitFormatter;
exports.useUser = TransformPatches.useUser;
exports.useUserColor = TransformPatches.useUserColor;
exports.useUserColorManager = TransformPatches.useUserColorManager;
exports.useUserStore = TransformPatches.useUserStore;
exports.useVirtualizerScrollInstance = TransformPatches.useVirtualizerScrollInstance;
exports.useWorkspace = TransformPatches.useWorkspace;
exports.useWorkspaces = TransformPatches.useWorkspaces;
exports.useZIndex = TransformPatches.useZIndex;
exports.userHasRole = TransformPatches.userHasRole;
exports.validateBasePaths = TransformPatches.validateBasePaths;
exports.validateDocument = TransformPatches.validateDocument;
exports.validateNames = TransformPatches.validateNames;
exports.validateWorkspaces = TransformPatches.validateWorkspaces;
exports.validation = TransformPatches.validation;
exports.visitDiff = TransformPatches.visitDiff;
exports.AddonDatasetProvider = AddonDatasetProvider;
exports.ArrayOfObjectsInputMember = ArrayOfObjectsInputMember;
exports.ArrayOfObjectsInputMembers = ArrayOfObjectsInputMembers;
exports.BetaBadge = BetaBadge;
exports.ChangeConnectorRoot = ChangeConnectorRoot;
exports.ChangeFieldWrapper = ChangeFieldWrapper;
exports.DefaultDocument = DefaultDocument;
exports.DisabledChangeConnectorRoot = DisabledChangeConnectorRoot;
exports.EnabledChangeConnectorRoot = EnabledChangeConnectorRoot;
exports.FormBuilder = FormBuilder;
exports.FormProvider = FormProvider;
exports.GetHookCollectionState = GetHookCollectionState;
exports.GlobalErrorHandler = GlobalErrorHandler;
exports.Hotkeys = Hotkeys;
exports.HoveredFieldProvider = HoveredFieldProvider;
exports.IntentButton = IntentButton;
exports.PresenceScope = PresenceScope;
exports.RelativeTime = RelativeTime;
exports.ScrollMonitor = ScrollMonitor;
exports.Studio = Studio;
exports.StudioLogo = StudioLogo;
exports.TelephoneInput = TelephoneInput;
exports.WithReferringDocuments = WithReferringDocuments;
exports.ZIndexProvider = ZIndexProvider;
exports._isCustomDocumentTypeDefinition = _isCustomDocumentTypeDefinition;
exports._isSanityDocumentTypeDefinition = _isSanityDocumentTypeDefinition;
exports.buildLegacyTheme = buildLegacyTheme;
exports.createConfig = createConfig;
exports.createMockAuthStore = createMockAuthStore;
exports.createNoopTrackerScope = createNoopTrackerScope;
exports.createPatchChannel = createPatchChannel;
exports.createPlugin = createPlugin;
exports.createSourceFromConfig = createSourceFromConfig;
exports.createWorkspaceFromConfig = createWorkspaceFromConfig;
exports.decodePath = decodePath;
exports.defaultRenderAnnotation = defaultRenderAnnotation;
exports.defaultRenderBlock = defaultRenderBlock;
exports.defaultRenderField = defaultRenderField;
exports.defaultRenderInlineBlock = defaultRenderInlineBlock;
exports.defaultRenderInput = defaultRenderInput;
exports.defaultRenderItem = defaultRenderItem;
exports.defaultRenderPreview = defaultRenderPreview;
exports.defaultTemplateForType = defaultTemplateForType;
exports.defaultTemplatesForSchema = defaultTemplatesForSchema;
exports.defineConfig = defineConfig;
exports.defineDocumentFieldAction = defineDocumentFieldAction;
exports.defineDocumentInspector = defineDocumentInspector;
exports.definePlugin = definePlugin;
exports.diffResolver = diffResolver;
exports.encodePath = encodePath;
exports.fromMutationPatches = fromMutationPatches;
exports.getConfigContextFromSource = getConfigContextFromSource;
exports.getExpandOperations = getExpandOperations;
exports.isArray = isArray;
exports.isTruthy = isTruthy;
exports.prepareTemplates = prepareTemplates;
exports.remoteSnapshots = remoteSnapshots;
exports.renderStudio = renderStudio;
exports.resolveConditionalProperty = resolveConditionalProperty;
exports.resolveConfig = resolveConfig;
exports.setAtPath = setAtPath;
exports.toMutationPatches = toMutationPatches;
exports.uncaughtErrorHandler = uncaughtErrorHandler;
exports.useAddonDataset = useAddonDataset;
exports.useConfigContextFromSource = useConfigContextFromSource;
exports.useConnectionState = useConnectionState;
exports.useDocumentOperationEvent = useDocumentOperationEvent;
exports.useDocumentType = useDocumentType;
exports.useEditState = useEditState;
exports.useFormState = useFormState;
exports.useFormattedDuration = useFormattedDuration;
exports.useNumberFormat = useNumberFormat;
exports.useOnScroll = useOnScroll;
exports.useProject = useProject;
exports.useProjectDatasets = useProjectDatasets;
exports.useReviewChanges = useReviewChanges;
exports.useSyncState = useSyncState;
exports.useThrottledCallback = useThrottledCallback;
exports.useTimeAgo = useTimeAgo;
exports.useTimelineSelector = useTimelineSelector;
exports.useTimelineStore = useTimelineStore;
exports.useTools = useTools;
exports.useUserListWithPermissions = useUserListWithPermissions;
exports.useValidationStatus = useValidationStatus;
Object.keys(types).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return types[k];
    }
  });
});
//# sourceMappingURL=index.js.map
