'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var diffMatchPatch = require('@sanity/diff-match-patch');
function pathToString(path) {
  return path.reduce((target, segment, i) => {
    if (Array.isArray(segment)) {
      return "".concat(target, "[").concat(segment.join(":"), "]");
    }
    if (isKeyedObject(segment)) {
      return "".concat(target, "[_key==\"").concat(segment._key, "\"]");
    }
    if (typeof segment === "number") {
      return "".concat(target, "[").concat(segment, "]");
    } else if (typeof segment === "string" && /^\d+$/.test(segment)) {
      return "".concat(target, "[\"").concat(segment, "\"]");
    }
    if (typeof segment === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    throw new Error("Unsupported path segment \"".concat(segment, "\""));
  }, "");
}
function isKeyedObject(obj) {
  return typeof obj === "object" && typeof obj._key === "string";
}
class DiffError extends Error {
  constructor(message, path, value) {
    const serializedPath = pathToString(path);
    super("".concat(message, " (at '").concat(serializedPath, "')"));
    this.path = path;
    this.serializedPath = serializedPath;
    this.value = value;
  }
}
const idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;
const propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
const propStartPattern = /^[a-z_]/i;
function validateProperty(property, value, path) {
  if (!propStartPattern.test(property)) {
    throw new DiffError("Keys must start with a letter (a-z)", path.concat(property), value);
  }
  if (!propPattern.test(property)) {
    throw new DiffError("Keys can only contain letters, numbers and underscores", path.concat(property), value);
  }
  if (property === "_key" || property === "_ref" || property === "_type") {
    if (typeof value !== "string") {
      throw new DiffError("Keys must be strings", path.concat(property), value);
    }
    if (!idPattern.test(value)) {
      throw new DiffError("Invalid key - use less exotic characters", path.concat(property), value);
    }
  }
  return property;
}
const ignoredKeys = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
const defaultOptions = {
  hideWarnings: false,
  diffMatchPatch: {
    enabled: true,
    // Only use diff-match-patch if target string is longer than this threshold
    lengthThresholdAbsolute: 30,
    // Only use generated diff-match-patch if the patch length is less than or equal to
    // (targetString * relative). Example: A 100 character target with a relative factor
    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,
    // it will fall back to a regular `set` patch.
    lengthThresholdRelative: 1.2
  }
};
function mergeOptions(options) {
  return {
    ...defaultOptions,
    ...options,
    diffMatchPatch: {
      ...defaultOptions.diffMatchPatch,
      ...(options.diffMatchPatch || {})
    }
  };
}
function diffPatch(itemA, itemB, opts) {
  const options = mergeOptions(opts || {});
  const id = options.id || itemA._id === itemB._id && itemA._id;
  const revisionLocked = options.ifRevisionID;
  const ifRevisionID = typeof revisionLocked === "boolean" ? itemA._rev : revisionLocked;
  const basePath = options.basePath || [];
  if (!id) {
    throw new Error("_id on itemA and itemB not present or differs, specify document id the mutations should be applied to");
  }
  if (revisionLocked === true && !ifRevisionID) {
    throw new Error("`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.");
  }
  if (basePath.length === 0 && itemA._type !== itemB._type) {
    throw new Error("_type is immutable and cannot be changed (".concat(itemA._type, " => ").concat(itemB._type, ")"));
  }
  const operations = diffItem(itemA, itemB, options, basePath, []);
  return serializePatches(operations, {
    id,
    ifRevisionID: revisionLocked ? ifRevisionID : void 0
  });
}
function diffItem(itemA, itemB) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;
  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  if (itemA === itemB) {
    return patches;
  }
  const aType = Array.isArray(itemA) ? "array" : typeof itemA;
  const bType = Array.isArray(itemB) ? "array" : typeof itemB;
  const aIsUndefined = aType === "undefined";
  const bIsUndefined = bType === "undefined";
  if (aIsUndefined && !bIsUndefined) {
    patches.push({
      op: "set",
      path,
      value: itemB
    });
    return patches;
  }
  if (!aIsUndefined && bIsUndefined) {
    patches.push({
      op: "unset",
      path
    });
    return patches;
  }
  const options = mergeOptions(opts);
  const dataType = aIsUndefined ? bType : aType;
  const isContainer = dataType === "object" || dataType === "array";
  if (!isContainer) {
    return diffPrimitive(itemA, itemB, options, path, patches);
  }
  if (aType !== bType) {
    patches.push({
      op: "set",
      path,
      value: itemB
    });
    return patches;
  }
  return dataType === "array" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);
}
function diffObject(itemA, itemB, options, path, patches) {
  const atRoot = path.length === 0;
  const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemA[key], path));
  const aKeysLength = aKeys.length;
  const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemB[key], path));
  const bKeysLength = bKeys.length;
  for (let i = 0; i < aKeysLength; i++) {
    const key = aKeys[i];
    if (!(key in itemB)) {
      patches.push({
        op: "unset",
        path: path.concat(key)
      });
    }
  }
  for (let i = 0; i < bKeysLength; i++) {
    const key = bKeys[i];
    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches);
  }
  return patches;
}
function diffArray(itemA, itemB, options, path, patches) {
  if (itemB.length > itemA.length) {
    patches.push({
      op: "insert",
      after: path.concat([-1]),
      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))
    });
  }
  if (itemB.length < itemA.length) {
    const isSingle = itemA.length - itemB.length === 1;
    const unsetItems = itemA.slice(itemB.length);
    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {
      patches.push({
        op: "unset",
        path: path.concat([isSingle ? itemB.length : [itemB.length, ""]])
      });
    } else {
      patches.push(...unsetItems.map(item => ({
        op: "unset",
        path: path.concat({
          _key: item._key
        })
      })));
    }
  }
  for (let i = 0; i < itemB.length; i++) {
    if (Array.isArray(itemB[i])) {
      throw new DiffError("Multi-dimensional arrays not supported", path.concat(i), itemB[i]);
    }
  }
  const overlapping = Math.min(itemA.length, itemB.length);
  const segmentA = itemA.slice(0, overlapping);
  const segmentB = itemB.slice(0, overlapping);
  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);
}
function diffArrayByIndex(itemA, itemB, options, path, patches) {
  for (let i = 0; i < itemA.length; i++) {
    diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);
  }
  return patches;
}
function diffArrayByKey(itemA, itemB, options, path, patches) {
  const keyedA = indexByKey(itemA);
  const keyedB = indexByKey(itemB);
  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {
    return diffArrayByIndex(itemA, itemB, options, path, patches);
  }
  for (let i = 0; i < keyedB.keys.length; i++) {
    const key = keyedB.keys[i];
    const valueA = keyedA.index[key];
    const valueB = nullifyUndefined(keyedB.index[key], path, i, options);
    diffItem(valueA, valueB, options, path.concat({
      _key: key
    }), patches);
  }
  return patches;
}
function getDiffMatchPatch(itemA, itemB, options, path) {
  const {
    enabled,
    lengthThresholdRelative,
    lengthThresholdAbsolute
  } = options.diffMatchPatch;
  const segment = path[path.length - 1];
  if (!enabled ||
  // Don't use for anything but strings
  typeof itemA !== "string" || typeof itemB !== "string" ||
  // Don't use for `_key`, `_ref` etc
  typeof segment === "string" && segment[0] === "_" ||
  // Don't use on short strings
  itemB.length < lengthThresholdAbsolute) {
    return void 0;
  }
  let strPatch = "";
  try {
    const patch = diffMatchPatch.makeDiff(itemA, itemB);
    const diff = diffMatchPatch.cleanupEfficiency(patch);
    strPatch = diffMatchPatch.stringifyPatches(diffMatchPatch.makePatches(diff));
  } catch (err) {
    return void 0;
  }
  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {
    op: "diffMatchPatch",
    path,
    value: strPatch
  };
}
function diffPrimitive(itemA, itemB, options, path, patches) {
  const dmp = getDiffMatchPatch(itemA, itemB, options, path);
  patches.push(dmp || {
    op: "set",
    path,
    value: itemB
  });
  return patches;
}
function isNotIgnoredKey(key) {
  return ignoredKeys.indexOf(key) === -1;
}
function serializePatches(patches, options) {
  if (patches.length === 0) {
    return [];
  }
  const {
    id,
    ifRevisionID
  } = options;
  const set = patches.filter(patch => patch.op === "set");
  const unset = patches.filter(patch => patch.op === "unset");
  const insert = patches.filter(patch => patch.op === "insert");
  const dmp = patches.filter(patch => patch.op === "diffMatchPatch");
  const withSet = set.length > 0 && set.reduce((patch, item) => {
    const path = pathToString(item.path);
    patch.set[path] = item.value;
    return patch;
  }, {
    id,
    set: {}
  });
  const withUnset = unset.length > 0 && unset.reduce((patch, item) => {
    const path = pathToString(item.path);
    patch.unset.push(path);
    return patch;
  }, {
    id,
    unset: []
  });
  const withInsert = insert.reduce((acc, item) => {
    const after = pathToString(item.after);
    return acc.concat({
      id,
      insert: {
        after,
        items: item.items
      }
    });
  }, []);
  const withDmp = dmp.length > 0 && dmp.reduce((patch, item) => {
    const path = pathToString(item.path);
    patch.diffMatchPatch[path] = item.value;
    return patch;
  }, {
    id,
    diffMatchPatch: {}
  });
  const patchSet = [withSet, withUnset, withDmp, ...withInsert].filter(item => item !== false);
  return patchSet.map((patch, i) => ({
    patch: ifRevisionID && i === 0 ? {
      ...patch,
      ifRevisionID
    } : patch
  }));
}
function isUniquelyKeyed(arr) {
  const keys = [];
  for (let i = 0; i < arr.length; i++) {
    const key = getKey(arr[i]);
    if (!key || keys.indexOf(key) !== -1) {
      return false;
    }
    keys.push(key);
  }
  return true;
}
function getKey(obj) {
  return typeof obj === "object" && obj !== null && obj._key;
}
function indexByKey(arr) {
  return arr.reduce((acc, item) => {
    acc.keys.push(item._key);
    acc.index[item._key] = item;
    return acc;
  }, {
    keys: [],
    index: {}
  });
}
function arrayIsEqual(itemA, itemB) {
  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);
}
function nullifyUndefined(item, path, index, options) {
  if (typeof item !== "undefined") {
    return item;
  }
  if (!options.hideWarnings) {
    const serializedPath = pathToString(path.concat(index));
    console.warn("undefined value in array converted to null (at '".concat(serializedPath, "')"));
  }
  return null;
}
function isRevisionLocked(options) {
  return Boolean(options.ifRevisionID);
}
function yes(_) {
  return true;
}
exports.DiffError = DiffError;
exports.diffItem = diffItem;
exports.diffPatch = diffPatch;
//# sourceMappingURL=index.cjs.map
