{
  "version": 3,
  "sources": ["../../../sanity/src/structure/components/paneRouter/PaneRouterProvider.tsx", "../../../sanity/src/structure/structureResolvers/PaneResolutionError.ts", "../../../sanity/src/structure/structureResolvers/assignId.ts", "../../../sanity/src/structure/structureResolvers/createPaneResolver.ts", "../../../sanity/src/structure/structureResolvers/memoBind.ts", "../../../sanity/src/structure/structureResolvers/resolveIntent.ts", "../../../sanity/src/structure/structureResolvers/createResolvedPaneNodeStream.ts", "../../../sanity/src/structure/structureResolvers/useResolvedPanes.ts", "../../../sanity/src/structure/components/structureTool/intentResolver/utils.ts", "../../../sanity/src/structure/components/structureTool/intentResolver/IntentResolver.tsx", "../../../sanity/src/structure/components/structureTool/StructureError.tsx", "../../../sanity/src/structure/panes/unknown/UnknownPaneType.tsx", "../../../sanity/src/structure/panes/StructureToolPane.tsx", "../../../sanity/src/structure/components/structureTool/NoDocumentTypesScreen.tsx", "../../../sanity/src/structure/components/structureTool/StructureTitle.tsx", "../../../sanity/src/structure/components/structureTool/StructureTool.tsx", "../../../sanity/src/structure/components/structureTool/StructureToolBoundary.tsx"],
  "sourcesContent": ["import {toString as pathToString} from '@sanity/util/paths'\nimport {omit} from 'lodash'\nimport type * as React from 'react'\nimport {useCallback, useMemo} from 'react'\nimport {useRouter, useRouterState} from 'sanity/router'\n\nimport {type RouterPaneGroup, type RouterPanes, type RouterPaneSibling} from '../../types'\nimport {usePaneLayout} from '../pane/usePaneLayout'\nimport {BackLink} from './BackLink'\nimport {ChildLink} from './ChildLink'\nimport {PaneRouterContext} from './PaneRouterContext'\nimport {ParameterizedLink} from './ParameterizedLink'\nimport {ReferenceChildLink} from './ReferenceChildLink'\nimport {type PaneRouterContextValue} from './types'\n\nconst emptyArray: never[] = []\n\n/**\n * @internal\n */\nexport function PaneRouterProvider(props: {\n  children: React.ReactNode\n  flatIndex: number\n  index: number\n  params: Record<string, string | undefined>\n  payload: unknown\n  siblingIndex: number\n}) {\n  const {children, flatIndex, index, params, payload, siblingIndex} = props\n  const {navigate, navigateIntent, resolvePathFromState} = useRouter()\n  const routerState = useRouterState()\n  const {panes, expand} = usePaneLayout()\n  const routerPaneGroups: RouterPaneGroup[] = useMemo(\n    () => (routerState?.panes || emptyArray) as RouterPanes,\n    [routerState?.panes],\n  )\n  const lastPane = useMemo(() => panes?.[panes.length - 2], [panes])\n\n  const groupIndex = index - 1\n\n  const createNextRouterState = useCallback(\n    (modifier: (siblings: RouterPaneGroup, item: RouterPaneSibling) => RouterPaneGroup) => {\n      const currentGroup = routerPaneGroups[groupIndex] || []\n      const currentItem = currentGroup[siblingIndex]\n      const nextGroup = modifier(currentGroup, currentItem)\n      const nextPanes = [\n        ...routerPaneGroups.slice(0, groupIndex),\n        nextGroup,\n        ...routerPaneGroups.slice(groupIndex + 1),\n      ]\n      const nextRouterState = {...(routerState || {}), panes: nextPanes}\n\n      return nextRouterState\n    },\n    [groupIndex, routerPaneGroups, routerState, siblingIndex],\n  )\n\n  const modifyCurrentGroup = useCallback(\n    (modifier: (siblings: RouterPaneGroup, item: RouterPaneSibling) => RouterPaneGroup) => {\n      const nextRouterState = createNextRouterState(modifier)\n      setTimeout(() => navigate(nextRouterState), 0)\n      return nextRouterState\n    },\n    [createNextRouterState, navigate],\n  )\n\n  const createPathWithParams: PaneRouterContextValue['createPathWithParams'] = useCallback(\n    (nextParams) => {\n      const nextRouterState = createNextRouterState((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, params: nextParams},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n\n      return resolvePathFromState(nextRouterState)\n    },\n    [createNextRouterState, resolvePathFromState, siblingIndex],\n  )\n\n  const setPayload: PaneRouterContextValue['setPayload'] = useCallback(\n    (nextPayload) => {\n      modifyCurrentGroup((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, payload: nextPayload},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n    },\n    [modifyCurrentGroup, siblingIndex],\n  )\n\n  const setParams: PaneRouterContextValue['setParams'] = useCallback(\n    (nextParams) => {\n      modifyCurrentGroup((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, params: nextParams},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n    },\n    [modifyCurrentGroup, siblingIndex],\n  )\n\n  const handleEditReference: PaneRouterContextValue['handleEditReference'] = useCallback(\n    ({id, parentRefPath, type, template}) => {\n      navigate({\n        panes: [\n          ...routerPaneGroups.slice(0, groupIndex + 1),\n          [\n            {\n              id,\n              params: {template: template.id, parentRefPath: pathToString(parentRefPath), type},\n              payload: template.params,\n            },\n          ],\n        ],\n      })\n    },\n    [groupIndex, navigate, routerPaneGroups],\n  )\n\n  const ctx: PaneRouterContextValue = useMemo(\n    () => ({\n      // Zero-based index (position) of pane, visually\n      index: flatIndex,\n\n      // Zero-based index of pane group (within URL structure)\n      groupIndex,\n\n      // Zero-based index of pane within sibling group\n      siblingIndex,\n\n      // Payload of the current pane\n      payload,\n\n      // Params of the current pane\n      params,\n\n      // Whether or not the pane has any siblings (within the same group)\n      hasGroupSiblings: routerPaneGroups[groupIndex]\n        ? routerPaneGroups[groupIndex].length > 1\n        : false,\n\n      // The length of the current group\n      groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,\n\n      // Current router state for the \"panes\" property\n      routerPanesState: routerPaneGroups,\n\n      // Curried StateLink that passes the correct state automatically\n      ChildLink,\n\n      // Curried StateLink that pops off the last pane group\n      BackLink,\n\n      // A specialized `ChildLink` that takes in the needed props to open a\n      // referenced document to the right\n      ReferenceChildLink,\n\n      // Similar to `ReferenceChildLink` expect without the wrapping component\n      handleEditReference,\n\n      // Curried StateLink that passed the correct state, but merges params/payload\n      ParameterizedLink,\n\n      // Replaces the current pane with a new one\n      replaceCurrent: (opts = {}): void => {\n        modifyCurrentGroup(() => [\n          {id: opts.id || '', payload: opts.payload, params: opts.params || {}},\n        ])\n      },\n\n      // Removes the current pane from the group\n      closeCurrent: (): void => {\n        modifyCurrentGroup((siblings, item) =>\n          siblings.length > 1 ? siblings.filter((sibling) => sibling !== item) : siblings,\n        )\n      },\n\n      // Removes all panes to the right including current\n      closeCurrentAndAfter: (expandLast = true): void => {\n        if (expandLast && lastPane) {\n          expand(lastPane.element)\n        }\n        navigate(\n          {\n            panes: [...routerPaneGroups.slice(0, groupIndex)],\n          },\n          {replace: true},\n        )\n      },\n\n      // Duplicate the current pane, with optional overrides for payload, parameters\n      duplicateCurrent: (options): void => {\n        modifyCurrentGroup((siblings, item) => {\n          const duplicatedItem = {\n            ...item,\n            payload: options?.payload || item.payload,\n            params: options?.params || item.params,\n          }\n\n          return [\n            ...siblings.slice(0, siblingIndex),\n            duplicatedItem,\n            ...siblings.slice(siblingIndex),\n          ]\n        })\n      },\n\n      // Set the view for the current pane\n      setView: (viewId) => {\n        const restParams = omit(params, 'view')\n        return setParams(viewId ? {...restParams, view: viewId} : restParams)\n      },\n\n      // Set the parameters for the current pane\n      setParams,\n\n      // Set the payload for the current pane\n      setPayload,\n\n      // A function that returns a path with the given parameters\n      createPathWithParams,\n\n      // Proxied navigation to a given intent. Consider just exposing `router` instead?\n      navigateIntent,\n    }),\n    [\n      flatIndex,\n      groupIndex,\n      siblingIndex,\n      payload,\n      params,\n      routerPaneGroups,\n      handleEditReference,\n      setParams,\n      setPayload,\n      createPathWithParams,\n      navigateIntent,\n      modifyCurrentGroup,\n      lastPane,\n      navigate,\n      expand,\n    ],\n  )\n\n  return <PaneRouterContext.Provider value={ctx}>{children}</PaneRouterContext.Provider>\n}\n", "import {type RouterPaneSiblingContext} from '../types'\n\nexport interface PaneResolutionErrorOptions {\n  message: string\n  context?: RouterPaneSiblingContext\n  helpId?: string\n  cause?: Error\n}\n\n/**\n * An error thrown during pane resolving. This error is meant to be bubbled up\n * through react and handled in an error boundary. It includes a `cause`\n * property which is the original error caught\n */\nexport class PaneResolutionError extends Error {\n  cause: Error | undefined\n  context: RouterPaneSiblingContext | undefined\n  helpId: string | undefined\n\n  constructor({message, context, helpId, cause}: PaneResolutionErrorOptions) {\n    super(message)\n    this.context = context\n    this.helpId = helpId\n    this.cause = cause\n  }\n}\n", "import {nanoid} from 'nanoid'\n\n// `WeakMap`s require the first type param to extend `object`\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst randomIdCache = new WeakMap<object, string>()\n\n/**\n * given an object, this function randomly generates an ID and returns it. this\n * result is then saved in a WeakMap so subsequent requests for the same object\n * will receive the same ID\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function assignId(obj: object): string {\n  const cachedValue = randomIdCache.get(obj)\n  if (cachedValue) return cachedValue\n\n  const id = nanoid()\n  randomIdCache.set(obj, id)\n  return id\n}\n", "import {from, isObservable, type Observable, of as observableOf} from 'rxjs'\nimport {publishReplay, refCount, switchMap} from 'rxjs/operators'\nimport {isRecord} from 'sanity'\n\nimport {type PaneNode, type RouterPaneSiblingContext, type UnresolvedPaneNode} from '../types'\nimport {PaneResolutionError} from './PaneResolutionError'\n\ninterface Serializable {\n  serialize: (...args: never[]) => unknown\n}\n\nconst isPromise = (thing: any): thing is PromiseLike<unknown> => {\n  return !!thing && typeof thing?.then === 'function'\n}\nconst isSerializable = (thing: unknown): thing is Serializable => {\n  if (!isRecord(thing)) return false\n  return typeof thing.serialize === 'function'\n}\n\n/**\n * The signature of the function used to take an `UnresolvedPaneNode` and turn\n * it into an `Observable<PaneNode>`.\n */\nexport type PaneResolver = (\n  unresolvedPane: UnresolvedPaneNode | undefined,\n  context: RouterPaneSiblingContext,\n  flatIndex: number,\n) => Observable<PaneNode>\n\nexport type PaneResolverMiddleware = (paneResolveFn: PaneResolver) => PaneResolver\n\nconst rethrowWithPaneResolutionErrors: PaneResolverMiddleware =\n  (next) => (unresolvedPane, context, flatIndex) => {\n    try {\n      return next(unresolvedPane, context, flatIndex)\n    } catch (e) {\n      // re-throw errors that are already `PaneResolutionError`s\n      if (e instanceof PaneResolutionError) {\n        throw e\n      }\n\n      // anything else, wrap with `PaneResolutionError` and set the underlying\n      // error as a the `cause`\n      throw new PaneResolutionError({\n        message: typeof e?.message === 'string' ? e.message : '',\n        context,\n        cause: e,\n      })\n    }\n  }\n\nconst wrapWithPublishReplay: PaneResolverMiddleware =\n  (next) =>\n  (...args) => {\n    return next(...args).pipe(\n      // need to add publishReplay + refCount to ensure new subscribers always\n      // get an emission. without this, memoized observables may get stuck\n      // waiting for their first emissions resulting in a loading pane\n      publishReplay(1),\n      refCount(),\n    )\n  }\n\nexport function createPaneResolver(middleware: PaneResolverMiddleware): PaneResolver {\n  // note: this API includes a middleware/wrapper function because the function\n  // is recursive. we want to call the wrapped version of the function always\n  // (even inside of nested calls) so the identifier invoked for the recursion\n  // should be the wrapped version\n  const resolvePane = rethrowWithPaneResolutionErrors(\n    wrapWithPublishReplay(\n      middleware((unresolvedPane, context, flatIndex) => {\n        if (!unresolvedPane) {\n          throw new PaneResolutionError({\n            message: 'Pane returned no child',\n            context,\n            helpId: 'structure-item-returned-no-child',\n          })\n        }\n\n        if (isPromise(unresolvedPane) || isObservable(unresolvedPane)) {\n          return from(unresolvedPane).pipe(\n            switchMap((result) => resolvePane(result, context, flatIndex)),\n          )\n        }\n\n        if (isSerializable(unresolvedPane)) {\n          return resolvePane(unresolvedPane.serialize(context), context, flatIndex)\n        }\n\n        if (typeof unresolvedPane === 'function') {\n          return resolvePane(unresolvedPane(context.id, context), context, flatIndex)\n        }\n\n        return observableOf(unresolvedPane)\n      }),\n    ),\n  )\n\n  return resolvePane\n}\n", "/* eslint-disable @typescript-eslint/ban-types */\n\n// `WeakMap`s require the first type param to extend `object`\nconst bindCache = new WeakMap<object, Map<string, Function>>()\n\n/**\n * An alternative to `obj.method.bind(obj)` that utilizes a weakmap to return\n * the same memory reference for sequent binds.\n */\nexport function memoBind<\n  T extends object,\n  K extends keyof {[P in keyof T]: T[P] extends Function ? T[P] : never},\n>(obj: T, methodKey: K): T[K]\nexport function memoBind(obj: Record<string, unknown>, methodKey: string): Function {\n  const boundMethods = bindCache.get(obj) || new Map<string, Function>()\n  if (boundMethods) {\n    const bound = boundMethods.get(methodKey)\n    if (bound) return bound\n  }\n\n  const method = obj[methodKey]\n\n  if (typeof method !== 'function') {\n    throw new Error(\n      `Expected property \\`${methodKey}\\` to be a function but got ${typeof method} instead.`,\n    )\n  }\n\n  const bound = method.bind(obj)\n  boundMethods.set(methodKey, bound)\n  bindCache.set(obj, boundMethods)\n\n  return bound\n}\n", "import {omit} from 'lodash'\nimport {firstValueFrom, type Observable} from 'rxjs'\n\nimport {type StructureContext} from '../structureBuilder'\nimport {\n  type PaneNode,\n  type RouterPanes,\n  type RouterPaneSiblingContext,\n  type UnresolvedPaneNode,\n} from '../types'\nimport {assignId} from './assignId'\nimport {createPaneResolver, type PaneResolverMiddleware} from './createPaneResolver'\nimport {memoBind} from './memoBind'\n\ninterface TraverseOptions {\n  unresolvedPane: UnresolvedPaneNode | undefined\n  intent: string\n  params: {type: string; id: string; [key: string]: string | undefined}\n  payload: unknown\n  parent: PaneNode | null\n  path: string[]\n  currentId: string\n  flatIndex: number\n  levelIndex: number\n  structureContext: StructureContext\n}\n\nexport interface ResolveIntentOptions {\n  rootPaneNode?: UnresolvedPaneNode\n  intent: string\n  params: {type: string; id: string; [key: string]: string | undefined}\n  payload: unknown\n  structureContext: StructureContext\n}\n\n/**\n * Resolves an intent request using breadth first search. If a match is not\n * found, the intent will resolve to the fallback editor.\n *\n * A match is found if:\n * 1. the `PaneNode` is of type `document` and the its ID matches the intent ID\n * 2. the `PaneNode` is of type `documentList` and the `schemaTypeName` matches\n * 3. the `PaneNode`'s `canHandleIntent` method returns true\n *\n * If a `PaneNode` of type `list` is found, it will be searched for a match.\n *\n * @see PaneNode\n */\nexport async function resolveIntent(options: ResolveIntentOptions): Promise<RouterPanes> {\n  const resolvedPaneCache = new Map<string, Observable<PaneNode>>()\n\n  // this is a simple version of the memoizer in `createResolvedPaneNodeStream`\n  const memoize: PaneResolverMiddleware = (nextFn) => (unresolvedPane, context, flatIndex) => {\n    const key = unresolvedPane && `${assignId(unresolvedPane)}-${context.path.join('__')}`\n    const cachedResolvedPane = key && resolvedPaneCache.get(key)\n    if (cachedResolvedPane) return cachedResolvedPane\n\n    const result = nextFn(unresolvedPane, context, flatIndex)\n    if (key) resolvedPaneCache.set(key, result)\n    return result\n  }\n\n  const resolvePane = createPaneResolver(memoize)\n\n  const fallbackEditorPanes: RouterPanes = [\n    [\n      {\n        id: `__edit__${options.params.id}`,\n        params: {...omit(options.params, ['id']), type: options.params.type},\n        payload: options.payload,\n      },\n    ],\n  ]\n\n  async function traverse({\n    currentId,\n    flatIndex,\n    intent,\n    params,\n    parent,\n    path,\n    payload,\n    unresolvedPane,\n    levelIndex,\n    structureContext,\n  }: TraverseOptions): Promise<\n    Array<{panes: RouterPanes; depthIndex: number; levelIndex: number}>\n  > {\n    if (!unresolvedPane) return []\n\n    const {id: targetId, type: schemaTypeName, ...otherParams} = params\n    const context: RouterPaneSiblingContext = {\n      id: currentId,\n      splitIndex: 0,\n      parent,\n      path,\n      index: flatIndex,\n      params: {},\n      payload: undefined,\n      structureContext,\n    }\n    const resolvedPane = await firstValueFrom(resolvePane(unresolvedPane, context, flatIndex))\n\n    // if the resolved pane is a document pane and the pane's ID matches then\n    // resolve the intent to the current path\n    if (resolvedPane.type === 'document' && resolvedPane.id === targetId) {\n      return [\n        {\n          panes: [\n            ...path.slice(0, path.length - 1).map((i) => [{id: i}]),\n            [{id: targetId, params: otherParams, payload}],\n          ],\n          depthIndex: path.length,\n          levelIndex,\n        },\n      ]\n    }\n\n    // NOTE: if you update this logic, please also update the similar handler in\n    // `getIntentState.ts`\n    if (\n      // if the resolve pane's `canHandleIntent` returns true, then resolve\n      resolvedPane.canHandleIntent?.(intent, params, {\n        pane: resolvedPane,\n        index: flatIndex,\n      }) ||\n      // if the pane's `canHandleIntent` did not return true, then match against\n      // this default case. we will resolve the intent if:\n      (resolvedPane.type === 'documentList' &&\n        // 1. the schema type matches (this required for the document to render)\n        resolvedPane.schemaTypeName === schemaTypeName &&\n        // 2. the filter is the default filter.\n        //\n        // NOTE: this case is to prevent false positive matches where the user\n        // has configured a more specific filter for a particular type. In that\n        // case, the user can implement their own `canHandleIntent` function\n        resolvedPane.options.filter === '_type == $type')\n    ) {\n      return [\n        {\n          panes: [\n            // map the current path to router panes\n            ...path.map((id) => [{id}]),\n            // then augment with the intents IDs and params\n            [{id: params.id, params: otherParams, payload}],\n          ],\n          depthIndex: path.length,\n          levelIndex,\n        },\n      ]\n    }\n\n    if (resolvedPane.type === 'list' && resolvedPane.child && resolvedPane.items) {\n      return (\n        await Promise.all(\n          resolvedPane.items.map((item, nextLevelIndex) => {\n            if (item.type === 'divider') return Promise.resolve([])\n\n            return traverse({\n              currentId: item._id || item.id,\n              flatIndex: flatIndex + 1,\n              intent,\n              params,\n              parent: resolvedPane,\n              path: [...path, item.id],\n              payload,\n              unresolvedPane:\n                typeof resolvedPane.child === 'function'\n                  ? memoBind(resolvedPane, 'child')\n                  : resolvedPane.child,\n              levelIndex: nextLevelIndex,\n              structureContext,\n            })\n          }),\n        )\n      ).flat()\n    }\n\n    return []\n  }\n\n  const matchingPanes = await traverse({\n    currentId: 'root',\n    flatIndex: 0,\n    levelIndex: 0,\n    intent: options.intent,\n    params: options.params,\n    parent: null,\n    path: [],\n    payload: options.payload,\n    unresolvedPane: options.rootPaneNode,\n    structureContext: options.structureContext,\n  })\n\n  const closestPaneToRoot = matchingPanes.sort((a, b) => {\n    // break ties with the level index\n    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex\n    return a.depthIndex - b.depthIndex\n  })[0]\n\n  if (closestPaneToRoot) {\n    return closestPaneToRoot.panes\n  }\n\n  return fallbackEditorPanes\n}\n", "import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {isEqual} from 'lodash'\nimport {concat, NEVER, type Observable, of as observableOf} from 'rxjs'\nimport {distinctUntilChanged, map, pairwise, scan, startWith, switchMap} from 'rxjs/operators'\n\nimport {type StructureContext} from '../structureBuilder'\nimport {\n  type DocumentPaneNode,\n  type PaneNode,\n  type PaneNodeResolver,\n  type RouterPanes,\n  type RouterPaneSibling,\n  type RouterPaneSiblingContext,\n  type UnresolvedPaneNode,\n} from '../types'\nimport {assignId} from './assignId'\nimport {\n  createPaneResolver,\n  type PaneResolver,\n  type PaneResolverMiddleware,\n} from './createPaneResolver'\nimport {memoBind} from './memoBind'\nimport {PaneResolutionError} from './PaneResolutionError'\n\n/**\n * the fallback editor child that is implicitly inserted into the structure tree\n * if the id starts with `__edit__`\n */\nconst fallbackEditorChild: PaneNodeResolver = (nodeId, context): DocumentPaneNode => {\n  const id = nodeId.replace(/^__edit__/, '')\n  const {\n    params,\n    payload,\n    structureContext: {resolveDocumentNode},\n  } = context\n  const {type, template} = params\n\n  if (!type) {\n    throw new Error(\n      `Document type for document with ID ${id} was not provided in the router params.`,\n    )\n  }\n\n  let defaultDocumentBuilder = resolveDocumentNode({schemaType: type, documentId: id}).id('editor')\n\n  if (template) {\n    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(\n      template,\n      payload as {[key: string]: unknown},\n    )\n  }\n\n  return defaultDocumentBuilder.serialize() as DocumentPaneNode\n}\n\n/**\n * takes in a `RouterPaneSiblingContext` and returns a normalized string\n * representation that can be used for comparisons\n */\nfunction hashContext(context: RouterPaneSiblingContext): string {\n  return `contextHash(${JSON.stringify({\n    id: context.id,\n    parentId: parent && assignId(parent),\n    path: context.path,\n    index: context.index,\n    splitIndex: context.splitIndex,\n    serializeOptionsIndex: context.serializeOptions?.index,\n    serializeOptionsPath: context.serializeOptions?.path,\n  })})`\n}\n\n/**\n * takes in `ResolvedPaneMeta` and returns a normalized string representation\n * that can be used for comparisons\n */\nconst hashResolvedPaneMeta = (meta: ResolvedPaneMeta): string => {\n  const normalized = {\n    type: meta.type,\n    id: meta.routerPaneSibling.id,\n    params: meta.routerPaneSibling.params || {},\n    payload: meta.routerPaneSibling.payload || null,\n    flatIndex: meta.flatIndex,\n    groupIndex: meta.groupIndex,\n    siblingIndex: meta.siblingIndex,\n    path: meta.path,\n    paneNode: meta.type === 'resolvedMeta' ? assignId(meta.paneNode) : null,\n  }\n\n  return `metaHash(${JSON.stringify(normalized)})`\n}\n\n/**\n * Represents one flattened \"router pane\", including the source group and\n * sibling indexes.\n *\n * @see RouterPanes\n */\ninterface FlattenedRouterPane {\n  routerPaneSibling: RouterPaneSibling\n  flatIndex: number\n  groupIndex: number\n  siblingIndex: number\n}\n\n/**\n * The state of the accumulator used to store and manage memo cache state\n */\ninterface CacheState {\n  /**\n   * Holds the memoization results keyed by a combination of `assignId` and a\n   * context hash.\n   */\n  resolvedPaneCache: Map<string, Observable<PaneNode>>\n  /**\n   * Acts as a dictionary that stores cache keys by their flat index. This is\n   * used to clean up the cache between different branches in the pane\n   * structure.\n   *\n   * @see createResolvedPaneNodeStream look inside the `scan` where `wrapFn` is\n   * defined\n   */\n  cacheKeysByFlatIndex: Array<Set<string>>\n  /**\n   * The resulting memoized `PaneResolver` function. This function closes over\n   * the `resolvedPaneCache`.\n   */\n  resolvePane: PaneResolver\n  flattenedRouterPanes: FlattenedRouterPane[]\n}\n\nexport interface CreateResolvedPaneNodeStreamOptions {\n  /**\n   * an input stream of `RouterPanes`\n   * @see RouterPanes\n   */\n  routerPanesStream: Observable<RouterPanes>\n  /**\n   * any `UnresolvedPaneNode` (could be an observable, promise, pane resolver etc)\n   */\n  rootPaneNode: UnresolvedPaneNode\n  /** used primarily for testing */\n  initialCacheState?: CacheState\n\n  structureContext: StructureContext\n}\n\n/**\n * The result of pane resolving\n */\nexport type ResolvedPaneMeta = {\n  groupIndex: number\n  siblingIndex: number\n  flatIndex: number\n  routerPaneSibling: RouterPaneSibling\n  path: string[]\n} & ({type: 'loading'; paneNode: null} | {type: 'resolvedMeta'; paneNode: PaneNode})\n\ninterface ResolvePaneTreeOptions {\n  resolvePane: PaneResolver\n  flattenedRouterPanes: FlattenedRouterPane[]\n  unresolvedPane: UnresolvedPaneNode | undefined\n  parent: PaneNode | null\n  path: string[]\n  structureContext: StructureContext\n}\n\n/**\n * A recursive pane resolving function. Starts at one unresolved pane node and\n * continues until there is no more flattened router panes that can be used as\n * input to the unresolved panes.\n */\nfunction resolvePaneTree({\n  unresolvedPane,\n  flattenedRouterPanes,\n  parent,\n  path,\n  resolvePane,\n  structureContext,\n}: ResolvePaneTreeOptions): Observable<ResolvedPaneMeta[]> {\n  const [current, ...rest] = flattenedRouterPanes\n  const next = rest[0] as FlattenedRouterPane | undefined\n\n  const context: RouterPaneSiblingContext = {\n    id: current.routerPaneSibling.id,\n    splitIndex: current.siblingIndex,\n    parent,\n    path: [...path, current.routerPaneSibling.id],\n    index: current.flatIndex,\n    params: current.routerPaneSibling.params || {},\n    payload: current.routerPaneSibling.payload,\n    structureContext,\n  }\n\n  try {\n    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(\n      // this switch map receives a resolved pane\n      switchMap((paneNode) => {\n        // we can create a `resolvedMeta` type using it\n        const resolvedPaneMeta: ResolvedPaneMeta = {\n          type: 'resolvedMeta',\n          ...current,\n          paneNode: paneNode,\n          path: context.path,\n        }\n\n        // for the other unresolved panes, we can create \"loading panes\"\n        const loadingPanes = rest.map((i, restIndex) => {\n          const loadingPanePath = [\n            ...context.path,\n            ...rest.slice(restIndex).map((_, currentIndex) => `[${i.flatIndex + currentIndex}]`),\n          ]\n\n          const loadingPane: ResolvedPaneMeta = {\n            type: 'loading',\n            path: loadingPanePath,\n            paneNode: null,\n            ...i,\n          }\n\n          return loadingPane\n        })\n\n        if (!rest.length) {\n          return observableOf([resolvedPaneMeta])\n        }\n\n        let nextStream\n\n        if (\n          // the fallback editor case\n          next?.routerPaneSibling.id.startsWith('__edit__')\n        ) {\n          nextStream = resolvePaneTree({\n            unresolvedPane: fallbackEditorChild,\n            flattenedRouterPanes: rest,\n            parent,\n            path: context.path,\n            resolvePane,\n            structureContext,\n          })\n        } else if (current.groupIndex === next?.groupIndex) {\n          // if the next flattened router pane has the same group index as the\n          // current flattened router pane, then the next flattened router pane\n          // belongs to the same group (i.e. it is a split pane)\n          nextStream = resolvePaneTree({\n            unresolvedPane,\n            flattenedRouterPanes: rest,\n            parent,\n            path,\n            resolvePane,\n            structureContext,\n          })\n        } else {\n          // normal children resolving\n          nextStream = resolvePaneTree({\n            unresolvedPane:\n              typeof paneNode.child === 'function'\n                ? (memoBind(paneNode, 'child') as PaneNodeResolver)\n                : paneNode.child,\n            flattenedRouterPanes: rest,\n            parent: paneNode,\n            path: context.path,\n            resolvePane,\n            structureContext,\n          })\n        }\n\n        return concat(\n          // we emit the loading panes first in a concat (this emits immediately)\n          observableOf([resolvedPaneMeta, ...loadingPanes]),\n          // then whenever the next stream is done, the results will be combined.\n          nextStream.pipe(map((nextResolvedPanes) => [resolvedPaneMeta, ...nextResolvedPanes])),\n        )\n      }),\n    )\n  } catch (e) {\n    if (e instanceof PaneResolutionError) {\n      if (e.context) {\n        console.warn(\n          `Pane resolution error at index ${e.context.index}${\n            e.context.splitIndex > 0 ? ` for split pane index ${e.context.splitIndex}` : ''\n          }: ${e.message}${e.helpId ? ` - see ${generateHelpUrl(e.helpId)}` : ''}`,\n          e,\n        )\n      }\n\n      if (e.helpId === 'structure-item-returned-no-child') {\n        // returning an observable of an empty array will remove loading panes\n        // note: this one intentionally does not throw\n        return observableOf([])\n      }\n    }\n\n    throw e\n  }\n}\n\n/**\n * Takes in a stream of `RouterPanes` and an unresolved root pane and returns\n * a stream of `ResolvedPaneMeta`\n */\nexport function createResolvedPaneNodeStream({\n  routerPanesStream,\n  rootPaneNode,\n  initialCacheState = {\n    cacheKeysByFlatIndex: [],\n    flattenedRouterPanes: [],\n    resolvedPaneCache: new Map(),\n    resolvePane: () => NEVER,\n  },\n  structureContext,\n}: CreateResolvedPaneNodeStreamOptions): Observable<ResolvedPaneMeta[]> {\n  const resolvedPanes$ = routerPanesStream.pipe(\n    // add in implicit \"root\" router pane\n    map((rawRouterPanes) => [[{id: 'root'}], ...rawRouterPanes]),\n    // create flattened router panes\n    map((routerPanes) => {\n      const flattenedRouterPanes: FlattenedRouterPane[] = routerPanes\n        .flatMap((routerPaneGroup, groupIndex) =>\n          routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({\n            routerPaneSibling,\n            groupIndex,\n            siblingIndex,\n          })),\n        )\n        // add in the flat index\n        .map((i, index) => ({...i, flatIndex: index}))\n\n      return flattenedRouterPanes\n    }),\n    // calculate a \"diffIndex\" used for clearing the memo cache\n    startWith([] as FlattenedRouterPane[]),\n    pairwise(),\n    map(([prev, curr]) => {\n      for (let i = 0; i < curr.length; i++) {\n        const prevValue = prev[i]\n        const currValue = curr[i]\n\n        if (!isEqual(prevValue, currValue)) {\n          return {\n            flattenedRouterPanes: curr,\n            diffIndex: i,\n          }\n        }\n      }\n\n      return {\n        flattenedRouterPanes: curr,\n        diffIndex: curr.length,\n      }\n    }),\n    // create the memoized `resolvePane` function and manage the memo cache\n    scan((acc, next) => {\n      const {cacheKeysByFlatIndex, resolvedPaneCache} = acc\n      const {flattenedRouterPanes, diffIndex} = next\n\n      // use the `cacheKeysByFlatIndex` like a dictionary to find cache keys to\n      // and cache keys to delete\n      const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1)\n      const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1)\n\n      const keysToKeep = new Set(beforeDiffIndex.flatMap((keySet) => Array.from(keySet)))\n      const keysToDelete = afterDiffIndex\n        .flatMap((keySet) => Array.from(keySet))\n        .filter((key) => !keysToKeep.has(key))\n\n      for (const key of keysToDelete) {\n        resolvedPaneCache.delete(key)\n      }\n\n      // create a memoizing pane resolver middleware that utilizes the cache\n      // maintained above. this keeps the cache from growing indefinitely\n      const memoize: PaneResolverMiddleware = (nextFn) => (unresolvedPane, context, flatIndex) => {\n        const key = unresolvedPane && `${assignId(unresolvedPane)}-${hashContext(context)}`\n        const cachedResolvedPane = key && resolvedPaneCache.get(key)\n        if (cachedResolvedPane) return cachedResolvedPane\n\n        const result = nextFn(unresolvedPane, context, flatIndex)\n        if (!key) return result\n\n        const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || new Set()\n        cacheKeySet.add(key)\n        cacheKeysByFlatIndex[flatIndex] = cacheKeySet\n        resolvedPaneCache.set(key, result)\n        return result\n      }\n\n      return {\n        flattenedRouterPanes,\n        cacheKeysByFlatIndex,\n        resolvedPaneCache,\n        resolvePane: createPaneResolver(memoize),\n      }\n    }, initialCacheState),\n    // run the memoized, recursive resolving\n    switchMap(({flattenedRouterPanes, resolvePane}) =>\n      resolvePaneTree({\n        unresolvedPane: rootPaneNode,\n        flattenedRouterPanes,\n        parent: null,\n        path: [],\n        resolvePane,\n        structureContext,\n      }),\n    ),\n  )\n\n  // after we've created a stream of `ResolvedPaneMeta[]`, we need to clean up\n  // the results to remove unwanted loading panes and prevent unnecessary\n  // emissions\n  return resolvedPanes$.pipe(\n    // this diffs the previous emission with the current one. if there is a new\n    // loading pane at the same position where a previous pane already had a\n    // resolved value (looking at the IDs to compare), then return the previous\n    // pane instead of the loading pane\n    scan(\n      (prev, next) =>\n        next.map((nextPane, index) => {\n          const prevPane = prev[index] as ResolvedPaneMeta | undefined\n          if (!prevPane) return nextPane\n          if (nextPane.type !== 'loading') return nextPane\n\n          if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {\n            return prevPane\n          }\n          return nextPane\n        }),\n      [] as ResolvedPaneMeta[],\n    ),\n    // this prevents duplicate emissions\n    distinctUntilChanged((prev, next) => {\n      if (prev.length !== next.length) return false\n\n      for (let i = 0; i < next.length; i++) {\n        const prevValue = prev[i]\n        const nextValue = next[i]\n        if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {\n          return false\n        }\n      }\n\n      return true\n    }),\n  )\n}\n", "import {useEffect, useMemo, useState} from 'react'\nimport {ReplaySubject} from 'rxjs'\nimport {map} from 'rxjs/operators'\nimport {type RouterState, useRouter} from 'sanity/router'\n\nimport {LOADING_PANE} from '../constants'\nimport {type PaneNode, type RouterPaneGroup, type RouterPanes} from '../types'\nimport {useStructureTool} from '../useStructureTool'\nimport {createResolvedPaneNodeStream} from './createResolvedPaneNodeStream'\n\ninterface PaneData {\n  active: boolean\n  childItemId: string | null\n  groupIndex: number\n  index: number\n  itemId: string\n  key: string\n  pane: PaneNode | typeof LOADING_PANE\n  params: Record<string, string | undefined>\n  path: string\n  payload: unknown\n  selected: boolean\n  siblingIndex: number\n}\n\nexport interface Panes {\n  paneDataItems: PaneData[]\n  routerPanes: RouterPanes\n  resolvedPanes: (PaneNode | typeof LOADING_PANE)[]\n}\n\nfunction useRouterPanesStream() {\n  const routerStateSubject = useMemo(() => new ReplaySubject<RouterState>(1), [])\n  const routerPanes$ = useMemo(\n    () =>\n      routerStateSubject\n        .asObservable()\n        .pipe(map((_routerState) => (_routerState?.panes || []) as RouterPanes)),\n    [routerStateSubject],\n  )\n  const {state: routerState} = useRouter()\n  useEffect(() => {\n    routerStateSubject.next(routerState)\n  }, [routerState, routerStateSubject])\n\n  return routerPanes$\n}\n\nexport function useResolvedPanes(): Panes {\n  // used to propagate errors from async effect. throwing inside of the render\n  // will bubble the error to react where it can be picked up by standard error\n  // boundaries\n  const [error, setError] = useState<unknown>()\n  if (error) throw error\n\n  const {structureContext, rootPaneNode} = useStructureTool()\n\n  const [data, setData] = useState<Panes>({\n    paneDataItems: [],\n    resolvedPanes: [],\n    routerPanes: [],\n  })\n\n  const routerPanesStream = useRouterPanesStream()\n\n  useEffect(() => {\n    const resolvedPanes$ = createResolvedPaneNodeStream({\n      rootPaneNode,\n      routerPanesStream,\n      structureContext,\n    }).pipe(\n      map((resolvedPanes) => {\n        const routerPanes = resolvedPanes.reduce<RouterPanes>((acc, next) => {\n          const currentGroup = acc[next.groupIndex] || []\n          currentGroup[next.siblingIndex] = next.routerPaneSibling\n          acc[next.groupIndex] = currentGroup\n          return acc\n        }, [])\n\n        const groupsLen = routerPanes.length\n\n        const paneDataItems = resolvedPanes.map((pane) => {\n          const {groupIndex, flatIndex, siblingIndex, routerPaneSibling, path} = pane\n          const itemId = routerPaneSibling.id\n          const nextGroup = routerPanes[groupIndex + 1] as RouterPaneGroup | undefined\n\n          const paneDataItem: PaneData = {\n            active: groupIndex === groupsLen - 2,\n            childItemId: nextGroup?.[0].id ?? null,\n            index: flatIndex,\n            itemId: routerPaneSibling.id,\n            groupIndex,\n            key: `${\n              pane.type === 'loading' ? 'unknown' : pane.paneNode.id\n            }-${itemId}-${siblingIndex}`,\n            pane: pane.type === 'loading' ? LOADING_PANE : pane.paneNode,\n            params: routerPaneSibling.params || {},\n            path: path.join(';'),\n            payload: routerPaneSibling.payload,\n            selected: flatIndex === resolvedPanes.length - 1,\n            siblingIndex,\n          }\n\n          return paneDataItem\n        })\n\n        return {\n          paneDataItems,\n          routerPanes,\n          resolvedPanes: paneDataItems.map((pane) => pane.pane),\n        }\n      }),\n    )\n\n    const subscription = resolvedPanes$.subscribe({\n      next: (result) => setData(result),\n      error: (e) => setError(e),\n    })\n\n    return () => subscription.unsubscribe()\n  }, [rootPaneNode, routerPanesStream, structureContext])\n\n  return data\n}\n", "import {uuid} from '@sanity/uuid'\nimport {firstValueFrom, type Observable} from 'rxjs'\nimport {type DocumentStore, getPublishedId} from 'sanity'\n\nimport {PaneResolutionError} from '../../../structureResolvers'\n\nexport function removeDraftPrefix(documentId: string): string {\n  const publishedId = getPublishedId(documentId)\n\n  if (publishedId !== documentId) {\n    console.warn(\n      'Removed unexpected draft id in document link: All links to documents should have the ' +\n        '`drafts.`-prefix removed and something appears to have made an intent link to `%s`',\n      documentId,\n    )\n  }\n\n  return publishedId\n}\n\nexport async function ensureDocumentIdAndType(\n  documentStore: DocumentStore,\n  id: string | undefined,\n  type: string | undefined,\n): Promise<{id: string; type: string}> {\n  if (id && type) return {id, type}\n  if (!id && type) return {id: uuid(), type}\n  if (id && !type) {\n    const resolvedType = await firstValueFrom(\n      documentStore.resolveTypeForDocument(id) as Observable<string>,\n    )\n\n    return {id, type: resolvedType}\n  }\n\n  throw new PaneResolutionError({\n    message: 'Neither document `id` or `type` was provided when trying to resolve intent.',\n  })\n}\n", "import {memo, useCallback, useEffect, useState} from 'react'\nimport {isRecord, useDocumentStore} from 'sanity'\nimport {useRouter, useRouterState} from 'sanity/router'\n\nimport {resolveIntent} from '../../../structureResolvers'\nimport {useStructureTool} from '../../../useStructureTool'\nimport {ensureDocumentIdAndType} from './utils'\n\nconst EMPTY_RECORD: Record<string, unknown> = {}\n\n/**\n * A component that receives an intent from props and redirects to the resolved\n * intent location (while showing a loading spinner during the process)\n */\nexport const IntentResolver = memo(function IntentResolver() {\n  const {navigate} = useRouter()\n  const maybeIntent = useRouterState(\n    useCallback((routerState) => {\n      const intentName = typeof routerState.intent === 'string' ? routerState.intent : undefined\n      return intentName\n        ? {\n            intent: intentName,\n            params: isRecord(routerState.params) ? routerState.params : EMPTY_RECORD,\n            payload: routerState.payload,\n          }\n        : undefined\n    }, []),\n  )\n  const {rootPaneNode, structureContext} = useStructureTool()\n  const documentStore = useDocumentStore()\n  const [error, setError] = useState<unknown>(null)\n\n  // this re-throws errors so that parent ErrorBoundary's can handle them properly\n  if (error) throw error\n\n  // eslint-disable-next-line consistent-return\n  useEffect(() => {\n    if (maybeIntent) {\n      const {intent, params, payload} = maybeIntent\n\n      let cancelled = false\n      // eslint-disable-next-line no-inner-declarations\n      async function effect() {\n        const {id, type} = await ensureDocumentIdAndType(\n          documentStore,\n          typeof params.id === 'string' ? params.id : undefined,\n          typeof params.type === 'string' ? params.type : undefined,\n        )\n\n        if (cancelled) return\n\n        const panes = await resolveIntent({\n          intent,\n          params: {...params, id, type},\n          payload,\n          rootPaneNode,\n          structureContext,\n        })\n\n        if (cancelled) return\n\n        navigate({panes}, {replace: true})\n      }\n\n      effect().catch(setError)\n\n      return () => {\n        cancelled = true\n      }\n    }\n  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext])\n\n  return null\n})\n", "import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {SyncIcon} from '@sanity/icons'\nimport {Box, Card, Code, Container, Heading, Stack, Text} from '@sanity/ui'\nimport {useCallback} from 'react'\nimport {useTranslation} from 'sanity'\nimport styled from 'styled-components'\n\nimport {Button} from '../../../ui-components'\nimport {structureLocaleNamespace} from '../../i18n'\nimport {SerializeError} from '../../structureBuilder'\nimport {PaneResolutionError} from '../../structureResolvers'\n\nconst PathSegment = styled.span`\n  &:not(:last-child)::after {\n    content: ' ➝ ';\n    opacity: 0.5;\n  }\n`\n\nfunction formatStack(stack: string) {\n  return (\n    stack\n      // Prettify builder functions\n      .replace(/\\(\\.\\.\\.\\)\\./g, '(...)\\n  .')\n      // Remove webpack cruft from function names\n      .replace(/__WEBPACK_IMPORTED_MODULE_\\d+_+/g, '')\n      // Remove default export postfix from function names\n      .replace(/___default\\./g, '.')\n      // Replace full host path, leave only path to JS-file\n      .replace(new RegExp(` \\\\(https?:\\\\/\\\\/${window.location.host}`, 'g'), ' (')\n  )\n}\n\ninterface StructureErrorProps {\n  error: unknown\n}\n\nexport function StructureError({error}: StructureErrorProps) {\n  if (!(error instanceof PaneResolutionError)) {\n    throw error\n  }\n  const {cause} = error\n  const {t} = useTranslation(structureLocaleNamespace)\n\n  // Serialize errors are well-formatted and should be readable, in these cases a stack trace is\n  // usually not helpful. Build errors in dev (with HMR) usually also contains a bunch of garbage\n  // instead of an actual error message, so make sure we show the message in these cases as well\n  const stack = cause?.stack || error.stack\n  const showStack =\n    stack && !(cause instanceof SerializeError) && !error.message.includes('Module build failed:')\n\n  const path = cause instanceof SerializeError ? cause.path : []\n  const helpId = (cause instanceof SerializeError && cause.helpId) || error.helpId\n\n  const handleReload = useCallback(() => {\n    window.location.reload()\n  }, [])\n\n  return (\n    <Card height=\"fill\" overflow=\"auto\" padding={4} sizing=\"border\" tone=\"critical\">\n      <Container>\n        <Heading as=\"h2\">{t('structure-error.header.text')}</Heading>\n\n        <Card marginTop={4} padding={4} radius={2} overflow=\"auto\" shadow={1} tone=\"inherit\">\n          {path.length > 0 && (\n            <Stack space={2}>\n              <Text size={1} weight=\"medium\">\n                {t('structure-error.structure-path.label')}\n              </Text>\n              <Code>\n                {/* TODO: it seems like the path is off by one and includes */}\n                {/* `root` twice  */}\n                {path.slice(1).map((segment, i) => (\n                  // eslint-disable-next-line react/no-array-index-key\n                  <PathSegment key={`${segment}-${i}`}>{segment}</PathSegment>\n                ))}\n              </Code>\n            </Stack>\n          )}\n\n          <Stack marginTop={4} space={2}>\n            <Text size={1} weight=\"medium\">\n              {t('structure-error.error.label')}\n            </Text>\n            <Code>{showStack ? formatStack(stack) : error.message}</Code>\n          </Stack>\n\n          {helpId && (\n            <Box marginTop={4}>\n              <Text>\n                <a href={generateHelpUrl(helpId)} rel=\"noopener noreferrer\" target=\"_blank\">\n                  {t('structure-error.docs-link.text')}\n                </a>\n              </Text>\n            </Box>\n          )}\n\n          <Box marginTop={4}>\n            <Button\n              text={t('structure-error.reload-button.text')}\n              icon={SyncIcon}\n              tone=\"primary\"\n              onClick={handleReload}\n            />\n          </Box>\n        </Card>\n      </Container>\n    </Card>\n  )\n}\n", "import {Box, Text} from '@sanity/ui'\nimport {isRecord, Translate, useTranslation} from 'sanity'\n\nimport {Pane, PaneContent, PaneHeader} from '../../components/pane'\nimport {structureLocaleNamespace} from '../../i18n'\n\ninterface UnknownPaneProps {\n  isSelected: boolean\n  pane: unknown\n  paneKey: string\n}\n\n/**\n * @internal\n */\nexport function UnknownPane(props: UnknownPaneProps) {\n  const {isSelected, pane, paneKey} = props\n  const type = (isRecord(pane) && pane.type) || null\n  const {t} = useTranslation(structureLocaleNamespace)\n  return (\n    <Pane id={paneKey} selected={isSelected}>\n      <PaneHeader title={t('panes.unknown-pane-type.title')} />\n      <PaneContent>\n        <Box padding={4}>\n          {typeof type === 'string' ? (\n            <Text as=\"p\" muted>\n              <Translate\n                t={t}\n                i18nKey=\"panes.unknown-pane-type.unknown-type.text\"\n                values={{type}}\n              />\n            </Text>\n          ) : (\n            <Text as=\"p\" muted>\n              <Translate t={t} i18nKey=\"panes.unknown-pane-type.missing-type.text\" />\n            </Text>\n          )}\n        </Box>\n      </PaneContent>\n    </Pane>\n  )\n}\n", "import {isEqual} from 'lodash'\nimport {lazy, memo, Suspense} from 'react'\n\nimport {PaneRouterProvider} from '../components/paneRouter'\nimport {type PaneNode} from '../types'\nimport {LoadingPane} from './loading'\nimport {UnknownPane} from './unknown'\n\ninterface StructureToolPaneProps {\n  active: boolean\n  childItemId: string | null\n  groupIndex: number\n  index: number\n  itemId: string\n  pane: PaneNode\n  paneKey: string\n  params: Record<string, string | undefined>\n  payload: unknown\n  path: string\n  selected: boolean\n  siblingIndex: number\n}\n\n// TODO: audit this creates separate chunks\nconst paneMap = {\n  component: lazy(() => import('./userComponent')),\n  document: lazy(() => import('./document/pane')),\n  documentList: lazy(() => import('./documentList/pane')),\n  list: lazy(() => import('./list')),\n}\n\n/**\n * NOTE: The same pane might appear multiple times (split pane), so use index as tiebreaker\n *\n * @internal\n */\nexport const StructureToolPane = memo(\n  function StructureToolPane(props: StructureToolPaneProps) {\n    const {\n      active,\n      childItemId,\n      groupIndex,\n      index,\n      itemId,\n      pane,\n      paneKey,\n      params,\n      payload,\n      path,\n      selected,\n      siblingIndex,\n    } = props\n\n    const PaneComponent = paneMap[pane.type] || UnknownPane\n\n    return (\n      <PaneRouterProvider\n        flatIndex={index}\n        index={groupIndex}\n        params={params}\n        payload={payload}\n        siblingIndex={siblingIndex}\n      >\n        <Suspense fallback={<LoadingPane paneKey={paneKey} path={path} selected={selected} />}>\n          <PaneComponent\n            childItemId={childItemId || ''}\n            index={index}\n            itemId={itemId}\n            isActive={active}\n            isSelected={selected}\n            paneKey={paneKey}\n            // @ts-expect-error TS doesn't know how to handle this intersection\n            pane={pane}\n          />\n        </Suspense>\n      </PaneRouterProvider>\n    )\n  },\n  (\n    {params: prevParams = {}, payload: prevPayload = null, ...prev},\n    {params: nextParams = {}, payload: nextPayload = null, ...next},\n  ) => {\n    // deeply compare these objects (it's okay, they're small)\n    if (!isEqual(prevParams, nextParams)) return false\n    if (!isEqual(prevPayload, nextPayload)) return false\n\n    const keys = new Set([...Object.keys(prev), ...Object.keys(next)]) as Set<\n      keyof typeof next | keyof typeof prev\n    >\n\n    // then shallow equal the rest\n    for (const key of keys) {\n      if (prev[key] !== next[key]) return false\n    }\n\n    return true\n  },\n)\n", "import {WarningOutlineIcon} from '@sanity/icons'\nimport {Box, Card, Container, Flex, Stack, Text} from '@sanity/ui'\nimport {useTranslation} from 'sanity'\n\nimport {structureLocaleNamespace} from '../../i18n'\n\nexport function NoDocumentTypesScreen() {\n  const {t} = useTranslation(structureLocaleNamespace)\n\n  return (\n    <Card height=\"fill\">\n      <Flex align=\"center\" height=\"fill\" justify=\"center\" padding={4} sizing=\"border\">\n        <Container width={0}>\n          <Card padding={4} radius={2} shadow={1} tone=\"caution\">\n            <Flex>\n              <Box>\n                <Text size={1}>\n                  <WarningOutlineIcon />\n                </Text>\n              </Box>\n              <Stack flex={1} marginLeft={3} space={3}>\n                <Text as=\"h1\" size={1} weight=\"medium\">\n                  {t('no-document-types-screen.title')}\n                </Text>\n                <Text as=\"p\" muted size={1}>\n                  {t('no-document-types-screen.subtitle')}\n                </Text>\n                <Text as=\"p\" muted size={1}>\n                  <a\n                    href=\"https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio\"\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                  >\n                    {t('no-document-types-screen.link-text')}\n                  </a>\n                </Text>\n              </Stack>\n            </Flex>\n          </Card>\n        </Container>\n      </Flex>\n    </Card>\n  )\n}\n", "import {type ObjectSchemaType} from '@sanity/types'\nimport {useEffect} from 'react'\nimport {\n  unstable_useValuePreview as useValuePreview,\n  useEditState,\n  useSchema,\n  useTranslation,\n} from 'sanity'\n\nimport {LOADING_PANE} from '../../constants'\nimport {structureLocaleNamespace} from '../../i18n'\nimport {type Panes} from '../../structureResolvers'\nimport {type DocumentPaneNode} from '../../types'\nimport {useStructureTool} from '../../useStructureTool'\n\ninterface StructureTitleProps {\n  resolvedPanes: Panes['resolvedPanes']\n}\n\nconst DocumentTitle = (props: {documentId: string; documentType: string}) => {\n  const {documentId, documentType} = props\n  const editState = useEditState(documentId, documentType)\n  const schema = useSchema()\n  const {t} = useTranslation(structureLocaleNamespace)\n  const isNewDocument = !editState?.published && !editState?.draft\n  const documentValue = editState?.draft || editState?.published\n  const schemaType = schema.get(documentType) as ObjectSchemaType | undefined\n\n  const {value, isLoading: previewValueIsLoading} = useValuePreview({\n    enabled: true,\n    schemaType,\n    value: documentValue,\n  })\n\n  const documentTitle = isNewDocument\n    ? t('browser-document-title.new-document', {\n        schemaType: schemaType?.title || schemaType?.name,\n      })\n    : value?.title || t('browser-document-title.untitled-document')\n\n  const settled = editState.ready && !previewValueIsLoading\n  const newTitle = useConstructDocumentTitle(documentTitle)\n  useEffect(() => {\n    if (!settled) return\n    // Set the title as the document title\n    document.title = newTitle\n  }, [documentTitle, settled, newTitle])\n\n  return null\n}\n\nconst PassthroughTitle = (props: {title?: string}) => {\n  const {title} = props\n  const newTitle = useConstructDocumentTitle(title)\n  useEffect(() => {\n    // Set the title as the document title\n    document.title = newTitle\n  }, [newTitle, title])\n  return null\n}\n\nexport const StructureTitle = (props: StructureTitleProps) => {\n  const {resolvedPanes} = props\n\n  if (!resolvedPanes?.length) return null\n\n  const lastPane = resolvedPanes[resolvedPanes.length - 1]\n\n  // If the last pane is loading, display the structure tool title only\n  if (isLoadingPane(lastPane)) {\n    return <PassthroughTitle />\n  }\n\n  // If the last pane is a document\n  if (isDocumentPane(lastPane)) {\n    // Passthrough the document pane's title, which may be defined in structure builder\n    if (lastPane?.title) {\n      return <PassthroughTitle title={lastPane.title} />\n    }\n\n    // Otherwise, display a `document.title` containing the resolved Sanity document title\n    return <DocumentTitle documentId={lastPane.options.id} documentType={lastPane.options.type} />\n  }\n\n  // Otherwise, display the last pane's title (if present)\n  return <PassthroughTitle title={lastPane?.title} />\n}\n\n/**\n * Construct a pipe delimited title containing `activeTitle` (if applicable) and the base structure title.\n *\n * @param activeTitle - Title of the first segment\n *\n * @returns A pipe delimited title in the format `${activeTitle} | %BASE_STRUCTURE_TITLE%`\n * or simply `%BASE_STRUCTURE_TITLE` if `activeTitle` is undefined.\n */\nfunction useConstructDocumentTitle(activeTitle?: string) {\n  const structureToolBaseTitle = useStructureTool().structureContext.title\n  return [activeTitle, structureToolBaseTitle].filter((title) => title).join(' | ')\n}\n\n// Type guards\nfunction isDocumentPane(pane: Panes['resolvedPanes'][number]): pane is DocumentPaneNode {\n  return pane !== LOADING_PANE && pane.type === 'document'\n}\n\nfunction isLoadingPane(pane: Panes['resolvedPanes'][number]): pane is typeof LOADING_PANE {\n  return pane === LOADING_PANE\n}\n", "import {PortalProvider, useTheme, useToast} from '@sanity/ui'\nimport isHotkey from 'is-hotkey'\nimport {Fragment, memo, useCallback, useEffect, useState} from 'react'\nimport {_isCustomDocumentTypeDefinition, useSchema} from 'sanity'\nimport {useRouterState} from 'sanity/router'\nimport styled from 'styled-components'\n\nimport {LOADING_PANE} from '../../constants'\nimport {LoadingPane, StructureToolPane} from '../../panes'\nimport {useResolvedPanes} from '../../structureResolvers'\nimport {type PaneNode} from '../../types'\nimport {useStructureTool} from '../../useStructureTool'\nimport {PaneLayout} from '../pane'\nimport {NoDocumentTypesScreen} from './NoDocumentTypesScreen'\nimport {StructureTitle} from './StructureTitle'\n\ninterface StructureToolProps {\n  onPaneChange: (panes: Array<PaneNode | typeof LOADING_PANE>) => void\n}\n\nconst StyledPaneLayout = styled(PaneLayout)`\n  min-height: 100%;\n  min-width: 320px;\n`\n\nconst isSaveHotkey = isHotkey('mod+s')\n\n/**\n * @internal\n */\nexport const StructureTool = memo(function StructureTool({onPaneChange}: StructureToolProps) {\n  const {push: pushToast} = useToast()\n  const schema = useSchema()\n  const {layoutCollapsed, setLayoutCollapsed} = useStructureTool()\n  const {paneDataItems, resolvedPanes} = useResolvedPanes()\n  // Intent resolving is processed by the sibling `<IntentResolver />` but it doesn't have a UI for indicating progress.\n  // We handle that here, so if there are only 1 pane (the root structure), and there's an intent state in the router, we need to show a placeholder LoadingPane until\n  // the structure is resolved and we know what panes to load/display\n  const isResolvingIntent = useRouterState(\n    useCallback((routerState) => typeof routerState.intent === 'string', []),\n  )\n  const {\n    sanity: {media},\n  } = useTheme()\n\n  const [portalElement, setPortalElement] = useState<HTMLDivElement | null>(null)\n\n  const handleRootCollapse = useCallback(() => setLayoutCollapsed(true), [setLayoutCollapsed])\n  const handleRootExpand = useCallback(() => setLayoutCollapsed(false), [setLayoutCollapsed])\n\n  useEffect(() => {\n    // we check for length before emitting here to skip the initial empty array\n    // state from the `useResolvedPanes` hook. there should always be a root\n    // pane emitted on subsequent emissions\n    if (resolvedPanes.length) {\n      onPaneChange(resolvedPanes)\n    }\n  }, [onPaneChange, resolvedPanes])\n\n  useEffect(() => {\n    const handleGlobalKeyDown = (event: KeyboardEvent) => {\n      // Prevent `Cmd+S`\n      if (isSaveHotkey(event)) {\n        event.preventDefault()\n\n        pushToast({\n          closable: true,\n          id: 'auto-save-message',\n          status: 'info',\n          title: 'Your work is automatically saved!',\n          duration: 4000,\n        })\n      }\n    }\n\n    window.addEventListener('keydown', handleGlobalKeyDown)\n    return () => window.removeEventListener('keydown', handleGlobalKeyDown)\n  }, [pushToast])\n\n  const hasDefinedDocumentTypes = schema._original?.types.some(_isCustomDocumentTypeDefinition)\n\n  if (!hasDefinedDocumentTypes) {\n    return <NoDocumentTypesScreen />\n  }\n\n  return (\n    <PortalProvider element={portalElement || null}>\n      <StyledPaneLayout\n        flex={1}\n        height={layoutCollapsed ? undefined : 'fill'}\n        minWidth={media[1]}\n        onCollapse={handleRootCollapse}\n        onExpand={handleRootExpand}\n      >\n        {paneDataItems.map(\n          ({\n            active,\n            childItemId,\n            groupIndex,\n            itemId,\n            key: paneKey,\n            pane,\n            index: paneIndex,\n            params: paneParams,\n            path,\n            payload,\n            siblingIndex,\n            selected,\n          }) => (\n            <Fragment key={`${pane === LOADING_PANE ? 'loading' : pane.type}-${paneIndex}`}>\n              {pane === LOADING_PANE ? (\n                <LoadingPane paneKey={paneKey} path={path} selected={selected} />\n              ) : (\n                <StructureToolPane\n                  active={active}\n                  groupIndex={groupIndex}\n                  index={paneIndex}\n                  pane={pane}\n                  childItemId={childItemId}\n                  itemId={itemId}\n                  paneKey={paneKey}\n                  params={paneParams}\n                  payload={payload}\n                  path={path}\n                  selected={selected}\n                  siblingIndex={siblingIndex}\n                />\n              )}\n            </Fragment>\n          ),\n        )}\n        {/* If there's just 1 pane (the root), or less, and we're resolving an intent then it's necessary to show */}\n        {/* a loading indicator as the intent resolving is async, could take a while and can also be interrupted/redirected */}\n        {paneDataItems.length <= 1 && isResolvingIntent && (\n          <LoadingPane paneKey=\"intent-resolver\" />\n        )}\n      </StyledPaneLayout>\n      <StructureTitle resolvedPanes={resolvedPanes} />\n      <div data-portal=\"\" ref={setPortalElement} />\n    </PortalProvider>\n  )\n})\n", "import {ErrorBoundary} from '@sanity/ui'\nimport {useEffect, useState} from 'react'\nimport {SourceProvider, type Tool, useWorkspace} from 'sanity'\n\nimport {setActivePanes} from '../../getIntentState'\nimport {StructureToolProvider} from '../../StructureToolProvider'\nimport {type StructureToolOptions} from '../../types'\nimport {IntentResolver} from './intentResolver'\nimport {StructureError} from './StructureError'\nimport {StructureTool} from './StructureTool'\n\ninterface StructureToolBoundaryProps {\n  tool: Tool<StructureToolOptions>\n}\n\nexport function StructureToolBoundary({tool: {options}}: StructureToolBoundaryProps) {\n  const {unstable_sources: sources} = useWorkspace()\n  const [firstSource] = sources\n  const {source, defaultDocumentNode, structure} = options || {}\n\n  // Set active panes to blank on mount and unmount\n  useEffect(() => {\n    setActivePanes([])\n    return () => setActivePanes([])\n  }, [])\n\n  const [{error}, setError] = useState<{error: unknown}>({error: null})\n  // this re-throws if the error it catches is not a PaneResolutionError\n  if (error) return <StructureError error={error} />\n\n  return (\n    <ErrorBoundary onCatch={setError}>\n      <SourceProvider name={source || firstSource.name}>\n        <StructureToolProvider defaultDocumentNode={defaultDocumentNode} structure={structure}>\n          <StructureTool onPaneChange={setActivePanes} />\n          <IntentResolver />\n        </StructureToolProvider>\n      </SourceProvider>\n    </ErrorBoundary>\n  )\n}\n"],
  "mappings": "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",
  "names": ["emptyArray", "PaneRouterProvider", "props", "children", "flatIndex", "index", "params", "payload", "siblingIndex", "navigate", "navigateIntent", "resolvePathFromState", "useRouter", "routerState", "useRouterState", "panes", "expand", "usePaneLayout", "routerPaneGroups", "useMemo", "lastPane", "length", "groupIndex", "createNextRouterState", "useCallback", "modifier", "currentGroup", "currentItem", "nextGroup", "nextPanes", "slice", "nextRouterState", "modifyCurrentGroup", "setTimeout", "createPathWithParams", "nextParams", "siblings", "item", "setPayload", "nextPayload", "setParams", "handleEditReference", "_ref", "id", "parentRefPath", "type", "template", "pathToString", "ctx", "hasGroupSiblings", "groupLength", "routerPanesState", "ChildLink", "BackLink", "ReferenceChildLink", "ParameterizedLink", "replaceCurrent", "opts", "arguments", "undefined", "closeCurrent", "filter", "sibling", "closeCurrentAndAfter", "expandLast", "element", "replace", "duplicateCurrent", "options", "duplicatedItem", "setView", "viewId", "restParams", "omit", "view", "PaneRouterContext", "Provider", "value", "PaneResolutionError", "Error", "constructor", "message", "context", "helpId", "cause", "_ref2", "randomIdCache", "WeakMap", "assignId", "obj", "cachedValue", "get", "nanoid", "set", "isPromise", "thing", "then", "isSerializable", "isRecord", "serialize", "rethrowWithPaneResolutionErrors", "next", "unresolvedPane", "e", "wrapWithPublishReplay", "pipe", "publishReplay", "refCount", "createPaneResolver", "middleware", "resolvePane", "isObservable", "from", "switchMap", "result", "observableOf", "bindCache", "memoBind", "methodKey", "boundMethods", "Map", "bound", "method", "concat", "bind", "resolveIntent", "resolvedPaneCache", "memoize", "nextFn", "key", "path", "join", "cachedResolvedPane", "fallbackEditorPanes", "traverse", "_ref3", "currentId", "intent", "parent", "levelIndex", "structureContext", "_a", "targetId", "schemaTypeName", "otherParams", "splitIndex", "resolvedPane", "firstValueFrom", "map", "i", "depthIndex", "canHandleIntent", "call", "pane", "child", "items", "Promise", "all", "nextLevelIndex", "resolve", "_id", "flat", "matchingPanes", "rootPaneNode", "closestPaneToRoot", "sort", "a", "b", "fallbackEditorChild", "nodeId", "resolveDocumentNode", "defaultDocumentBuilder", "schemaType", "documentId", "initialValueTemplate", "hashContext", "_b", "stringify", "parentId", "serializeOptionsIndex", "serializeOptions", "serializeOptionsPath", "hashResolvedPaneMeta", "meta", "normalized", "routerPaneSibling", "paneNode", "JSON", "resolvePaneTree", "_ref4", "flattenedRouterPanes", "current", "rest", "resolvedPaneMeta", "loadingPanes", "restIndex", "loadingPanePath", "_", "currentIndex", "loadingPane", "nextStream", "startsWith", "nextResolvedPanes", "console", "warn", "generateHelpUrl", "createResolvedPaneNodeStream", "_ref5", "routerPanesStream", "initialCacheState", "cacheKeysByFlatIndex", "NEVER", "resolvedPanes$", "rawRouterPanes", "routerPanes", "flatMap", "routerPaneGroup", "startWith", "pairwise", "_ref6", "prev", "curr", "prevValue", "currValue", "isEqual", "diffIndex", "scan", "acc", "beforeDiffIndex", "afterDiffIndex", "keysToKeep", "Set", "keySet", "Array", "keysToDelete", "has", "delete", "cacheKeySet", "add", "_ref7", "nextPane", "prevPane", "distinctUntilChanged", "nextValue", "useRouterPanesStream", "routerStateSubject", "ReplaySubject", "routerPanes$", "asObservable", "_routerState", "state", "useEffect", "useResolvedPanes", "error", "setError", "useState", "useStructureTool", "data", "setData", "paneDataItems", "resolvedPanes", "reduce", "groupsLen", "itemId", "paneDataItem", "active", "childItemId", "LOADING_PANE", "selected", "subscription", "subscribe", "unsubscribe", "ensureDocumentIdAndType", "documentStore", "uuid", "resolvedType", "resolveTypeForDocument", "EMPTY_RECORD", "IntentResolver", "memo", "maybeIntent", "intentName", "useDocumentStore", "cancelled", "effect", "catch", "PathSegment", "styled", "span", "__template", "formatStack", "stack", "RegExp", "location", "host", "StructureError", "_ref8", "t", "useTranslation", "structureLocaleNamespace", "showStack", "SerializeError", "includes", "handleReload", "window", "reload", "jsx", "Card", "height", "overflow", "padding", "sizing", "tone", "Container", "Heading", "as", "jsxs", "marginTop", "radius", "shadow", "Stack", "space", "Text", "size", "weight", "Code", "segment", "Box", "href", "rel", "target", "Button", "text", "icon", "SyncIcon", "onClick", "UnknownPane", "isSelected", "paneKey", "Pane", "PaneHeader", "title", "PaneContent", "muted", "Translate", "i18nKey", "values", "paneMap", "component", "lazy", "document", "documentList", "list", "StructureToolPane", "PaneComponent", "Suspense", "fallback", "LoadingPane", "isActive", "_ref9", "_ref10", "prevParams", "prevPayload", "keys", "Object", "NoDocumentTypesScreen", "Flex", "align", "justify", "width", "WarningOutlineIcon", "flex", "marginLeft", "DocumentTitle", "documentType", "editState", "useEditState", "schema", "useSchema", "isNewDocument", "published", "draft", "documentValue", "isLoading", "previewValueIsLoading", "useValuePreview", "enabled", "documentTitle", "name", "settled", "ready", "newTitle", "useConstructDocumentTitle", "PassthroughTitle", "StructureTitle", "isLoadingPane", "isDocumentPane", "activeTitle", "structureToolBaseTitle", "StyledPaneLayout", "PaneLayout", "isSaveHotkey", "isHotkey", "StructureTool", "_ref11", "onPaneChange", "push", "pushToast", "useToast", "layoutCollapsed", "setLayoutCollapsed", "isResolvingIntent", "sanity", "media", "useTheme", "portalElement", "setPortalElement", "handleRootCollapse", "handleRootExpand", "handleGlobalKeyDown", "event", "preventDefault", "closable", "status", "duration", "addEventListener", "removeEventListener", "hasDefinedDocumentTypes", "_original", "types", "some", "_isCustomDocumentTypeDefinition", "PortalProvider", "minWidth", "onCollapse", "onExpand", "_ref12", "paneIndex", "paneParams", "Fragment", "ref", "StructureToolBoundary", "tool", "_ref13", "unstable_sources", "sources", "useWorkspace", "firstSource", "source", "defaultDocumentNode", "structure", "setActivePanes", "ErrorBoundary", "onCatch", "SourceProvider", "StructureToolProvider"]
}
